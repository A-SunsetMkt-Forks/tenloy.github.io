<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tenloy&#39;s Blog</title>
  
  <subtitle>学习 记录</subtitle>
  <link href="https://tenloy.github.io/atom.xml" rel="self"/>
  
  <link href="https://tenloy.github.io/"/>
  <updated>2022-02-09T09:25:55.034Z</updated>
  <id>https://tenloy.github.io/</id>
  
  <author>
    <name>Tenloy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[转] OAuth 2.0简述</title>
    <link href="https://tenloy.github.io/2022/02/09/OAuth.html"/>
    <id>https://tenloy.github.io/2022/02/09/OAuth.html</id>
    <published>2022-02-09T17:03:25.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 —— <a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0 的一个简单解释 —— 阮一峰</a></p></blockquote><p>OAuth 2.0 的标准是 <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> 文件。该文件先解释了 OAuth 是什么。</p><blockquote><p>OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p></blockquote><p>这段话的意思就是，<strong>OAuth 是一种授权机制，核心就是向第三方应用颁发令牌(token)。</strong>以获取用户数据</p><p>然后，RFC 6749 接着写道：</p><blockquote><p>（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。</p></blockquote><p>下面就是重点讲解这两点：OAuth的运行流程、四种授权方式</p><h1 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h1><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p><p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p><p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p><p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p><ol><li>“云冲印”为了后续的服务，会保存用户的密码，这样很不安全。</li><li>Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。</li><li>“云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。</li><li>用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。</li><li>只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</li></ol><p>OAuth就是为了解决上面这些问题而诞生的。</p><p><strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p><h1 id="二、令牌与密码"><a href="#二、令牌与密码" class="headerlink" title="二、令牌与密码"></a>二、令牌与密码</h1><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。</p><p>（3）令牌有权限范围（scope）。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p><p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong> 这也是为什么令牌的有效期，一般都设置得很短的原因。</p><h1 id="三、OAuth的思路与运行流程"><a href="#三、OAuth的思路与运行流程" class="headerlink" title="三、OAuth的思路与运行流程"></a>三、OAuth的思路与运行流程</h1><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p><ul><li><strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。</li><li><strong>HTTP service</strong>：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。<ul><li><strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</li><li><strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</li></ul></li><li><strong>Resource Owner</strong>：资源所有者，本文中又称”用户”（user）。</li><li><strong>User Agent</strong>：用户代理，本文中就是指浏览器。</li></ul><p>OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。</p><ul><li>“客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。</li><li>“客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</li><li>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</li></ul><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051203.png"></p><blockquote><p>（A）用户打开客户端以后，客户端要求用户给予授权。</p><p>（B）用户同意给予客户端授权。</p><p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p><p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p><p>（E）客户端使用令牌，向资源服务器申请获取资源。</p><p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p></blockquote><p>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p><p>OAuth 2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。</p><h1 id="四、四种授权方式"><a href="#四、四种授权方式" class="headerlink" title="四、四种授权方式"></a>四、四种授权方式</h1><p><strong>OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。</strong>下面就是这四种授权方式。</p><ul><li>授权码（authorization-code）</li><li>隐藏式（implicit）</li><li>密码式（password）：</li><li>客户端凭证（client credentials）</li></ul><p>注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p><h2 id="4-1-授权码"><a href="#4-1-授权码" class="headerlink" title="4.1 授权码"></a>4.1 授权码</h2><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p><p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p><p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040902.jpg" alt="img"></p><p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback?code=AUTHORIZATION_CODE</span></span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>code</code>参数就是授权码。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040907.jpg" alt="img"></p><p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040904.jpg" alt="img"></p><p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="string">&quot;access_token&quot;</span>:<span class="string">&quot;ACCESS_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;token_type&quot;</span>:<span class="string">&quot;bearer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;expires_in&quot;</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="string">&quot;refresh_token&quot;</span>:<span class="string">&quot;REFRESH_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scope&quot;</span>:<span class="string">&quot;read&quot;</span>,</span><br><span class="line">  <span class="string">&quot;uid&quot;</span>:<span class="number">100101</span>,</span><br><span class="line">  <span class="string">&quot;info&quot;</span>:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040905.jpg" alt="img"></p><h2 id="4-2-隐藏式"><a href="#4-2-隐藏式" class="headerlink" title="4.2 隐藏式"></a>4.2 隐藏式</h2><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p><p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p><p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback#token=ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。</p><p>注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040906.jpg" alt="img"></p><p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p><h2 id="4-3-密码式"><a href="#4-3-密码式" class="headerlink" title="4.3 密码式"></a>4.3 密码式</h2><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p><p>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=USERNAME&amp;</span><br><span class="line">  password=PASSWORD&amp;</span><br><span class="line">  client_id=CLIENT_ID</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p><p>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p><p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p><h2 id="4-4-凭证式"><a href="#4-4-凭证式" class="headerlink" title="4.4 凭证式"></a>4.4 凭证式</h2><p><strong>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</strong></p><p>第一步，A 应用在命令行向 B 发出请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p><p>第二步，B 网站验证通过以后，直接返回令牌。</p><p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p><h1 id="五、令牌的使用"><a href="#五、令牌的使用" class="headerlink" title="五、令牌的使用"></a>五、令牌的使用</h1><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p><p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Authorization: Bearer ACCESS_TOKEN&quot;</span> \</span><br><span class="line"><span class="string">&quot;https://api.b.com&quot;</span></span><br></pre></td></tr></table></figure><p>上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p><h1 id="六、令牌的更新"><a href="#六、令牌的更新" class="headerlink" title="六、令牌的更新"></a>六、令牌的更新</h1><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p><p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET&amp;</span><br><span class="line">  refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p><p>B 网站验证通过以后，就会颁发新的令牌。</p><h1 id="七、示例-GitHub-OAuth第三方登录"><a href="#七、示例-GitHub-OAuth第三方登录" class="headerlink" title="七、示例: GitHub OAuth第三方登录"></a>七、示例: GitHub OAuth第三方登录</h1><p>今天演示一个实例，如何通过 OAuth 获取 API 数据。</p><p>很多网站登录时，允许使用第三方网站的身份，这称为”第三方登录”。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042101.jpg" alt="img"></p><p>下面就以 GitHub 为例，写一个最简单的应用，演示第三方登录。</p><h2 id="7-1-第三方登录的原理"><a href="#7-1-第三方登录的原理" class="headerlink" title="7.1 第三方登录的原理"></a>7.1 第三方登录的原理</h2><p>所谓第三方登录，实质就是 OAuth 授权。用户想要登录 A 网站，A 网站让用户提供第三方网站的数据，证明自己的身份。获取第三方网站的身份数据，就需要 OAuth 授权。</p><p>举例来说，A 网站允许 GitHub 登录，背后就是下面的流程。</p><ol><li>A 网站让用户跳转到 GitHub。</li><li>GitHub 要求用户登录，然后询问”A 网站要求获得 xx 权限，你是否同意？”</li><li>用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码。</li><li>A 网站使用授权码，向 GitHub 请求令牌。</li><li>GitHub 返回令牌.</li><li>A 网站使用令牌，向 GitHub 请求用户数据。</li></ol><p>下面就是这个流程的代码实现。</p><h2 id="7-2-应用登记"><a href="#7-2-应用登记" class="headerlink" title="7.2 应用登记"></a>7.2 应用登记</h2><p>一个应用要求 OAuth 授权，必须先到对方网站登记，让对方知道是谁在请求。</p><p>所以，你要先去 GitHub 登记一下。当然，我已经登记过了，你使用我的登记信息也可以，但为了完整走一遍流程，还是建议大家自己登记。这是免费的。</p><p>访问这个<a href="https://github.com/settings/applications/new">网址</a>，填写登记表。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042102.jpg" alt="img"></p><p>应用的名称随便填，主页 URL 填写<code>http://localhost:8080</code>，跳转网址填写 <code>http://localhost:8080/oauth/redirect</code>。</p><p>提交表单以后，GitHub 应该会返回客户端 ID（client ID）和客户端密钥（client secret），这就是应用的身份识别码。</p><h2 id="7-3-示例仓库"><a href="#7-3-示例仓库" class="headerlink" title="7.3 示例仓库"></a>7.3 示例仓库</h2><p>我写了一个<a href="https://github.com/ruanyf/node-oauth-demo">代码仓库</a>，请将它克隆到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:ruanyf/node-oauth-demo.git</span><br><span class="line">$ <span class="built_in">cd</span> node-oauth-demo</span><br></pre></td></tr></table></figure><p>两个配置项要改一下，写入上一步的身份识别码。</p><ul><li><a href="https://github.com/ruanyf/node-oauth-demo/blob/master/index.js#L3"><code>index.js</code></a>：改掉变量<code>clientID</code> and <code>clientSecret</code></li><li><a href="https://github.com/ruanyf/node-oauth-demo/blob/master/public/index.html#L16"><code>public/index.html</code></a>：改掉变量<code>client_id</code></li></ul><p>然后，安装依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>启动服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br></pre></td></tr></table></figure><p>浏览器访问<code>http://localhost:8080</code>，就可以看到这个示例了。</p><h2 id="7-4-浏览器跳转-GitHub"><a href="#7-4-浏览器跳转-GitHub" class="headerlink" title="7.4 浏览器跳转 GitHub"></a>7.4 浏览器跳转 GitHub</h2><p>示例的首页很简单，就是一个链接，让用户跳转到 GitHub。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042103.jpg" alt="img"></p><p>跳转的 URL 如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;authorize?</span><br><span class="line">  client_id&#x3D;7e015d8ce32370079895&amp;</span><br><span class="line">  redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;redirect</span><br></pre></td></tr></table></figure><p>这个 URL 指向 GitHub 的 OAuth 授权网址，带有两个参数：<code>client_id</code>告诉 GitHub 谁在请求，<code>redirect_uri</code>是稍后跳转回来的网址。</p><p>用户点击到了 GitHub，GitHub 会要求用户登录，确保是本人在操作。</p><h2 id="7-5-授权码"><a href="#7-5-授权码" class="headerlink" title="7.5 授权码"></a>7.5 授权码</h2><p>登录后，GitHub 询问用户，该应用正在请求数据，你是否同意授权。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042104.png" alt="img"></p><p>用户同意授权， GitHub 就会跳转到<code>redirect_uri</code>指定的跳转网址，并且带上授权码，跳转回来的 URL 就是下面的样子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;redirect?</span><br><span class="line">  code&#x3D;859310e7cecc9196f4af</span><br></pre></td></tr></table></figure><p>后端收到这个请求以后，就拿到了授权码（<code>code</code>参数）。</p><h2 id="7-6-后端实现"><a href="#7-6-后端实现" class="headerlink" title="7.6 后端实现"></a>7.6 后端实现</h2><p>示例的<a href="https://github.com/ruanyf/node-oauth-demo/blob/master/index.js">后端</a>采用 Koa 框架编写，具体语法请看<a href="https://www.ruanyifeng.com/blog/2017/08/koa.html">教程</a>。</p><p>这里的关键是针对<code>/oauth/redirect</code>的请求，编写一个<a href="https://github.com/ruanyf/node-oauth-demo/blob/master/index.js#L16">路由</a>，完成 OAuth 认证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oauth = <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(route.get(<span class="string">&#x27;/oauth/redirect&#x27;</span>, oauth));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>oauth</code>函数就是路由的处理函数。下面的代码都写在这个函数里面。</p><p>路由函数的第一件事，是从 URL 取出授权码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestToken = ctx.request.query.code;</span><br></pre></td></tr></table></figure><h2 id="7-7-令牌"><a href="#7-7-令牌" class="headerlink" title="7.7 令牌"></a>7.7 令牌</h2><p>后端使用这个授权码，向 GitHub 请求令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tokenResponse = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">  method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  url: <span class="string">&#x27;https://github.com/login/oauth/access_token?&#x27;</span> +</span><br><span class="line">    <span class="string">`client_id=<span class="subst">$&#123;clientID&#125;</span>&amp;`</span> +</span><br><span class="line">    <span class="string">`client_secret=<span class="subst">$&#123;clientSecret&#125;</span>&amp;`</span> +</span><br><span class="line">    <span class="string">`code=<span class="subst">$&#123;requestToken&#125;</span>`</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    accept: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，GitHub 的令牌接口<code>https://github.com/login/oauth/access_token</code>需要提供三个参数。</p><ul><li><code>client_id</code>：客户端的 ID</li><li><code>client_secret</code>：客户端的密钥</li><li><code>code</code>：授权码</li></ul><p>作为回应，GitHub 会返回一段 JSON 数据，里面包含了令牌<code>accessToken</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> accessToken = tokenResponse.data.access_token;</span><br></pre></td></tr></table></figure><h2 id="7-8-API-数据"><a href="#7-8-API-数据" class="headerlink" title="7.8 API 数据"></a>7.8 API 数据</h2><p>有了令牌以后，就可以向 API 请求数据了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">  method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  url: <span class="string">`https://api.github.com/user`</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    accept: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    Authorization: <span class="string">`token <span class="subst">$&#123;accessToken&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，GitHub API 的地址是<code>https://api.github.com/user</code>，请求的时候必须在 HTTP 头信息里面带上令牌<code>Authorization: token 361507da</code>。</p><p>然后，就可以拿到用户数据，得到用户的身份。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = result.data.name;</span><br><span class="line">ctx.response.redirect(<span class="string">`/welcome.html?name=<span class="subst">$&#123;name&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接 —— &lt;a href=&quot;https://www.ruanyifeng.com/blog/2019/04/oauth_design.html&quot;&gt;OAuth 2.0 的一个简单解释 —— 阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="互联网标准RFC" scheme="https://tenloy.github.io/categories/%E4%BA%92%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86RFC/"/>
    
    
  </entry>
  
  <entry>
    <title>WKWebView使用过程中遇到的坑</title>
    <link href="https://tenloy.github.io/2022/01/18/wkwebview-buges.html"/>
    <id>https://tenloy.github.io/2022/01/18/wkwebview-buges.html</id>
    <published>2022-01-18T17:39:45.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WKWebView-API"><a href="#WKWebView-API" class="headerlink" title="WKWebView API"></a>WKWebView API</h1><h2 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h2><p>关于 <code>extendedLayoutIncludesOpaqueBars</code> 和 <code>automaticallyAdjustsScrollViewInsets</code></p><ul><li>这两个属性属于UIViewController</li><li>默认情况下extendedLayoutIncludesOpaqueBars = false 扩展布局不包含导航栏</li><li>默认情况下automaticallyAdjustsScrollViewInsets = true 自动计算滚动视图的内容边距</li><li>但是，当 导航栏 是 不透明时，而tabBar为透明的时候，为了正确显示tableView的全部内容，需要重新设置这两个属性的值，然后设置contentInset(参考代码).</li></ul><p>在iOS11 中， UIViewController的 <code>automaticallyAdjustsScrollViewInsets</code> 属性已经不再使用，我们需要使用UIScrollView的 <code>contentInsetAdjustmentBehavior </code> 属性来替代它.</p><p>UIScrollViewContentInsetAdjustmentBehavior 是一个枚举类型，值有以下几种:</p><ul><li>automatic 和scrollableAxes一样，scrollView会自动计算和适应顶部和底部的内边距并且在scrollView 不可滚动时，也会设置内边距.</li><li>scrollableAxes 自动计算内边距.</li><li>never不计算内边距</li><li>always 根据safeAreaInsets 计算内边距一般我们肯定需要设置为 never，我们自己来控制间距，但是在iOS 12的webView中，就会出现开始所说的问题，需要设置为automatic才能解决</li></ul><p><strong>调整WKWebView布局方式，避免调整webView.scrollView.contentInset。实际上，即便在 UIWebView 上也不建议直接调整webView.scrollView.contentInset的值.</strong></p><h2 id="2-调整滚动速率"><a href="#2-调整滚动速率" class="headerlink" title="2. 调整滚动速率"></a>2. 调整滚动速率</h2><p>WKWebView 需要通过 scrollView delegate 调整滚动速率：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">  scrollView.decelerationRate = <span class="built_in">UIScrollViewDecelerationRateNormal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-视频自动播放"><a href="#3-视频自动播放" class="headerlink" title="3. 视频自动播放"></a>3. 视频自动播放</h2><p>WKWebView 需要通过WKWebViewConfiguration.mediaPlaybackRequiresUserAction设置是否允许自动播放，但一定要在 WKWebView 初始化之前设置，在 WKWebView 初始化之后设置无效。</p><h2 id="4-goBack-API问题"><a href="#4-goBack-API问题" class="headerlink" title="4. goBack API问题"></a>4. goBack API问题</h2><p>WKWebView 上调用 -[WKWebView goBack]， 回退到上一个页面后不会触发window.onload()函数、不会执行JS。</p><h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>在以前，一直以为Hybrid App开发是一种略显简单的事，不会使用太多能发挥移动端原生本身优势的复杂API，后来在新公司的工作(半混合式开发)过程中，发现混合式开发也是很多坑… 或者说WKWebView好多坑…</p><blockquote><p> 以下所说的内容，<a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA">参考链接</a>上基本上都有，本文的叙述方式主要是结合自己的经历(自己踩过的总结总是那么的深刻…[\捂脸])</p><p> 应该在开始混合开发之前就看下这篇文章的，结果真的是等自己踩坑踩了一遍，总结之后，发现这篇文章上都有….[\大哭]</p><p> 参考链接2： <a href="https://www.jianshu.com/p/86d99192df68">https://www.jianshu.com/p/86d99192df68</a></p></blockquote><h2 id="1-加载URL的-encode问题"><a href="#1-加载URL的-encode问题" class="headerlink" title="1. 加载URL的 encode问题"></a>1. 加载URL的 encode问题</h2><p>在数据网络请求或其他情况下，需要把URL中的一些特殊字符转换成UTF-8编码，比如：中文。解决<code>无法加载</code>的问题</p><h5 id="编码："><a href="#编码：" class="headerlink" title="编码："></a>编码：</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS 9以前</span></span><br><span class="line">stringByAddingPercentEscapesUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ios9后对其方法进行了修改</span></span><br><span class="line">stringByAddingPercentEncodingWithAllowedCharacters: [<span class="built_in">NSCharacterSet</span> URLQueryAllowedCharacterSet]</span><br></pre></td></tr></table></figure><h5 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS 9以前</span></span><br><span class="line">stringByReplacingPercentEscapesUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// iOS 9以后</span></span><br><span class="line">stringByRemovingPercentEncoding</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>混合开发中，最好将所有的URL的编解码问题都<strong>交给前端或者后端来做</strong>，毕竟移动端发版不够灵活。</li><li>API编写时，要<strong>保证iOS与Android两端的处理一致</strong>，否则前端同学做处理就太麻烦了。</li></ul><h2 id="2-loadRequest造成的body数据丢失"><a href="#2-loadRequest造成的body数据丢失" class="headerlink" title="2. loadRequest造成的body数据丢失"></a>2. loadRequest造成的body数据丢失</h2><p>在 WKWebView 上通过 loadRequest 发起的 post 请求 body 数据会丢失：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同样是由于进程间通信性能问题，HTTPBody字段被丢弃[request setHTTPMethod:@&quot;POST&quot;];</span></span><br><span class="line">[request setHTTPBody:[<span class="string">@&quot;bodyData&quot;</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</span><br><span class="line">[wkwebview loadRequest: request];</span><br></pre></td></tr></table></figure><p>解决方案：见参考链接，目前暂无使用场景</p><h2 id="3-WKUserContentController造成内存泄漏"><a href="#3-WKUserContentController造成内存泄漏" class="headerlink" title="3. WKUserContentController造成内存泄漏"></a>3. WKUserContentController造成内存泄漏</h2><blockquote><p>self -&gt; webView -&gt; WKWebViewConfiguration -&gt; WKUserContentController -&gt; self (addScriptMessageHandler)</p></blockquote><p>以下的方法，并不能解决问题</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) copy_self = <span class="keyword">self</span>;</span><br><span class="line">addScriptMessageHandler: copy_self</span><br></pre></td></tr></table></figure><p>解决方案： 单独创建一个类实现<code>WKScriptMessageHandler</code>协议，然后在该类中再创建一个协议，由self来实现协议。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span> -&gt; webView -&gt; <span class="built_in">WKWebViewConfiguration</span> -&gt; <span class="built_in">WKUserContentController</span> -&gt; <span class="keyword">weak</span> delegate obj --delegate--&gt; <span class="keyword">self</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个新类WeakScriptMessageDelegate</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;WebKit/WebKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakScriptMessageDelegate</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt; scriptDelegate;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptDelegate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakScriptMessageDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptDelegate &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">      _scriptDelegate = scriptDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</span><br><span class="line">    [<span class="keyword">self</span>.scriptDelegate userContentController:userContentController didReceiveScriptMessage:message];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.在我们使用WKWebView的控制器中引入我们创建的那个类，将注入js对象的代码改为:</span></span><br><span class="line">[config.userContentController addScriptMessageHandler:[[WeakScriptMessageDelegate alloc] initWithDelegate:<span class="keyword">self</span>] name:scriptMessage];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.在delloc方法中通过下面的方式移除注入的js对象</span></span><br><span class="line">[<span class="keyword">self</span>.config.userContentController removeScriptMessageHandlerForName:scriptMessage];</span><br></pre></td></tr></table></figure><p>上面三步就可以解决控制器不能被释放的问题了。</p><h2 id="4-WKWebView的白屏问题-拍照引起"><a href="#4-WKWebView的白屏问题-拍照引起" class="headerlink" title="4.  WKWebView的白屏问题(拍照引起)"></a>4.  WKWebView的白屏问题(拍照引起)</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>WKWebView 自诩拥有更快的加载速度，更低的内存占用，但实际上 WKWebView 是一个多进程组件，Network Loading 以及 UI Rendering 在其它进程中执行。</p><p>换WKWebView加载网页后，App 进程内存消耗反而大幅下降，但是仔细观察会发现，Other Process 的内存占用会增加。<strong>在一些用 webGL 渲染的复杂页面，使用 WKWebView 总体的内存占用（App Process Memory + Other Process Memory）不见得比 UIWebView 少很多。</strong></p><ul><li><p>在 UIWebView 上当内存占用太大的时候，App Process 会 crash；</p></li><li><p>在 WKWebView 上当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象</p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>总结下来，白屏的现象有几种：</p><ul><li>WKWebView的URL为空，出现白屏，这种现象可以通过loadRequest解决。</li><li>WKWebView的URL不空，出现白屏、部分白屏、白屏部分能点击，这种现象无论是reload还是loadRequest都不能刷出网页。（可以尝试3、4）</li></ul><h4 id="方案1-ContentProcessDidTerminate"><a href="#方案1-ContentProcessDidTerminate" class="headerlink" title="方案1. ContentProcessDidTerminate"></a>方案1. ContentProcessDidTerminate</h4><p>借助 iOS 9以后 <code>WKNavigtionDelegate</code> 新增了一个回调函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webViewWebContentProcessDidTerminate:(<span class="built_in">WKWebView</span> *)webView API_AVAILABLE(macosx(<span class="number">10.11</span>), ios(<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure><p>当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数，我们在该函数里执行<code>[webView reload]</code>(这个时候 webView.URL 取值尚不为 nil）解决白屏问题。在一些高内存消耗的页面可能会频繁刷新当前页面，H5侧也要做相应的适配操作。</p><h4 id="方案2-检测-webView-title-是否为空"><a href="#方案2-检测-webView-title-是否为空" class="headerlink" title="方案2. 检测 webView.title 是否为空"></a>方案2. 检测 webView.title 是否为空</h4><p>并不是所有H5页面白屏的时候都会调用上面的回调函数，比如，最近遇到在一个高内存消耗的<code>意见反馈</code>H5页面上 present 系统相机，拍照完毕后返回原来页面的时候出现白屏现象（拍照过程消耗了大量内存，导致内存紧张，<strong>WebContent Process 被系统挂起</strong>），但上面的回调函数并没有被调用。</p><p>在WKWebView白屏的时候，另一种现象是 webView.titile 会被置空， 因此，可以在 viewWillAppear 的时候检测 <code>webView.title</code> 是否为空来 reload 页面。</p><p>注意：可能<strong>有的前端页面确实没写title标签</strong>，在前端移动端开发中是可能会有这种场景的，会造成页面反复刷新</p><p>综合以上两种方法可以解决绝大多数的白屏问题。</p><h4 id="方案3-检索WKCompositingView控件"><a href="#方案3-检索WKCompositingView控件" class="headerlink" title="方案3. 检索WKCompositingView控件"></a>方案3. 检索WKCompositingView控件</h4><blockquote><p>（<em>未验证，有人说不好使</em>）</p></blockquote><p>WKWebView的URL不空，出现白屏不能点击、白屏部分能点击、部分白屏能点击等，这种现象无论是reload、loadRequest、清缓存、setNeedsLayout都不能刷出网页，只能回收旧webview（webview = nil 后记得清除代理，移除监听，要不然会crash）创建新的 webview， 然后重新request。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否白屏</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isBlankView:(<span class="built_in">UIView</span> *)view &#123; <span class="comment">// YES：blank</span></span><br><span class="line">    Class wkCompositingView = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;WKCompositingView&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ([view isKindOfClass:[wkCompositingView <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">UIView</span> * subView <span class="keyword">in</span> view.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> isBlankView:subView]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案4-html中加入资源加载的监听"><a href="#方案4-html中加入资源加载的监听" class="headerlink" title="方案4. html中加入资源加载的监听"></a>方案4. html中加入资源加载的监听</h4><p>在本地html中加入资源加载的监听，只要发生错误，就调用location.reload();重载当前文档。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监控资源加载错误(img,script,css,以及jsonp)</span></span><br><span class="line">window.addEventListener(<span class="string">&#x27;error&#x27;</span>, function (e) &#123;</span><br><span class="line">    console.log(<span class="string">&quot;===&quot;</span> + e.message + <span class="string">&quot;===&quot;</span>);</span><br><span class="line">    location.reload();</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">window.onerror = function (errorMessage, scriptURI, lineNumber, columnNumber, errorObj) &#123;</span><br><span class="line">    console.log(<span class="string">&quot;错误信息：&quot;</span>, errorMessage);</span><br><span class="line">    console.log(<span class="string">&quot;出错文件：&quot;</span>, scriptURI);</span><br><span class="line">    console.log(<span class="string">&quot;出错行号：&quot;</span>, lineNumber);</span><br><span class="line">    console.log(<span class="string">&quot;出错列号：&quot;</span>, columnNumber);</span><br><span class="line">    console.log(<span class="string">&quot;错误详情：&quot;</span>, errorObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这段代码要放在head内，并且css不能内联。</p><h2 id="5-NSURLProtocol-做网页缓存"><a href="#5-NSURLProtocol-做网页缓存" class="headerlink" title="5. NSURLProtocol(做网页缓存)"></a>5. NSURLProtocol(做网页缓存)</h2><p>见<a href="https://www.jianshu.com/p/9989ef064f7d">WKWebView中NSURLProtocol的使用以及对H5的缓存</a>，这是利用NSURLProtocol做网页缓存以及带来的隐患。</p><h2 id="6-WKWebView的截屏问题-做意见反馈"><a href="#6-WKWebView的截屏问题-做意见反馈" class="headerlink" title="6.  WKWebView的截屏问题(做意见反馈)"></a>6.  WKWebView的截屏问题(做意见反馈)</h2><p>WKWebView 下通过 <code>-[CALayer renderInContext:]</code>实现截屏的方式失效，需要通过以下方式实现截屏功能：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">ImageSnapshot</span>) </span></span><br><span class="line">- (<span class="built_in">UIImage</span>*)imageSnapshot &#123; </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size,<span class="literal">YES</span>,<span class="keyword">self</span>.contentScaleFactor); </span><br><span class="line">    [<span class="keyword">self</span> drawViewHierarchyInRect:<span class="keyword">self</span>.bounds afterScreenUpdates:<span class="literal">YES</span>]; </span><br><span class="line">    <span class="built_in">UIImage</span>* newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>(); </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>(); </span><br><span class="line">    <span class="keyword">return</span> newImage; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然而这种方式依然解决不了 webGL 页面的截屏问题，Safari 以及 Chrome 这两个全量切换到 WKWebView 的浏览器也存在同样的问题：<strong>对webGL 页面的截屏结果不是空白就是纯黑图片</strong>。</p><h2 id="7-window-alert-引起的crash问题-暂时没遇到"><a href="#7-window-alert-引起的crash问题-暂时没遇到" class="headerlink" title="7. window.alert()引起的crash问题(暂时没遇到)"></a>7. window.alert()引起的crash问题(暂时没遇到)</h2><h2 id="8-WKWebView拦截协议"><a href="#8-WKWebView拦截协议" class="headerlink" title="8. WKWebView拦截协议"></a>8. WKWebView拦截协议</h2><p>WKWebView内默认不允许iTunes、weixin等协议跳转。</p><p>UIWebView打开ituns.apple.com、跳转到appStore、拨打电话、唤起邮箱等一系列操作，UIWebView自己处理不了会自动交给UIApplication 来处理。</p><p>WKWebView上述事件WKWebView 不会自动交给UIApplication 来处理，除此之外，js端通过window.open() 打开新的网页的动作也被禁掉了。</p><h2 id="9-User-Agent修改"><a href="#9-User-Agent修改" class="headerlink" title="9. User-Agent修改"></a>9. User-Agent修改</h2><ul><li><p>在UIWebView初始化之前，全局设置User-Agent才会生效</p></li><li><p>在shouldStartLoadWithRequest可以给某个request设置UA，但是需要重新[webView loadUrl]，注意判断条件，不要死循环</p></li><li><p><strong>不要擅自修改webView的User-Agent，务必要跟前端反复确认，是否有用UA来做一些设备区分，进而做一些系统、机型适配问题。</strong></p></li></ul><h2 id="10-didFinish不调用"><a href="#10-didFinish不调用" class="headerlink" title="10. didFinish不调用"></a>10. didFinish不调用</h2><p>WKWebView didFinishNavigation明明看起来页面加载完全，却不调用(<strong>一般只发生在第一次进入该页面</strong>)。经过自定义NSURLProtocol，拦截所有的H5加载资源，并在didCompleteWithError中打印资源的加载情况，发现有图片资源，域名有问题。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Domain=<span class="built_in">NSURLErrorDomain</span> Code=<span class="number">-1003</span> <span class="string">&quot;未能找到使用指定主机名的服务器。 </span></span><br></pre></td></tr></table></figure><p>原因：DNS解析失败导致系统认定H5一直没加载完成！第二次再进入，系统缓存了DNS解析的映射记录，所以很快就认定资源错误，调用了didFinish方法。</p><h2 id="11-UI细节问题"><a href="#11-UI细节问题" class="headerlink" title="11. UI细节问题"></a>11. UI细节问题</h2><h3 id="11-1-WKWebView中-h5绝对布局不生效"><a href="#11-1-WKWebView中-h5绝对布局不生效" class="headerlink" title="11.1 WKWebView中 h5绝对布局不生效"></a>11.1 WKWebView中 h5绝对布局不生效</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ios 11之后</span></span><br><span class="line">_baseWebView.scrollView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>;</span><br></pre></td></tr></table></figure><p>然后：前端需要在meta标签中增加 <strong>iPhoneX</strong>的适配**—<strong>适配方案</strong>viewport-fit<strong>：</strong>cover**</p><h3 id="11-2-iOS-12中WKWebView中表单-键盘"><a href="#11-2-iOS-12中WKWebView中表单-键盘" class="headerlink" title="11.2. iOS 12中WKWebView中表单 键盘"></a>11.2. iOS 12中WKWebView中表单 键盘</h3><p>iOS 12中WKWebView中表单键盘弹起自动上移，导致的兼容问题。</p><p>WKWebView会自动监听键盘弹出，并做上下移动处理(效果如同IQKeyboardManage这些库)，但是在iOS12中会有一些问题，键盘收起后，控件不恢复原状，或者部分控件消失等不兼容问题</p><p>解决方案：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(kSystemVersion &lt; <span class="number">12.0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">        _webview.scrollView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">12.0</span>, *)) &#123;</span><br><span class="line">     _webview.scrollView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentAutomatic</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-WKWebview会下移20"><a href="#11-3-WKWebview会下移20" class="headerlink" title="11.3 WKWebview会下移20"></a>11.3 WKWebview会下移20</h3><p>解决方案：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iOS11前</span></span><br><span class="line">VC.automaticallyAdjustsScrollViewInsets = <span class="literal">NO</span>;  </span><br><span class="line"><span class="comment">//iOS11及以后</span></span><br><span class="line">_webview.scrollView.contentInsetAdjustmentBehavior;</span><br></pre></td></tr></table></figure><h2 id="12-H5标签不可点击，Native不受影响"><a href="#12-H5标签不可点击，Native不受影响" class="headerlink" title="12. H5标签不可点击，Native不受影响"></a>12. H5标签不可点击，Native不受影响</h2><p><em>iOS 11系统上，WKWebView内H5标签不可点击，Native不受影响。</em></p><p>在频繁的切换页面、刷新WKWebView的情况下，会出现WKWebView卡死，所有的H5标签不可点击，Native的UI不受影响，TabBarVC的几个子控制器最为严重，有时候切换、刷新四五次左右，就会出现这种情况。</p><p><strong>更新：结论：在viewWillAppear方法中调用了<code>evaluateJavaScript: completionHandler:</code>方法，将该方法的调用移到viewDidAppear方法中即可。</strong></p><p>下面是探索的一些步骤，也走了一些弯路，可绕过：</p><blockquote><p>分别从内存、视图、网络请求几个方面入手，按照以下步骤定位问题：</p><ol><li><p>对APP进行内存泄漏检测，优化了几处代码。毫无用处</p></li><li><p>WKWebView单独进程内存问题？因为有一些二级页面按照问题出现流程复现了N多次，都没有出现，所以暂时先排除</p></li><li><p>网速问题。发现网速差时，确实很容易复现，网速好的时候，试了好几次没复现！做了一些网络优化，比如及时cancel掉一些不需要的请求，没有效果。</p></li><li><p>视图加载、更新问题。猜测依据：一级页面更容易复现，且比二级页面多了一个Tabbar的视图。</p></li><li><p>结论：结合第3、4，猜测是网络过慢时，tabbar出现、隐藏，及WKWebView刷新、加载、渲染HTML，几种情况结合导致的WKWebView布局混乱。</p></li></ol><p>最后解决方法：包含WKWebView的一级页面，<code>viewDidAppear</code>时重新设置了一下WKWebView的约束。(设置UIScrollViewContentInsetAdjustmentAutomatic = YES，没有效果)</p><p>效果：大大改善了，但却没有根治问题。加了个保底方案，下拉刷新时，销毁旧WKWebView，创建新的，并loadRequest。(因为这些情况下iOS 11上出现的，且没有更低版本的测试机复现，所以暂时把修改限制在了iOS 11及以下的系统)</p></blockquote><p><strong>最后</strong>：有个最省事的方案，针对这些页面，<strong>将WKWebView替换成UIWebView</strong>。 可行，但逃避问题，不太可取，而且UIWebView、WKWebView各有一些特性，另一个不支持，比如WKWebView支持html，滚动时实时回调，而UIWebView只支持滚动停止时回调。且苹果已经不太支持UIWebView。还是早点拥抱WKWebView吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WKWebView-API&quot;&gt;&lt;a href=&quot;#WKWebView-API&quot; class=&quot;headerlink&quot; title=&quot;WKWebView API&quot;&gt;&lt;/a&gt;WKWebView API&lt;/h1&gt;&lt;h2 id=&quot;1-属性&quot;&gt;&lt;a href=&quot;#1-属性&quot;</summary>
      
    
    
    
    <category term="Hybid APP" scheme="https://tenloy.github.io/categories/Hybid-APP/"/>
    
    
  </entry>
  
  <entry>
    <title>数据加密 — 对称加密(以AES为例)</title>
    <link href="https://tenloy.github.io/2021/12/22/aes.html"/>
    <id>https://tenloy.github.io/2021/12/22/aes.html</id>
    <published>2021-12-22T17:52:12.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据加密简述"><a href="#一、数据加密简述" class="headerlink" title="一、数据加密简述"></a>一、数据加密简述</h2><blockquote><p>数据加密(Encryption)是指将明文信息(Plaintext)采取 <code>数学方法进行函数转换</code>成密文(Ciphertext)，只有特定接受方才能将其解密(Decryption)还原成明文的过程。</p></blockquote><p>构成:</p><ul><li>明文(Plaintext)：加密前的原始信息 </li><li>密文(Ciphertext)：明文被加密后的信息 </li><li>密钥(Key)：控制加密算法和解密算法得以实现的关键信息，分为<code>加密密钥和解密密钥</code>(必然，密钥不同，由明文生成的密文的结果也不同)</li><li>加密(Encryption)：将明文通过数学算法转换成密文的过程 </li><li>解密(Decryption)：将密文还原成明文的过程</li></ul><h3 id="1-1-密码系统的一般模型"><a href="#1-1-密码系统的一般模型" class="headerlink" title="1.1 密码系统的一般模型"></a>1.1 密码系统的一般模型</h3><img src="/images/encrypt/20.png" alt="20" style="zoom:80%;" /><ul><li>如果不论截取者获得了多少密文，但在密文中都没有足够的信息来唯一地确定出对应的明文，则这一密码体制称为<strong>无条件安全</strong>的，或称为<strong>理论上是不可破</strong>的（这种方法是不太容易获得的，因此在现实生活中，更多是追求计算上安全即可。）</li><li>如果密码体制中的密码不能被<em>可使用的计算资源</em> 破译，则这一密码体制称为在<strong>计算上是安全的</strong>（利用已有的最好方法破译某个密码系统所需要的代价超出了破译者的能力（如时间、空间、资金等资源））</li></ul><h2 id="二、对称密钥加密-单钥加密"><a href="#二、对称密钥加密-单钥加密" class="headerlink" title="二、对称密钥加密(单钥加密)"></a>二、对称密钥加密(单钥加密)</h2><img src="/images/encrypt/21.jpg" alt="20" style="zoom:60%;" /><p>常用的对称加密算法：</p><ul><li>DES/3DES(3重DES)</li><li>IDEA</li><li>RC5</li><li>AES(Rijndael)</li></ul><p>DES早期用的很多，但是由于相对比较简单，加密的安全性偏低，所以现在一般都使用3DES或 AES来替代。</p><h3 id="2-1-对称加密的优缺点"><a href="#2-1-对称加密的优缺点" class="headerlink" title="2.1 对称加密的优缺点"></a>2.1 对称加密的优缺点</h3><p>优点：</p><ol><li>算法公开(往往是标准算法，是可以公开的)</li><li>计算量小</li><li>加密速度快(核心是替换和移位，可以用硬件来实现)</li><li>加密效率高。</li></ol><p>缺点：</p><ol><li>交易双方都使用同样钥匙，安全性得不到保证。</li><li>每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一钥匙，使得发收双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户负担。</li><li>密钥分发比较困难，尤其网络环境中安全难以保障，易成为瓶颈。</li></ol><h2 id="三、AES-Rijndael"><a href="#三、AES-Rijndael" class="headerlink" title="三、AES(Rijndael)"></a>三、AES(Rijndael)</h2><blockquote><p>下面摘自 <a href="https://blog.dynox.cn/?p=1562">一篇写的非常全面的博客</a></p></blockquote><p>AES, Advanced Encryption Standard，其实是一套标准：<a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">FIPS 197</a>，而我们所说的AES算法其实是Rijndael算法。</p><img src="/images/encrypt/22.png" alt="20" style="zoom:60%;" /><p>Rijndael算法是基于代换-置换网络（SPN，Substitution-permutation network）的迭代算法。明文数据经过多轮次的转换后方能生成密文，每个轮次的转换操作由轮函数定义。轮函数任务就是根据密钥编排序列（即轮密码）对数据进行不同的代换及置换等操作。</p><p><strong>补充</strong>：<strong>代换-置换网络SPN</strong>是一系列被应用于分组密码中相关的数学运算，高级加密标准(AES)、3-Way、Kuznyechik、PRESENT、SAFER、SHARK、Square都有涉用。这种加密网络使用明文块和密钥块作为输入，并通过交错的若干“轮”（或“层”）代换操作和置换操作产生密文块。<strong>代换（Substitution）和置换（Permutation）分别被称作S盒（替换盒/S-boxes）和P盒（排列盒/P-boxes）</strong>。由于其实施于硬件的高效性，SPN的应用十分广泛。</p><h2 id="四、iOS中的AES"><a href="#四、iOS中的AES" class="headerlink" title="四、iOS中的AES"></a>四、iOS中的AES</h2><blockquote><p>部分摘自 <a href="https://www.jianshu.com/p/df828a57cb8f">简书博客1</a>，加了一些个人理解，有兴趣可以直接移步原文</p><p>iOS中的AES：iOS SDK中的Security.framework库，非openssl库  </p></blockquote><h3 id="4-1-四个参数"><a href="#4-1-四个参数" class="headerlink" title="4.1 四个参数"></a>4.1 四个参数</h3><p>AES是开发中常用的加密算法之一。然而由于前后端开发使用的语言不统一，导致经常出现前端加密而后端不能解密的情况出现。然而无论什么语言系统，AES的算法总是相同的， 因此导致结果不一致的原因在于 加密设置的参数不一致 。于是先来看看在两个平台使用AES加密时需要统一的几个参数。</p><ul><li>密钥长度（Key Size）</li><li>加密模式（Cipher Mode）</li><li>填充方式（Padding）</li><li>初始向量（Initialization Vector）</li></ul><h4 id="4-1-1-密钥长度"><a href="#4-1-1-密钥长度" class="headerlink" title="4.1.1 密钥长度"></a>4.1.1 密钥长度</h4><p><strong>AES算法标准</strong>下，key的长度有三种：128、192和256 bits。由于历史原因，JDK默认只支持不大于128 bits的密钥，而128 bits的key已能够满足商用安全需求。因此本例先使用AES-128。（Java使用大于128 bits的key方法在文末提及）</p><h4 id="4-1-2-加密模式"><a href="#4-1-2-加密模式" class="headerlink" title="4.1.2 加密模式"></a>4.1.2 加密模式</h4><p>AES属于块加密（Block Cipher），块加密中有ECB、CBC、CFB、OFB、CTR、CCM、GCM等几种工作模式。本例统一使用CBC模式。</p><h4 id="4-1-3-填充方式"><a href="#4-1-3-填充方式" class="headerlink" title="4.1.3 填充方式"></a>4.1.3 填充方式</h4><p>由于块加密只能对特定长度的数据块进行加密，因此CBC、ECB模式需要在最后一数据块<code>加密前进行数据填充，解密后删除掉填充的数据</code>。（CFB，OFB和CTR模式由于与key进行加密操作的是上一块加密后的密文，因此不需要对最后一段明文进行填充）</p><ul><li><strong>NoPadding</strong>：<ul><li>顾名思义，不填充，自己对长度不足block size的部分进行填充</li></ul></li><li><strong>ZeroPadding</strong>：<ul><li>数据长度不对齐时使用0填充，否则不填充(当原数据尾部也存在0时，在unpadding时可能会存在问题)。</li></ul></li><li><strong>PKCS7Padding</strong>：<ul><li>如果数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n；</li><li>如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。</li></ul></li><li><strong>PKCS5Padding</strong>：<ul><li>PKCS7Padding的子集，块大小固定为8字节，其它一致(即<strong>PKCS5Padding是限制块大小的PKCS7Padding</strong>)。</li></ul></li><li><strong>PKCS1Padding</strong>：<ul><li>与RSA算法一起使用，这里不再赘述</li></ul></li></ul><p>附上文档链接：</p><ul><li><a href="http://tools.ietf.org/html/rfc2315">PKCS #7: Cryptographic Message Syntax</a> 10.3节中讲到了上面提到的填充算法,  对Block Size并没有做规定</li><li><a href="http://tools.ietf.org/html/rfc2898">PKCS #5: Password-Based Cryptography Specification</a> 在6.1.1 中对 填充做了说明，该标准只讨论了 8字节(64位) 块的加密, 对其他块大小没有做说明，其填充算法跟 PKCS7是一样的</li></ul><p>使用PKCS7Padding/PKCS5Padding填充时，最后一个字节肯定为填充数据的长度，所以在解密后，取最后一位，就可以准确删除填充的数据。</p><p>在iOS SDK中提供了PKCS7Padding，而JDK则提供了PKCS5Padding(限制Block Size为8 bytes)，但AES等算法，后来都把BlockSize扩充到了16字节或更大，<strong>Java中，采用PKCS5实质上就是采用PKCS7</strong>(PKCS5Padding与PKCS7Padding填充结果是相等的）。</p><h4 id="4-1-4-初始向量"><a href="#4-1-4-初始向量" class="headerlink" title="4.1.4 初始向量"></a>4.1.4 初始向量</h4><p>使用除ECB以外的其他加密模式均需要传入一个初始向量，其<strong>大小(即串的长度)与Block Size相等</strong>（AES的Block Size为128 bits），而两个平台的API文档均指明当不传入初始向量时，系统将默认使用一个全0的初始向量。(<strong>在区块加密中，使用了初始化向量的加密模式被称为区块加密模式</strong>)</p><p>以CBC为例：IV是长度为分组大小的一组随机，通常情况下不用保密，不过在大多数情况下，针对同一密钥不应多次使用同一组IV。 CBC要求第一个分组的明文在加密运算前先与IV进行<strong>异或</strong>；从第二组开始，所有的明文先与前一分组加密后的密文进行异或。</p><h3 id="4-2-iOS实现"><a href="#4-2-iOS实现" class="headerlink" title="4.2 iOS实现"></a>4.2 iOS实现</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义一个初始向量IV的值。ECB模式不需要</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> kInitVector = <span class="string">@&quot;16-Bytes--String&quot;</span>;</span><br><span class="line"><span class="comment">//确定密钥长度，这里选择 AES-128。即&quot;密钥是个16位字符串</span></span><br><span class="line">size_t <span class="keyword">const</span> kKeySize = kCCKeySizeAES128;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)encryptAES:(<span class="built_in">NSString</span> *)content key:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *contentData = [content dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> dataLength = contentData.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为结束符&#x27;\0&#x27; +1</span></span><br><span class="line">    <span class="keyword">char</span> keyPtr[kKeySize + <span class="number">1</span>];</span><br><span class="line">    memset(keyPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(keyPtr));</span><br><span class="line">    [key getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 密文长度 &lt;= 明文长度 + BlockSize</span></span><br><span class="line">    size_t encryptSize = dataLength + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *encryptedBytes = malloc(encryptSize);</span><br><span class="line">    size_t actualOutSize = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *initVector = [kInitVector dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      第三个参数：先查看下枚举说明，可以发现里面只有两个枚举变量，并在kCCOptionECBMode的旁边，写着Default is CBC.</span></span><br><span class="line"><span class="comment">        kCCOptionPKCS7Padding：表示函数运用CBC加密模式，并且使用PKCS7Padding的填充模式进行加密</span></span><br><span class="line"><span class="comment">        kCCOptionPKCS7Padding | kCCOptionECBMode：就表示函数运用ECB加密模式，并且使用PKCS7Padding的填充模式进行加密</span></span><br><span class="line"><span class="comment">        如果要设置NoPadding，可以填入0x0000</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, <span class="comment">//加密/解密</span></span><br><span class="line">                                          kCCAlgorithmAES, <span class="comment">//选用的加密算法</span></span><br><span class="line">                                          kCCOptionPKCS7Padding,  <span class="comment">//设置工作模式+填充</span></span><br><span class="line">                                          keyPtr,  <span class="comment">//key</span></span><br><span class="line">                                          kKeySize, <span class="comment">// key length </span></span><br><span class="line">                                          initVector.bytes, <span class="comment">// 初始向量IV的长度，如果不需要IV，设置为nil(不可以为@&quot;&quot;)</span></span><br><span class="line">                                          contentData.bytes,</span><br><span class="line">                                          dataLength,</span><br><span class="line">                                          encryptedBytes,</span><br><span class="line">                                          encryptSize,</span><br><span class="line">                                          &amp;actualOutSize);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="comment">// 对加密后的数据进行 base64 编码</span></span><br><span class="line">        <span class="keyword">return</span> [[<span class="built_in">NSData</span> dataWithBytesNoCopy:encryptedBytes length:actualOutSize] base64EncodedStringWithOptions:<span class="built_in">NSDataBase64EncodingEndLineWithLineFeed</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    free(encryptedBytes);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-Java实现"><a href="#4-3-Java实现" class="headerlink" title="4.3 Java实现"></a>4.3 Java实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同理先在类中定义一个初始向量，需要与iOS端的统一。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IV_STRING = <span class="string">&quot;16-Bytes--String&quot;</span>;</span><br><span class="line"><span class="comment">//另 Java 不需手动设置密钥大小，系统会自动根据传入的 Key 进行判断。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptAES</span><span class="params">(String content, String key)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InvalidKeyException, NoSuchAlgorithmException, </span></span><br><span class="line"><span class="function">            NoSuchPaddingException, UnsupportedEncodingException, </span></span><br><span class="line"><span class="function">            InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] byteContent = content.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，为了能与 iOS 统一</span></span><br><span class="line">    <span class="comment">// 这里的 key 不可以使用 KeyGenerator、SecureRandom、SecretKey 生成</span></span><br><span class="line">    <span class="keyword">byte</span>[] enCodeFormat = key.getBytes();</span><br><span class="line">    SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(enCodeFormat, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">byte</span>[] initParam = IV_STRING.getBytes();</span><br><span class="line">    IvParameterSpec ivParameterSpec = <span class="keyword">new</span> IvParameterSpec(initParam);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 指定加密的算法、工作模式和填充方式</span></span><br><span class="line">    Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">byte</span>[] encryptedBytes = cipher.doFinal(byteContent);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同样对加密后数据进行 base64 编码</span></span><br><span class="line">    Encoder encoder = Base64.getEncoder();</span><br><span class="line">    <span class="keyword">return</span> encoder.encodeToString(encryptedBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于Java使用大于128 bits的key：</strong></p><p>到Oracle官网下载对应Java版本的 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">JCE</a> ，解压后放到 <strong>JAVA_HOME/jre/lib/security/</strong> ，然后修改 iOS 端的 kKeySize 和两端对应的 key 即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、数据加密简述&quot;&gt;&lt;a href=&quot;#一、数据加密简述&quot; class=&quot;headerlink&quot; title=&quot;一、数据加密简述&quot;&gt;&lt;/a&gt;一、数据加密简述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据加密(Encryption)是指将明文信息(Plaintext</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] AES标准及Rijndael算法解析</title>
    <link href="https://tenloy.github.io/2021/12/21/aes-standard.html"/>
    <id>https://tenloy.github.io/2021/12/21/aes-standard.html</id>
    <published>2021-12-21T17:12:12.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://blog.dynox.cn/?p=1562">原文链接</a>，一字不差转载(防丢失)</p></blockquote><h2 id="一、AES简介"><a href="#一、AES简介" class="headerlink" title="一、AES简介"></a>一、AES简介</h2><p><strong>AES即高级加密标准</strong>(Advanced Encryption Standard)，其实是一套标准。美国国家标准与技术研究院<strong>NIST</strong>(National INstitute of Standards and Technology) 在1997年9月12日公开征集更高效更安全的替代DES加密算法，第一轮共有15种算法入选，其中5种算法入围了决赛，分别是MARS，RC6，Rijndael，Serpent和Twofish。又经过3年的验证、评测及公众讨论之后Rijndael算法最终入选。所以，我们所说的AES算法其实是<code>Rijndael算法</code>。</p><p><strong>高级加密标准</strong> 由 <strong>NIST</strong> 于2001年11月26日发布于<a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">FIPS PUB 197</a>，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p><img src="/images/encrypt/02.png" alt="02" style="zoom:80%;" /><h3 id="1-1-Rijndael算法"><a href="#1-1-Rijndael算法" class="headerlink" title="1.1 Rijndael算法"></a>1.1 Rijndael算法</h3><p>Rijndael算法是由比利时学者Joan Daemen和Vincent Rijmen所提出的，算法的名字就由两位作者的名字组合而成。Rijndael的优势在于集安全性、性能、效率、可实现性及灵活性与一体。</p><h3 id="1-2-AES-vs-Rijndael"><a href="#1-2-AES-vs-Rijndael" class="headerlink" title="1.2 AES vs Rijndael"></a>1.2 AES vs Rijndael</h3><p>Rijndael算法支持多种分组及密钥长度，介于128-256之间所有32的倍数均可，最小支持128位，最大256位，共25种组合。而AES标准支持的分组大小固定为128位，密钥长度有3种选择：128位、192位及256位。</p><h3 id="1-3-加密实例"><a href="#1-3-加密实例" class="headerlink" title="1.3 加密实例"></a>1.3 加密实例</h3><p>下面针对16字节的简单明文字串“0011223344….eeff”，分别用AES-128/AES-192及AES-256进行加密运算：</p><h4 id="1-3-1-AES-128"><a href="#1-3-1-AES-128" class="headerlink" title="1.3.1 AES-128"></a>1.3.1 AES-128</h4><p>密钥选用16字节长的简单字串：“00010203….0e0f” 来，上面的明文经过加密变换后成为”69c4e0d8….6089”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain :  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br><span class="line">key   :  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f</span><br><span class="line">cypher:  69 c4 e0 d8 6a 7b 04 30 d8 cd b7 80 70 b4 c5 5a</span><br></pre></td></tr></table></figure><h4 id="1-3-2-AES-192"><a href="#1-3-2-AES-192" class="headerlink" title="1.3.2 AES-192"></a>1.3.2 AES-192</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain :  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br><span class="line">key   :  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d .. .. .. 17</span><br><span class="line">cypher:  dd a9 7c a4 86 4c df e0 6e af 70 a0 ec 0d 71 91</span><br></pre></td></tr></table></figure><h4 id="1-3-3-AES-256"><a href="#1-3-3-AES-256" class="headerlink" title="1.3.3 AES-256"></a>1.3.3 AES-256</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain :  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br><span class="line">key   :  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d .. .. .. 17 .. .. .. 1f</span><br><span class="line">cypher:  8e a2 b7 ca 51 67 45 bf ea fc 49 90 4b 49 60 89</span><br></pre></td></tr></table></figure><h2 id="二、总体结构"><a href="#二、总体结构" class="headerlink" title="二、总体结构"></a>二、总体结构</h2><p>Rijndael算法是基于代换-置换网络（SPN，Substitution-permutation network）的迭代算法。明文数据经过多轮次的转换后方能生成密文，每个轮次的转换操作由轮函数定义。轮函数任务就是根据密钥编排序列（即轮密码）对数据进行不同的代换及置换等操作。</p><img src="/images/encrypt/03.png" alt="02" style="zoom:80%;" /><p>图左侧为轮函数的流程，主要包含4种主要运算操作：字节代换(SubByte)、行移位(ShiftRow)、列混合(MixColumn)、轮密钥加(AddRoundKey)。图右侧为密钥编排方案，在Rijndael中称为密钥扩展算法（KeyExpansion）。</p><p>AES标准算法将128位的明文，以特定次序生成一个4x4的矩阵（每个元素是一个字节，8位），即初始状态（state），经由轮函数的迭代转换之后又将作为下一轮迭代的输入继续参与运算直到迭代结束。</p><p>Rijndael算法支持大于128位的明文分组，所以需要列数更多的矩阵来描述。Rijndael轮函数的运算是在特殊定义的有限域GF(256)上进行的。有限域（Finite Field）又名伽罗瓦域（Galois field），简单言之就是一个满足特定规则的集合，集合中的元素可以进行加减乘除运算，且运算结果也是属于此集合。更详细有有关Rijndael算法的数学描述，可以参阅本文最后所罗列的参考资料，在此不做熬述。</p><h3 id="2-1-轮函数"><a href="#2-1-轮函数" class="headerlink" title="2.1 轮函数"></a>2.1 轮函数</h3><p>我们已经得知轮函数主要包含4种运算，但不同的运算轮所做的具体运的算组合并不相同。主要区别是初始轮（Round: 0）和最后一轮（Round: Nr），所有中间轮的运算都是相同的，会依次进行4种运算，即：</p><ol><li>字节代换(SubByte)</li><li>行移位(ShiftRow)</li><li>列混合(MixColumn)</li><li>轮密钥加(AddRoundKey)</li></ol><p>根据Rinjdael算法的定义，加密轮数会针对不同的分组及不同的密钥长度选择不同的数值：</p><img src="/images/encrypt/04.png" alt="02" style="zoom:80%;" /><p>AES标准只支持128位分组（Nb = 4）的情况。</p><p>轮函数的实现代码如下，直接实现在加密函数内部循环中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aes_encrypt</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *data, <span class="keyword">int</span> len, <span class="keyword">uint8_t</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> w[<span class="number">4</span> * <span class="number">4</span> * <span class="number">15</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* round key */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span> * <span class="number">4</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* state */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nr, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* key expansion */</span></span><br><span class="line">    aes_key_expansion(mode, key, w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start data cypher loop over input buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">4</span> * g_aes_nb[mode]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* init state from user buffer (plaintext) */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            s[j] = data[i + j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* start AES cypher loop over all AES rounds */</span></span><br><span class="line">        <span class="keyword">for</span> (nr = <span class="number">0</span>; nr &lt;= g_aes_rounds[mode]; nr++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nr &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do SubBytes */</span></span><br><span class="line">                aes_sub_bytes(mode, s);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do ShiftRows */</span></span><br><span class="line">                aes_shift_rows(mode, s);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nr &lt; g_aes_rounds[mode]) &#123;</span><br><span class="line">                    <span class="comment">/* do MixColumns */</span></span><br><span class="line">                    aes_mix_columns(mode, s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* do AddRoundKey */</span></span><br><span class="line">            aes_add_round_key(mode, s, w, nr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* save state (cypher) to user buffer */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            data[i + j] = s[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-动画演示加密过程"><a href="#2-2-动画演示加密过程" class="headerlink" title="2.2 动画演示加密过程"></a>2.2 动画演示加密过程</h3><p>Enrique Zabala创建了一个AES-128加密算法的动画演示，清楚、直观地介绍了轮函数执行的过程。<a href="http://www.formaestudio.com/rijndaelinspector/archivos/Rijndael_Animation_v4_eng.swf">点击可直接观看</a>。</p><h3 id="2-3-轮函数拆解：字节代换（Substitute-Bytes）"><a href="#2-3-轮函数拆解：字节代换（Substitute-Bytes）" class="headerlink" title="2.3 轮函数拆解：字节代换（Substitute Bytes）"></a>2.3 轮函数拆解：字节代换（Substitute Bytes）</h3><img src="/images/encrypt/05.png" alt="02" style="zoom:70%;" /><p>字节代换（SubBytes）是对state矩阵中的每一个独立元素于置换盒 （Substitution-box，S盒）中进行查找并以此替换输入状态的操作。字节代换是可逆的非线性变换，也是AES运算组中唯一的非线性变换。字节代换逆操作也是通过逆向置换盒的查找及替换来完成的。</p><p>S盒是事先设计好的16x16的查询表，即256个元素。其设计不是随意的，要根据设计原则严格计算求得，不然无法保证算法的安全性。既然是S盒是计算得来，所以字节代换的操作完全可以通过计算来完成，不过通过S盒查表操作更方便快捷，图中所示就是通过S盒查找对应元素进行的替换操作。</p><img src="/images/encrypt/06.jpg" alt="02" style="zoom:75%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_sub_bytes</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_aes_nb[mode]; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            state[i * <span class="number">4</span> + j] = aes_sub_sbox(state[i * <span class="number">4</span> + j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:  00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0</span><br><span class="line">  sub:  63 ca b7 04 09 53 d0 51 cd 60 e0 e7 ba 70 e1 8c</span><br></pre></td></tr></table></figure><h3 id="2-4-轮函数拆解：行移位（Shift-Rows）"><a href="#2-4-轮函数拆解：行移位（Shift-Rows）" class="headerlink" title="2.4 轮函数拆解：行移位（Shift Rows）"></a>2.4 轮函数拆解：行移位（Shift Rows）</h3><img src="/images/encrypt/07.png" alt="02" style="zoom:80%;" /><p>行移位主要目的是实现字节在每一行的扩散，属于线性变换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_shift_rows</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *s = (<span class="keyword">uint8_t</span> *)state;</span><br><span class="line">    <span class="keyword">int</span> i, j, r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; g_aes_nb[mode]; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> tmp = s[i];</span><br><span class="line">            <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; g_aes_nb[mode]; r++) &#123;</span><br><span class="line">                s[i + r * <span class="number">4</span>] = s[i + (r + <span class="number">1</span>) * <span class="number">4</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            s[i + (g_aes_nb[mode] - <span class="number">1</span>) * <span class="number">4</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> sub:  63 ca b7 04 09 53 d0 51 cd 60 e0 e7 ba 70 e1 8c</span><br><span class="line">shift:  63 53 e0 8c 09 60 e1 04 cd 70 b7 51 ba ca d0 e7</span><br></pre></td></tr></table></figure><h3 id="2-5-轮函数拆解：列混合（Mix-Columns）"><a href="#2-5-轮函数拆解：列混合（Mix-Columns）" class="headerlink" title="2.5 轮函数拆解：列混合（Mix Columns）"></a>2.5 轮函数拆解：列混合（Mix Columns）</h3><img src="/images/encrypt/08.png" alt="02" style="zoom:75%;" /><p>列混合是通过将state矩阵与常矩阵C相乘以达成在列上的扩散，属于代替变换。列混合是Rijndael算法中最复杂的一步，其实质是在有限域GF(256)上的多项式乘法运算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_mix_columns</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> y[<span class="number">16</span>] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,  <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j, r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_aes_nb[mode]; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; <span class="number">4</span>; r++) &#123;</span><br><span class="line">            s[r] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                s[r] = s[r] ^ aes_mul(state[i * <span class="number">4</span> + j], y[r * <span class="number">4</span> + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; <span class="number">4</span>; r++) &#123;</span><br><span class="line">            state[i * <span class="number">4</span> + r] = s[r];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shift:  63 53 e0 8c 09 60 e1 04 cd 70 b7 51 ba ca d0 e7</span><br><span class="line"> mix:  5f 72 64 15 57 f5 bc 92 f7 be 3b 29 1d b9 f9 1a</span><br></pre></td></tr></table></figure><h3 id="2-6-轮函数拆解：轮密钥加（Add-Round-Key）"><a href="#2-6-轮函数拆解：轮密钥加（Add-Round-Key）" class="headerlink" title="2.6 轮函数拆解：轮密钥加（Add Round Key）"></a>2.6 轮函数拆解：轮密钥加（Add Round Key）</h3><img src="/images/encrypt/09.png" alt="02" style="zoom:75%;" /><p>密钥加是将轮密钥简单地与状态进行逐比特异或。实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_add_round_key</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *state,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">uint8_t</span> *round, <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *w = (<span class="keyword">uint32_t</span> *)round;</span><br><span class="line">    <span class="keyword">uint32_t</span> *s = (<span class="keyword">uint32_t</span> *)state;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_aes_nb[mode]; i++) &#123;</span><br><span class="line">        s[i] ^= w[nr * g_aes_nb[mode] + i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  mix:  5f 72 64 15 57 f5 bc 92 f7 be 3b 29 1d b9 f9 1a</span><br><span class="line">round:  d6 aa 74 fd d2 af 72 fa da a6 78 f1 d6 ab 76 fe</span><br><span class="line">state:  89 d8 10 e8 85 5a ce 68 2d 18 43 d8 cb 12 8f e4</span><br></pre></td></tr></table></figure><h3 id="2-7-密钥扩展算法（Key-Expansion）"><a href="#2-7-密钥扩展算法（Key-Expansion）" class="headerlink" title="2.7 密钥扩展算法（Key Expansion）"></a>2.7 密钥扩展算法（Key Expansion）</h3><p>密钥扩展算法是Rijndael的密钥编排实现算法，其目的是根据种子密钥（用户密钥）生成多组轮密钥。轮密钥为多组128位密钥，对应不同密钥长度，分别是11，13，15组。</p><img src="/images/encrypt/10.png" alt="02" style="zoom:80%;" /><p>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * nr: number of rounds</span></span><br><span class="line"><span class="comment"> * nb: number of columns comprising the state, nb = 4 dwords (16 bytes)</span></span><br><span class="line"><span class="comment"> * nk: number of 32-bit words comprising cipher key, nk = 4, 6, 8 (KeyLength/(4*8))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_key_expansion</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *key, <span class="keyword">uint8_t</span> *round)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *w = (<span class="keyword">uint32_t</span> *)round;</span><br><span class="line">    <span class="keyword">uint32_t</span>  t;</span><br><span class="line">    <span class="keyword">int</span>      i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        w[i] = *((<span class="keyword">uint32_t</span> *)&amp;key[i * <span class="number">4</span> + <span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">while</span> (++i &lt; g_aes_nk[mode]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i % g_aes_nk[mode]) == <span class="number">0</span>) &#123;</span><br><span class="line">            t = aes_rot_dword(w[i - <span class="number">1</span>]);</span><br><span class="line">            t = aes_sub_dword(t);</span><br><span class="line">            t = t ^ aes_swap_dword(g_aes_rcon[i/g_aes_nk[mode] - <span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g_aes_nk[mode] &gt; <span class="number">6</span> &amp;&amp; (i % g_aes_nk[mode]) == <span class="number">4</span>) &#123;</span><br><span class="line">            t = aes_sub_dword(w[i - <span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = w[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        w[i] = w[i - g_aes_nk[mode]] ^ t;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (++i &lt; g_aes_nb[mode] * (g_aes_rounds[mode] + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* key can be discarded (or zeroed) from memory */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以AES-128为例，从128位种子密钥生成11组轮密钥（每组128位）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">    key :  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f</span><br><span class="line">Key Expansion:</span><br><span class="line">    00:  rs: 00010203</span><br><span class="line">    01:  rs: 04050607</span><br><span class="line">    02:  rs: 08090a0b</span><br><span class="line">    03:  rs: 0c0d0e0f</span><br><span class="line">    04:  rot: 0d0e0f0c sub: d7ab76fe rcon: 01000000 xor: fe76abd6 rs: d6aa74fd</span><br><span class="line">    05:  equ: d6aa74fd rs: d2af72fa</span><br><span class="line">    06:  equ: d2af72fa rs: daa678f1</span><br><span class="line">    07:  equ: daa678f1 rs: d6ab76fe</span><br><span class="line">    08:  rot: ab76fed6 sub: 6238bbf6 rcon: 02000000 xor: f6bb3860 rs: b692cf0b</span><br><span class="line">    09:  equ: b692cf0b rs: 643dbdf1</span><br><span class="line">    10:  equ: 643dbdf1 rs: be9bc500</span><br><span class="line">    11:  equ: be9bc500 rs: 6830b3fe</span><br><span class="line">    12:  rot: 30b3fe68 sub: 046dbb45 rcon: 04000000 xor: 45bb6d00 rs: b6ff744e</span><br><span class="line">    13:  equ: b6ff744e rs: d2c2c9bf</span><br><span class="line">    14:  equ: d2c2c9bf rs: 6c590cbf</span><br><span class="line">    15:  equ: 6c590cbf rs: 0469bf41</span><br><span class="line">    16:  rot: 69bf4104 sub: f90883f2 rcon: 08000000 xor: f28308f1 rs: 47f7f7bc</span><br><span class="line">    17:  equ: 47f7f7bc rs: 95353e03</span><br><span class="line">    18:  equ: 95353e03 rs: f96c32bc</span><br><span class="line">    19:  equ: f96c32bc rs: fd058dfd</span><br><span class="line">    20:  rot: 058dfdfd sub: 6b5d5454 rcon: 10000000 xor: 54545d7b rs: 3caaa3e8</span><br><span class="line">    21:  equ: 3caaa3e8 rs: a99f9deb</span><br><span class="line">    22:  equ: a99f9deb rs: 50f3af57</span><br><span class="line">    23:  equ: 50f3af57 rs: adf622aa</span><br><span class="line">    24:  rot: f622aaad sub: 4293ac95 rcon: 20000000 xor: 95ac9362 rs: 5e390f7d</span><br><span class="line">    25:  equ: 5e390f7d rs: f7a69296</span><br><span class="line">    26:  equ: f7a69296 rs: a7553dc1</span><br><span class="line">    27:  equ: a7553dc1 rs: 0aa31f6b</span><br><span class="line">    28:  rot: a31f6b0a sub: 0ac07f67 rcon: 40000000 xor: 677fc04a rs: 14f9701a</span><br><span class="line">    29:  equ: 14f9701a rs: e35fe28c</span><br><span class="line">    30:  equ: e35fe28c rs: 440adf4d</span><br><span class="line">    31:  equ: 440adf4d rs: 4ea9c026</span><br><span class="line">    32:  rot: a9c0264e sub: d3baf72f rcon: 80000000 xor: 2ff7ba53 rs: 47438735</span><br><span class="line">    33:  equ: 47438735 rs: a41c65b9</span><br><span class="line">    34:  equ: a41c65b9 rs: e016baf4</span><br><span class="line">    35:  equ: e016baf4 rs: aebf7ad2</span><br><span class="line">    36:  rot: bf7ad2ae sub: 08dab5e4 rcon: 1b000000 xor: e4b5da13 rs: 549932d1</span><br><span class="line">    37:  equ: 549932d1 rs: f0855768</span><br><span class="line">    38:  equ: f0855768 rs: 1093ed9c</span><br><span class="line">    39:  equ: 1093ed9c rs: be2c974e</span><br><span class="line">    40:  rot: 2c974ebe sub: 71882fae rcon: 36000000 xor: ae2f8847 rs: 13111d7f</span><br><span class="line">    41:  equ: 13111d7f rs: e3944a17</span><br><span class="line">    42:  equ: e3944a17 rs: f307a78b</span><br><span class="line">    43:  equ: f307a78b rs: 4d2b30c5</span><br></pre></td></tr></table></figure><h3 id="2-8-加密过程实例"><a href="#2-8-加密过程实例" class="headerlink" title="2.8 加密过程实例"></a>2.8 加密过程实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Encrypting block ...</span><br><span class="line"> Round 0:</span><br><span class="line">   input:  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br><span class="line">   round:  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f</span><br><span class="line">   state:  00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0</span><br><span class="line"> Round 1:</span><br><span class="line">   input:  00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0</span><br><span class="line">     sub:  63 ca b7 04 09 53 d0 51 cd 60 e0 e7 ba 70 e1 8c</span><br><span class="line">   shift:  63 53 e0 8c 09 60 e1 04 cd 70 b7 51 ba ca d0 e7</span><br><span class="line">     mix:  5f 72 64 15 57 f5 bc 92 f7 be 3b 29 1d b9 f9 1a</span><br><span class="line">   round:  d6 aa 74 fd d2 af 72 fa da a6 78 f1 d6 ab 76 fe</span><br><span class="line">   state:  89 d8 10 e8 85 5a ce 68 2d 18 43 d8 cb 12 8f e4</span><br><span class="line"> Round 2:</span><br><span class="line">   input:  89 d8 10 e8 85 5a ce 68 2d 18 43 d8 cb 12 8f e4</span><br><span class="line">     sub:  a7 61 ca 9b 97 be 8b 45 d8 ad 1a 61 1f c9 73 69</span><br><span class="line">   shift:  a7 be 1a 69 97 ad 73 9b d8 c9 ca 45 1f 61 8b 61</span><br><span class="line">     mix:  ff 87 96 84 31 d8 6a 51 64 51 51 fa 77 3a d0 09</span><br><span class="line">   round:  b6 92 cf 0b 64 3d bd f1 be 9b c5 00 68 30 b3 fe</span><br><span class="line">   state:  49 15 59 8f 55 e5 d7 a0 da ca 94 fa 1f 0a 63 f7</span><br><span class="line"> Round 3:</span><br><span class="line">   input:  49 15 59 8f 55 e5 d7 a0 da ca 94 fa 1f 0a 63 f7</span><br><span class="line">     sub:  3b 59 cb 73 fc d9 0e e0 57 74 22 2d c0 67 fb 68</span><br><span class="line">   shift:  3b d9 22 68 fc 74 fb 73 57 67 cb e0 c0 59 0e 2d</span><br><span class="line">     mix:  4c 9c 1e 66 f7 71 f0 76 2c 3f 86 8e 53 4d f2 56</span><br><span class="line">   round:  b6 ff 74 4e d2 c2 c9 bf 6c 59 0c bf 04 69 bf 41</span><br><span class="line">   state:  fa 63 6a 28 25 b3 39 c9 40 66 8a 31 57 24 4d 17</span><br><span class="line"> Round 4:</span><br><span class="line">   input:  fa 63 6a 28 25 b3 39 c9 40 66 8a 31 57 24 4d 17</span><br><span class="line">     sub:  2d fb 02 34 3f 6d 12 dd 09 33 7e c7 5b 36 e3 f0</span><br><span class="line">   shift:  2d 6d 7e f0 3f 33 e3 34 09 36 02 dd 5b fb 12 c7</span><br><span class="line">     mix:  63 85 b7 9f fc 53 8d f9 97 be 47 8e 75 47 d6 91</span><br><span class="line">   round:  47 f7 f7 bc 95 35 3e 03 f9 6c 32 bc fd 05 8d fd</span><br><span class="line">   state:  24 72 40 23 69 66 b3 fa 6e d2 75 32 88 42 5b 6c</span><br><span class="line"> Round 5:</span><br><span class="line">   input:  24 72 40 23 69 66 b3 fa 6e d2 75 32 88 42 5b 6c</span><br><span class="line">     sub:  36 40 09 26 f9 33 6d 2d 9f b5 9d 23 c4 2c 39 50</span><br><span class="line">   shift:  36 33 9d 50 f9 b5 39 26 9f 2c 09 2d c4 40 6d 23</span><br><span class="line">     mix:  f4 bc d4 54 32 e5 54 d0 75 f1 d6 c5 1d d0 3b 3c</span><br><span class="line">   round:  3c aa a3 e8 a9 9f 9d eb 50 f3 af 57 ad f6 22 aa</span><br><span class="line">   state:  c8 16 77 bc 9b 7a c9 3b 25 02 79 92 b0 26 19 96</span><br><span class="line"> Round 6:</span><br><span class="line">   input:  c8 16 77 bc 9b 7a c9 3b 25 02 79 92 b0 26 19 96</span><br><span class="line">     sub:  e8 47 f5 65 14 da dd e2 3f 77 b6 4f e7 f7 d4 90</span><br><span class="line">   shift:  e8 da b6 90 14 77 d4 65 3f f7 f5 e2 e7 47 dd 4f</span><br><span class="line">     mix:  98 16 ee 74 00 f8 7f 55 6b 2c 04 9c 8e 5a d0 36</span><br><span class="line">   round:  5e 39 0f 7d f7 a6 92 96 a7 55 3d c1 0a a3 1f 6b</span><br><span class="line">   state:  c6 2f e1 09 f7 5e ed c3 cc 79 39 5d 84 f9 cf 5d</span><br><span class="line"> Round 7:</span><br><span class="line">   input:  c6 2f e1 09 f7 5e ed c3 cc 79 39 5d 84 f9 cf 5d</span><br><span class="line">     sub:  b4 15 f8 01 68 58 55 2e 4b b6 12 4c 5f 99 8a 4c</span><br><span class="line">   shift:  b4 58 12 4c 68 b6 8a 01 4b 99 f8 2e 5f 15 55 4c</span><br><span class="line">     mix:  c5 7e 1c 15 9a 9b d2 86 f0 5f 4b e0 98 c6 34 39</span><br><span class="line">   round:  14 f9 70 1a e3 5f e2 8c 44 0a df 4d 4e a9 c0 26</span><br><span class="line">   state:  d1 87 6c 0f 79 c4 30 0a b4 55 94 ad d6 6f f4 1f</span><br><span class="line"> Round 8:</span><br><span class="line">   input:  d1 87 6c 0f 79 c4 30 0a b4 55 94 ad d6 6f f4 1f</span><br><span class="line">     sub:  3e 17 50 76 b6 1c 04 67 8d fc 22 95 f6 a8 bf c0</span><br><span class="line">   shift:  3e 1c 22 c0 b6 fc bf 76 8d a8 50 67 f6 17 04 95</span><br><span class="line">     mix:  ba a0 3d e7 a1 f9 b5 6e d5 51 2c ba 5f 41 4d 23</span><br><span class="line">   round:  47 43 87 35 a4 1c 65 b9 e0 16 ba f4 ae bf 7a d2</span><br><span class="line">   state:  fd e3 ba d2 05 e5 d0 d7 35 47 96 4e f1 fe 37 f1</span><br><span class="line"> Round 9:</span><br><span class="line">   input:  fd e3 ba d2 05 e5 d0 d7 35 47 96 4e f1 fe 37 f1</span><br><span class="line">     sub:  54 11 f4 b5 6b d9 70 0e 96 a0 90 2f a1 bb 9a a1</span><br><span class="line">   shift:  54 d9 90 a1 6b a0 9a b5 96 bb f4 0e a1 11 70 2f</span><br><span class="line">     mix:  e9 f7 4e ec 02 30 20 f6 1b f2 cc f2 35 3c 21 c7</span><br><span class="line">   round:  54 99 32 d1 f0 85 57 68 10 93 ed 9c be 2c 97 4e</span><br><span class="line">   state:  bd 6e 7c 3d f2 b5 77 9e 0b 61 21 6e 8b 10 b6 89</span><br><span class="line"> Round 10:</span><br><span class="line">   input:  bd 6e 7c 3d f2 b5 77 9e 0b 61 21 6e 8b 10 b6 89</span><br><span class="line">     sub:  7a 9f 10 27 89 d5 f5 0b 2b ef fd 9f 3d ca 4e a7</span><br><span class="line">   shift:  7a d5 fd a7 89 ef 4e 27 2b ca 10 0b 3d 9f f5 9f</span><br><span class="line">   round:  13 11 1d 7f e3 94 4a 17 f3 07 a7 8b 4d 2b 30 c5</span><br><span class="line">   state:  69 c4 e0 d8 6a 7b 04 30 d8 cd b7 80 70 b4 c5 5a</span><br><span class="line">Output:</span><br><span class="line">  cypher:  69 c4 e0 d8 6a 7b 04 30 d8 cd b7 80 70 b4 c5 5a</span><br></pre></td></tr></table></figure><h3 id="2-9-解密轮函数"><a href="#2-9-解密轮函数" class="headerlink" title="2.9 解密轮函数"></a>2.9 解密轮函数</h3><p>对Rijndael算法来说，<strong>解密过程就是加密过程的逆向过程</strong>，其解密轮函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aes_decrypt</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *data, <span class="keyword">int</span> len, <span class="keyword">uint8_t</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> w[<span class="number">4</span> * <span class="number">4</span> * <span class="number">15</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* round key */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span> * <span class="number">4</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* state */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nr, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* key expansion */</span></span><br><span class="line">    aes_key_expansion(mode, key, w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start data cypher loop over input buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">4</span> * g_aes_nb[mode]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* init state from user buffer (cyphertext) */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            s[j] = data[i + j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* start AES cypher loop over all AES rounds */</span></span><br><span class="line">        <span class="keyword">for</span> (nr = g_aes_rounds[mode]; nr &gt;= <span class="number">0</span>; nr--) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* do AddRoundKey */</span></span><br><span class="line">            aes_add_round_key(mode, s, w, nr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nr &lt; g_aes_rounds[mode]) &#123;</span><br><span class="line">                    <span class="comment">/* do MixColumns */</span></span><br><span class="line">                    inv_mix_columns(mode, s);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do ShiftRows */</span></span><br><span class="line">                inv_shift_rows(mode, s);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do SubBytes */</span></span><br><span class="line">                inv_sub_bytes(mode, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* save state (cypher) to user buffer */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            data[i + j] = s[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10-解密过程实例"><a href="#2-10-解密过程实例" class="headerlink" title="2.10 解密过程实例"></a>2.10 解密过程实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Decrypting block ...</span><br><span class="line"> Round 10:</span><br><span class="line">   input:  69 c4 e0 d8 6a 7b 04 30 d8 cd b7 80 70 b4 c5 5a</span><br><span class="line">   round:  13 11 1d 7f e3 94 4a 17 f3 07 a7 8b 4d 2b 30 c5</span><br><span class="line">   shift:  7a d5 fd a7 89 ef 4e 27 2b ca 10 0b 3d 9f f5 9f</span><br><span class="line">     sub:  7a 9f 10 27 89 d5 f5 0b 2b ef fd 9f 3d ca 4e a7</span><br><span class="line">   state:  bd 6e 7c 3d f2 b5 77 9e 0b 61 21 6e 8b 10 b6 89</span><br><span class="line"> Round 9:</span><br><span class="line">   input:  bd 6e 7c 3d f2 b5 77 9e 0b 61 21 6e 8b 10 b6 89</span><br><span class="line">   round:  54 99 32 d1 f0 85 57 68 10 93 ed 9c be 2c 97 4e</span><br><span class="line">     mix:  e9 f7 4e ec 02 30 20 f6 1b f2 cc f2 35 3c 21 c7</span><br><span class="line">   shift:  54 d9 90 a1 6b a0 9a b5 96 bb f4 0e a1 11 70 2f</span><br><span class="line">     sub:  54 11 f4 b5 6b d9 70 0e 96 a0 90 2f a1 bb 9a a1</span><br><span class="line">   state:  fd e3 ba d2 05 e5 d0 d7 35 47 96 4e f1 fe 37 f1</span><br><span class="line"> Round 8:</span><br><span class="line">   input:  fd e3 ba d2 05 e5 d0 d7 35 47 96 4e f1 fe 37 f1</span><br><span class="line">   round:  47 43 87 35 a4 1c 65 b9 e0 16 ba f4 ae bf 7a d2</span><br><span class="line">     mix:  ba a0 3d e7 a1 f9 b5 6e d5 51 2c ba 5f 41 4d 23</span><br><span class="line">   shift:  3e 1c 22 c0 b6 fc bf 76 8d a8 50 67 f6 17 04 95</span><br><span class="line">     sub:  3e 17 50 76 b6 1c 04 67 8d fc 22 95 f6 a8 bf c0</span><br><span class="line">   state:  d1 87 6c 0f 79 c4 30 0a b4 55 94 ad d6 6f f4 1f</span><br><span class="line"> Round 7:</span><br><span class="line">   input:  d1 87 6c 0f 79 c4 30 0a b4 55 94 ad d6 6f f4 1f</span><br><span class="line">   round:  14 f9 70 1a e3 5f e2 8c 44 0a df 4d 4e a9 c0 26</span><br><span class="line">     mix:  c5 7e 1c 15 9a 9b d2 86 f0 5f 4b e0 98 c6 34 39</span><br><span class="line">   shift:  b4 58 12 4c 68 b6 8a 01 4b 99 f8 2e 5f 15 55 4c</span><br><span class="line">     sub:  b4 15 f8 01 68 58 55 2e 4b b6 12 4c 5f 99 8a 4c</span><br><span class="line">   state:  c6 2f e1 09 f7 5e ed c3 cc 79 39 5d 84 f9 cf 5d</span><br><span class="line"> Round 6:</span><br><span class="line">   input:  c6 2f e1 09 f7 5e ed c3 cc 79 39 5d 84 f9 cf 5d</span><br><span class="line">   round:  5e 39 0f 7d f7 a6 92 96 a7 55 3d c1 0a a3 1f 6b</span><br><span class="line">     mix:  98 16 ee 74 00 f8 7f 55 6b 2c 04 9c 8e 5a d0 36</span><br><span class="line">   shift:  e8 da b6 90 14 77 d4 65 3f f7 f5 e2 e7 47 dd 4f</span><br><span class="line">     sub:  e8 47 f5 65 14 da dd e2 3f 77 b6 4f e7 f7 d4 90</span><br><span class="line">   state:  c8 16 77 bc 9b 7a c9 3b 25 02 79 92 b0 26 19 96</span><br><span class="line"> Round 5:</span><br><span class="line">   input:  c8 16 77 bc 9b 7a c9 3b 25 02 79 92 b0 26 19 96</span><br><span class="line">   round:  3c aa a3 e8 a9 9f 9d eb 50 f3 af 57 ad f6 22 aa</span><br><span class="line">     mix:  f4 bc d4 54 32 e5 54 d0 75 f1 d6 c5 1d d0 3b 3c</span><br><span class="line">   shift:  36 33 9d 50 f9 b5 39 26 9f 2c 09 2d c4 40 6d 23</span><br><span class="line">     sub:  36 40 09 26 f9 33 6d 2d 9f b5 9d 23 c4 2c 39 50</span><br><span class="line">   state:  24 72 40 23 69 66 b3 fa 6e d2 75 32 88 42 5b 6c</span><br><span class="line"> Round 4:</span><br><span class="line">   input:  24 72 40 23 69 66 b3 fa 6e d2 75 32 88 42 5b 6c</span><br><span class="line">   round:  47 f7 f7 bc 95 35 3e 03 f9 6c 32 bc fd 05 8d fd</span><br><span class="line">     mix:  63 85 b7 9f fc 53 8d f9 97 be 47 8e 75 47 d6 91</span><br><span class="line">   shift:  2d 6d 7e f0 3f 33 e3 34 09 36 02 dd 5b fb 12 c7</span><br><span class="line">     sub:  2d fb 02 34 3f 6d 12 dd 09 33 7e c7 5b 36 e3 f0</span><br><span class="line">   state:  fa 63 6a 28 25 b3 39 c9 40 66 8a 31 57 24 4d 17</span><br><span class="line"> Round 3:</span><br><span class="line">   input:  fa 63 6a 28 25 b3 39 c9 40 66 8a 31 57 24 4d 17</span><br><span class="line">   round:  b6 ff 74 4e d2 c2 c9 bf 6c 59 0c bf 04 69 bf 41</span><br><span class="line">     mix:  4c 9c 1e 66 f7 71 f0 76 2c 3f 86 8e 53 4d f2 56</span><br><span class="line">   shift:  3b d9 22 68 fc 74 fb 73 57 67 cb e0 c0 59 0e 2d</span><br><span class="line">     sub:  3b 59 cb 73 fc d9 0e e0 57 74 22 2d c0 67 fb 68</span><br><span class="line">   state:  49 15 59 8f 55 e5 d7 a0 da ca 94 fa 1f 0a 63 f7</span><br><span class="line"> Round 2:</span><br><span class="line">   input:  49 15 59 8f 55 e5 d7 a0 da ca 94 fa 1f 0a 63 f7</span><br><span class="line">   round:  b6 92 cf 0b 64 3d bd f1 be 9b c5 00 68 30 b3 fe</span><br><span class="line">     mix:  ff 87 96 84 31 d8 6a 51 64 51 51 fa 77 3a d0 09</span><br><span class="line">   shift:  a7 be 1a 69 97 ad 73 9b d8 c9 ca 45 1f 61 8b 61</span><br><span class="line">     sub:  a7 61 ca 9b 97 be 8b 45 d8 ad 1a 61 1f c9 73 69</span><br><span class="line">   state:  89 d8 10 e8 85 5a ce 68 2d 18 43 d8 cb 12 8f e4</span><br><span class="line"> Round 1:</span><br><span class="line">   input:  89 d8 10 e8 85 5a ce 68 2d 18 43 d8 cb 12 8f e4</span><br><span class="line">   round:  d6 aa 74 fd d2 af 72 fa da a6 78 f1 d6 ab 76 fe</span><br><span class="line">     mix:  5f 72 64 15 57 f5 bc 92 f7 be 3b 29 1d b9 f9 1a</span><br><span class="line">   shift:  63 53 e0 8c 09 60 e1 04 cd 70 b7 51 ba ca d0 e7</span><br><span class="line">     sub:  63 ca b7 04 09 53 d0 51 cd 60 e0 e7 ba 70 e1 8c</span><br><span class="line">   state:  00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0</span><br><span class="line"> Round 0:</span><br><span class="line">   input:  00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0</span><br><span class="line">   round:  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f</span><br><span class="line">   state:  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br><span class="line">Output:</span><br><span class="line">   plain:  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br></pre></td></tr></table></figure><h2 id="三、算法设计思想"><a href="#三、算法设计思想" class="headerlink" title="三、算法设计思想"></a>三、算法设计思想</h2><h3 id="3-1-加密算法的一般设计准则"><a href="#3-1-加密算法的一般设计准则" class="headerlink" title="3.1 加密算法的一般设计准则"></a>3.1 加密算法的一般设计准则</h3><p>混淆 (Confusion) 最大限度地复杂化密文、明文与密钥之间的关系，通常用非线性变换算法达到最大化的混淆。</p><p>扩散 (Diffusion) 明文或密钥每变动一位将最大化地影响密文中的位数，通常采用线性变换算法达到最大化的扩散。</p><h3 id="3-2-AES评判要求"><a href="#3-2-AES评判要求" class="headerlink" title="3.2 AES评判要求"></a>3.2 AES评判要求</h3><p>NIST在征集算法的时候就提出了几项硬性要求：</p><ul><li>分组加密算法：支持128位分组大小，128/192/256位密钥</li><li>安全性不低于3DES，但实施与执行要比3DES的更高效</li><li>优化过的ANSI C的实现代码</li><li>KAT(Known-Answer tests)及MCT(Monte Carlo Tests)测试及验证</li><li>软件及硬件实现的便捷</li><li>可抵御已知攻击</li></ul><h3 id="3-3-Rijndael设计思想"><a href="#3-3-Rijndael设计思想" class="headerlink" title="3.3 Rijndael设计思想"></a>3.3 Rijndael设计思想</h3><ul><li>安全性（Security） 算法足够强，抗攻击</li><li>经济性（Efficiency） 算法运算效率高</li><li>密钥捷变（Key Agility） 更改密钥所引入的损失尽量小，即最小消耗的密钥扩展算法</li><li>适应性 （Versatility） 适用于不同的CPU架构，软件或硬件平台的实现</li><li>设计简单（Simplicity） 轮函数的设计精简，只是多轮迭代</li></ul><h3 id="3-4-S盒设计"><a href="#3-4-S盒设计" class="headerlink" title="3.4 S盒设计"></a>3.4 S盒设计</h3><p>S盒是由一个有限域GF(256)上的乘法求逆并串联线性仿射变换所构造出来的，不是一个随意构造的简单查询表。因其运算复杂，众多的AES 软件及硬件实现直接使用了查找表(LUP, Look-up table)，但查询表的方式并不适合所有场景，针对特定的硬件最小化面积设计需求，则要采用优化的组合逻辑以得到同价的S盒替换。</p><h2 id="四、工作模式"><a href="#四、工作模式" class="headerlink" title="四、工作模式"></a>四、工作模式</h2><p>分组加密算法是按分组大小来进行加解密操作的，如DES算法的分组是64位，而AES是128位，但实际明文的长度一般要远大于分组大小，这样的情况如何处理呢？</p><p>这正是”mode of operation”即工作模式要解决的问题：明文数据流怎样按分组大小切分，数据不对齐的情况怎么处理等等。</p><p>早在1981年，DES算法公布之后，NIST在标准文献FIPS 81中公布了4种工作模式：</p><ul><li>电子密码本：Electronic Code Book Mode (ECB)</li><li>密码分组链接：Cipher Block Chaining Mode (CBC)</li><li>密文反馈：Cipher Feedback Mode (CFB)</li><li>输出反馈：Output Feedback Mode (OFB)</li></ul><p>2001年又针对AES加入了新的工作模式：</p><ul><li>计数器模式：Counter Mode (CTR)</li></ul><p>后来又陆续引入其它新的工作模式。在此仅介绍几种常用的：</p><h3 id="4-1-ECB：电子密码本模式"><a href="#4-1-ECB：电子密码本模式" class="headerlink" title="4.1 ECB：电子密码本模式"></a>4.1 ECB：电子密码本模式</h3><p>ECB模式只是将明文按分组大小切分，然后用同样的密钥正常加密切分好的明文分组。</p><img src="/images/encrypt/11.png" alt="02" style="zoom:100%;" /><p>ECB的理想应用场景是短数据（如加密密钥）的加密。此模式的问题是无法隐藏原明文数据的模式，因为同样的明文分组加密得到的密文也是一样的。</p><p>举例来说明，下图为明文图片：</p><img src="/images/encrypt/12.png" alt="02" style="zoom:50%;" /><p>经ECB模式加密的图片：</p><img src="/images/encrypt/13.png" alt="02" style="zoom:50%;" /><p>图中也正好验证了AES的扩散效果：作为局部图案的叶子，其红颜色在加密后扩散到了整张图片上。</p><p>经CBC模式加密的图片：</p><img src="/images/encrypt/14.jpg" alt="02" style="zoom:50%;" /><h3 id="4-2-CBC：密码分组链接模式"><a href="#4-2-CBC：密码分组链接模式" class="headerlink" title="4.2 CBC：密码分组链接模式"></a>4.2 CBC：密码分组链接模式</h3><p>此模式是1976年由IBM所发明，引入了IV（初始化向量：Initialization Vector）的概念。IV是长度为分组大小的一组随机，通常情况下不用保密，不过在大多数情况下，针对同一密钥不应多次使用同一组IV。 CBC要求第一个分组的明文在加密运算前先与IV进行异或；从第二组开始，所有的明文先与前一分组加密后的密文进行异或。[区块链(blockchain)的鼻祖！]  </p><img src="/images/encrypt/15.png" alt="02" style="zoom:70%;" /><p>CBC模式相比ECB实现了更好的模式隐藏，但因为其将密文引入运算，加解密操作无法并行操作。同时引入的IV向量，还需要加、解密双方共同知晓方可。</p><p>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aes_encrypt_cbc</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *data, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">uint8_t</span> *key, <span class="keyword">uint8_t</span> *iv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> w[<span class="number">4</span> * <span class="number">4</span> * <span class="number">15</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* round key */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span> * <span class="number">4</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* state */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> v[<span class="number">4</span> * <span class="number">4</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* iv */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nr, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* key expansion */</span></span><br><span class="line">    aes_key_expansion(mode, key, w);</span><br><span class="line">    <span class="built_in">memcpy</span>(v, iv, <span class="keyword">sizeof</span>(v));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start data cypher loop over input buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">4</span> * g_aes_nb[mode]) &#123;</span><br><span class="line">        <span class="comment">/* init state from user buffer (plaintext) */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            s[j] = data[i + j] ^ v[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* start AES cypher loop over all AES rounds */</span></span><br><span class="line">        <span class="keyword">for</span> (nr = <span class="number">0</span>; nr &lt;= g_aes_rounds[mode]; nr++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nr &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do SubBytes */</span></span><br><span class="line">                aes_sub_bytes(mode, s);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do ShiftRows */</span></span><br><span class="line">                aes_shift_rows(mode, s);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nr &lt; g_aes_rounds[mode]) &#123;</span><br><span class="line">                    <span class="comment">/* do MixColumns */</span></span><br><span class="line">                    aes_mix_columns(mode, s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* do AddRoundKey */</span></span><br><span class="line">            aes_add_round_key(mode, s, w, nr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* save state (cypher) to user buffer */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            data[i + j] = v[j] = s[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-CFB：密文反馈模式"><a href="#4-3-CFB：密文反馈模式" class="headerlink" title="4.3 CFB：密文反馈模式"></a>4.3 CFB：密文反馈模式</h3><p>与CBC模式类似，但不同的地方在于，CFB模式先生成密码流字典，然后用密码字典与明文进行异或操作并最终生成密文。后一分组的密码字典的生成需要前一分组的密文参与运算。</p><img src="/images/encrypt/16.png" alt="02" style="zoom:70%;" /><p>CFB模式是用分组算法实现流算法，明文数据不需要按分组大小对齐。</p><h3 id="4-4-OFB：输出反馈模式"><a href="#4-4-OFB：输出反馈模式" class="headerlink" title="4.4 OFB：输出反馈模式"></a>4.4 OFB：输出反馈模式</h3><p>OFB模式与CFB模式不同的地方是：生成字典的时候会采用明文参与运算，CFB采用的是密文。</p><img src="/images/encrypt/17.png" alt="02" style="zoom:70%;" /><h3 id="4-5-CTR：计数器模式模式"><a href="#4-5-CTR：计数器模式模式" class="headerlink" title="4.5 CTR：计数器模式模式"></a>4.5 CTR：计数器模式模式</h3><p>CTR模式同样会产生流密码字典，但同是会引入一个计数，以保证任意长时间均不会产生重复输出。</p><img src="/images/encrypt/18.png" alt="02" style="zoom:70%;" /><p>CTR模式只需要实现加密算法以生成字典，明文数据与之异或后得到密文，反之便是解密过程。CTR模式可以采用并行算法处理以提升吞量，另外加密数据块的访问可以是随机的，与前后上下文无关。</p><h3 id="4-6-CCM：Counter-with-CBC-MAC"><a href="#4-6-CCM：Counter-with-CBC-MAC" class="headerlink" title="4.6 CCM：Counter with CBC-MAC"></a>4.6 CCM：Counter with CBC-MAC</h3><p>CCM模式，全称是Counter with Cipher Block Chaining-Message Authentication Code，是CTR工作模式和CMAC认证算法的组合体，可以同时数据加密和鉴别服务。</p><p>明文数据通过CTR模式加密成密文，然后在密文后面再附加上认证数据，所以最终的密文会比明文要长。具体的加密流程如下描述：先对明文数据认证并产生一个tag，在后续加密过程中使用此tag和IV生成校验值U。然后用CTR模式来加密原输入明文数据，在密文的后面附上校验码Ｕ。</p><h3 id="4-7-GCM：伽罗瓦计数器模式"><a href="#4-7-GCM：伽罗瓦计数器模式" class="headerlink" title="4.7 GCM：伽罗瓦计数器模式"></a>4.7 GCM：伽罗瓦计数器模式</h3><p>类型CCM模式，GCM模式是CTR和GHASH的组合，GHASH操作定义为密文结果与密钥以及消息长度在GF（2^128）域上相乘。GCM比CCM的优势是在于更高并行度及更好的性能。TLS 1.2标准使用的就是AES-GCM算法，并且Intel CPU提供了GHASH的硬件加速功能。</p><h2 id="五、硬件加速"><a href="#五、硬件加速" class="headerlink" title="五、硬件加速"></a>五、硬件加速</h2><p>AES作为主导的加密标准，其应用越来越广泛，特别是针对网络数据的加密需求，越来越多的硬件都集成AES 128/192/256位算法及不同的工作模式的硬件加速的实现。</p><h3 id="5-1-AES-NI-X86架构"><a href="#5-1-AES-NI-X86架构" class="headerlink" title="5.1 AES_NI: X86架构"></a>5.1 AES_NI: X86架构</h3><p>Intel于2010发发布了支持AES加速的CPU，实现了高阶的AES加解密指令即AES_NI：AES New Instructions。AES_NI包含6指令：其中4条用于加解密，2条用于密钥扩展。根据<a href="https://software.intel.com/sites/default/files/article/165683/aes-wp-2012-09-22-v01.pdf">AES_NI白皮书</a>中所说，AES_NI可以带来2-3倍的性能提升。</p><table><thead><tr><th>Instruction</th><th>Description</th></tr></thead><tbody><tr><td>AESENC</td><td>Perform one round of an AES encryption flow</td></tr><tr><td>AESENCLAST</td><td>Perform the last round of an AES encryption flow</td></tr><tr><td>AESDEC</td><td>Perform one round of an AES decryption flow</td></tr><tr><td>AESDECLAST</td><td>Perform the last round of an AES decryption flow</td></tr><tr><td>AESKEYGENASSIST</td><td>Assist in AES round key generation</td></tr><tr><td>AESIMC</td><td>Assist in AES Inverse Mix Columns</td></tr></tbody></table><p>目前OpenSSL，Linux’s Crypto API以及Windows Cryptography API中均已加入对AES_NI的支持。</p><h4 id="AES-NI-测试"><a href="#AES-NI-测试" class="headerlink" title="AES_NI: 测试"></a>AES_NI: 测试</h4><p>测试环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz 4 Cores with HyperThread (Enabled or Disabled)</span><br><span class="line">Ubuntu 16.04 AMD64, OpenSSL 1.0.2g-fips  1 Mar 2016</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">关闭硬件加速1&#x2F;2&#x2F;4&#x2F;8线程AES-256&#x2F;128-CBC：</span><br><span class="line">OPENSSL_ia32cap&#x3D;&quot;~0x200000200000000&quot; openssl speed -multi &#123;1&#x2F;2&#x2F;4&#x2F;8&#125; -elapsed -evp &#123;aes-256&#x2F;128-cbc&#125;</span><br><span class="line"></span><br><span class="line">开启硬件加速1&#x2F;2&#x2F;4&#x2F;8线程AES-256&#x2F;128-CBC：</span><br><span class="line">openssl speed -multi &#123;1&#x2F;2&#x2F;4&#x2F;8&#125; -elapsed -evp &#123;aes-256&#x2F;128-cbc&#125;</span><br><span class="line"></span><br><span class="line">超线程的开户与关闭只能通过UEFI&#x2F;BIOS来设置，测试命令同上。</span><br></pre></td></tr></table></figure><img src="/images/encrypt/19.png" alt="02" style="zoom:95%;" /><p>从图中可以得到如下结论：</p><ol><li> AES_NI加速可以提升性能1倍多，AESNI-128基本上都是AES-128的2.2倍左右。</li><li> AES-128与AES-256的性能比基本在1.36左右（15/11，忽略密钥编排用时的情况下）</li><li> 比较有趣的一点发现是，超线程所带来的影响比预想的要大得多。针对高并行的情形，在开启AES_NI时超线程可以带来接近1倍的性能提升；但在关闭AES_NI的情况下对性能提升的贡献要小的多。超线程虽然逻辑上让我们觉得一核变成了两核，其实质只是同一物理核上的队列管理机制，关闭AES_NI的情况下的测试数据基本验证了这一点。另一方面AES_NI硬件加速是基于物理核的，不可能是针对超线程的，所以超线程与AES_NI组合所带来的巨大的性能提升让人有些费解，比较可能的解释是AES_NI硬件加速引擎的潜力足够强大以至于一个物理核心不能完全发挥其效能，所以在超线程开启的情况下能有更好的表现。</li></ol><h3 id="5-2-ARM及其它体系"><a href="#5-2-ARM及其它体系" class="headerlink" title="5.2 ARM及其它体系"></a>5.2 ARM及其它体系</h3><p>2011年发布的ARMv8-A处理器架构开始支持AES加速指令，其指令集与AES_NI不兼容但实现了类似的功能。除ARM外，SUN SPARC(T4, T5, M5以后)及IBM Power7+架构的CPU均已支持AES加速。</p><h2 id="六、实现上的安全性考虑"><a href="#六、实现上的安全性考虑" class="headerlink" title="六、实现上的安全性考虑"></a>六、实现上的安全性考虑</h2><h3 id="6-1-内存与交换"><a href="#6-1-内存与交换" class="headerlink" title="6.1 内存与交换"></a>6.1 内存与交换</h3><p>程序如果将密钥存储在可交换内存页中，在内存吃紧的情况下有可能会交换出来并写入磁盘。如辅以代码逆向等，密钥很有可能会泄露。</p><p>应用层最好用mlock(Linux)或VirtualLock(Windows)来防止内存页被交换至磁盘。</p><p>但因为密钥在内存中，所以任何能访问内存的方式均有可能导致密钥的泄漏。曾流行的一种攻击是通过1394 DMA方式来访问目标机内存，Linux/Windows Login bypass，Windows bitlock等漏洞均由起引起。较新的CPU为硬件虚拟化所引入的IO MMU （Intel VT-d or AMD-Vi）可以有效地限制硬件对内存的访问权限。</p><h3 id="6-2-传统攻击"><a href="#6-2-传统攻击" class="headerlink" title="6.2 传统攻击"></a>6.2 传统攻击</h3><p>AES从产生至今依然是最安全的加密算法，传统攻击手段依然无法撼动其安全性。虽然已有<a href="https://www.schneier.com/blog/archives/2009/07/another_new_aes.html">攻击手段</a>显示可以将AES-256的暴力搜索次数从2^256次降至2^119次，但依然没有实际操作价值。</p><p>不过随着计算力的提升，特别是量子计算机的发展，AES将不再是安全的。不过可以肯定的是：一定会出现更安全的加密算法。</p><h3 id="6-3-旁路攻击"><a href="#6-3-旁路攻击" class="headerlink" title="6.3 旁路攻击"></a>6.3 旁路攻击</h3><p>旁路攻击（Side-channel attack, SCA）是指绕过对加密算法的正面对抗及分析，利用硬件实现加密算法的逻辑电路在运算中所泄露的信息，如执行时间、功耗、电磁辐射等，并结合统计理论来实现对密码系统攻击的手段。</p><p>旁路攻击成功的必要条件：</p><ol><li> 在泄漏的物理信号与处理的数据之间建立关联</li><li> 在信息泄漏模型中处理的数据与芯片中处理的数据之间建立关联</li></ol><p>智能卡CPU的实现逻辑相对比较简单，并且都是单线程处理机制，因此可以很好的建立起密码-时序或密码-功耗之间的关联。</p><h4 id="6-3-1-时序攻击"><a href="#6-3-1-时序攻击" class="headerlink" title="6.3.1 时序攻击"></a>6.3.1 时序攻击</h4><p>不同的数值及不同的运算所需时间是不同的，在算法(运算逻辑)固定的前提下完全可以根据运行时间反推出具体的操作数。举个简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (strelen(passwd) != <span class="keyword">sizeof</span>(fixed_passwd))</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(fixed_passwd); i++)</span><br><span class="line">  <span class="keyword">if</span> (passwd[i] != fixed_passwd[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这段代码在密码的判断上就存在时序攻击的漏洞，如果第一个字符不匹配则直接退出，只有在当前字符匹配的情况下才会继续下一个字符的比较。</p><p>所以如果实际密码长度为8位且只能用字母及数字，则理论上暴力搜索次数为 (26 *2 + 10) ^ 8。但因为算法的实现没有考虑到时序攻击，如果将执行时间加入考量，则搜索次数将降低至(26 *2 + 10) * 8。</p><p>本文示例代码中aes_mul()的实现也有时序攻击的漏洞，并且实现效率也比较低，当然主要目的是为了算法演示。</p><h4 id="6-3-2-功耗攻击"><a href="#6-3-2-功耗攻击" class="headerlink" title="6.3.2 功耗攻击"></a>6.3.2 功耗攻击</h4><p>当信号发生0-1跳变时，需要电源对电容进行充电；而在其它三种情况(0-0, 1-1, 1-0)下则不会进行充电操作，因此可以很容易区分出前者来，这就是功耗攻击原理的简单解释。</p><p>功耗攻击一般分为简单功耗攻击(Simple Power Analysis，SPA)，差分功耗攻击(Differential Power Analysis, DPA)，高阶DPA等。SPA可以揭示出执行操作和能耗泄露间的关系，而DPA则能够揭示出处理数据和能耗泄露间的关系。</p><p>DPA利用不同数据对应的条件功耗分布的差异进行统计分析以找出数值与功耗的微弱关联性，并利用此关联性极大的降低密钥的搜索空间，进而完成高效且低成本的攻击。</p><p>上海交大的教授<a href="http://yuyu.hk/">郁昱</a>就通过功耗攻击成功破解了来自多家手机制造商以及服务供应商的SIM卡的密钥。更详细信息可见于他在Blackhat 2015年的<a href="http://yuyu.hk/files/us-15-Yu-Cloning-3G-4G-Sim-Cards.pdf">演示稿: Cloning 3G/4G SIM Cards with a PC and an Oscilloscope: Lessons Learned in Physical Security</a>。</p><p>以色列特拉维夫大学的研究人员利用旁路攻击，成功从Android和iOS设备上窃取到用于加密比特币钱包、Apple Pay账号和其他高价值资产的密钥，详细请参阅<a href="https://www.cs.tau.ac.il/~tromer/mobilesc/mobilesc.pdf">论文: ECDSA Key Extraction from Mobile Devices via Nonintrusive Physical Side Channels</a>。</p><h2 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h2><ol><li> 密码学原理与实践(第二版)，Douglas R. Stinson，<strong>冯登国</strong>译</li><li> <a href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf">AES Proposal: Rijndael by Joan Daemen and Vincent Rijmen</a></li><li> <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">FIPS 197: <strong>Announcing the AES</strong></a></li><li> <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Advanced Encryption Standard - <strong>Wikipedia</strong></a></li><li> <a href="http://www.springer.com/gp/book/9783540425809">The Design of Rijndael by Joan Daemen &amp; Vincent Rijmen</a></li><li> The Block Cipher Companion, <strong>L. Knudsen &amp; M. Robshaw</strong>, 2011</li><li> 加密芯片的旁道攻击防御对策研究(博士学位论文),  <strong>李海军</strong>, 2008</li><li> <a href="https://g2ex.github.io/2016/05/31/Power-Analysis-Attacks-on-Smart-Card/">旁路之能量分析攻击总结</a></li><li> AES算法介绍: <strong>万天添</strong>，2015/3/23</li><li> <a href="https://en.wikipedia.org/wiki/AES_instruction_set">AES_NI - <strong>Wikipedia</strong></a></li><li> <a href="https://software.intel.com/en-us/articles/intel-advanced-encryption-standard-aes-instructions-set/">AES_NI v3.01 - <strong>Intel</strong></a></li></ol><h2 id="八、相关代码"><a href="#八、相关代码" class="headerlink" title="八、相关代码"></a>八、相关代码</h2><ol><li> <a href="https://github.com/matt-wu/AES/">https://github.com/matt-wu/AES/</a></li></ol><p>&lt;最早的手工计算AES-128的想法源于2016年底读过的一本书《How Software Works: The Magic Behind Encryption …》，在阅读过程中发现AES一节中的数据全对不上，然后于17年初开始翻阅AES及Rijndael算法标准等资料，等看完所有文档后才发现此书对AES的介绍真是简化得没边了，后来又做了大量的延伸阅读，春节期间根据FIPS 197及《The Design of Rijndael》实现了AES 128/192/256 ECB/CBC的计算过程，之后开始本blog的书写，中间断断续续直至今日才完工，本文估计用时约40小时。学习从来不是容易的事！但越是不容易的事情做起来才更有乐趣！&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.dynox.cn/?p=1562&quot;&gt;原文链接&lt;/a&gt;，一字不差转载(防丢失)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、AES简介&quot;&gt;&lt;a href=&quot;#一、AES简介&quot; class=&quot;he</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>数据加密 — 非对称加密(加签/加密，以RSA为例)</title>
    <link href="https://tenloy.github.io/2021/12/20/asymmetric.html"/>
    <id>https://tenloy.github.io/2021/12/20/asymmetric.html</id>
    <published>2021-12-20T15:49:12.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-非对称加密-公钥加密"><a href="#1-1-非对称加密-公钥加密" class="headerlink" title="1.1 非对称加密(公钥加密)"></a>1.1 非对称加密(公钥加密)</h3><p>公开密钥密码学（Public-key cryptography）也称非对称式密码学（Asymmetric cryptography）是密码学的一种算法。</p><ul><li>它需要两个密钥，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。</li><li>公钥可以公开，可任意向外发布；<strong>私钥不可以公开，必须由用户自行严格秘密保管</strong>，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。</li><li><strong>公钥加密，私钥加密</strong>：使用公钥把明文加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。</li><li><strong>私钥签名，公钥验签</strong>：基于非对称加密的特性，它还能提供<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0">数字签名</a>的功能，使电子文件可以得到如同在纸本文件上亲笔签署的效果。</li></ul><h3 id="1-2-RSA算法"><a href="#1-2-RSA算法" class="headerlink" title="1.2 RSA算法"></a>1.2 RSA算法</h3><p><strong>RSA加密算法</strong>是一种非对称加密算法。</p><p>RSA在相关应用的时候，是需要有一些标准的 — PKI(public key infrastructure)标准(见上篇)。最常用的是pkcs。现在的各种程序中，基本都是遵循这个标准来使用RSA的。</p><ul><li><p><a href="https://www.rsa.com/">RSA官网</a></p></li><li><p><a href="https://www.rfc-editor.org/search/rfc_search_detail.php?title=pkcs&pubstatus%5B%5D=Any&pub_date_type=any">标准的查看</a></p></li></ul><p>公钥加密标准(The Public-Key Cryptography Standards, PKCS)是由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。</p><p><strong>RSA根据密钥长度可以分为rsa 2048、rsa 1024(单位是bit，换算成字节分别是256、128)。注意不要把密钥长度跟证书长度混淆，在rsa1024中，证书的长度应该是216。</strong></p><h2 id="二、加密、解密"><a href="#二、加密、解密" class="headerlink" title="二、加密、解密"></a>二、加密、解密</h2><p>加密的目的是实现只有指定个体才能打开发送方发出的数据，所以<strong>公钥加密</strong>(使用指定接受者的公钥来加密)，<strong>私钥解密</strong>，常用的加密算法如RSA</p><h2 id="三、加签、验签"><a href="#三、加签、验签" class="headerlink" title="三、加签、验签"></a>三、加签、验签</h2><p>接收方可以通过签名来确认发送方的身份，并可进行数据完整性检查。由RSA加密算法的规则可知，一个安全个体的私钥只有自己才知道，公钥则是可以被多方知道，所以要起到签名的效果，需要<strong>私钥签名，公钥验签</strong>。</p><img src="/images/encrypt/01.jpg" alt="01" style="zoom:70%;" /><p><strong>步骤</strong>：</p><ul><li>将原始数据哈希运算，得出标记，用 A 的私钥进行一次非对称加密算法处理。</li><li>B用A的公钥进行解密：<ul><li>如果能解出来，表示：确实是 A 发的。</li><li>如果解出来的值与收到的原始文本算出的哈希值相同，表示：数据传输途中未被修改。</li></ul></li></ul><p><strong>过程中出现的算法</strong>：</p><ul><li><p>哈希算法：将任意长度的消息M映射成一个固定长度的散列值h(也称为消息摘要)，常见的比如MD4、MD5、SHA-1、SHA-256、SHA-384、SHA-512</p></li><li><p>签名算法：RSA、DSA。其中RSA既能当做加密算法，也能当做签名算法来用，正反逆运算都是通的。<strong>DSA只能用作签名</strong> </p></li><li><p>本文代码签名算法为SHA1+RSA，Java中称 <code>SHA1WithRSA</code></p></li></ul><h2 id="四、iOS中的RSA"><a href="#四、iOS中的RSA" class="headerlink" title="四、iOS中的RSA"></a>四、iOS中的RSA</h2><p>在iOS中使用RSA加/验签、加/解密，首先需要拿到我们想要的公钥、私钥，在 <a href="%5Bhttps://www.jianshu.com/p/bc32cbfe49e7%5D(https://www.jianshu.com/p/bc32cbfe49e7)">上篇博客</a> 中已经介绍过：</p><p>证书文件常见的两种编码方式：<strong>DER编码</strong>、<strong>PEM编码</strong>。</p><p>在iOS中经常接触到的证书格式标准：<strong>PKCS#1</strong>、<strong>PKCS#8(java中经常使用)<strong>、</strong>PKCS#12</strong>，PKCS#12文件扩展名为**.p12或者.pfx**(可存储公钥+私钥)，此外常见的还有<code>.cer/.crt/.der</code> (存储的是公钥)。</p><p>注意：</p><ul><li>加载 .p12 文件代码转换成私钥</li><li>加载.cer .crt  .der文件代码转换成公钥</li><li>直接将PEM编码格式的、PKCS#1格式的公钥、PKCS#1 / PKCS#8标准的私钥硬编码，写在代码里使用</li></ul><p>以上都是可以的，但是首先需要先确定到底使用哪种方式，因为不同的数据加载方式、不同的证书格式，所要处理的过程是不一样的。详见下面代码</p><h2 id="五、代码处理过程"><a href="#五、代码处理过程" class="headerlink" title="五、代码处理过程"></a>五、代码处理过程</h2><p>这里使用的是iOS SDK中的 Security.framework 库，非openssl库，多年以前苹果就弃用了 OpenSSL，转而推荐自有框架 Security 和 CommonCrypto。当然你仍然可以使用 OpenSSL，比如说在 iOS 上使用开源库 <a href="https://link.jianshu.com/?t=https://github.com/x2on/OpenSSL-for-iPhone">OpenSSL for iPhone</a>。</p><p>分为两步(其实很简单)：</p><ol><li><p>将公私钥文件或者字符串转换成 SecKeyRef 对象， SecKeyRef 对象是一个密码学角度的抽象的密钥对象（也就是说它可以代表一个公钥、私钥或者某种对称加密的密钥）。无论是加解密还是签名，都会需要这个对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="meta-keyword">pragma</span> mark - &#x27;.der&#x27;公钥文件生成SecKeyRef对象(公钥)</span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">pragma</span> mark - PKCS#1、PKCS#8 PEM编码公钥生成SecKeyRef对象(公钥)</span></span><br><span class="line"><span class="comment">//PKCS#8格式的证书如果在代码的处理上，比PKCS#1多了一步对header的处理，也就是demo中的stripPublicKeyHeader函数，如果是PKCS#1的证书，跳过这个函数即可</span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">pragma</span> mark - &#x27;.12&#x27;私钥文件生成SecKeyRef对象(私钥)</span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">pragma</span> mark - PKCS#1、PKCS#8 PEM编码公钥生成SecKeyRef对象(私钥)</span></span><br><span class="line"><span class="comment">//生成代码与公钥过程大致相同，有一些细微差别</span></span><br></pre></td></tr></table></figure><p>有兴趣可以看下<a href="https://www.jianshu.com/p/783f2605f3e9">这篇文章 — iOS 生成 SecKeyRef 的正规方式</a>，文章有提到直接处理PEM编码格式的头时，由于对应的代码解析力不够强，经常会返回一个空的密钥对象，但是在我们APP内频繁测试没有发现这个问题(如果读到这里能为我解答这个疑问，麻烦评论留言一下吧，多谢)</p></li><li><p>调用相应的函数，实现功能</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加签函数</span></span><br><span class="line">OSStatus SecKeyRawSign(SecKeyRef key, SecPadding padding, <span class="keyword">const</span> uint8_t *dataToSign, size_t dataToSignLen, uint8_t *sig, size_t *sigLen);</span><br><span class="line"><span class="comment">//验签函数</span></span><br><span class="line">OSStatus SecKeyRawVerify(SecKeyRef key, SecPadding padding, <span class="keyword">const</span> uint8_t *signedData, size_t signedDataLen, <span class="keyword">const</span> uint8_t *sig, size_t sigLen);</span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line">OSStatus SecKeyEncrypt(SecKeyRef key, SecPadding padding, <span class="keyword">const</span> uint8_t *plainText, size_t plainTextLen, uint8_t *cipherText, size_t *cipherTextLen);</span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line">OSStatus SecKeyDecrypt(SecKeyRef key, SecPadding padding, <span class="keyword">const</span> uint8_t *cipherText, size_t cipherTextLen, uint8_t *plainText, size_t *plainTextLen)</span><br></pre></td></tr></table></figure><p>从上面的函数可以看到，函数参数并不复杂，将1中生成SecKeyRef对象传入，数据传输两端确定padding填充方式即可。<strong>要确认两边使用的签名算法设置参数一致</strong>；，详细代码看demo即可</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// digest message with sha1</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)sha1:(<span class="built_in">NSString</span> *)str</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *data = [str cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    CC_LONG len = (CC_LONG)strlen(data);</span><br><span class="line">    uint8_t * md = malloc( CC_SHA1_DIGEST_LENGTH * <span class="keyword">sizeof</span>(uint8_t) );;</span><br><span class="line">    CC_SHA1(data, len, md);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:md length:CC_SHA1_DIGEST_LENGTH];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="6-1-为什么RSA公钥加密使用PKCS1填充每次生成结果都不一样？"><a href="#6-1-为什么RSA公钥加密使用PKCS1填充每次生成结果都不一样？" class="headerlink" title="6.1 为什么RSA公钥加密使用PKCS1填充每次生成结果都不一样？"></a>6.1 为什么RSA公钥加密使用PKCS1填充每次生成结果都不一样？</h3><p>在<a href="https://tenloy.github.io/2021/12/09/pki.html#PKCS1%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F">上一篇博客 — 常见的PKI标准(X.509、PKCS)</a> 中已经介绍过PKCS1填充方式的过程,不再赘述，总结一下：</p><ul><li><p><strong>PKCS1填充格式：加密块EB</strong> = <strong>00 + 块类型BT + 填充字符PS + 00 + 数据D</strong>。</p></li><li><p><strong>如果使用公钥操作，BT永远为02，而对于BT为02的，PS对应的填充字节的值随机产生但不能是0字节(非00)。</strong></p></li><li><p>填充后，进行加密运算之前的数据不一致，得出的结果当然就不一样。</p></li><li><p>(<a href="https://blog.csdn.net/guyongqiangx/article/details/74930951">这篇博客</a>的作者一步步验证了这个现象，感兴趣的可以看下)</p></li></ul><h2 id="七、代码整理Demo"><a href="#七、代码整理Demo" class="headerlink" title="七、代码整理Demo"></a>七、代码整理Demo</h2><p>在<a href="https://github.com/ideawu/Objective-C-RSA">Objective-C-RSA</a>项目代码的基础上，根据自己项目的使用场景，整理了一下代码，放在了 <a href="https://github.com/Roten8/RSAHandle">GitHub - RSAHandle</a> 上，希望能有所帮助，有什么问题可以留言讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-非对称加密-公钥加密&quot;&gt;&lt;a href=&quot;#1-1-非对称加密-公钥加密&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的PKI标准(X.509、PKCS)及证书相关介绍</title>
    <link href="https://tenloy.github.io/2021/12/09/pki.html"/>
    <id>https://tenloy.github.io/2021/12/09/pki.html</id>
    <published>2021-12-09T15:07:02.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PKI(public key infrastructure)标准可以分为第一代标准和第二代标准。</p><p>第一代PKI标准主要包括：</p><ul><li>美国RSA公司的<strong>公钥加密标准</strong>（<code>Public Key Cryptography Standards，PKCS</code>）系列</li><li>国际电信联盟的ITU-T <code>X.509</code></li><li>IETF组织的公钥基础设施X.509（Public Key Infrastructure X.509，PKIX）标准系列</li><li>无线应用协议（Wireless Application Protocol ,WAP）论坛的无线公钥基础设施（Wireless Public Key Infrastructure，WPKI）标准等。</li></ul><p><strong>第一代PKI标准主要是基于抽象语法符号（Abstract Syntax Notation One，ASN.1）编码的</strong>，实现比较困难，这也在一定程度上影响了标准的推广。</p><p>第二代PKI标准，略。</p><p>CA中心普遍采用的规范是X.509系列和PKCS系列。</p><h2 id="一、ASN-1-数据结构描述语言"><a href="#一、ASN-1-数据结构描述语言" class="headerlink" title="一、ASN.1 - 数据结构描述语言"></a>一、ASN.1 - 数据结构描述语言</h2><p>引用自<a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One">Wiki</a>：</p><blockquote><p>ASN.1 is a standard <strong>interface description language</strong> for defining <strong>data structures</strong> that can be serialized and deserialized in a <strong>cross-platform</strong> way.</p></blockquote><p>也就是说ASN.1是一种用来定义数据结构的接口描述语言，它不是二进制，也不是文件格式，看下面的例子你就会明白了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FooQuestion ::&#x3D; SEQUENCE &#123;</span><br><span class="line">    trackingNumber INTEGER,</span><br><span class="line">    question       IA5String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了FooQuestion的数据结构，下面是FooQuestion这个数据接口的某个具体的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myQuestion FooQuestion ::&#x3D; SEQUENCE &#123;</span><br><span class="line">    trackingNumber     5,</span><br><span class="line">    question           &quot;Anybody there?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ASN.1用在很多地方比如下面要讲的 <a href="https://en.wikipedia.org/wiki/X.509">X.509</a> 和 <a href="https://en.wikipedia.org/wiki/PKCS">PKCS group of cryptography standards</a>。</p><h2 id="二、文件编码格式"><a href="#二、文件编码格式" class="headerlink" title="二、文件编码格式"></a>二、文件编码格式</h2><h3 id="2-1-DER编码格式"><a href="#2-1-DER编码格式" class="headerlink" title="2.1 DER编码格式"></a>2.1 DER编码格式</h3><p>引用自<a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One">Wiki</a>：</p><blockquote><p>ASN.1 is closely associated with a set of encoding rules that specify how to represent a data structure as a series of bytes</p></blockquote><p>意思是ASN.1有一套关联的编码规则，这些编码规则用来规定如何用二进制来表示数据结构，<a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">DER</a>是其中一种。</p><p>把上面的FooQuestion的例子用DER编码则是（16进制）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 13 02 01 05 16 0e 41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f</span><br></pre></td></tr></table></figure><p>翻译过来就是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">30 — type tag indicating SEQUENCE</span><br><span class="line">13 — length in octets of value that follows</span><br><span class="line">  02 — type tag indicating INTEGER</span><br><span class="line">  01 — length in octets of value that follows</span><br><span class="line">    05 — value (5)</span><br><span class="line">  16 — type tag indicating IA5String </span><br><span class="line">     (IA5 means the full 7-bit ISO 646 set, including variants, </span><br><span class="line">      but is generally US-ASCII)</span><br><span class="line">  0e — length in octets of value that follows</span><br><span class="line">    41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f — value (&quot;Anybody there?&quot;)</span><br></pre></td></tr></table></figure><p>看到这里你应该对DER编码格式有一个比较好的认识了。</p><p>我们可以使用openssl命令来看一下pkcs1.der的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">openssl asn1parse -i -<span class="keyword">in</span> pkcs1.der -inform DER</span><br><span class="line">    0:d=0  hl=4 l= 604 cons: SEQUENCE</span><br><span class="line">    4:d=1  hl=2 l=   1 prim:  INTEGER           :00</span><br><span class="line">    7:d=1  hl=3 l= 129 prim:  INTEGER           :ACB3B7D2A7EA996800A05BEAC54AD1CE0F1F19EC7AF56C53319EA75EEB54A6705E9D6EE73F0B5960258FC5CAB4CFC65BB8C063694E1567D653DFBD0282367E3DDA477C925D3CEB77E1537AE4FBBFF5F11FAE402AE9B33F511B3D734929911F69B78A0C3335A7E38AEF6F009EDE999E509931881AA01AA3ADB0EF0697C7C81F23</span><br><span class="line">  139:d=1  hl=2 l=   3 prim:  INTEGER           :010001</span><br><span class="line">  144:d=1  hl=3 l= 128 prim:  INTEGER           :2898FEC7686DBFAE312781340938F3650B2CF67D1ED27EAA77E9A1D2B0636FD4CE8917BF0894F467A3ACCE843E48F18A323E17A0739898964B9536EB560CD553F5E0305BB3F762033E169269F1E9935E37055BBA7DCD07BEDF8A21F52AB63D214872275B5B48090440DCE26850359335335B0FE88D431FBA4F9DC0198DE76691</span><br><span class="line">  275:d=1  hl=2 l=  65 prim:  INTEGER           :E081C9230D8281F520C1F2D1B8A220B71FFAC7716F48CBD71528522A2B2FB5907885263B06698F095A936BE1ED3149A5720BDA22EC80892645B07BDE1109D135</span><br><span class="line">  342:d=1  hl=2 l=  65 prim:  INTEGER           :C4ED93DD4F5834E428A8EB780E0CD444297326D6C3D655E671BE4C3CA90BC5C8013F3195A2BDB5D7DBC280698C93F9F5EB6BF2B396077E2C5E83C5CB20D7D1F7</span><br><span class="line">  409:d=1  hl=2 l=  64 prim:  INTEGER           :3FA8AD76D202DA84BE48206915386B9C6166039D879795AD2423ADC0A5443EF07B2C0E1E18805FFDA000434BE9ACDB1C1D8D7CCA0053A610031CBAD2C9F405AD</span><br><span class="line">  475:d=1  hl=2 l=  64 prim:  INTEGER           :76EB61178C0AA02607C7BA2A4D91C1BD47AA9A11A7418FAE1191F147D06DA38A1BF6A562CF5BF0ABE1B19B0A22325A07FF9AB87D6A642BF56F3DF3FBAE61A611</span><br><span class="line">  541:d=1  hl=2 l=  65 prim:  INTEGER           :8761C1634E8489A5FBA6D2DCCC4BC05925C1600B07364CBCE2967CA4D0F6F03A5F6ED935306DD228F6E4C236EAC0FB76DB85AB6EFB36CF7DF90770AF91558E78</span><br></pre></td></tr></table></figure><p>里面将RSA私钥的所有数据都输出了。</p><h3 id="2-2-PEM编码格式"><a href="#2-2-PEM编码格式" class="headerlink" title="2.2 PEM编码格式"></a>2.2 PEM编码格式</h3><p>引用自<a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">Wiki</a>：</p><blockquote><p>Privacy-Enhanced Mail (PEM) is a de facto file format for storing and sending cryptographic keys, certificates, and other data, based on a set of 1993 IETF standards defining “privacy-enhanced mail.”</p></blockquote><p>PEM是一个用来存储和发送密码学key、证书和其他数据的文件格式的事实标准。许多使用ASN.1的密码学标准（比如<a href="https://en.wikipedia.org/wiki/X.509">X.509</a>和<a href="https://en.wikipedia.org/wiki/PKCS">PKCS</a>）都使用DER编码，而DER编码的内容是二进制的，不适合与邮件传输（早期Email不能发送附件），因此使用PEM把二进制内容转换成ASCII码。文件内容的格式像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN label-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END label-----</span><br></pre></td></tr></table></figure><p>label用来区分内容到底是什么类型，下面会讲。</p><p>和PEM相关的RFC有很多，与本文内容相关的则是<a href="https://tools.ietf.org/html/rfc7468">RFC7468</a>，这里面规定了很多label，不过要注意不是所有label都会有对应的RFC或Specification，这些label只是一种约定俗成。</p><p><strong>PEM实际上就是把DER编码的文件的二进制内容用base64编码一下，然后加上 <code>-----BEGIN label-----</code> 这样的头和 <code>-----END label-----</code> 这样的尾，中间则是DER文件的Base64编码</strong>。</p><p>我们可以通过下面的方法验证这个结论，先生成一个RSA Private Key，编码格式是PEM格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out key.pem</span><br></pre></td></tr></table></figure><p>查看一下文件内容，可以看到label是<code>RSA PRIVATE KEY</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p>在—–BEGIN—–与—–END—–之间内容的顶部，有时使用一些头定义对信息进行封装，这些头信息格式如下（不一定都需要，可选的）： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proc-Type,4: ENCRYPTED</span><br><span class="line">DEK-Info: cipher-name, ivec</span><br></pre></td></tr></table></figure><p>其中，第一个头信息标注了该文件是否进行了加密，该头信息可能的值包括：</p><ul><li>ENCRYPTED(信息已经加密和签名)</li><li>MIC-ONLY(信息经过数字签名但没有加密)</li><li>MIC-CLEAR(信息经过数字签名但是没有加密、也没有进行编码，可使用非PEM格式阅读)</li><li>CLEAR(信息没有签名和加密并且没有进行编码，该项好象是openssl自身的扩展，但是并没有真正实现)；</li></ul><p>第二个头信息标注了加密的算法以及使用的ivec参量，ivec其实在这儿提供的应该是一个随机产生的数据序列，与块加密算法中要使用到的初始化变量（IV）不一样。 </p><h3 id="2-3-DER与PEM的格式转换"><a href="#2-3-DER与PEM的格式转换" class="headerlink" title="2.3 DER与PEM的格式转换"></a>2.3 DER与PEM的格式转换</h3><p>我们可以把PEM格式转换成DER格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> key.pem -outform der -out key.der</span><br></pre></td></tr></table></figure><p>如果你这个时候看一下文件内容会发现都是二进制。然后我们把DER文件的内容Base64一下，会看到内容和PEM文件一样（忽略头尾和换行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64 -i key.der -o key.der.base64</span><br></pre></td></tr></table></figure><h2 id="三、证书、密码学Key格式标准"><a href="#三、证书、密码学Key格式标准" class="headerlink" title="三、证书、密码学Key格式标准"></a>三、证书、密码学Key格式标准</h2><p>上面讲到的PEM是对证书、密码学Key文件的一种编码方式，下面举例这些证书、密码学Key文件格式：</p><h3 id="3-1-X-509标准"><a href="#3-1-X-509标准" class="headerlink" title="3.1 X.509标准"></a>3.1 X.509标准</h3><p>引用自<a href="https://en.wikipedia.org/wiki/X.509">Wiki</a> ：</p><blockquote><p>In cryptography, <strong>X.509</strong> is a standard defining the format of public key certificates. X.509 certificates are used in many Internet protocols, including TLS/SSL, which is the basis for HTTPS, the secure protocol for browsing the web.</p></blockquote><p>X.509是一个 <a href="https://en.wikipedia.org/wiki/Public_key_certificate">Public Key Certificates</a> 的格式标准，TLS/SSL使用它，TLS/SSL是HTTPS的基础所以HTTPS也使用它。而所谓 <a href="https://en.wikipedia.org/wiki/Public_key_certificate">Public Key Certificates</a>又被称为 <strong>Digital Certificate(数字证书)</strong> 或 <strong>Identity Certificate</strong>(<strong>身份证书</strong>)。</p><blockquote><p>An X.509 certificate contains a public key and an identity (a hostname, or an organization, or an individual), and is either signed by a certificate authority or self-signed.</p></blockquote><p>一个X.509 Certificate包含一个Public Key和一个身份信息，它要么是被CA签发的要么是自签发的。</p><p>下面这种张图就是一个X.509 Certificate：</p><img src="/images/net/x509.png" alt="x509" style="zoom:80%;" /><p>事实上X.509 Certificate这个名词通常指代的是IETF的PKIX Certificate和CRL Profile，见<a href="https://tools.ietf.org/html/rfc5280">RFC5280</a>。所以当你看到PKIX Certificate字样的时候可以认为就是X.509 Certificate。</p><h3 id="3-2-PKCS-公钥加密标准-系列"><a href="#3-2-PKCS-公钥加密标准-系列" class="headerlink" title="3.2 PKCS(公钥加密标准)系列"></a>3.2 PKCS(公钥加密标准)系列</h3><p>PKCS是由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。</p><p>引用自<a href="https://en.wikipedia.org/wiki/PKCS">Wiki</a>：</p><blockquote><p>In cryptography, <strong>PKCS</strong> stands for “Public Key Cryptography Standards”</p></blockquote><p>前面提到的X.509是定义Public Key Certificates的格式的标准，看上去和PKCS有点像，但实际上不同，PKCS是Public Key密码学标准。此外<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Public-Key Cryptography</a>虽然名字看上去只涉及Public Key，实际上也涉及Priviate Key，因此PKCS也涉及Private Key。</p><p>到1999年底，PKCS已经公布了以下标准： </p><ul><li>PKCS#1：定义RSA公开密钥算法加密和签名机制，主要用于组织PKCS#7中所描述的数字签名和数字信封。 </li><li>PKCS#3：定义Diffie-Hellman密钥交换协议。 </li><li>PKCS#5：描述一种利用从口令派生出来的安全密钥加密字符串的方法。使用MD2或MD5 从口令中派生密钥，并采用DES-CBC模式加密。主要用于加密从一个计算机传送到另一个计算机的私人密钥，不能用于加密消息。 </li><li>PKCS#6：描述了公钥证书的标准语法，主要描述X.509证书的扩展格式。 </li><li>PKCS#7：定义一种通用的消息语法，包括数字签名和加密等用于增强的加密机制，PKCS#7与PEM兼容，所以不需其他密码操作，就可以将加密的消息转换成PEM消息。 </li><li>PKCS#8：描述私有密钥信息格式，该信息包括公开密钥算法的私有密钥以及可选的属性集等。 </li><li>PKCS#9：定义一些用于PKCS#6证书扩展、PKCS#7数字签名和PKCS#8私钥加密信息的属性类型。 </li><li>PKCS#10：描述证书请求语法。 </li><li>PKCS#11：称为Cyptoki，定义了一套独立于技术的程序设计接口，用于智能卡和PCMCIA卡之类的加密设备。 </li><li>PKCS#12：描述个人信息交换语法标准。描述了将用户公钥、私钥、证书和其他相关信息打包的语法。 </li><li>PKCS#13：椭圆曲线密码体制标准。 </li><li>PKCS#14：伪随机数生成标准。 </li><li>PKCS#15：密码令牌信息格式标准。 </li></ul><p>下面挑讲PKCS #1、PKCS #8、PKCS #12。</p><h4 id="3-2-1-PKCS-1"><a href="#3-2-1-PKCS-1" class="headerlink" title="3.2.1 PKCS #1"></a>3.2.1 PKCS #1</h4><p>PKCS #1，RSA Cryptography Standard，定义了RSA Public Key和Private Key数学属性和格式，详见<a href="https://tools.ietf.org/html/rfc8017">RFC8017</a>。</p><p>详细的介绍了RSA算法的计算过程，包括：key的产生，key的结构，对数字加密／解密／签名／验证签名的过程、对应算法。</p><ol><li><p><strong>key</strong>：关于key，分别记录了private和public的详细结构，以及存储哪些内容。并且在附录里面推荐了ASN.1 Syntax中的存储结构。注：没有规定实际的物理文件存储结构，比如pem等。</p></li><li><p><strong>加密／解密</strong>：详细描述了加密／解密的算法。包括，首先针对字符串，怎么转化成数字，之后，怎么根据数字进行加密。 这里可以看出，标准中没有对超长字符串处理的说明。而转化出的字符串的长度，全都是key的模长度k。<br> 在字符串转化成数字过程中，需要增加填充字符，所以，分成了两种不同算法：RSAES-OAEP（现有标准）  RSAES-PKCS1-v1_5（兼容过去标准）。在实际加密过程中，就只有一种算法了</p></li><li><p>无论在加密还是签名过程中，都会进行hash操作，hash操作没有自己定义，而是从附录中可以选择需要的hash方式。</p></li><li><p><strong>PKCS1填充方式</strong>：在进行RSA运算时需要将源数据D转化为Encryption block（EB）。其中pkcs1padding V1.5的填充模式按照以下方式进行。</p></li></ol><h5 id="PKCS1填充方式"><a href="#PKCS1填充方式" class="headerlink" title="PKCS1填充方式"></a>PKCS1填充方式</h5><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：加密块EB = <span class="number">00</span> + 块类型BT + 填充字符PS + <span class="number">00</span> + 数据D  <span class="comment">//以下描述均以十六进制字符串来描述</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>EB：为转化后Hex进制表示的数据块，长度为128个字节（密钥1024位的情况下）</li><li>00：为了确保块转换为整数的时候 小于模数</li><li>BT(Block Type)：<ul><li>用一个字节表示，在目前的版本上，有三个值00 01 02。如果使用公钥操作，BT永远为02，如果用私钥操作则可能为00或01。</li><li>块类型为00，数据开头必须不能是00，因为填充的也是00，将无法解析。</li><li>块类型为01或02，块可以被准确解析，因为不会是00来填充。</li><li>如果是私钥操作，且明文数据是以00字节开头，那么建议把BT的值设置为01，否则，BT为00，PS为00，D开头为00，数据无法被分隔开</li></ul></li><li>PS(Padding String)：<ul><li>为填充位，PS由k-3-D这么多个字节构成，k表示密钥的字节长度，如果我们用1024bit的RSA密钥，这个长度就是1024/8=128，D表示明文数据D的字节长度</li><li>对于BT为00的，则这些字节全部为00</li><li>对于BT为01的，这些值全部为FF</li><li>对于BT为02的，这些字节的值随机产生但不能是0字节(非00)</li><li>填充长度至少为8个字节</li></ul></li><li>00：用于分开 PS 和 D</li><li>D：数据原文(HEX十六进制)<ul><li>PS至少为8个字节，所以D &lt;= k-11</li><li>当我们使用128字节密钥对数据进行加密时，明文数据的长度不能超过过128-11=117字节</li><li>当RSA要加密数据大于 k-11字节时怎么办呢？把明文数据按照D的最大长度分块然后逐块加密,最后把密文拼起来就行。</li></ul></li></ul><p>注意：<strong>加密块EB长度 = RSA密钥key的长度</strong>。比如密钥1024bit，即128字节，加密块也会被填充为128字节</p><p>示例：下面的数据需要填充74个FF才够128个字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加密块 &#x3D; 00 + 01 + FF(74个) + 00 + &quot;&gt;3031300d060960864801650304020105000420b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9(51字节)</span><br></pre></td></tr></table></figure><p>此外还有其他标准里定义的填充方式，比如PKCS5Padding、PKCS7Padding，不再赘述</p><h4 id="3-2-2-PKCS-8"><a href="#3-2-2-PKCS-8" class="headerlink" title="3.2.2 PKCS #8"></a>3.2.2 PKCS #8</h4><p>PKCS #8，Private-Key Information Syntax Standard，详细的描述了私钥的存储格式。用于加密、非加密地存储Private Certificate Keypairs（不限于RSA），详见<a href="https://tools.ietf.org/html/rfc5958">RFC5858</a>。</p><h4 id="3-2-3-PKCS-12"><a href="#3-2-3-PKCS-12" class="headerlink" title="3.2.3 PKCS #12"></a>3.2.3 PKCS #12</h4><p>PKCS #12定义了通常用来存储Private Keys和Public Key Certificates（例如前面提到的X.509）的文件格式，使用基于密码的对称密钥进行保护。注意上述Private Keys和Public Key Certificates是复数形式，这意味着PKCS #12文件实际上是一个Keystore，PKCS #12文件可以被用做 <a href="https://en.wikipedia.org/wiki/Keystore">Java Key Store</a>（JKS），详见<a href="https://tools.ietf.org/html/rfc7292">RFC7292</a>。</p><p>如果你用自己的CA所签发了一个证书，运行下列命令可以生成PKCS #12 keystore：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export \</span><br><span class="line">  -in &lt;cert&gt; \</span><br><span class="line">  -inkey &lt;private-key&gt; \</span><br><span class="line">  -name my-cert \</span><br><span class="line">  -caname my-ca-root \</span><br><span class="line">  -CAfile &lt;ca-cert&gt; \</span><br><span class="line">  -chain</span><br><span class="line">  -out &lt;pkcs-file&gt;</span><br></pre></td></tr></table></figure><p>PKCS #12一般不导出PEM编码格式。</p><h2 id="四、常见的证书标准格式-PEM编码"><a href="#四、常见的证书标准格式-PEM编码" class="headerlink" title="四、常见的证书标准格式(PEM编码)"></a>四、常见的证书标准格式(PEM编码)</h2><p>当你不知道你的PEM文件内容是什么格式的可以根据下面查询。</p><h3 id="4-1-X-509-Certificate"><a href="#4-1-X-509-Certificate" class="headerlink" title="4.1 X.509 Certificate"></a>4.1 X.509 Certificate</h3><p><a href="https://tools.ietf.org/html/rfc7468#section-5.1">RFC7468 - Textual Encoding of Certificates</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure><h3 id="4-2-X-509-Certificate-Subject-Public-Key-Info"><a href="#4-2-X-509-Certificate-Subject-Public-Key-Info" class="headerlink" title="4.2 X.509 Certificate Subject Public Key Info"></a>4.2 X.509 Certificate Subject Public Key Info</h3><p><a href="https://tools.ietf.org/html/rfc7468#section-13">RFC7468 - Textual Encoding of Subject Public Key Info</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><h3 id="4-3-PKCS-1-Private-Key"><a href="#4-3-PKCS-1-Private-Key" class="headerlink" title="4.3 PKCS #1 Private Key"></a>4.3 PKCS #1 Private Key</h3><p>没有RFC或权威Specification，该格式有时候被称为traditional format、SSLeay format（见<a href="https://crypto.stackexchange.com/a/47433">SO</a>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h3 id="4-4-PKCS-1-Public-Key"><a href="#4-4-PKCS-1-Public-Key" class="headerlink" title="4.4 PKCS #1 Public Key"></a>4.4 PKCS #1 Public Key</h3><p>同上没有RFC或权威Specification</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PUBLIC KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END RSA PUBLIC KEY-----</span><br></pre></td></tr></table></figure><h3 id="4-5-PKCS-8-Unencrypted-Private-Key"><a href="#4-5-PKCS-8-Unencrypted-Private-Key" class="headerlink" title="4.5 PKCS #8 Unencrypted Private Key"></a>4.5 PKCS #8 Unencrypted Private Key</h3><p><a href="https://tools.ietf.org/html/rfc7468#section-10">RFC7468 - One Asymmetric Key and the Textual Encoding of PKCS #8 Private Key Info</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h3 id="4-6-PKCS-8-Encrypted-Private-Key"><a href="#4-6-PKCS-8-Encrypted-Private-Key" class="headerlink" title="4.6 PKCS #8 Encrypted Private Key"></a>4.6 PKCS #8 Encrypted Private Key</h3><p><a href="https://tools.ietf.org/html/rfc7468#section-11">RFC7468 - Textual Encoding of PKCS #8 Encrypted Private Key Info</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN ENCRYPTED PRIVATE KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END ENCRYPTED PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h3 id="4-7-RSA私钥PKCS1与PKCS8格式区别？"><a href="#4-7-RSA私钥PKCS1与PKCS8格式区别？" class="headerlink" title="4.7 RSA私钥PKCS1与PKCS8格式区别？"></a>4.7 RSA私钥PKCS1与PKCS8格式区别？</h3><p><strong>PKCS1：</strong>全名《Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications》最新版本2.2 <em>(rfc8017, 有兴趣的同学可以读一下)</em> ，从名称上可以看出它是针对RSA算法的一个规范。里面包含了RSA加密、解密、签名验签等所有的内容，当然也包含了私钥的格式。PKCS1的1.1版本是1991年发布的。</p><p><strong>PKCS8：</strong>全名《Public-Key Cryptography Standards (PKCS) #8: Private-Key Information Syntax Specification》最新版本1.2，从名称上可以看出它是一个专门用来存储私钥的文件格式规范。PKCS1的1.2版本是2008年发布的。</p><p>它们两个有重合的部分，都定义了私钥的存储，那他们到底有什么关系呢？下面来验证一下</p><h4 id="第一步：产生RSA私钥"><a href="#第一步：产生RSA私钥" class="headerlink" title="第一步：产生RSA私钥"></a>第一步：产生RSA私钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out pkcs1.pem 1024</span><br></pre></td></tr></table></figure><p>此时当前目录下就有一个pkcs1.pem文件，查看文件内容可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXAIBAAKBgQCss7fSp+qZaACgW+rFStHODx8Z7Hr1bFMxnqde61SmcF6dbuc/</span><br><span class="line">C1lgJY/FyrTPxlu4wGNpThVn1lPfvQKCNn492kd8kl0863fhU3rk+7/18R+uQCrp</span><br><span class="line">mhGnQY+u+6bS3MxLwFklwWALBzZMvOKWfKTQ9vA6 <span class="comment">#....省略一大坨</span></span><br><span class="line">X27ZNTBt0ij25MI26sD7dtuFq277Ns99+Qdwr5FVjng=</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h4 id="第二步：将私钥转为PKCS8"><a href="#第二步：将私钥转为PKCS8" class="headerlink" title="第二步：将私钥转为PKCS8"></a>第二步：将私钥转为PKCS8</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -inform PEM -<span class="keyword">in</span> pkcs1.pem -outform PEM -nocrypt -out pkcs8.pem</span><br></pre></td></tr></table></figure><p>此时当前目录下会多出一个pkcs8.pem文件，查看文件内容可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKyzt9Kn6ploAKBb</span><br><span class="line">6sVK0c4PHxnsevVsUzGep17rVKZwXp1u5z8LWWAlj8XKtM/GW7jAY2lOFWfWU9+9</span><br><span class="line">nt6ZnlCZMYgaoBqjrbDvBpfHyB8jAgMBAAECgY <span class="comment">#....省略一大坨</span></span><br><span class="line">iaX7ptLczEvAWSXBYAsHNky84pZ8pND28Dpfbtk1MG3SKPbkwjbqwPt224Wrbvs2</span><br><span class="line">z335B3CvkVWOeA==</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>那么之间有什么区别呢？从PEM格式的内容中看不出来什么规律，我们需要将两个PEM格式的文件转换为DER格式，这个二进制的数据容易做对比。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rsa -<span class="keyword">in</span> pkcs1.pem -out pkcs1.der -outform DER</span><br><span class="line">$ openssl pkcs8 -topk8 -inform PEM -<span class="keyword">in</span> pkcs1.pem -outform DER -nocrypt -out pkcs8.der</span><br><span class="line">$ ls </span><br><span class="line">pkcs1.der pkcs1.pem pkcs8.der pkcs8.pem</span><br></pre></td></tr></table></figure><p>现在我们得到了两个DER格式的文件，我们可以先用hexdemp看看两个文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat pkcs1.der | hexdump</span><br><span class="line">0000000 30 82 02 5c 02 01 00 02 81 81 00 ac b3 b7 d2 a7</span><br><span class="line">0000010 ea 99 68 00 a0 5b ea c5 4a d1 ce 0f 1f 19 ec 7a</span><br><span class="line">0000020 f5 6c 53 31 9e a7 5e eb ... <span class="comment">#后面的没用，省略</span></span><br><span class="line"></span><br><span class="line">cat pkcs8.der | hexdump</span><br><span class="line">0000000 30 82 02 76 02 01 00 30 0d 06 09 2a 86 48 86 f7</span><br><span class="line">0000010 0d 01 01 01 05 00 04 82 02 60 30 82 02 5c 02 01</span><br><span class="line">0000020 00 02 81 81 00 ac b3 b7 d2 a7 ea 99 68 00 a0 5b</span><br><span class="line">0000030 ea c5 4a d1 ce 0f 1f 19 ec 7a f5 6c 53 31 9e a7</span><br><span class="line">0000040 5e eb ... <span class="comment"># 省略</span></span><br></pre></td></tr></table></figure><p>此时如果从后往前看的话，其实可以发现PKCS8仅比PKCS1多了一个26自己的头，剩余的内容均完全一致。<br> 我们可以使用以下的命令进行验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">openssl asn1parse -i -<span class="keyword">in</span> pkcs8.der -inform DER</span><br><span class="line">    0:d=0  hl=4 l= 630 cons: SEQUENCE</span><br><span class="line">    4:d=1  hl=2 l=   1 prim:  INTEGER           :00</span><br><span class="line">    7:d=1  hl=2 l=  13 cons:  SEQUENCE</span><br><span class="line">    9:d=2  hl=2 l=   9 prim:   OBJECT            :rsaEncryption</span><br><span class="line">   20:d=2  hl=2 l=   0 prim:   NULL</span><br><span class="line">   22:d=1  hl=4 l= 608 prim:  OCTET STRING      [HEX DUMP]:3082025C02010002818100ACB3B7D2A7EA99 <span class="comment">#pkcs1.der的内容</span></span><br></pre></td></tr></table></figure><p>可以看到 <strong>22:d=1 hl=4 l= 608 prim: OCTET STRING</strong> 这一行的输出就是pkcs1.der的内容。而上面的内容就是pkcs8比pkcs1多的内容。其实最主要的就是算法信息，这也是pkcs8能存储各种算法私钥的原因。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从时间顺序上可以看出来，PKCS标准也是在不断发展的，PKCS1的标准是先于PKCS8出来的，那时候甚至非对称算法还只有RSA是成熟的，在计算机领域刚刚得到应用，PKCS专门将RSA的算法作为一个标准输出就不难理解了。随着加密算法的发展才有了PKCS8出来专门做存储密钥这样一件事情。</p><h2 id="五、常见的证书后缀"><a href="#五、常见的证书后缀" class="headerlink" title="五、常见的证书后缀"></a>五、常见的证书后缀</h2><p>作为文件形式存在的证书一般有这几种后缀：(证书中包含公钥，以及公钥颁发机构、版本号、算法等信息，可以以X.509为例看一下证书内容)</p><p>1.带有私钥的证书：（一般都有密码保护，使用的是DER编码）</p><ul><li><code>.pfx</code> 常用于Windows上的 IIS服务器</li><li><code>.p12</code> 常用于MAC OS、iOS中(PKCS#12由PFX进化而来的用于交换公共的和私有的对象的标准格式)</li><li><code>.jks</code> Java Key Storage，这是Java的专利，JAVA的专属格式，一般用于 Tomcat 服务器。</li></ul><p>2.不带私钥的证书：</p><ul><li><code>.cer/crt</code> 编码方式不一定，可能是DER也可能是PEM</li><li><code>.pem</code> 都是PEM编码格式</li><li><code>.der</code> 都是DER编码格式</li><li><code>.p7b</code> 以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥</li></ul><p>3.补充</p><ul><li>.der文件一般只放证书，<code>不含私钥</code></li><li>.pem文件中可以放证书或者私钥，或者两者都有，pem如果只含私钥的话，一般用<code>.key</code>扩展名，而且可以有密码保护</li><li>.csr - Certificate Signing Request，即证书签名请求，这个并不是证书，而是向权威证书颁发机构获得签名证书的申请，其核心内容是一个公钥(当然还附带了一些别的信息)，在生成这个申请的时候，同时也会生成一个私钥key，私钥要自己保管好。做过iOS APP的朋友都应该知道是怎么向苹果申请开发者证书的吧.</li></ul><p>可以使用命令行工具、代码、在线网站等实现不同后缀格式、不同证书标准之间的转换，比如这个网站<a href="http://www.metools.info/">http://www.metools.info/</a></p><h2 id="六、常用的openssl公私钥操作命令"><a href="#六、常用的openssl公私钥操作命令" class="headerlink" title="六、常用的openssl公私钥操作命令"></a>六、常用的openssl公私钥操作命令</h2><h3 id="6-1-Private-Key操作命令"><a href="#6-1-Private-Key操作命令" class="headerlink" title="6.1 Private Key操作命令"></a>6.1 Private Key操作命令</h3><h4 id="6-1-1-私钥创建"><a href="#6-1-1-私钥创建" class="headerlink" title="6.1.1 私钥创建"></a>6.1.1 私钥创建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成PKCS1格式RSA Private Key</span></span><br><span class="line">openssl genrsa -out private-key.p1.pem 2048</span><br></pre></td></tr></table></figure><h4 id="6-1-2-私钥格式转换"><a href="#6-1-2-私钥格式转换" class="headerlink" title="6.1.2 私钥格式转换"></a>6.1.2 私钥格式转换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PKCS #1 -&gt; Unencrypted PKCS #8</span></span><br><span class="line">openssl pkcs8 -topk8 -<span class="keyword">in</span> private-key.p1.pem -out private-key.p8.pem -nocrypt</span><br><span class="line"></span><br><span class="line"><span class="comment"># PKCS #1 -&gt; Encrypted PKCS #8</span></span><br><span class="line"><span class="comment"># 过程中会让你输入密码，你至少得输入4位，所以PKCS #8相比PKCS #1更安全。</span></span><br><span class="line">openssl pkcs8 -topk8 -<span class="keyword">in</span> private-key.p1.pem -out private-key.p8.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># PKCS #8 -&gt; PKCS #1</span></span><br><span class="line"><span class="comment"># 如果这个PKCS #8是加密的，那么你得输入密码。</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> private-key.p8.pem -out private-key.p1.pem</span><br></pre></td></tr></table></figure><h3 id="6-2-Public-Key操作命令"><a href="#6-2-Public-Key操作命令" class="headerlink" title="6.2 Public Key操作命令"></a>6.2 Public Key操作命令</h3><h4 id="6-2-1-从PKCS-1、-8私钥中提取公钥"><a href="#6-2-1-从PKCS-1、-8私钥中提取公钥" class="headerlink" title="6.2.1 从PKCS #1、#8私钥中提取公钥"></a>6.2.1 从PKCS #1、#8私钥中提取公钥</h4><p>提取指的是从Private Key中提取Public Key，<code>openssl rsa</code>同时支持PKCS #1和PKCS #8的RSA Private Key，唯一的区别是如果PKCS #8是加密的，会要求你输入密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取X.509格式RSA Public Key</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> private-key.pem -pubout -out public-key.x509.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取PKCS #1格式RSA Public Key</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> private-key.pem -out public-key.p1.pem -RSAPublicKey_out</span><br></pre></td></tr></table></figure><h4 id="6-2-2-从X-509证书提取公钥"><a href="#6-2-2-从X-509证书提取公钥" class="headerlink" title="6.2.2 从X.509证书提取公钥"></a>6.2.2 从X.509证书提取公钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> cert.pem -pubkey -noout &gt; public-key.x509.pem</span><br></pre></td></tr></table></figure><h4 id="6-2-3-公钥格式转换"><a href="#6-2-3-公钥格式转换" class="headerlink" title="6.2.3 公钥格式转换"></a>6.2.3 公钥格式转换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># X.509 RSA Public Key -&gt; PKCS #1 RSA Public Key</span></span><br><span class="line">openssl rsa -pubin -<span class="keyword">in</span> public-key.x509.pem -RSAPublicKey_out -out public-key.p1.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># PKCS #1 RSA Public Key -&gt; X.509 RSA Public Key</span></span><br><span class="line">openssl rsa -RSAPublicKey_in -<span class="keyword">in</span> public-key.p1.pem -pubout -out public-key.x509.pem</span><br></pre></td></tr></table></figure><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li><p><a href="https://segmentfault.com/a/1190000019008423">X.509、PKCS文件格式介绍</a></p></li><li><p><a href="https://press.one/files/0d970f6bab501e9b4eac540dbf69dcf452551aa1c33f2e22cf87aec152f34e75">PKCS1与PKCS8的小知识</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;PKI(public key infrastructure)标准可以分为第一代标准和第二代标准。&lt;/p&gt;
&lt;p&gt;第一代PKI标准主要包括：&lt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] 位运算实现加、减、乘、除运算</title>
    <link href="https://tenloy.github.io/2021/11/22/bit-calculation.html"/>
    <id>https://tenloy.github.io/2021/11/22/bit-calculation.html</id>
    <published>2021-11-22T16:35:03.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，计算机最基本的操作单元是字节(byte)，一个字节由8个位(bit)组成，一个位只能存储一个0或1，其实也就是高低电平。无论多么复杂的逻辑、庞大的数据、酷炫的界面，最终体现在计算机最底层都只是对0101的存储和运算。因此，了解位运算有助于提升我们对计算机底层操作原理的理解。</p><p>今天就来看看怎么不使用显式“ + - * /”运算符来实现加减乘除运算。</p><p>下面我们一个一个来看。</p><h2 id="一、加法运算"><a href="#一、加法运算" class="headerlink" title="一、加法运算"></a>一、加法运算</h2><h3 id="1-1-十进制-举例"><a href="#1-1-十进制-举例" class="headerlink" title="1.1 十进制 举例"></a>1.1 十进制 举例</h3><p>先来个我们最熟悉的十进制的加法运算：</p><blockquote><p>13 + 9 = 22</p></blockquote><p>我们像这样来拆分这个运算过程：分别对各位数进行相加</p><ol><li><p>不考虑进位(要进位的值丢弃)：结果为sum：个位数3加上9为2；十位数1加上0为1； 最终结果为12；</p></li><li><p>只考虑进位(只保留进位的值)，结果为carry： 3 + 9 有进位，进位的值为10；</p></li><li><p>如果步骤2所得进位结果carry不为0。那么把步骤1所得sum、步骤2所得carry当成操作数重复步骤1、 2、3；</p><p>如果carry为0则结束，最终结果为步骤1所得sum：</p><p>这里即是对sum = 12 和carry = 10重复以上三个步骤：</p><p>a. 不考虑进位，分别对各位数进行相加:sum = 22; </p><p>b. 只考虑进位: 上一步没有进位，所以carry = 0； </p><p>c. 步骤2carry = 0，结束，结果为sum = 22.</p></li></ol><h3 id="1-2-二进制-举例"><a href="#1-2-二进制-举例" class="headerlink" title="1.2 二进制 举例"></a>1.2 二进制 举例</h3><p>我们发现这三板斧行得通！那我们现在还使用上面的三板斧把十进制运算放在二进制中看看是不是也行的通。</p><p>13的二进制为0000 1101，9的二进制为0000 1001:</p><ol><li><p>不考虑进位：分别对各位数进行相加：sum = 0000 1101 + 0000 1001 = 0000 0100</p></li><li><p>只考虑进位： 有两处进位，第0位和第3位，只考虑进位的结果为：carry = 0001 0010</p></li><li><p>步骤2 carry == 0 ?，不为0，重复步骤1 、2 、3；本例中，</p><p> a. 不考虑进位sum = 0001 0110;</p><p> b. 只考虑进位carry  = 0;</p><p> c. carry == 0？为0，结束，结果为sum = 0001 0110。转换成十进制刚好是22.</p></li></ol><h3 id="1-3-结论"><a href="#1-3-结论" class="headerlink" title="1.3 结论"></a>1.3 结论</h3><p>我们发现，适用于十进制的三板斧同样适用于二进制！仔细观察者三板斧，其实：</p><ul><li>第一步不考虑进位的加法其实就是<font color=red>异或运算</font>；</li><li>第二步只考虑进位就是<font color=red>与运算并左移一位</font>；</li><li>第三步就是<strong>重复前面两步操作直到第二步进位结果为0</strong>。</li></ul><p>这里关于第三步多说一点。为什么要循环步骤1、 2、 3直到步骤2所得进位carry等于0？其实这是因为有的数做加法时会出现连续进位的情况，举例：3 + 9，我们来走一遍上述逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0011</span>, b = <span class="number">1001</span>;</span><br><span class="line">start;</span><br><span class="line"></span><br><span class="line">first loop;</span><br><span class="line"> <span class="number">1.1</span> sum = <span class="number">1010</span></span><br><span class="line"> <span class="number">1.2</span> carry = <span class="number">0010</span></span><br><span class="line"> <span class="number">1.3</span> carry != <span class="number">0</span> , go on;</span><br><span class="line"></span><br><span class="line">second loop;</span><br><span class="line"> <span class="number">2.1</span> sum = <span class="number">1000</span>;</span><br><span class="line"> <span class="number">2.2</span> carry = <span class="number">0100</span>;</span><br><span class="line"> <span class="number">2.3</span> carry != <span class="number">0</span>, go on;</span><br><span class="line"></span><br><span class="line">third loop;</span><br><span class="line"> <span class="number">3.1</span> sum = <span class="number">1100</span>;</span><br><span class="line"> <span class="number">3.2</span> carry = <span class="number">0000</span>;</span><br><span class="line"> <span class="number">3.3</span> carry == <span class="number">0</span>, stop; result = sum;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如上面的栗子，有的加法操作是有连续进位的情况的，所以这里要在第三步检测carry是不是为0，如果为0则表示没有进位了，第一步的sum即为最终的结果。</p><h3 id="1-4-代码"><a href="#1-4-代码" class="headerlink" title="1.4 代码"></a>1.4 代码</h3><p>有了上面的分析，我们不难写出如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num2 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="built_in">int</span> sum = num1 ^ num2;</span><br><span class="line">    <span class="built_in">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">add</span>(sum, carry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> sum = num1 ^ num2;</span><br><span class="line">    <span class="built_in">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = sum;</span><br><span class="line">        <span class="built_in">int</span> b = carry;</span><br><span class="line">        sum = a ^ b;</span><br><span class="line">        carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的计算机其实就是通过上述的位运算实现加法运算的（通过加法器，加法器就是使用上述的方法实现加法的），而程序语言中的+ - * /运算符只不过是呈现给程序员的操作工具，计算机底层实际操作的永远是形如0101的位，所以说位运算真的很重要！</p><h2 id="二、减法运算"><a href="#二、减法运算" class="headerlink" title="二、减法运算"></a>二、减法运算</h2><p>我们知道了位运算实现加法运算，那减法运算就相对简单一些了。我们实现了加法运算，自然的，我们会想到把减法运算11 - 6变形为加法运算11 + (-6)，即一个正数加上一个负数。是的，很聪明，其实我们的计算机也是这样操作的，那有的人会说为什么计算机不也像加法器一样实现一个减法器呢？对的，这样想当然是合理的，但是考虑到减法比加法来的复杂，实现起来比较困难。为什么呢？我们知道加法运算其实只有两个操作，加、 进位，而减法呢，减法会有借位操作，如果当前位不够减那就从高位借位来做减法，这里就会问题了，借位怎么表示呢？加法运算中，进位通过与运算并左移一位实现，而借位就真的不好表示了。所以我们自然的想到将减法运算转变成加法运算。</p><p>怎么实现呢？</p><p>刚刚我们说了减法运算可转变成一个正数加上一个负数，那首先就要来看看负数在计算机中是怎么表示的。</p><p>+8在计算机中表示为二进制的1000，那-8怎么表示呢？</p><p>很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+8就是00001000，而-8则是10001000。这只是直观的表示方法，其实计算机是通过2的补码来表示负数的，那什么是2的补码（同补码，英文是2’s complement，其实应该翻译为2的补码）呢？它是一种用二进制表示有号数的方法，也是一种将数字的正负号变号的方式，求取步骤：</p><ul><li>第一步，每一个二进制位都取相反值，0变成1，1变成0（即反码）。</li><li>第二步，将上一步得到的值（反码）加1。</li></ul><p>简单来说就是取反加一！</p><p>关于补码更详细的内容可参<a href="https://link.jianshu.com/?t=!https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8">维基百科-补码</a>，这里不再赘述。</p><p>其实我们利用的恰巧是补码的可以将数字的正负号变号的功能，这样我们就可以把减法运算转变成加法运算了，因为负数可以通过其对应正数求补码得到。计算机也是通过增加一个补码器配合加法器来做减法运算的，而不是再重新设计一个减法器。</p><p>以上，我们很容易写出了位运算做减法运算的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* num1: 减数</span></span><br><span class="line"><span class="comment">* num2: 被减数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">substract</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> subtractor = <span class="keyword">add</span>(~num2, <span class="number">1</span>);<span class="comment">// 先求减数的补码（取反加一）</span></span><br><span class="line">    <span class="built_in">int</span> result = <span class="keyword">add</span>(num1, subtractor); <span class="comment">// add()即上述加法运算　　</span></span><br><span class="line">    <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、乘法运算"><a href="#三、乘法运算" class="headerlink" title="三、乘法运算"></a>三、乘法运算</h2><p>我们知道了加法运算的位运算实现，那很容易想到乘法运算可以转换成加法运算，被乘数加上乘数倍的自己不就行了么。这里还有一个问题，就是乘数和被乘数的正负号问题，我们这样处理，先处理乘数和被乘数的绝对值的乘积，然后根据它们的符号确定最终结果的符号即可。步骤如下：</p><blockquote><p>(1) 计算绝对值得乘积<br> (2) 确定乘积符号（同号为证，异号为负）</p></blockquote><p>有了这个思路，代码就不难写了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* a: 被乘数</span></span><br><span class="line"><span class="comment">* b: 乘数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123; </span><br><span class="line">    <span class="comment">// 取绝对值　　    </span></span><br><span class="line">    <span class="built_in">int</span> multiplicand = a &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~a, <span class="number">1</span>) : a;    </span><br><span class="line">    <span class="built_in">int</span> multiplier = b &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~b , <span class="number">1</span>) : b;<span class="comment">// 如果为负则取反加一得其补码，即正数　　    </span></span><br><span class="line">    <span class="comment">// 计算绝对值的乘积　　    </span></span><br><span class="line">    <span class="built_in">int</span> product = <span class="number">0</span>;    </span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span>(count &lt; multiplier) &#123;        </span><br><span class="line">        product = <span class="keyword">add</span>(product, multiplicand);        </span><br><span class="line">        count = <span class="keyword">add</span>(count, <span class="number">1</span>);<span class="comment">// 这里可别用count++，都说了这里是位运算实现加法　　    </span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定乘积的符号　　    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>) &#123;<span class="comment">// 只考虑最高位，如果a,b异号，则异或后最高位为1；如果同号，则异或后最高位为0；　　　　        </span></span><br><span class="line">        product = <span class="keyword">add</span>(~product, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的思路在步骤上没有问题，但是第一步对绝对值作乘积运算我们是通过不断累加的方式来求乘积的，这在乘数比较小的情况下还是可以接受的，但在乘数比较大的时候，累加的次数也会增多，这样的效率不是最高的。我们可以思考，如何优化求绝对值的乘积这一步。</p><p>考虑我们现实生活中手动求乘积的过程，这种方式同样适用于二进制，下面我以13*14为例，向大家演示如何用手动计算的方式求乘数和被乘数绝对值的乘积。</p><img src="/images/bit-cal/01.png" alt="01" style="zoom:95%;" /><p>从上图的计算过程可以看出，如果乘数当前位为1，则取被乘数左移一位的结果加到最终结果中；如果当前位为0，则取0加到乘积中（加0也就是什么也不做）；</p><p>整理成算法步骤：</p><blockquote><p>(1) 判断乘数是否为0，为0跳转至步骤(4)</p><p>(2) 将乘数与1作与运算，确定末尾位为1还是为0，如果为1，则相加数为当前被乘数；如果为0，则相加数为0；将相加数加到最终结果中；</p><p>(3) 被乘数左移一位，乘数右移一位；回到步骤(1)</p><p>(4) 确定符号位，输出结果；</p></blockquote><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> &#123;　　</span><br><span class="line">    <span class="comment">//将乘数和被乘数都取绝对值　</span></span><br><span class="line">    <span class="built_in">int</span> multiplicand = a &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~a, <span class="number">1</span>) : a; 　　</span><br><span class="line">    <span class="built_in">int</span> multiplier = b &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~b , <span class="number">1</span>) : b;　　</span><br><span class="line">    　</span><br><span class="line">    <span class="comment">//计算绝对值的乘积　　</span></span><br><span class="line">    <span class="built_in">int</span> product = <span class="number">0</span>;　　</span><br><span class="line">    <span class="keyword">while</span>(multiplier &gt; <span class="number">0</span>) &#123;　　　　</span><br><span class="line">        <span class="keyword">if</span>((multiplier &amp; <span class="number">0x1</span>) &gt; <span class="number">0</span>) &#123;<span class="comment">// 每次考察乘数的最后一位　　　　</span></span><br><span class="line">            product = <span class="keyword">add</span>(product, multiplicand);　　　　</span><br><span class="line">        &#125; 　　　　</span><br><span class="line">        multiplicand = multiplicand &lt;&lt; <span class="number">1</span>;<span class="comment">// 每运算一次，被乘数要左移一位　　　　</span></span><br><span class="line">        multiplier = multiplier &gt;&gt; <span class="number">1</span>;<span class="comment">// 每运算一次，乘数要右移一位（可对照上图理解）　　</span></span><br><span class="line">    &#125; 　　</span><br><span class="line">    <span class="comment">//计算乘积的符号　　</span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>) &#123;　　　　</span><br><span class="line">        product = <span class="keyword">add</span>(~product, <span class="number">1</span>);　　</span><br><span class="line">    &#125; 　　</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，第二种求乘积的方式明显要优于第一种。</p><h2 id="四、除法运算"><a href="#四、除法运算" class="headerlink" title="四、除法运算"></a>四、除法运算</h2><p>除法运算很容易想到可以转换成减法运算，即不停的用除数去减被除数，直到被除数小于除数时，此时所减的次数就是我们需要的商，而此时的被除数就是余数。这里需要注意的是符号的确定，商的符号和乘法运算中乘积的符号确定一样，即取决于除数和被除数，同号为证，异号为负；余数的符号和被除数一样。</p><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* a : 被除数</span></span><br><span class="line"><span class="comment">* b : 除数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">divide</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123;    </span><br><span class="line">    <span class="comment">// 先取被除数和除数的绝对值    </span></span><br><span class="line">    <span class="built_in">int</span> dividend = a &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~a, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> divisor = b &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~b, <span class="number">1</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> quotient = <span class="number">0</span>;<span class="comment">// 商    </span></span><br><span class="line">    <span class="built_in">int</span> remainder = <span class="number">0</span>;<span class="comment">// 余数    </span></span><br><span class="line">    <span class="comment">// 不断用除数去减被除数，直到被除数小于被除数（即除不尽了）    </span></span><br><span class="line">    <span class="keyword">while</span>(dividend &gt;= divisor)&#123;<span class="comment">// 直到商小于被除数        </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(quotient, <span class="number">1</span>);        </span><br><span class="line">        dividend = substract(dividend, divisor);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定商的符号    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>)&#123;<span class="comment">// 如果除数和被除数异号，则商为负数  </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(~quotient, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定余数符号    </span></span><br><span class="line">    remainder = b &gt; <span class="number">0</span> ? dividend : <span class="keyword">add</span>(~dividend, <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> quotient;<span class="comment">// 返回商</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有和简单版乘法运算一样的问题，如果被除数非常大，除数非常小，那就要进行很多次减法运算，有没有更简便的方法呢？</p><p>上面的代码之所以比较慢是因为步长太小，每次只能用1倍的除数去减被除数，所以速度比较慢。那能不能增大步长呢？如果能，应该怎么增大步长呢？</p><p>计算机是一个二元的世界，所有的int型数据都可以用[2^0, 2^1, … , 2^31]这样一组基来表示（int型最高31位）。不难想到用除数的2^31, 2^30, … , 2^2, 2^1, 2^0 倍尝试去减被除数，如果减得动，则把相应的倍数加到商中；如果减不动，则依次尝试更小的倍数。这样就可以快速逼近最终的结果。</p><p>2的i次方其实就相当于左移i位，为什么从31位开始呢？因为int型数据最大值就是2^31啊。</p><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">divide_v2</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span> &#123;   </span><br><span class="line">    <span class="comment">// 先取被除数和除数的绝对值    </span></span><br><span class="line">    <span class="built_in">int</span> dividend = a &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~a, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> divisor = b &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~b, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> quotient = <span class="number">0</span>;<span class="comment">// 商    </span></span><br><span class="line">    <span class="built_in">int</span> remainder = <span class="number">0</span>;<span class="comment">// 余数    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//比较dividend是否大于divisor的(1&lt;&lt;i)次方，不要将dividend与(divisor&lt;&lt;i)比较，而是用(dividend&gt;&gt;i)与divisor比较，</span></span><br><span class="line">        <span class="comment">//效果一样，但是可以避免因(divisor&lt;&lt;i)操作可能导致的溢出，如果溢出则会可能dividend本身小于divisor，但是溢出导致dividend大于divisor       </span></span><br><span class="line">        <span class="keyword">if</span>((dividend &gt;&gt; i) &gt;= divisor) &#123;            </span><br><span class="line">            quotient = <span class="keyword">add</span>(quotient, <span class="number">1</span> &lt;&lt; i);            </span><br><span class="line">            dividend = substract(dividend, divisor &lt;&lt; i);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定商的符号    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果除数和被除数异号，则商为负数        </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(~quotient, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定余数符号    </span></span><br><span class="line">    remainder = b &gt; <span class="number">0</span> ? dividend : <span class="keyword">add</span>(~dividend, <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> quotient;<span class="comment">// 返回商</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，计算机最基本的操作单元是字节(byte)，一个字节由8个位(bit)组成，一个位只能存储一个0或1，其实也就是高低电平。无论多么复杂的逻辑、庞大的数据、酷炫的界面，最终体现在计算机最底层都只是对0101的存储和运算。因此，了解位运算有助于提升我们对计算机底层操作原</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Git的使用总结</title>
    <link href="https://tenloy.github.io/2021/11/10/git-use.html"/>
    <id>https://tenloy.github.io/2021/11/10/git-use.html</id>
    <published>2021-11-10T11:06:05.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Git"><a href="#一、Git" class="headerlink" title="一、Git"></a>一、Git</h2><ul><li>集中式版本控制系统，版本库是集中存放在中央服务器的(服务器必须联网才能连接)。所有人都是通过中央服务器来交换修改。</li><li>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库。两个人的电脑之间可以相互推送修改。不过， 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</li><li>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等。 而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB。(Microsoft的Word格式是二进制格式)。</li><li>文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</li></ul><h2 id="二、Git的安装"><a href="#二、Git的安装" class="headerlink" title="二、Git的安装"></a>二、Git的安装</h2><p>首先，试着输入<code>git</code>，看看系统有没有安装Git。</p><p>Mac OS X上安装Git：</p><h3 id="2-1-通过homebrew安装"><a href="#2-1-通过homebrew安装" class="headerlink" title="2.1 通过homebrew安装"></a>2.1 通过homebrew安装</h3><blockquote><p>引用官方的一句话：Homebrew是Mac OS 不可或缺的套件管理器。 </p><p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p></blockquote><p>安装homebrew，然后通过homebrew安装Git。</p><h3 id="2-2-通过Command-Line-Tools安装"><a href="#2-2-通过Command-Line-Tools安装" class="headerlink" title="2.2 通过Command Line Tools安装"></a>2.2 通过Command Line Tools安装</h3><p>安装Xcode IDE附带的命令行工具—Command Line Tools(需要自己安装 <code>xcode-select--install</code> )</p><blockquote><p>Command Line Tools就是一个小型独立包，为mac终端用户提供了许多常用的命令行工具（实用程序、编译器等）。包括svn，git，make，GCC，clang，perl，size，strip，strings，libtool，cpp，what以及其他很多能够在Linux默认安装中找到的有用的命令。</p><p>安装目录： /Library/Developer/CommandLineTools/</p></blockquote><h2 id="三、Git的配置"><a href="#三、Git的配置" class="headerlink" title="三、Git的配置"></a>三、Git的配置</h2><h3 id="3-1-配置远程仓库"><a href="#3-1-配置远程仓库" class="headerlink" title="3.1 配置远程仓库"></a>3.1 配置远程仓库</h3><p>常见的本地、远程仓库几种模式：</p><ul><li><p>从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p></li><li><p>在GitHub上，可以任意Fork开源仓库(点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone)</p><ul><li>自己拥有Fork后的仓库的读写权限； </li><li>可以推送pull request给官方仓库来贡献代码( 当然，对方是否接受你的pull request就不一定了 )。</li></ul></li><li><p>将已存在的文件夹，变成 Git 仓库，并创建关联的远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 本地文件夹名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把这个目录变成Git可以管理的仓库 ，会多一个.git的目录，是Git来跟踪管理版本库的，如非必要不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 </span></span><br><span class="line">git init </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加后，远程库的名字一般就是origin，这是Git默认的叫法，也可以改成别的，只不过origin这个名字一看就知道是远程库。</span></span><br><span class="line">git remote add &lt;remote-name&gt; &lt;remote-url(ssh/https)&gt; </span><br><span class="line"><span class="comment"># 一个本地仓库是可以关联多个远程库的，多次执行上面命令即可，但不能重名</span></span><br><span class="line"><span class="comment"># 查看远程库信息（如果没有推送权限，就不会看到push的地址）</span></span><br><span class="line">git remote [-v/--verbose]</span><br><span class="line"><span class="comment"># 删除已有的远程库</span></span><br><span class="line">git remote rm &lt;remoteName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本地的master分支内容推送的远程新的master分支，并建立本地master与远程仓库的master分支的关联，详见git push命令</span></span><br><span class="line">git push -u &lt;remote-name&gt; master </span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-配置忽略文件"><a href="#3-2-配置忽略文件" class="headerlink" title="3.2 配置忽略文件"></a>3.2 配置忽略文件</h3><h4 id="3-2-1-全局与局部忽略"><a href="#3-2-1-全局与局部忽略" class="headerlink" title="3.2.1 全局与局部忽略"></a>3.2.1 全局与局部忽略</h4><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦。</p><p>此时，可以把要忽略的文件名填入忽略文件，Git就会自动忽略这些文件。可以定义忽略是全局的，还是局限于一个仓库。</p><ul><li>全局忽略文件：<code>/User/用户名/.gitignore_global</code> ;</li><li>仓库忽略文件：Git工作区的根目录下有一个特殊的 <code>.gitignore</code> 文件。</li></ul><h4 id="3-2-2-忽略文件的编写"><a href="#3-2-2-忽略文件的编写" class="headerlink" title="3.2.2 忽略文件的编写"></a>3.2.2 忽略文件的编写</h4><p>忽略文件的格式：</p><ul><li><p>注释格式同shell脚本： #注释；</p></li><li><p>忽略精确的文件名：文件名；</p></li><li><p>忽略所有此扩展名的文件：如 *.pbxuser 表示要忽略后缀名为.pbxuser的文件；</p></li><li><p>忽略文件夹下面的一切：如 build/ 表示要忽略 build 文件夹下的所有内容；</p></li><li><p><code>*</code> 表示通配符：如 fastlane/screenshots/<code>**/*.png</code>；</p></li><li><p><code>!</code> 表示取反：如 *.pbxuser 表示忽略所有后缀名为.pbxuser的文件，如果加上!default.pbxuser则表示，除了default.pbxuse忽略其它后缀名为pbxuse的文件。</p></li></ul><p>忽略文件的原则是：</p><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件，比如IDE的一些个人偏好设置。</li></ul><p>不需要从头写.gitignore文件，<a href="https://github.com/github/gitignore">github/gitignore </a> 已经为我们准备了各种配置文件，只需要组合一下就可以使用了。</p><p>如 iOS 项目忽略文件的几项配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## User settings</span></span><br><span class="line">xcuserdata/</span><br><span class="line"></span><br><span class="line"><span class="comment">## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)</span></span><br><span class="line">*.xcscmblueprint</span><br><span class="line">*.xccheckout</span><br><span class="line"></span><br><span class="line"><span class="comment">## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)</span></span><br><span class="line">build/</span><br><span class="line">DerivedData/</span><br><span class="line"></span><br><span class="line"><span class="comment">## App packaging</span></span><br><span class="line">*.ipa</span><br><span class="line">*.dSYM.zip</span><br><span class="line">*.dSYM</span><br></pre></td></tr></table></figure><h4 id="3-2-3-忽略文件的检查"><a href="#3-2-3-忽略文件的检查" class="headerlink" title="3.2.3 忽略文件的检查"></a>3.2.3 忽略文件的检查</h4><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：The following paths are ignored by one of your .gitignore files，可以使用<code>git add -f &lt;file&gt;</code>强制添加。</p><p>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore -v &lt;file&gt;</code>命令检查， Git会告诉我们，.gitignore的第几行规则忽略了该文件。</p><h3 id="3-3-git-config配置"><a href="#3-3-git-config配置" class="headerlink" title="3.3 git config配置"></a>3.3 git config配置</h3><h4 id="3-3-1-三种优先级的配置"><a href="#3-3-1-三种优先级的配置" class="headerlink" title="3.3.1 三种优先级的配置"></a>3.3.1 三种优先级的配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config [--global | --system] &lt;oo&gt;.&lt;kk&gt; &lt;vv&gt;</span><br><span class="line"><span class="comment"># 如配置用户信息    git config user.name/email xx</span></span><br><span class="line"><span class="comment"># 如配置编辑器      git config core.editor emacs</span></span><br><span class="line"><span class="comment"># 如配置别名       git config alias.st status</span></span><br><span class="line"><span class="comment"># 如配置输出的着色  git config color.ui false</span></span><br></pre></td></tr></table></figure><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： </p><ul><li><code>/etc/gitconfig</code>：包含系统上每一个用户及他们仓库的通用配置，使用带有 <code>--system</code> 选项的git config时，会从此文件读写配置变量；</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code>：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。 </li><li>仓库目录下 <code>/.git/config</code>：只针对该仓库，在仓库中使用带有 <code>--local(默认)</code> 选项的git config时，会读写该文件；<br>在优先级方面，从上往下依次上升。</li></ul><p>git config 的配置项有很多，详细可以看 <a href="https://github.com/git/git/tree/7a2dc95cbc25b4b82cff35931f69f8a5aafeb878/Documentation/config">git文档</a>。下面只是列出常见的几种。</p><h4 id="3-3-2-配置用户信息"><a href="#3-3-2-配置用户信息" class="headerlink" title="3.3.2 配置用户信息"></a>3.3.2 配置用户信息</h4><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面已经说过，用了--global参数表示这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址</span></span><br><span class="line">git config --global user.name “Your Name”</span><br><span class="line">git config --global user.email “email@example.com”</span><br></pre></td></tr></table></figure><p>用户名和邮箱地址的作用：</p><ul><li><p>每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改；</p></li><li><p>github 的 contributions 统计就是按邮箱来统计的。</p></li><li><p>注意：<strong>name、email是不用作git权限校验的，只为commit时做记录，随便怎么改都行</strong>。</p><p>亲证：误操作，用了一个全局配置的git name/email(公司的)用户名和邮箱，成功推送到了我的私人仓库</p></li></ul><p>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p><h4 id="3-3-3-配置文本编辑器"><a href="#3-3-3-配置文本编辑器" class="headerlink" title="3.3.3 配置文本编辑器"></a>3.3.3 配置文本编辑器</h4><p>当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器，通常是 Vim。 如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure><blockquote><p>Vim 和 Emacs 是像 Linux 与 Mac 等基于 Unix 的系统上开发者经常使用的流行的文本编辑器。 如果你对这些编辑器都不是很了解或者你使用的是 Windows 系统，那么可能需要搜索如何在 Git 中配置你最常用的编辑器。 如果你不设置编辑器并且不知道 Vim 或 Emacs 是什么，当它们运行起来后你可能会被弄糊涂、不知所措。</p></blockquote><h4 id="3-3-4-配置Git别名"><a href="#3-3-4-配置Git别名" class="headerlink" title="3.3.4 配置Git别名"></a>3.3.4 配置Git别名</h4><p>别名可以使你的 Git 体验更简单、容易、熟悉。</p><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.co checkout </span><br><span class="line">git config --global alias.ci commit </span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">&#x27;reset HEAD&#x27;</span></span><br><span class="line">git config --global alias.last <span class="string">&#x27;log -1&#x27;</span>  <span class="comment">#使用git last查看最后一次提交</span></span><br></pre></td></tr></table></figure><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-5-配置权限校验缓存"><a href="#3-3-5-配置权限校验缓存" class="headerlink" title="3.3.5 配置权限校验缓存"></a>3.3.5 配置权限校验缓存</h4><p>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p><p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 <code>git config --global credential.helper cache</code> 来设置它。</p><p>了解更多关于不同验证缓存的可用选项，查看 <a href="https://www.progit.cn/#_credential_caching">凭证存储</a>。</p><h4 id="3-3-6-配置Git的着色"><a href="#3-3-6-配置Git的着色" class="headerlink" title="3.3.6 配置Git的着色"></a>3.3.6 配置Git的着色</h4><p>Git 充分支持对终端内容着色，对你凭肉眼简单、快速分析命令输出有很大帮助。</p><p>Git 会自动着色大部分输出内容，但如果你不喜欢花花绿绿，也可以关掉。 要想关掉 Git 的终端颜色输出，试一下这个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个设置的默认值是 <code>auto</code>，它会着色直接输出到终端的内容；而当内容被重定向到一个管道或文件时，则忽略着色功能。</p><p>你也可以设置成 <code>always</code>，来忽略掉管道和终端的不同，即在任何情况下着色输出。 你很少会这么设置，在大多数场合下，如果你想在被重定向的输出中插入颜色码，可以传递 <code>--color</code> 标志给 Git 命令来强制它这么做。 默认设置就已经能满足大多数情况下的需求了。</p><p>要想具体到哪些命令输出需要被着色以及怎样着色，你需要用到和具体命令有关的颜色配置选项。 它们都能被置为 <code>true</code>、<code>false</code> 或 <code>always</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color.branch</span><br><span class="line">color.diff</span><br><span class="line">color.interactive</span><br><span class="line">color.status</span><br></pre></td></tr></table></figure><p>另外，以上每个配置项都有子选项，它们可以被用来覆盖其父设置，以达到为输出的各个部分着色的目的。 例如，为了让 <code>diff</code> 的输出信息以蓝色前景、黑色背景和粗体显示，你可以运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.diff.meta <span class="string">&quot;blue black bold&quot;</span></span><br></pre></td></tr></table></figure><p>你能设置的颜色有：<code>normal</code>、<code>black</code>、<code>red</code>、<code>green</code>、<code>yellow</code>、<code>blue</code>、<code>magenta</code>、<code>cyan</code> 或 <code>white</code>。 正如以上例子设置的粗体属性，想要设置字体属性的话，可以选择包括：<code>bold</code>、<code>dim</code>、<code>ul</code>（下划线）、<code>blink</code>、<code>reverse</code>（交换前景色和背景色）。</p><h4 id="3-3-7-查看配置信息"><a href="#3-3-7-查看配置信息" class="headerlink" title="3.3.7 查看配置信息"></a>3.3.7 查看配置信息</h4><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name=John Doe</span><br><span class="line">user.email=johndoe@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 <code>git config &lt;key&gt;</code>： 来检查 Git 的某一项配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">John Doe</span><br></pre></td></tr></table></figure><h2 id="四、服务器上的Git"><a href="#四、服务器上的Git" class="headerlink" title="四、服务器上的Git"></a>四、服务器上的Git</h2><h3 id="4-1-Git-的四种传输协议"><a href="#4-1-Git-的四种传输协议" class="headerlink" title="4.1 Git 的四种传输协议"></a>4.1 Git 的四种传输协议</h3><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。</p><h4 id="4-1-1-哑协议与智能协议之分"><a href="#4-1-1-哑协议与智能协议之分" class="headerlink" title="4.1.1 哑协议与智能协议之分"></a>4.1.1 哑协议与智能协议之分</h4><p><a href="https://www.progit.cn/#_%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">原文链接</a> Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。</p><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。 这个协议之所以被称为“哑”协议，是因为在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 <code>GET</code> 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p><blockquote><p>现在已经很少使用哑协议了。 使用哑协议的版本库很难保证安全性和私有化，所以大多数 Git 服务器宿主（包括云端和本地）都会拒绝使用它。 一般情况下都建议使用智能协议。</p></blockquote><p>哑协议虽然很简单但效率略低，且它不能从客户端向服务端发送数据。 智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p><ul><li>为了上传数据至远端，Git 使用 <code>send-pack</code> 和 <code>receive-pack</code> 进程。 运行在客户端上的 <code>send-pack</code> 进程连接到远端运行的 <code>receive-pack</code> 进程。</li><li>当你在下载数据时， <code>fetch-pack</code> 和 <code>upload-pack</code> 进程就起作用了。 客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code> 进程，以协商后续传输的数据。</li></ul><h4 id="4-1-2-本地协议"><a href="#4-1-2-本地协议" class="headerlink" title="4.1.2 本地协议"></a>4.1.2 本地协议</h4><p>最基本的就是 <em>本地协议（Local protocol）</em> ，其中的远程版本库就是硬盘内的另一个目录。 这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。 后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p><p>如果你使用共享文件系统，就可以从本地版本库克隆（clone）、推送（push）以及拉取（pull）。 像这样去克隆一个版本库或者增加一个远程到现有的项目中，使用版本库路径作为 URL。 例如，克隆一个本地版本库，可以执行如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> /opt/git/project.git</span><br></pre></td></tr></table></figure><p>或你可以执行这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> file:///opt/git/project.git</span><br></pre></td></tr></table></figure><p>如果在 URL 开头明确的指定 <code>file://</code>，那么 Git 的行为会略有不同。 如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。 如果指定 <code>file://</code>，Git 会触发平时用于网路传输资料的进程，那通常是传输效率较低的方法。 指定 <code>file://</code> 的主要目的是取得一个没有外部参考（extraneous references）或对象（object）的干净版本库副本– 通常是在从其他版本控制系统导入后或一些类似情况（参见 <a href="https://www.progit.cn/#_git_internals">Git 内部原理</a> for maintenance tasks）需要这么做。 在此我们将使用普通路径，因为这样通常更快。</p><h4 id="4-1-3-SSH-协议"><a href="#4-1-3-SSH-协议" class="headerlink" title="4.1.3 SSH 协议"></a>4.1.3 SSH 协议</h4><p>架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下已经支持通过 SSH 访问 —— 即时没有也比较很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p><p>通过 SSH 协议克隆版本库，你可以指定一个 <code>ssh://</code> 的 URL：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ssh://user@server/project.git</span></span><br></pre></td></tr></table></figure><p>或者使用一个简短的 scp 式的写法：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> user@server:project.git</span></span><br></pre></td></tr></table></figure><p>你也可以不指定用户，Git 会使用当前登录的用户名。</p><h5 id="1-优势"><a href="#1-优势" class="headerlink" title="1. 优势"></a>1. 优势</h5><p>用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTP/S 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</p><h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><p>SSH 协议的缺点在于你不能通过他实现匿名访问。 即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外，还得架设一个可以让其他人访问的服务。</p><h4 id="4-1-4-Git-协议"><a href="#4-1-4-Git-协议" class="headerlink" title="4.1.4 Git 协议"></a>4.1.4 Git 协议</h4><p>接下来是 Git 协议。 这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 <code>git-daemon-export-ok</code> 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。 不用说，极少会有人这么做。</p><h5 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h5><p>目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。</p><h5 id="2-缺点-1"><a href="#2-缺点-1" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><p>Git 协议缺点是缺乏授权机制。 把 Git 协议作为访问项目版本库的唯一手段是不可取的。 一般的做法里，会同时提供 SSH 或者 HTTPS 协议的访问服务，只让少数几个开发者有推送（写）权限，其他人通过 <code>git://</code> 访问只有读权限。 Git 协议也许也是最难架设的。 它要求有自己的守护进程，这就要配置 <code>xinetd</code> 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。</p><h4 id="4-1-5-HTTP-协议"><a href="#4-1-5-HTTP-协议" class="headerlink" title="4.1.5 HTTP 协议"></a>4.1.5 HTTP 协议</h4><p>Git 通过 HTTP 通信有两种模式。 在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。 Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。 之后几年，这个新的 HTTP 协议因为其简单、智能变的十分流行。 新版本的 HTTP 协议一般被称为“智能” HTTP 协议，旧版本的一般被称为“哑” HTTP 协议。 我们先了解一下新的“智能” HTTP 协议。</p><h5 id="1-智能（Smart）-HTTP-协议"><a href="#1-智能（Smart）-HTTP-协议" class="headerlink" title="1. 智能（Smart） HTTP 协议"></a>1. 智能（Smart） HTTP 协议</h5><p><a href="https://www.progit.cn/#_smart_http">Smart HTTP</a>：我们一般通过 SSH 进行授权访问，通过 git:// 进行无授权访问，但是还有一种协议可以同时实现以上两种方式的访问。 设置 Smart HTTP 一般只需要在服务器上启用一个 Git 自带的名为 <code>git-http-backend</code> 的 CGI 脚本。 该 CGI 脚本将会读取由 <code>git fetch</code> 或 <code>git push</code> 命令向 HTTP URL 发送的请求路径和头部信息，来判断该客户端是否支持 HTTP 通信（不低于 1.6.6 版本的客户端支持此特性）。 如果 CGI 发现该客户端支持智能（Smart）模式，它将会以智能模式与它进行通信，否则它将会回落到哑（Dumb）模式下（因此它可以对某些老的客户端实现向下兼容）。</p><p>“智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p><p>智能 HTTP 协议或许已经是最流行的使用 Git 的方式了，它即支持像 <code>git://</code> 协议一样设置匿名服务，也可以像 SSH 协议一样提供传输时的授权和加密。 而且只用一个 URL 就可以都做到，省去了为不同的需求设置不同的 URL。 如果你要推送到一个需要授权的服务器上（一般来讲都需要），服务器会提示你输入用户名和密码。 从服务器获取数据时也一样。</p><p>事实上，类似 GitHub 的服务，你在网页上看到的 URL （比如， <code>https://github.com/schacon/simplegit[]</code>)，和你在克隆、推送（如果你有权限）时使用的是一样的。</p><h5 id="2-哑（Dumb）-HTTP-协议"><a href="#2-哑（Dumb）-HTTP-协议" class="headerlink" title="2. 哑（Dumb） HTTP 协议"></a>2. 哑（Dumb） HTTP 协议</h5><p>如果服务器没有提供智能 HTTP 协议的服务，Git 客户端会尝试使用更简单的“哑” HTTP 协议。 哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 哑 HTTP 协议的优美之处在于设置起来简单。 基本上，只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 <code>post-update</code> 的挂钩就可以了（见 <a href="https://www.progit.cn/#_git_hooks">Git 钩子</a>）。 此时，只要能访问 web 服务器上你的版本库，就可以克隆你的版本库。</p><p>通常的，会在可以提供读／写的智能 HTTP 服务和简单的只读的哑 HTTP 服务之间选一个。 极少会将二者混合提供服务。</p><h5 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h5><p>我们将只关注智能 HTTP 协议的优点。</p><p>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用 Git 变得非常简单。 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效。</p><p>你也可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</p><p>另一个好处是 HTTP/S 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</p><h5 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h5><p>在一些服务器上，架设 HTTP/S 协议的服务端会比 SSH 协议的棘手一些。 除了这一点，用其他协议提供 Git 服务与 “智能” HTTP 协议相比就几乎没有优势了。</p><p>如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如 OSX 的 Keychain 或者 Windows 的凭证管理器。 参考 <a href="https://www.progit.cn/#_credential_caching">凭证存储</a> 如何安全地保存 HTTP 密码。</p><h3 id="4-2-搭建Git服务器"><a href="#4-2-搭建Git服务器" class="headerlink" title="4.2 搭建Git服务器"></a>4.2 搭建Git服务器</h3><p>搭建Git服务器非常简单，通常10分钟即可完成； </p><ul><li><p>要方便管理公钥，用<a href="https://github.com/res0nat0r/gitosis">Gitosis</a>； </p></li><li><p>要像SVN那样变态地控制权限，用<a href="https://github.com/sitaramc/gitolite">Gitolite</a>。</p></li></ul><p>参考链接：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664">搭建Git服务器</a></p><h3 id="4-3-error：hung-up-unexpectedly"><a href="#4-3-error：hung-up-unexpectedly" class="headerlink" title="4.3 error：hung up unexpectedly"></a>4.3 error：hung up unexpectedly</h3><p>使用场景：clone、push的时候报错<code>The remote end hung up unexpectedly</code>时</p><ul><li>git <code>config http.postBuffer 524288000 </code>(stackOverFlow上有人说好像对SSH协议报这个错时也有效)</li><li>也可能是：接口不通(Git默认端口22，可能运维改了)，或者网络不好</li><li>可以试试，具体还是以<code>“error: ...信息”</code>为准（ 如果改了postBuffer，问题解决之后，建议改回去 ）</li></ul><p>我当时因为传输了大量大文件，修改了http.postBuffer没用；</p><p>还有说修改http.lowSpeedLimit=0、http.lowSpeedTime=999999；设置允许的最低速度，最低速度时间(没试，我是SSH协议push的！）</p><p>修改了SSH的重连ServerAliveInterval=30、ServerAliveCountMax=5没用；</p><p>后来无奈，只能分批次上传。</p><h4 id="4-3-1-配置http-postBuffer"><a href="#4-3-1-配置http-postBuffer" class="headerlink" title="4.3.1 配置http.postBuffer"></a>4.3.1 配置http.postBuffer</h4><blockquote><p><a href="https://github.com/git/git/blob/7a2dc95cbc25b4b82cff35931f69f8a5aafeb878/Documentation/config/http.txt#L195-L209">官方链接</a></p><p>Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally.  Default is 1 MiB, which is sufficient for most requests.</p><p>Note that raising this limit is only effective for disabling chunked transfer encoding and therefore should be used only where the remote server or a proxy only supports HTTP/1.0 or is noncompliant with the HTTP standard.  Raising this is not, in general, an effective solution for most push problems, but can increase memory consumption significantly since the entire buffer is allocated even for small pushes.</p></blockquote><p>个人认为：这个参数是用来设置HTTP传输发送buffer池的大小(池子满了，或者数据已写入完毕就发送)</p><ul><li>客户端、服务端会根据这个参数来申请内存当做buffer池(所以如果太大了，会消耗内存，而且如果块太大，并不是所有的服务器系统都能正常接收处理的)</li><li>客户端推送的大小如果超过这个可能会失败(至于说是本地发送失败，还是因为服务端根据这个设置的接收buffer池大小，结果接收到的数据太大，缓冲区溢出造成的失败就不清楚了)</li><li>服务端应答的大小如果超过这个会分块传输</li><li>仅对禁用分块传输编码有效（因此仅在远程服务器或代理仅支持HTTP/1.0或不符合HTTP标准的情况下才应使用），意思是分块传输编码时，有自己的分块传输(块多大)策略，而且优先级更高</li></ul><p>服务端程序在接收客户端表单提交的数据时，需要先将数据存储到一个内存空间，然后做解析等后续工作，这个内存空间一般称之为接收缓冲区。对于post数据因为有Content-Length标记，服务端可以按标记的长度创建一个等于或稍大于提交数据的缓冲区；对于get，因为事先不知道提交的数据有多少，需要估计缓冲区长度，如果缓冲区很大而接收数据很小会造成内存浪费，而如果缓冲区小于接收数据，就可能造成缓冲区溢出。</p><p>“聪明的”黑客，会在溢出部分放置特殊的代码来攻陷你的服务器。<a href="https://www.cnblogs.com/meilibao/archive/2012/10/29/2744525.html">博客</a></p><h4 id="4-3-2-补充：Transfer-Encoding-chunked"><a href="#4-3-2-补充：Transfer-Encoding-chunked" class="headerlink" title="4.3.2 补充：Transfer-Encoding:chunked"></a>4.3.2 补充：Transfer-Encoding:chunked</h4><p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">维基百科</a></p><p>表示输出的内容长度不能确定， 通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度， 先把整个要输出的数据写到一个很大的字节数组里(如 ByteArrayOutputStream)，然后得到数组大小 -&gt; Content-Length。 </p><p>如果结合Transfer-Encoding: chunked使用，就不必申请一个很大的字节数组了，可以一块一块的输出，更科学，占用资源更少。 这在http协议中也是个常见的字段，用于http传送过程的分块技术，原因是http服务器响应的报文长度经常是不可预测的，使用Content-length的实体搜捕并不是总是管用。</p><h2 id="五、Git的两种鉴权方式"><a href="#五、Git的两种鉴权方式" class="headerlink" title="五、Git的两种鉴权方式"></a>五、Git的两种鉴权方式</h2><p>HTTPS URLs和SSH URLs对应的是两套完全独立的权限校验方式，主要的区别就是：</p><ul><li><p>前者采用账号密码进行校验；</p></li><li><p>后者采用SSH秘钥对进行校验。</p></li></ul><h3 id="5-1-SSH"><a href="#5-1-SSH" class="headerlink" title="5.1 SSH"></a>5.1 SSH</h3><p><a href="https://help.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh">GitHub官网配置步骤指导</a></p><p>只要选择正确的密钥，本地的私钥加密，对应的远程仓库账号中事先添加的公钥能解开就能提交成功。</p><p>生成公钥时，需要指定GitHub的邮箱地址，配置在GitHub中的公钥串中也包含邮箱，GitHub是校验的这个邮箱账号。</p><h4 id="5-1-1-ssh-agent"><a href="#5-1-1-ssh-agent" class="headerlink" title="5.1.1 ssh-agent"></a>5.1.1 ssh-agent</h4><p>ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。参考链接：<a href="https://www.zsythink.net/archives/2407">了解ssh代理：ssh-agent</a>。</p><p>个人理解： 类似VPN代理软件吧，会拦截我们的请求并针对性地加以处理。还有一点相同的是： 将私钥加入ssh-agent后，即使删除私钥文件，本地计算机仍可以正常访问 GitHub 代码仓库。</p><h4 id="5-1-2-修改SSH默认端口"><a href="#5-1-2-修改SSH默认端口" class="headerlink" title="5.1.2 修改SSH默认端口"></a>5.1.2 修改SSH默认端口</h4><p>为了安全起见，有时会修改服务器ssh连接端口，比如改为3222。此时我们需要在 <em>/etc/ssh/ssh_config</em> 或者 <em>~/.ssh/config</em> 中找到行 <em>port 22</em> 并修改(像这种配置文件最好使用vim编辑器)。</p><h3 id="5-2-HTTPS"><a href="#5-2-HTTPS" class="headerlink" title="5.2 HTTPS"></a>5.2 HTTPS</h3><p>https 除了速度慢以外，还有个最大的麻烦是每次与远程仓库交互时，都必须输入账号(可以是git用户名，也可以是邮箱地址)、口令进行校验。</p><p>可以记住密码：</p><ul><li><p>Mac中可以存储在keychain中，<strong>在开启Keychain机制的情况下，进行权限校验后会自动将账号密码保存至Keychain Access</strong>。</p></li><li><p>Mac、Windows共用—— git 提供的 credential helper机制：可以将账号密码以 cache 的形式在内存中缓存一段时间（默认 15 分钟），或者以文件的形式存储起来（~/.git-credentials）。</p></li></ul><h3 id="5-3-配置不同账号访问不同仓库"><a href="#5-3-配置不同账号访问不同仓库" class="headerlink" title="5.3 配置不同账号访问不同仓库"></a>5.3 配置不同账号访问不同仓库</h3><p>当一台计算机中需要以不同账号访问不同的仓库时：</p><ul><li>SSH：如果不同的仓库配置了不同的公钥，那么在使用本地私钥时，就要加以区分。(当然也可以所有仓库都使用一套公钥、私钥，理论上私钥只有自己知道)。</li><li>HTTPS：如果不记住账号密码，即每次都输入账号密码，那就不需要配置。<ul><li>如果使用Keychain记住了密码，此时会根据仓库的 host 去 Keychain 中寻找账户密码，因为 Keychain 中针对这个host 存储了多个账号、密码，那找出的可能是错误的，此时就会权限校验失败。此时我们需要处理一下我们的仓库URL。</li></ul></li></ul><h4 id="5-3-1-SSH的处理"><a href="#5-3-1-SSH的处理" class="headerlink" title="5.3.1 SSH的处理"></a>5.3.1 SSH的处理</h4><p>以SSH方式：通过远程仓库的url（clone之后存储在repo/.git/config中）的host </p><ul><li>找到host配置的对应SSH-Key(SSH-Key一般都存在~/.ssh文件夹中)<ul><li>当只有一个SSH账号时，/etc/ssh/ssh_config配置文件，默认直接指向~/.ssh/id_rsa</li><li>当有多个SSH账号时，<del>/.ssh/config配置文件中，分别配置每个host对应的</del>/.ssh中的SSH-Key</li></ul></li><li>通过密钥进行权限校验</li></ul><p>两个文件的影响范围：</p><ul><li><p>/etc/ssh/ssh_config下的配置是针对当前系统所有用户</p></li><li><p>~/.ssh/config(/User/用户名/.ssh/config)只针对当前用户(默认是没有该文件的，只有当有多个用户，需要做映射时，才创建、配置)</p></li></ul><p>如果两个仓库host不相同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">Host github.com <span class="comment"># Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件</span></span><br><span class="line">Port 22         <span class="comment"># 端口号（如果不是默认22号端口则需要指定） </span></span><br><span class="line">HostName github.com  <span class="comment"># 是代码仓库服务器的主机(此处是github)</span></span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa  <span class="comment"># 指明User对应的identityFile路径，即SSH-Key</span></span><br><span class="line">User loten   <span class="comment"># 登录名（如gitlab的username） </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个同上，如 smartgit</span></span><br></pre></td></tr></table></figure><p>如果两个仓库host也相同，则需要在Host中进行区分，然后经过 <code>CNAME</code> 映射到 <code>HostName</code>（<code>Host相当于是HostName的别名</code>），然后分别指向不同的SSH-key，即IdentityFile，从而实现了对两个 GitHub 账号的分离。（<code>HostName才是真正指定 GitHub 服务器主机的字段</code>）</p><p>在config文件修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debugtalk</span></span><br><span class="line">Host debugtalk</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    User git</span><br><span class="line"></span><br><span class="line"><span class="comment"># DJI</span></span><br><span class="line">Host djileolee</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/dji_id_rsa</span><br><span class="line">    User git</span><br></pre></td></tr></table></figure><p>此处改了还没完，还需要在各个项目中分别进行修改配置：代码提交、拉取时远程仓库的地址。 即<code>repo/.git/config</code>文件：可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将原先的远程仓库的URL  git@github.com:debugtalk/DroidMeter.git中的host改成我们刚设置的host(别名)</span></span><br><span class="line">git remote add origin git@debugtalk:debugtalk/DroidMeter.git</span><br></pre></td></tr></table></figure><h4 id="5-3-2-HTTPS的处理"><a href="#5-3-2-HTTPS的处理" class="headerlink" title="5.3.2 HTTPS的处理"></a>5.3.2 HTTPS的处理</h4><p>以HTTPS方式：通过远程仓库的url（clone之后存储在repo/.git/config中）。</p><p>比如：本来的HTTPS URL为 <code>https://github.com/loten/RSAHandle.git</code> 手动改为：<code>https://loten@github.com/loten/RSAHandle.git</code>。</p><p>注意：loten是GitHub的用户名，不能打错。在第一次拉取/推送的时候(钥匙串keychain中还没存储账号、密码)，会要求输入该用户名对应的密码：Password Required For user Roten8 on host github.com. 输入成功后，即可成功拉取/推送。</p><p>配置原理很容易理解，即将 GitHub 用户名添加到仓库的 Git 地址中，这样在执行 git 命令的时候，系统就会采用指定的 GitHub 用户名去<code>Keychain</code> 或 <code>~/.git-credentials</code> 中寻找对应的认证信息，账号使用错乱的问题也就不复存在了。</p><p>然后可以发现使用这种方式修改之后，可以看到keychain中的存储信息的<code>账号</code>：<code>由邮箱号变为了Git用户名</code>。即不再仅仅通过host来寻找账号密码，而是找到keychain中，这个host下指定的用户名对应的密码，来使用。</p><p>参考链接： <a href="https://ruby-china.org/topics/30298">Git深入浅出 Git 权限校验 (最熟悉的陌生概念)</a></p><h2 id="六、从仓库目录角度了解Git工作原理"><a href="#六、从仓库目录角度了解Git工作原理" class="headerlink" title="六、从仓库目录角度了解Git工作原理"></a>六、从仓库目录角度了解Git工作原理</h2><h3 id="6-1-目录结构"><a href="#6-1-目录结构" class="headerlink" title="6.1 目录结构"></a>6.1 目录结构</h3><img src="/images/git/dir.png" alt="dir" style="zoom:70%;" /><ul><li>Directory：使用 Git 管理的一个目录，也就是一个仓库，包含我们的工作空间和 Git 的管理空间。</li><li>WorkSpace：需要通过 Git 进行版本控制的目录和文件，这些目录和文件组成了工作空间/工作区/工作目录，除了 .git 之外的都属于工作区。<ul><li>工作目录下的文件有两种状态：已跟踪tracked或未跟踪untracked（新创建的文件，没有被add到暂存区就是untracked状态）</li></ul></li><li>.git：存放 Git 管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入 repo 之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD 会只是当前的开发分支（branch）。</li><li>Stash：是一个工作状态保存栈，用于保存/恢复 WorkSpace 中的临时状态。</li></ul><blockquote><p>一个 modification 的提交要经历工作区——add到暂存区(staged)——commit到本地仓库——push到远程仓库</p></blockquote><p>文件的状态改变：</p><img src="/images/git/lifecycle.png" alt="lifecycle" style="zoom:70%;" /><h3 id="6-2-git文件夹-版本库"><a href="#6-2-git文件夹-版本库" class="headerlink" title="6.2 .git文件夹(版本库)"></a>6.2 .git文件夹(版本库)</h3><h4 id="6-2-1-index"><a href="#6-2-1-index" class="headerlink" title="6.2.1 index"></a>6.2.1 index</h4><p>暂存区是Git相比SVN的特色；</p><p>当修改了工作区里的一个文件时，这些修改一开始是<code>unstaged</code>状态，为了提交这些修改，你需要使用<code>git add</code>把它加入到index，使它成为<code>staged</code>状态。当你提交一个commit时，index里面的修改被提交；</p><p>当在工作区新增一个文件，文件是<code>untracked</code>状态，<code>git add &lt;file&gt;</code>添加到index，变为<code>tracked</code>状态。</p><h4 id="6-2-2-objects"><a href="#6-2-2-objects" class="headerlink" title="6.2.2 objects/"></a>6.2.2 objects/</h4><p>该文件夹下存储了所有数据内容。主要有四大对象：数据对象、树对象、提交对象、标签对象。</p><h5 id="1-数据对象-对应-文件"><a href="#1-数据对象-对应-文件" class="headerlink" title="1. 数据对象(对应 文件)"></a>1. 数据对象(对应 文件)</h5><p>Git 是一个内容寻址文件系统，即Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 </p><p>可以通过底层命令hash-object来<strong>演示</strong>上述效果——该命令可将任意数据保存于.git目录，并返回相应的键值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;test content&#x27;</span> | git hash-object -w --stdin</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;version 1&#x27;</span> &gt; test.txt</span><br><span class="line">git hash-object -w test.txt</span><br></pre></td></tr></table></figure><ul><li>-w选项指示hash-object命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值。</li><li>–stdin选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。 </li><li>该命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。</li><li>可以在objects目录下看到一个文件， <strong>校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名</strong>。</li></ul><p>可以通过 <code>cat-file</code> 命令从 Git 那里取回数据，这个命令简直就是一把剖析 Git 对象的瑞士军刀。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -t 打印其内部存储的对象类型（SHA-1 值为目录名+文件名）：输出为：`blob`、`tree`、`commit`</span></span><br><span class="line">git cat-file -t &lt;SHA-1&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># -p 打印对象里的内容  </span></span><br><span class="line">git cat-file -p &lt;SHA-1&gt;  <span class="comment"># -p: Pretty-print 自动判断内容的类型，并为我们显示格式友好的内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># - blob对象，打印出是可视化的，我们做的修改</span></span><br><span class="line"><span class="comment"># - tree对象，打印出其包含的数据对象和子树对象的SHA-1指针</span></span><br><span class="line"><span class="comment"># - commit对象，打印出：tree对象、parent父提交对象、author(name、email、时间戳)、commiter、留空一行、注释</span></span><br></pre></td></tr></table></figure><p><strong>每当一个文件修改时，就会生成一个数据对象。数据对象的内容是源文件当前的全部内容</strong>(<strong>而非存储的修改内容，保证了每次切换节点时，快速恢复！</strong>)。</p><p>不过， 记住文件的每一个版本所对应的 SHA-1 值并不现实。另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为数据对象（blob object）</p><h5 id="2-树对象-对应-目录"><a href="#2-树对象-对应-目录" class="headerlink" title="2. 树对象(对应 目录)"></a>2. 树对象(对应 目录)</h5><p>树对象（tree object）能解决文件名保存的问题，也允许我们将多个文件组织到一起。 <strong>Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化</strong>：</p><ul><li><p>所有内容均以树对象和数据对象的形式存储，其中<font color='red'>树对象对应了 UNIX 中的目录项</font><strong>，</strong><font color='red'>数据对象则大致上对应了 inodes 或文件内容</font>；</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Inode">inode</a>是一个重要概念，是理解Unix/Linux文件系统和硬盘储存的基础。</p><p>我觉得，理解inode，不仅有助于提高系统操作水平，还有助于体会Unix设计哲学，即如何把底层的复杂性抽象成一个简单概念，从而大大简化用户接口。</p><p><strong>一、inode是什么？</strong></p><p>理解inode，要从文件储存说起。</p><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><p><strong>二、inode的内容</strong></p><p>inode包含文件的元信息，具体来说有以下内容：</p><ul><li><p>文件的字节数</p></li><li><p>文件拥有者的User ID</p></li><li><p>文件的Group ID</p></li><li><p>文件的读、写、执行权限</p></li><li><p>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</p></li><li><p>链接数，即有多少文件名指向这个inode</p></li><li><p>文件数据block的位置</p></li></ul><p>可以用stat命令，查看某个文件的inode信息：<code>stat example.txt</code></p></blockquote></li><li><p>一个树对象包含了一条或多条树对象记录（tree entry）；</p></li><li><p>每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。</p><ul><li>文件模式为 <code>100644</code>，表明这是一个普通文件。 </li><li><code>100755</code>，表示一个可执行文件；</li><li><code>120000</code>，表示一个符号链接。</li><li> 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</li></ul></li></ul><p>通常，Git 根据某一时刻暂存区所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。</p><p>可以通过<code>write-tree</code>命令将暂存区内容写入一个树对象。</p><p>例如，某项目当前对应的最新树对象可能是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master^&#123;tree&#125;语法表示 master 分支上最新的提交所指向的树对象</span></span><br><span class="line">git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，lib子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象</span></span><br><span class="line">git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0</span><br><span class="line">100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</span><br></pre></td></tr></table></figure><p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件、以及一个目录：</p><img src="/images/git/data-model-1.png" alt="data-model-3" style="zoom:70%;" /><p>下面是个（非常规操作…）举例，你可以将一个旧的树对象加入新的树对象，使其成为新的树对象的一个子目录。 通过调用 <code>read-tree</code> 命令，可以把树对象读入暂存区。本例中，可以通过对 <code>read-tree</code> 指定 <code>--prefix</code> 选项，将一个已有的树对象作为子树读入暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git write-tree</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure><p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为 <code>bak</code> 的子目录，该子目录包含 test.txt 文件的第一个版本。 可以认为 Git 内部存储着的用于表示上述结构的数据是这样的：</p><img src="/images/git/data-model-2.png" alt="data-model-3" style="zoom:70%;" /><h5 id="3-提交对象"><a href="#3-提交对象" class="headerlink" title="3. 提交对象"></a>3. 提交对象</h5><p><strong>树对象代表了我们想要跟踪的不同项目快照</strong>。然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是提交对象（commit object）能为你保存的基本信息。</p><ul><li>可以通过调用<code>commit-tree</code>命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。</li><li>提交对象的格式很简单：<ul><li>它先指定一个顶层树对象，代表当前项目快照；<strong>这个树对象记录了此刻工作目录所有文件的状态，这也是Git切换快速便捷的原理</strong>。</li><li>然后是作者/提交者信息（依据你的user.name和user.email配置来设定，外加一个时间戳）；</li><li>留空一行，最后是提交注释。(重要的两点：顶层树对象、父提交对象)</li></ul></li><li>提交对象的<strong>SHA-1值即为commit id</strong></li></ul><p><strong>提交对象对应的这个最顶层的树对象就对应了我们的工作目录，下面的每一个tree对象对应我们项目中的文件夹，每一个的blob对象就是此时该文件的最新全部内容</strong>。比如下面是一个大项目的master分支上最新提交对应的树对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob 17eb1b55d91525217c8615813a702207d038eec8.DS_Store</span><br><span class="line">100755 blob 47acf8552d011d70d98b1805a1f2fd00ca060356.gitignore</span><br><span class="line">040000 tree 7b19b9ca1fece9c204770f7ddfa3a362f12dbf2eLLBaseKit</span><br><span class="line">040000 tree 8f826ece85e875c00af345ab4b40c6661a512eb5LLIDCard</span><br><span class="line">040000 tree 3f96965ac93c24a71a4bff9bbfbc587d5889bc92LLLiveDetection</span><br><span class="line">100644 blob a42e52ed334aa15800dca69d256d0e340494551fPodfile</span><br><span class="line">100644 blob f0430fd46587a9c29a5385001adb89c6ae9ef759Podfile.lock</span><br><span class="line">040000 tree 44e5dd79ef5a0435e1f3a0ea112cbaf8b6b48071Pods</span><br><span class="line">040000 tree dd706fe8898be1a2a7ccdfc3fb61115a0aef4b01RTSu.xcodeproj</span><br><span class="line">040000 tree 65ac1588391931d47e65f7fc7c2032f6a738a819RTSu.xcworkspace</span><br><span class="line">040000 tree 221347dd21123109ffa63300c4003de34cfec8f4RTSu</span><br><span class="line">040000 tree bd7d6129ab1bbf677aaaab85f493ed437c976493RTSuJPush</span><br><span class="line">040000 tree 40152f8dc68864e779104a782278ee2bd3dcd9e4RTSuTests</span><br><span class="line">040000 tree b8397ded7e7b5efa1cc83bddc69a93fc2c6cc1c7RTSuUITests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以 git cat-file -p 打印上面的树对象，打印出来即是我们的源文件</span></span><br></pre></td></tr></table></figure><h5 id="4-三种对象的关系图"><a href="#4-三种对象的关系图" class="headerlink" title="4. 三种对象的关系图"></a>4. 三种对象的关系图</h5><p>每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时， Git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。 如果跟踪所有的内部指针，将得到一个类似下面的对象关系图：</p><img src="/images/git/data-model-3.png" alt="data-model-3" style="zoom:70%;" /><h5 id="5-对象的存储"><a href="#5-对象的存储" class="headerlink" title="5. 对象的存储"></a>5. 对象的存储</h5><p>Git在存储内容时，会有个头部信息一并被保存</p><ul><li>以对象类型作为开头来构造一个头部信息：比如“blob”字符串，接着 Git 会添加一个空格，随后是数据内容的长度，最后是一个空字节（null byte）<code>&quot;blob #&#123;content.length&#125;\0&quot;</code></li><li>将上述头部信息和原始数据拼接起来，并计算出这条新内容的 SHA-1 校验和</li><li>通过 zlib 压缩这条新内容</li><li>最后，需要将这条经由 zlib 压缩的内容写入磁盘上的某个对象。 要先确定待写入对象的路径（SHA-1 值的前两个字符作为子目录名称，后 38 个字符则作为子目录内文件的名称）。 如果该子目录不存在则创建它。</li><li>所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。 另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</li></ul><h4 id="6-2-3-refs"><a href="#6-2-3-refs" class="headerlink" title="6.2.3 refs/"></a>6.2.3 refs/</h4><p>存储指向数据（分支）的提交对象的指针；</p><p>GIT引用概述：由于一些地方需要用到SHA-1值，而SHA-1不易记录， 我们需要一个文件来保存 SHA-1 值，并给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值。</p><ul><li>在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；可以在.git/refs目录下找到这类含有 SHA-1 值的文件。(<strong>帮助我们记忆最新提交所在的位置</strong>)；</li><li>这基本就是 Git 分支的本质：<strong>一个指向某一系列提交之首的指针或引用</strong>， 当运行类似于 <code>git branch (branchname)</code> 这样的命令时，Git 实际上会运行 <code>update-ref</code> 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</li></ul><img src="/images/git/data-model-4.png" alt="data-model-4" style="zoom:80%;" /><h5 id="1-heads-—-HEAD引用"><a href="#1-heads-—-HEAD引用" class="headerlink" title="1. heads/ — HEAD引用"></a>1. heads/ — HEAD引用</h5><p>现在的问题是，当你执行<code>git branch (branchname)</code>时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。</p><p>HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针：</p><ul><li>如果查看 HEAD 文件的内容，一般而言我们看到的类似这样： <code>ref: refs/heads/master(或者当前分支名)</code>；</li><li>当我们执行<code>git commit</code>时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。</li></ul><p>/refs/heads/ 记录<code>本地</code>每个分支的提交之首</p><h5 id="2-tags-—-Tag引用"><a href="#2-tags-—-Tag引用" class="headerlink" title="2. tags/ — Tag引用"></a>2. tags/ — Tag引用</h5><p>标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 </p><p>主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p><ul><li>轻量标签： 只是一个特定提交的固定引用</li><li>附注标签：Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象</li></ul><p>标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象(比如数据、树对象)打标签</p><h5 id="3-remotes-—-远程引用-remote-reference"><a href="#3-remotes-—-远程引用-remote-reference" class="headerlink" title="3. remotes/ — 远程引用(remote reference)"></a>3. remotes/ — 远程引用(remote reference)</h5><p>如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下每一个分支最近一次推送操作时所对应的SHA-1值，并保存在refs/remotes目录下(文件名为远程分支名)</p><ul><li>远程引用和分支（位于refs/heads目录下的引用）之间最主要的区别在于，远程引用是只读的（本地仓库的commit可以reset来修改HEAD的指向，但是remote repo的是不能的）</li></ul><p><strong>子文件夹为远程仓库的名称（如果有多个远程仓库(config文件中有多个[remote xxx])就有多个子文件夹），文件夹中的文件名称是远程仓库中执行过推送操作的远程分支名</strong>。</p><h5 id="4-for-—-Gerrit"><a href="#4-for-—-Gerrit" class="headerlink" title="4. for/ — Gerrit"></a>4. for/ — Gerrit</h5><p>如果我们使用的是Gerrit（一种开放源代码的代码审查软件，使用网页界面。利用网页浏览器，同一个团队的软件开发者，可以在评审网页上相互审阅彼此修改后的代码，决定是否能够提交，回退或是继续修改。它使用版本控制系统Git作为底层）</p><ul><li>Gerrit为了保证每次代码提交都强制开启代码评审，要求研发人员在提交代码的时候统一使用: git push [remote_name] HEAD:refs/for/[branch_name]，执行后会在评审界面创建一条新的code review，只有通过review之后才可以合入远程仓库。</li><li>此时如果执行<code>git push origin HEAD:refs/head/master</code>，那么就会有“! [remote rejected] master -&gt; master (prohibited by Gerrit)”的错误信息，命令失效。</li><li>对于那些希望将Code Review粒度控制在单次提交级别的研发团队，使用基于Gerrit机制的工具是比较合适的。( <a href="https://cloud.baidu.com/product/xly.html">百度效率云的iCode</a>就是基于Gerrit机制开发的 )</li></ul><img src="/images/git/gerrit.png" alt="gerrit" style="zoom:80%;" /><p>下面一段是对“refs/for”更详细的描述：</p><blockquote><p>The documentation for Gerrit explains that you push to the “magical refs/for/‘branch’ ref using any Git client tool”.</p><p>This image is taken from the Intro to Gerrit. When you push to Gerrit, you do git push gerrit HEAD:refs/for/<code>&lt;BRANCH&gt;</code>. This pushes your changes to the staging area (in the diagram, “Pending Changes”). Gerrit doesn’t actually have a branch called <code>&lt;BRANCH&gt;</code>; it lies to the git client.</p><p>Internally, Gerrit has it’s own implementation for the Git and SSH stacks. This allows it to provide the “magical” refs/for/<code>&lt;BRANCH&gt;</code> refs.</p><p>When a push request is received to create a ref in one of these namespaces Gerrit performs its own logic to update the database, and then lies to the client about the result of the operation. A successful result causes the client to believe that Gerrit has created the ref, but in reality Gerrit hasn’t created the ref at all.  </p><p>After a successful patch (i.e, the patch has been pushed to Gerrit, [putting it into the “Pending Changes” staging area], reviewed, and the review has passed), Gerrit pushes the change from the “Pending Changes” into the “Authoritative Repository”, calculating which branch to push it into based on the magic it did when you pushed to refs/for/<code>&lt;BRANCH&gt;</code>. This way, successfully reviewed patches can be pulled directly from the correct branches of the Authoritative Repository.</p></blockquote><h4 id="6-2-4-HEAD"><a href="#6-2-4-HEAD" class="headerlink" title="6.2.4 HEAD"></a>6.2.4 HEAD</h4><p>指向当前分支的当前提交；</p><h4 id="6-2-5-config"><a href="#6-2-5-config" class="headerlink" title="6.2.5 config"></a>6.2.5 config</h4><p>文件包含项目特有的配置选项，覆盖Git的全局配置</p><h4 id="6-2-6-description"><a href="#6-2-6-description" class="headerlink" title="6.2.6 description"></a>6.2.6 description</h4><p>仅供 GitWeb 程序使用，我们无需关心</p><h4 id="6-2-7-hooks"><a href="#6-2-7-hooks" class="headerlink" title="6.2.7 hooks/"></a>6.2.7 hooks/</h4><p>包含客户端或服务端的钩子脚本（hook scripts）, hook用户操作，拦截一些不合理的行为命令</p><h4 id="6-2-8-info"><a href="#6-2-8-info" class="headerlink" title="6.2.8 info/"></a>6.2.8 info/</h4><p>目录包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）</p><h2 id="七、常用命令"><a href="#七、常用命令" class="headerlink" title="七、常用命令"></a>七、常用命令</h2><h3 id="7-1-提交、撤销与查看"><a href="#7-1-提交、撤销与查看" class="headerlink" title="7.1 提交、撤销与查看"></a>7.1 提交、撤销与查看</h3><h4 id="1-git-checkout-工作区的撤销"><a href="#1-git-checkout-工作区的撤销" class="headerlink" title="1. git checkout  工作区的撤销"></a>1. git checkout  工作区的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤销文件在工作区的修改(处于暂存区的修改不受影响)</span></span><br><span class="line">git checkout -- &lt;filename&gt; <span class="comment"># .表示全选</span></span><br></pre></td></tr></table></figure><ul><li>注意：如果不加<code>--</code>，就变成了“切换到另一个分支”的命令</li><li>untracked的文件修改不受影响</li></ul><h4 id="2-git-add-暂存区的提交"><a href="#2-git-add-暂存区的提交" class="headerlink" title="2. git add 暂存区的提交"></a>2. git add 暂存区的提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt; <span class="comment"># .表示全选</span></span><br></pre></td></tr></table></figure><p>是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：</p><ul><li>可以用它开始跟踪新文件</li><li>把已跟踪的文件放到暂存区。</li><li>还能用于合并时把有冲突的文件标记为已解决状态</li></ul><h4 id="3-git-rm-暂存区的提交"><a href="#3-git-rm-暂存区的提交" class="headerlink" title="3. git rm 暂存区的提交"></a>3. git rm 暂存区的提交</h4><p>删除文件，并将这个删除添加到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;filename&gt;</span><br><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><h4 id="4-git-commit-本地仓库的提交"><a href="#4-git-commit-本地仓库的提交" class="headerlink" title="4. git commit 本地仓库的提交"></a>4. git commit 本地仓库的提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;commit message&#x27;</span></span><br><span class="line">git commit -am(-a -m) <span class="string">&#x27;commit message&#x27;</span> <span class="comment"># 将tracked状态的文件的修改`add+commit`(该命令对未跟踪状态的文件修改不生效)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上一条提交的 commit message</span></span><br><span class="line">git commit --amend <span class="comment"># amend(修改，修订；纠正)。修改后是一次新的提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改之前提交的 commit message。比如说，我想修改距此版本之前的第3条 commit message</span></span><br><span class="line"><span class="comment"># 第一步：运行</span></span><br><span class="line">git rebase -i HEAD~3  <span class="comment"># 需要变基，也就是重新提交一遍。与上面的限制是一样，提交对象的commit msg不可修改，除非重新产生提交对象</span></span><br><span class="line"><span class="comment"># -i, --interactive(互动) 允许用户编辑要rebase的提交列表.</span></span><br><span class="line"><span class="comment"># 比如，此时显示</span></span><br><span class="line"><span class="comment"># pick 56b2308 feat(pages): home DONE</span></span><br><span class="line"><span class="comment"># pick 82f65eb fix(pages movie): slides bug fixed</span></span><br><span class="line"><span class="comment"># pick 08b2087 feat(pages home &amp; movie): add FABs animation </span></span><br><span class="line"><span class="comment"># 第二步：将要修改的那条 commit message，如 pick 56b2308 feat(pages): home DONE，pick 改为 edit，修改完成后保存退出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：然后仍然是运行下面的命令修改commit message</span></span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步：最后运行</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>将暂存区里所有的修改提交到本地仓库的当前分支：</p><ul><li>会显示： file changed(文件修改)、insertions(插入行)、deletions(删除行)</li><li>可以多次add，一次commit</li></ul><p>commit id解释说明： 看到的一串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。</p><p>为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><h4 id="5-git-reset-暂存区与本地仓库的撤销"><a href="#5-git-reset-暂存区与本地仓库的撤销" class="headerlink" title="5. git reset 暂存区与本地仓库的撤销"></a>5. git reset 暂存区与本地仓库的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [&lt;mode&gt;] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure><p>将当前分支的HEAD指向给定的版本，并根据模式的不同决定是否修改index和working tree。</p><ul><li><p>–soft模式</p><ul><li>指定commit id之后的所有commit的修改、目前index中暂存的修改都被保留在index中；</li><li>working tree中还没暂存的修改保持原样。</li></ul></li><li><p>–mixed(默认)</p><ul><li>清空index</li><li>指定commit id之后的所有commit的修改、目前index中暂存的修改、目前working tree中还没暂存的修改都被保留在工作区中</li><li>可以巧用<code>git reset</code>来<strong>撤销添加到暂存区中的修改</strong>(放入了工作区)，即<code>git reset HEAD &lt;file&gt;</code></li></ul></li><li><p>–hard：</p><ul><li>清空index、workingtree，指定commit id之后的所有提交修改也不会保留。</li></ul></li></ul><p>需要注意：</p><ul><li><p>reset是<strong>操作的本地仓库</strong>，所以只能reset那些未push到remote仓库的commit。</p></li><li><p>Git的版本回退速度非常快，因为Git会保存所有修改，而reset实质上是重置本地仓库的HEAD到指定的commit id，即当你回退版本的时候，Git仅仅是在改变HEAD指向。</p></li><li><p>想从3回滚到1，可以使用<code>git log</code>来查看提交日志，获取commit id；</p></li><li><p>如果commit已经push到远程仓库，那么origin/HEAD是不受影响的(<code>提交的修改仍保留在远程仓库</code>)，还是指向最新的commit id，此时sourceTree会提示有提交未拉取。</p><p>如果在这个本地仓库的版本上做修改，提交的时候会失败：<code>Updates were rejected because the tip of your current branch is behind its remote counterpart</code>，即告诉你需要先pull再push。</p></li></ul><h5 id="撤销之后想恢复"><a href="#撤销之后想恢复" class="headerlink" title="撤销之后想恢复"></a>撤销之后想恢复</h5><p>假如我们刚刚使用了reset –hard从commit3回滚到了1（并清空了工作区），想再恢复到3：</p><blockquote><p>前提是被丢弃的分支或commit信息还没有被git gc清除，一般情况下，gc对那些无用的object会保留很长时间后才清除的。</p></blockquote><p>第一步：通过git log -g命令来找到需要恢复的信息对应的commitid。可以通过提交的时间和日期来辨别，找到执行reset –hard之前的那个commit对应的commitid。（使用 git reflog 从命令日志中找到commit对应的commitid也是可以的）。</p><p>第二步：</p><ol><li>仍然可以使用git reset：<code>git reset &lt;commitid&gt;</code></li><li>使用<code>git branch &lt;branchname&gt; &lt;commitid&gt;</code>，会新建分支，并将到commitid为止的代码、各种提交记录等信息都恢复到了新分支上。</li></ol><h4 id="6-git-revert-本地仓库的撤销"><a href="#6-git-revert-本地仓库的撤销" class="headerlink" title="6. git revert 本地仓库的撤销"></a>6. git revert 本地仓库的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>回滚指定的提交，并产生一条新的commit。</p><p>在指定commit id的时候，除了通过<code>git log</code>、<code>git reflog</code>来查看，还可以指定通过HEAD(大写)来指定，<code>HEAD</code>表示当前分支当前版本， 上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><h4 id="7-git-status"><a href="#7-git-status" class="headerlink" title="7. git status"></a>7. git status</h4><p>查看仓库当前的状态：</p><ul><li>changes to be committed: 将要被提交的修改包括以下</li><li>no changes added to commit：没有被暂存修改要提交</li><li>changes not staged for commit：以下修改没有被暂存</li><li>no thing to commit, working tree clean：没有需要提交的修改，而且工作目录是干净的</li></ul><h4 id="8-git-log"><a href="#8-git-log" class="headerlink" title="8. git log"></a>8. git log</h4><p>显示从最近到最远的提交日志。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线。</p><ul><li>–graph：显示 ASCII 图形表示的分支合并历史</li><li>–decorate 标记会让git log显示每个commit的引用(如:分支、tag等) </li><li>–simplify-by-decoration 只显示被branch或tag引用的commit(如果去掉该参数，分支图与GUI显示的基本一致了)</li><li>–all 表示显示所有的branch，这里也可以选择，比如我只想显示分支ABC的关系，则将–all替换为branchA branchB branchC</li><li>–abbrev-commit：仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</li><li>–pretty：使用其他格式显示历史提交信息。可用的选项包括 oneline(简写一行)，short，full，fuller 和 format（后跟指定格式）</li><li>-<code>&lt;num&gt;</code>：显示几条</li><li><a href="https://www.progit.cn/#_viewing_history">等等</a></li></ul><p>常用的git log命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --decorate --oneline --simplify-by-decoration --all</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> [branch_name] <span class="comment"># 打印指定分支的提交。如git log dev/3.27.0 --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定作者指定时间的记录</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&#x27;xxx&#x27;</span> <span class="comment">#指定人</span></span><br><span class="line">git <span class="built_in">log</span> --before=<span class="string">&#x27;2019-4-23&#x27;</span> --after=<span class="string">&#x27;2019-3-31&#x27;</span> <span class="comment">#指定时间段</span></span><br><span class="line">git <span class="built_in">log</span> --name-only <span class="comment"># 只列出提交文件的名称</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&#x27;zhangsan&#x27;</span> --before=<span class="string">&#x27;2019-4-23&#x27;</span> --after=<span class="string">&#x27;2019-3-31&#x27;</span> --name-only </span><br></pre></td></tr></table></figure><p>感觉再怎么着也没GUI清晰…</p><p>举例：一个统计代码仓库提交、去重的小脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出commit、然后手动去重(避免某些人不规范使用git，提msg一样的commit)即可</span></span><br><span class="line">array=(<span class="string">&quot;name1&quot;</span> <span class="string">&quot;name2&quot;</span> <span class="string">&quot;name3&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$element</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="variable">$element</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --since=<span class="string">&quot;2020-03-01&quot;</span> --until=<span class="string">&quot;2020-08-31&quot;</span> --no-merges &gt;~/xxxx.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计行数的命令</span></span><br><span class="line"><span class="comment"># 统计某个人、时间范围内、增删代码行数</span></span><br><span class="line">git <span class="built_in">log</span> --author=XX --since=<span class="string">&quot;2021-03-01&quot;</span> --until=<span class="string">&quot;2021-12-31&quot;</span> --no-merges --pretty=tformat: --numstat | awk <span class="string">&#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added line s: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="9-git-reflog"><a href="#9-git-reflog" class="headerlink" title="9. git reflog"></a>9. git reflog</h4><p>显示命令历史，记录每一次命令</p><h4 id="10-git-push"><a href="#10-git-push" class="headerlink" title="10. git push"></a>10. git push</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [-u | --set-upstream] [&lt;远程仓库名&gt;] [&lt;本地分支名&gt;]  [&lt;:远程分支名&gt;] </span><br></pre></td></tr></table></figure><p>将当前分支的修改推送到远程分支，如果没有该远程分支则创建；</p><p>远程分支名可以写为<code>refs/heads/xx</code>或直接写为<code>xx</code>，好像没区别。</p><ul><li>如果只省略<code>&lt;:远程分支&gt;</code>：将指定的本地分支上的修改推送到同名的远程主机分支上；</li><li>如果只省略<code>&lt;本地分支名&gt;</code>：表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 <code>git push origin --delete master</code>。注意：不会影响本地分支；</li><li>如果当前分支是某个远程仓库中某个分支的跟踪分支，且两者同名，git push后省略远程仓库名、本地分支名、远程分支名等一切参数；</li><li>不带任何参数的git push，默认只推送当前分支，这叫做simple方式，还有一种matching方式，会推送所有有对应的远程分支的本地分支， Git 2.0之前默认使用matching，现在改为simple方式。如果想更改设置，可以使用git config命令。<code>git config --global push.default matching</code> OR <code>git config --global push.default simple</code>；可以使用<code>git config -l </code>查看配置</li><li>Tag对象与Commit对象十分相似，所以上面一些用法，在推送、删除tag对象时同样适用，比如git push origin :tagName 删除远程tag。</li></ul><h4 id="11-冲突处理"><a href="#11-冲突处理" class="headerlink" title="11. 冲突处理"></a>11. 冲突处理</h4><p><strong>执行git push之前，养成git pull的好习惯</strong>，如果有冲突，先处理冲突。</p><p>如果远程分支有别人的提交，而本地没有拉取，git push的时候，会失败</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27; hint: Updates were rejected because the remote contains work that you do not have locally.</span><br></pre></td></tr></table></figure><p>此时，应先拉取，再push，push之后发现，提交分支图上，出现了分叉，这是因为你的commit及远程他人的提交的父提交对象都是同一个commit对象，所以图谱上当然有分叉。且额外创建了一个新的commit：<code> Merge branch ‘&lt;branch&gt;’ of github.com...</code>，如果不想要这种情况可以使用<code>git rebase</code>。</p><h4 id="12-git-rebase"><a href="#12-git-rebase" class="headerlink" title="12. git rebase"></a>12. git rebase</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;branch&gt;  <span class="comment"># 操作当前分支变基</span></span><br></pre></td></tr></table></figure><p>功能：</p><ul><li>将当前分支(分叉)上的一系列提交的基(父提交)改为指定分支的最新提交</li><li>视觉效果：消除了分支、push的时候远程有提交未拉取造成的分叉</li><li>注意：只能变基本地的分支，如果commit已经推到了远程，就不要再在本地操作了，会弄混乱：此时操作之后根据rebase的工作原理，相当于本地分支新增了数个commit，然后远程仓库中的几个老commit因为被本地分支上删除就会被认成是未拉取的commit。可以先删除远程分支，再变基，再推送。</li></ul><img src="/images/git/rebase.png" alt="rebase" style="zoom:80%;" /><p>本质是：</p><ol><li>把当前分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase“目录中)</li><li>然后把当前分支的根commit更新为指定分支的最新commit</li><li>最后把保存的这些补丁重新应用到当前分支上</li><li>更新之后，老的commit会丢弃，而&lt;当前分支&gt;引用指向新创建的最新commit</li></ol><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h4 id="13-git-pull"><a href="#13-git-pull" class="headerlink" title="13. git pull"></a>13. git pull</h4><p>取回远程主机某个分支的更新，再与本地的指定分支合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [远程仓库名] [远程分支名][:&lt;本地分支名&gt;] <span class="comment"># git pull origin develop:develop (:前后无空格)</span></span><br></pre></td></tr></table></figure><ul><li>[:&lt;本地分支名&gt;] 可以省略，表示拉取并与当前分支合并；</li><li>如果当前分支是跟踪分支，那么可以直接<code>git pull</code>；</li><li>实质上，这等同于先做<code>git fetch</code>（从远程获取最新版本(即对象和引用)到本地，不会自动合并），再执行<code>git merge</code>；</li></ul><p>避免与本地的改动冲突：</p><ul><li>如果本地仓库没有commit：先stash，再pull，再应用stash；</li><li>如果本地仓库中有commit：加<code>--rebase</code>参数：与git rebase功能类似，表示把你的本地当前分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到 <code>.git/rebase</code> 目录中)，然后把本地当前分支更新为最新的”origin”分支，最后把保存的这些补丁应用到本地当前分支上。 </li></ul><h3 id="7-2-分支-平行宇宙"><a href="#7-2-分支-平行宇宙" class="headerlink" title="7.2 分支(平行宇宙)"></a>7.2 分支(平行宇宙)</h3><p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 </p><p>但Git的分支是与众不同的，无论创建、切换和删除分支都很快。</p><p>前面已经提到，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支，默认有一条分支叫主分支，即master分支。</p><h4 id="1-git-branch-创建-删除-查看分支"><a href="#1-git-branch-创建-删除-查看分支" class="headerlink" title="1. git branch 创建/删除/查看分支"></a>1. git branch 创建/删除/查看分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch &lt;branchname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地分支。如果一个分支还没被合并，会删除失败， 提示：如果删除，将丢失掉修改，可以使用大写的-D参数强行删除</span></span><br><span class="line">git branch -d &lt;branch&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push &lt;remote&gt; &lt;:remote-branch&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 分支重命名(如果已经推送远程，那么需要删除远程，重新推送)</span></span><br><span class="line">git branch -m oldName newName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有分支，当前分支前面会标一个*号</span></span><br><span class="line">git branch</span><br></pre></td></tr></table></figure><h4 id="2-git-checkout-切换"><a href="#2-git-checkout-切换" class="headerlink" title="2. git checkout 切换"></a>2. git checkout 切换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch&gt;    <span class="comment"># 切换到分支</span></span><br><span class="line">git checkout -b &lt;branch&gt; <span class="comment"># 创建并切换分支</span></span><br></pre></td></tr></table></figure><p>前面讲过，撤销修改是 <code>git checkout -- &lt;file&gt;</code>，为了避免混淆，最新版本的Git提供了新的git switch命令来切换分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;branch&gt;    <span class="comment"># 切换</span></span><br><span class="line">git switch -c &lt;branch&gt; <span class="comment"># 创建并切换</span></span><br></pre></td></tr></table></figure><h4 id="3-跟踪分支"><a href="#3-跟踪分支" class="headerlink" title="3. 跟踪分支"></a>3. 跟踪分支</h4><p>跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入git pull、git push，Git 能自动地识别去<code>哪个服务器(仓库名指定的)</code>上的<code>哪个分支</code>pull、push。</p><h5 id="1-跟踪分支的设置"><a href="#1-跟踪分支的设置" class="headerlink" title="1) 跟踪分支的设置"></a>1) 跟踪分支的设置</h5><ul><li><p>从一个远程跟踪分支检出本地分支时，选择<strong>本地分支是否跟踪远程分支</strong>；</p></li><li><p>当克隆一个仓库时，它通常会自动地创建一个跟踪origin/master的master分支；</p></li><li><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用-u或–set-upstream-to选项运行git branch来显式地设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/mybranch1 mybranch1</span><br></pre></td></tr></table></figure><ul><li>后者可省略，表示当前本地分支</li><li>一定要加origin，否则表示本地分支，而且还能跟踪成功，表示当前本地分支跟踪了另一个本地分支</li></ul></li><li><p>git push的时候设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u/--set-upstream origin localBranch:remoteBranch  <span class="comment"># 后者可省略，表示远程同名分支</span></span><br></pre></td></tr></table></figure><p>表示把localBranch分支上的修改提交到remoteBranch上，并建立跟踪关联。相比之下这种方式比上面那种使用的更普遍，因为<strong>上面那个首先需要有那个远程分支才可以用</strong>。</p></li><li><p>如果想要查看设置的所有跟踪分支，可以使用<code>git branch -vv</code>： 会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p></li></ul><h5 id="2-如果未设置跟踪分支"><a href="#2-如果未设置跟踪分支" class="headerlink" title="2) 如果未设置跟踪分支"></a>2) 如果未设置跟踪分支</h5><p>无论是否存在同名的远程分支，git push、git pull时都要加上<code>&lt;远程主机名&gt; &lt;本地分支名&gt;</code></p><p>不然前者报错： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: The current branch &lt;localBranch&gt; has no upstream branch.</span><br><span class="line">To push the current branch and <span class="built_in">set</span> the remote as upstream, use `git push --set-upstream origin &lt;localBranch&gt;`</span><br></pre></td></tr></table></figure><p>后者报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details. </span><br><span class="line">`git pull &lt;remote&gt; &lt;branch&gt;`</span><br><span class="line">If you wish to set tracking information for this branch you can do so with: `git branch --set-upstream-to=origin/&lt;remoteBranch&gt; &lt;localBranch&gt;`</span><br></pre></td></tr></table></figure><h5 id="3-如果设置了跟踪分支"><a href="#3-如果设置了跟踪分支" class="headerlink" title="3) 如果设置了跟踪分支"></a>3) 如果设置了跟踪分支</h5><p>设置成功后，会提示：Branch ‘testBranch’ set up to track remote branch ‘testBranch’ from ‘origin’.</p><p>本地分支与跟踪的远程分支是否同名：</p><ul><li><p>是：可以直接使用git push、git pull，省略之后的参数</p></li><li><p>否：依然可以使用git pull。不能直接使用git push，省略之后报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: The upstream branch of your current branch does not match the name of your current branch.  </span><br><span class="line">To push to the upstream branch on the remote, use `git push origin HEAD:remoteBranch`</span><br><span class="line">To push to the branch of the same name on the remote, use `git push origin HEAD`</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-git-merge-合并"><a href="#4-git-merge-合并" class="headerlink" title="4. git merge 合并"></a>4. git merge 合并</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;  <span class="comment"># 合并指定分支到当前分支</span></span><br></pre></td></tr></table></figure><p>合并分支时，如果可能，Git会用<code>Fast forward</code>模式：</p><ul><li>当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”</li><li>举例：比如从master上创建分支A，在A上有了数个commit，master上没有提交，此时将A合并到master，实质是将master直接指向A的最新commit（将master引用指向的SHA-1值改为A最新的commit对象的SHA-1值）。</li><li>普通模式的合并有分叉，可以看出曾经做过合并，而fast forward合并看不出来曾经做过合并。</li></ul><p><strong>如果不是fast-forward模式，Git就会在merge时生成一个新的commit。</strong></p><p>可以强制禁用Fast forward模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &lt;“merge”&gt; &lt;branch&gt;   <span class="comment"># 要加commit message，因为会生成一个新commit对象</span></span><br></pre></td></tr></table></figure><p>如果合并发生冲突(两个分支都对一个文件进行修改)，需要解决冲突后，再手动commit。</p><ul><li>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交</li></ul><h4 id="5-git-log-查看"><a href="#5-git-log-查看" class="headerlink" title="5. git log 查看"></a>5. git log 查看</h4><p>显示分支合并图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h4 id="6-git-cherry-pick"><a href="#6-git-cherry-pick" class="headerlink" title="6. git cherry-pick"></a>6. git cherry-pick</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得在另一个分支中单个提交中引入的变更，然后尝试将作为一个新的提交引入到你当前分支上。</span></span><br><span class="line">git cherry-pick &lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转移多个提交</span></span><br><span class="line">git cherry-pick &lt;HashA&gt; &lt;HashB&gt; <span class="comment"># 将 A 和 B 两个提交应用到当前分支</span></span><br><span class="line">git cherry-pick A..B  <span class="comment"># 转移从 A 到 B 的所有提交</span></span><br><span class="line"><span class="comment"># 提交 A 必须早于提交 B，否则命令将失败，但不会报错。</span></span><br><span class="line"><span class="comment"># 提交 A 将不会包含在 Cherry pick 中，即(A, B]</span></span><br><span class="line">git cherry-pick A^..B <span class="comment"># 包含A，即[A, B]</span></span><br></pre></td></tr></table></figure><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p><ul><li><p>–continue </p><p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。 </p><p><code>git cherry-pick --continue</code></p></li><li><p>–abort </p><p>发生代码冲突后，放弃合并，回到操作前的样子。</p></li><li><p>–quit </p><p>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</p></li></ul><h4 id="7-分支管理策略"><a href="#7-分支管理策略" class="headerlink" title="7. 分支管理策略"></a>7. 分支管理策略</h4><ul><li>master：master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li><li>dev：dev分支是不稳定的， 每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。<ul><li>到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</li></ul></li></ul><img src="/images/git/Snip20200423_10.png" alt="Snip20200423_10" style="zoom:90%;" /><ul><li>bug：软件开发中，bug就像家常便饭一样，有了bug就需要修复。由于Git分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。<ul><li>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支。</li></ul></li><li>feature：软件开发中，总有无穷无尽的新的功能要不断添加进来。一般是在dev分支上新建feature分支， feature分支和bug分支是类似的，合并，然后删除。</li></ul><p>哪些分支需要推送：</p><ul><li>master分支是主分支，因此要时刻与远程同步； </li><li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； </li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； </li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 </li><li>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</li></ul><p>美团的命名示意图：</p><img src="/images/git/Snip20200423_11.png" alt="Snip20200423_11" style="zoom:90%;" /><h3 id="7-3-stash"><a href="#7-3-stash" class="headerlink" title="7.3 stash"></a>7.3 stash</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment"># 将更改储藏在脏工作目录中，clean目前工作区</span></span><br><span class="line"></span><br><span class="line">git stash list <span class="comment"># 查看所有stash</span></span><br><span class="line"><span class="comment"># stash@&#123;0&#125;: WIP on master: 049d078 added the index file </span></span><br><span class="line"><span class="comment"># stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span></span><br><span class="line"></span><br><span class="line">git stash apply [&lt;stash&gt;]  <span class="comment"># 恢复，但是恢复后，stash内容并不删除</span></span><br><span class="line"><span class="comment"># 可以通过名字指定它，像这样：git stash apply stash@&#123;2&#125;。</span></span><br><span class="line"><span class="comment"># 如果不指明，Git 默认使用最近的储藏并尝试应用它</span></span><br><span class="line"></span><br><span class="line">git stash drop [&lt;stash&gt;]   <span class="comment"># 删除</span></span><br><span class="line"></span><br><span class="line">git stash pop [&lt;stash&gt;]    <span class="comment"># 恢复的同时把stash内容也删掉</span></span><br></pre></td></tr></table></figure><h3 id="7-4-tag"><a href="#7-4-tag" class="headerlink" title="7.4 tag"></a>7.4 tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;name&gt; [commit]    <span class="comment"># 打一个轻量标签，如果省略&lt;commit&gt;，则表示最新提交</span></span><br><span class="line"></span><br><span class="line">git tag -a &lt;name&gt; -m &lt;<span class="string">&quot;message&quot;</span>&gt; [commit]  <span class="comment"># 打附注标签(带有说明)，用-a指定标签名，-m指定说明文字</span></span><br><span class="line"></span><br><span class="line">git tag <span class="comment"># 查看所有标签， 标签不是按时间顺序列出，而是按字母排序</span></span><br><span class="line"></span><br><span class="line">git show &lt;tagname&gt; <span class="comment"># 查看标签信息</span></span><br><span class="line"></span><br><span class="line">git push origin &lt;tagname&gt; <span class="comment"># 推送标签到远程</span></span><br><span class="line">git push origin --tags    <span class="comment"># 一次性推送全部尚未推送到远程的本地标签</span></span><br><span class="line"></span><br><span class="line">git tag -d &lt;name&gt;  <span class="comment"># 删除标签</span></span><br><span class="line">git push &lt;remote&gt; &lt;:tagname | refs/tags/&lt;tagname&gt;&gt; <span class="comment"># 删除远程标签</span></span><br></pre></td></tr></table></figure><p>如果tag与分支同名，在/refs/heads/、/refs/tags/下都能找到文件名为这个名字的文件，此时操作时如果直接写标签名，可能会报错：<code>...match more than one</code>。</p><h3 id="7-5-补丁的创建与应用"><a href="#7-5-补丁的创建与应用" class="headerlink" title="7.5 补丁的创建与应用"></a>7.5 补丁的创建与应用</h3><p>Git 提供了两种补丁方案</p><ul><li>用 <code>git diff</code> 生成的UNIX标准补丁.diff文件： .diff文件只是记录文件改变的内容，不带有commit记录信息，多个commit可以合并成一个diff文件。 </li><li>用 <code>git format-patch</code> 生成的Git专用.patch 文件:  .patch文件带有记录文件改变的内容，也带有commit记录信息。每个commit对应一个patch文件。</li></ul><p><strong>在Git下，我们可以使用.diff文件也可以使用.patch 文件来打补丁，主要应用场景有：CodeReview、代码迁移等。</strong></p><h4 id="7-5-1-创建补丁git-diff"><a href="#7-5-1-创建补丁git-diff" class="headerlink" title="7.5.1 创建补丁git diff"></a>7.5.1 创建补丁git diff</h4><p>顾名思义就是查看<code>已跟踪tracked文件</code>的difference：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff [--cached] [&lt;commit&gt; [(^.. | ..)&lt;commit&gt;]] [查看文件名] [&gt; diff补丁文件名]</span><br></pre></td></tr></table></figure><ul><li><p>不加参数即默认比较工作区与暂存区；</p></li><li><p>如果加了一个commit id，表示比较目前代码与指定commit的差异 = 当前工作区+暂存区+指定commit后的commit修改；</p></li><li><p>如果加了两个commit id，表示比较后者与前者两次提交之间的差异；</p></li><li><p>如果加了–cached（后面即使没有commit id，默认相当于有个HEAD），意义是在上条的基础上忽略工作区的改动，即差异 = 当前暂存区 + 指定commit后的commit修改；</p></li><li><p>在上面的基础上，后面如果加了 <code>&gt; 文件名</code>，表示将上面比较出的差异，导出一个补丁，可以拷贝到另一机器或者另一个马甲项目中应用。</p></li></ul><h4 id="7-5-2-创建补丁git-patch"><a href="#7-5-2-创建补丁git-patch" class="headerlink" title="7.5.2 创建补丁git patch"></a>7.5.2 创建补丁git patch</h4><p>会将指定commit id 后的每一个commit分别单独生成patch文件。</p><p>patch文件按照commit的先后顺序从1开始编号。</p><p>patch文件会生成到当前目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git format-patch [&lt;commit&gt; [(^.. | ..)&lt;commit&gt;]] [-n] [&gt; patch补丁文件名]</span><br></pre></td></tr></table></figure><ul><li>commitId 如果省略，表示HEAD指针指向的commit</li><li>-n 表示为HEAD后的n个 commit 生成 patch</li></ul><h4 id="7-5-3-补丁应用git-apply"><a href="#7-5-3-补丁应用git-apply" class="headerlink" title="7.5.3 补丁应用git apply"></a>7.5.3 补丁应用git apply</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查patch/diff是否能正常打入。如果没有任何输出，那么表示可以顺利接受这个补丁</span></span><br><span class="line">git apply --check patch/diff文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用补丁</span></span><br><span class="line">git apply patch/diff文件名</span><br><span class="line"><span class="comment"># apply patch 成功后会自动commit，并且保留原来commit的comments，submittor等信息。但是commit id会新生成</span></span><br><span class="line"><span class="comment"># apply diff 成功后，会将修改放入工作区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将能打的补丁先打上，有冲突的会生成.rej文件，此时可以找到这些文件进行手动打补丁</span></span><br><span class="line">git apply --reject patch/diff文件名</span><br></pre></td></tr></table></figure><p>此外，patch补丁文件，还可以使用git am命令来应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git am &lt;path/to/xxx.patch&gt; </span><br></pre></td></tr></table></figure><p>补丁冲突解决：</p><p>在打补丁过程中有时候会出现冲突的情况，有冲突时会打入失败。此时需要解决冲突： </p><ol><li>首先使用 以下命令行，自动合入 patch 中不冲突的代码改动，同时保留冲突的部分： git apply –reject xxxx.patch . 此时会在终端中显示出冲突的大致代码， 同时会生成后缀为 .rej 的文件，保存没有合并进去的部分的内容，可以参考这个进行冲突解决。</li><li>解决完冲突后删除后缀为 .rej 的文件，并执行 <code>git add .</code> 添加改动到暂存区. </li><li>接着执行 <code>git am --resolved</code> 或者 <code>git am --continue</code></li></ol><p>说明：在打入patch冲突时，可以执行git am –skip跳过此次冲突，也可以执行git am –abort回退打入patch的动作，还原到操作前的状态。</p><h4 id="7-5-4-手动修改补丁文件"><a href="#7-5-4-手动修改补丁文件" class="headerlink" title="7.5.4 手动修改补丁文件"></a>7.5.4 手动修改补丁文件</h4><img src="/images/git/patch.png" alt="patch" style="zoom:90%;" /><p>有时候patch apply遇到问题，可以根据当前上下文，手动修改patch再进行apply。</p><p>上图就是修改前的patch。patch格式说明，其格式为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@@ -[起始行号],[修改前的行数] +[起始行号],[修改后的行数]</span><br></pre></td></tr></table></figure><p>在新增或删除一行时，记得修改 [修改后的行数]</p><h2 id="八、报错基金"><a href="#八、报错基金" class="headerlink" title="八、报错基金"></a>八、报错基金</h2><h3 id="8-1-超过100M报错"><a href="#8-1-超过100M报错" class="headerlink" title="8.1 超过100M报错"></a>8.1 超过100M报错</h3><p>超过50M警告：remote: warning: File ppt/Implementing AutoML Techniques at Salesforce Scale.pdf is 66.68 MB; this is larger than GitHub’s recommended maximum file size of 50.00 MB</p><p>超过100M报错：remote: error: GH001: Large files detected. You may want to try Git Large File Storage - <a href="https://git-lfs.github.com/">https://git-lfs.github.com</a>. 报错信息，里面提供了解决办法，就是使用 <a href="https://www.iteblog.com/redirect.php?url=aHR0cHM6Ly9naXQtbGZzLmdpdGh1Yi5jb20v&article=true">Git Large File Storage (LFS)</a>。</p><p><strong>Find 命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有超过100M的文件</span></span><br><span class="line">find ./ -<span class="built_in">type</span> f -size +102400k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索名字为xxx的文件/文件夹</span></span><br><span class="line">find ./ -iname <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜出并删除，删除过程中可能会出现override r-r--r-- xxxx(系统当前用户名)/staff for 文件名? 没有权限的意思，加sudo即可</span></span><br><span class="line">find ./ -name <span class="string">&quot;.git&quot;</span> -<span class="built_in">exec</span> rm -r <span class="string">&quot;&#123;&#125;&quot;</span> \;</span><br></pre></td></tr></table></figure><h2 id="九、参考链接"><a href="#九、参考链接" class="headerlink" title="九、参考链接"></a>九、参考链接</h2><ul><li><p><a href="https://www.progit.cn/#_pro_git">《Pro Git》</a></p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 — 廖雪峰</a></p></li></ul><p>GUI工具：</p><ul><li><p>当我们对Git的提交、分支已经非常熟悉，可以熟练使用命令操作Git后，再使用GUI工具，就可以更高效。 </p></li><li><p>Git有很多图形界面工具，这里我们推荐SourceTree，它是由Atlassian开发的免费Git图形界面工具，可以操作任何Git库。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Git&quot;&gt;&lt;a href=&quot;#一、Git&quot; class=&quot;headerlink&quot; title=&quot;一、Git&quot;&gt;&lt;/a&gt;一、Git&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;集中式版本控制系统，版本库是集中存放在中央服务器的(服务器必须联网才能连接)。所有人都是通过中央服务器来</summary>
      
    
    
    
    <category term="Git" scheme="https://tenloy.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Objc Runtime总结</title>
    <link href="https://tenloy.github.io/2021/10/11/runtime-data-structure.html"/>
    <id>https://tenloy.github.io/2021/10/11/runtime-data-structure.html</id>
    <published>2021-10-11T14:26:09.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>内容骨架来自戴铭老师文章<a href="https://ming1016.github.io/2015/04/01/objc-runtime/">Objc Runtime 总结</a>，因为发布有些久远，一些内容已经过时，修正了一下，并填充了一些自己的知识总结。</p><p>更新：以下源码来自objc4-756.2，2019年下半年随着macOS 10.15发布了objc4-779.1，其后陆续对cache_t、class_rw_t等结构进行了一些调整。</p></blockquote><h1 id="一、Runtime概述"><a href="#一、Runtime概述" class="headerlink" title="一、Runtime概述"></a>一、Runtime概述</h1><h2 id="1-1-Runtime做了什么？"><a href="#1-1-Runtime做了什么？" class="headerlink" title="1.1 Runtime做了什么？"></a>1.1 Runtime做了什么？</h2><p>Objective-C跟C、C++等语言有着很大的不同，是一门动态性比较强的编程语言。允许很多操作推迟到程序运行时再进行，其可以在运行过程中修改之前编译好的行为，比如程序运行时创建，检查，修改类、对象和它们的方法。</p><blockquote><p>维基：<strong>动态编程语言</strong>是高级编程语言的一个类别，是一类在运行时可以改变其结构的语言，或者说可以在运行时执行静态编程语言在编译期间执行的许多常见编程行为。例如：程序的扩展、添加新代码，已有的函数可以被删除或修改、扩展对象、定义或修改类型系统等。</p></blockquote><p>而Objective-C的动态性是由Runtime来支撑和实现的。</p><blockquote><p>很久之前孙源老师的一篇文章中说道：objc = C + objc编译器 + runtime</p></blockquote><p>Runtime做了什么：</p><ul><li>建立了支持objc语言的数据结构。使得C具有了面向对象能力</li><li>建立了消息机制</li></ul><img src="/images/runtime/04.jpg" alt="04" style="zoom:60%;" /><h2 id="1-2-学习链接"><a href="#1-2-学习链接" class="headerlink" title="1.2 学习链接"></a>1.2 学习链接</h2><ul><li>Runtime是C和汇编编写的，是开源的，<a href="https://opensource.apple.com/source/objc4/">下载地址</a>；</li><li>GNU也有一个开源的runtime版本，他们都努力的保持一致。</li><li>苹果官方的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide</a>。</li><li>Runtime系统是由一系列的函数和数据结构组成的公共接口动态共享库，在/usr/include/objc目录下可以看到头文件，可以用其中一些函数通过C语言实现objectivec中一样的功能。可以在苹果官方文档<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc">Objective-C Runtime Reference</a>中查看 Runtime 库函数的详细解释。<ul><li>当我们导入了objc/Runtime.h和objc/message.h两个头文件之后，如果发现没有代码提示，函数里面的参数和描述也没有了。可以在 <code>Build Setting</code> 中设置 <code>Enable Strict Checking of objc_msgSend Calls</code> 为 NO。</li></ul></li></ul><p>写在前面：</p><ul><li>后缀 <code>_t</code> 意味着 type/typedef(类型) ，是一种命名规范，类似于全局变量加前缀 <code>g_</code>。</li><li><code>_np</code>表示不可移植(np意指non portable, 不可移植)。</li></ul><h1 id="二、Object、Class与MetaClass"><a href="#二、Object、Class与MetaClass" class="headerlink" title="二、Object、Class与MetaClass"></a>二、Object、Class与MetaClass</h1><h2 id="关系简图"><a href="#关系简图" class="headerlink" title="关系简图"></a>关系简图</h2><img src="/images/compilelink/36.png" alt="36" style="zoom:88%;" /><p>class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容。</p><p>class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容。</p><p>objc_class 1.0和2.0的差别示意图：</p><img src="/images/runtime/08.png" alt="08" style="zoom:67%;" /><h2 id="2-1-objc-object与id"><a href="#2-1-objc-object与id" class="headerlink" title="2.1 objc_object与id"></a>2.1 objc_object与id</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 类的实例结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line">    <span class="comment">//方法略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class. id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure><h3 id="对象是什么？"><a href="#对象是什么？" class="headerlink" title="对象是什么？"></a>对象是什么？</h3><p><strong>看到 objc_object 的结构后，此处有个结论：任何结构体，只要以一个指向 Class 结构体的指针开始，都可以视为一个 objc_object (对象)。</strong></p><blockquote><ul><li><strong>32位中，只要一个数据结构的前4个字节，是个指针(Class isa)，就是个对象。</strong></li><li><strong>64位中，只要一个数据结构的前8个字节，是个isa_t类型的变量(isa_t isa)，就是个对象。</strong></li></ul></blockquote><p><strong>反之，Objc中的对象是一个指向ClassObject地址的变量，即 id obj = &amp;ClassObject ， 而对象的实例变量 void *ivar = &amp;obj + offset(N)</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">- (<span class="keyword">void</span>)speak;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line">- (<span class="keyword">void</span>)speak &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;my name&#x27;s %@&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj speak];  </span><br><span class="line">    <span class="comment">// obj的前8个字节是指向Class Sark的数据，所以其能视为Sark类对象的。</span></span><br><span class="line">    <span class="comment">// 但是在-speak中，取obj的name，本质是取obj后偏移的第9-16字节的数据，此处会取出-viewDidLoad函数栈中的数据，错乱掉。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span> </span><br></pre></td></tr></table></figure><h2 id="2-2-objc-class"><a href="#2-2-objc-class" class="headerlink" title="2.2 objc_class"></a>2.2 objc_class</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Objc的类的本身也是一个Object，类的类型我们称为元类Meta Class，记录类方法、属性。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// 继承了isa_t isa;</span></span><br><span class="line">    Class superclass;          <span class="comment">// 指向父类的指针，用于组织类的继承链；</span></span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// 缓存调用过的method。对象接到一个消息会根据isa指针查找消息对象，这时会在methodLists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。(以前缓存指针pointer和vtable)</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    </span><br><span class="line">       <span class="comment">// class_rw_t * plus custom rr/alloc flags. </span></span><br><span class="line">       <span class="comment">// 表示class_data_bits_t其实是class_rw_t* 加上自定义的rr/alloc标志，rr/alloc标志是指含有的retain/release/autorelease/retainCount/alloc等</span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">// class_data_bits_t结构体主要用于记录，保存类的数据的`class_rw_t`结构体的内存地址。通过`date()`方法访问`bits`的有效位域指向的内存空间，返回`class_rw_t`结构体；`setData(class_rw_t *newData)`用于设置`bits`的值；</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">class_rw_t</span> *newData)</span> </span>&#123;</span><br><span class="line">        bits.<span class="built_in">setData</span>(newData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-成员-isa-t-isa"><a href="#2-2-1-成员-isa-t-isa" class="headerlink" title="2.2.1 成员: isa_t isa"></a>2.2.1 成员: isa_t isa</h3><p>在arm64架构之前，isa就是一个普通的指针(Class _Nonnull isa)，存储着Class、Meta-Class对象的内存地址 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>从arm64架构开始：</p><ul><li><p>明确的将objc_class定义为一个Object，继承自struct objc_object。</p></li><li><p>对isa进行了优化，变成了一个共用体（union）结构，使用位域来存储了更多的信息。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span> isa;   <span class="comment">// isa(is a)指向它的类。当向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// 继承了isa_t isa;    // class的isa指针指向class的类(术语称为Meta Class)，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL  取类指针值的掩码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL  取MAGIC值的掩码</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="keyword">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;  <span class="comment">// 代表是否开启isa指针优化。0 代表普通的指针，存储着Class、Meta-Class对象的内存地址； 1 代表优化过，使用位域存储更多的信息</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;  <span class="comment">// 是否设置或曾经过关联对象(associatedObject)，如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 是否有C++ 或者 Objc的析构函数（.cxx_destruct），如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// 类指针。存储着Class、Meta-Class对象的内存地址信息。源码中isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; 将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;  <span class="comment">// 用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;  <span class="comment">// 对象被指向或者曾经指向一个 ARC 的弱变量。如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;  <span class="comment">// 对象是否正在释放</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 引用计数器是否过大无法存储在isa(extra_rc字段)中。如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>  <span class="comment">// 里面存储的值是引用计数器减1（比如对象引用计数器是1，这里就是0）</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;                                     </span><br></pre></td></tr></table></figure><h4 id="关于Tagged-Pointer"><a href="#关于Tagged-Pointer" class="headerlink" title="关于Tagged Pointer"></a>关于Tagged Pointer</h4><p>在2013年9月，苹果推出了<a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/IPhone_5S">iPhone5s</a>，与此同时，iPhone5s配备了首个采用64位架构的<a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Apple_A7">A7双核处理器</a>，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。</p><p>在WWDC2013的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer用于优化NSNumber、NSDate、NSString等小对象的存储，其存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。</p><p>假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。</p><p>苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。如下图所示：</p><img src="/images/runtime/05.png" alt="05" style="zoom:75%;" /><h3 id="2-2-2-成员-cache-t-cache"><a href="#2-2-2-成员-cache-t-cache" class="headerlink" title="2.2.2 成员: cache_t cache"></a>2.2.2 成员: cache_t cache</h3><blockquote><p>cache: 用于缓存调用过的method</p></blockquote><p>Cache的作用主要是为了优化方法调用的性能。</p><p>假如，当对象receiver调用方法message时：</p><ol><li>首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法；</li><li>如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。</li></ol><p>这样查找方式效率就太低了，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span>  <span class="comment">// 是一个散列表，用来存储Method的链表</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;               <span class="comment">// 分配用来缓存bucket的总数。散列表的长度 - 1</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;           <span class="comment">// 目前实际占用的缓存bucket的个数。因为缓存是以散列表的形式存在的，所以会有空槽，而occupied表示当前被占用的数目</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;  <span class="comment">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="keyword">uintptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">cache_key_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uintptr_t</span> _imp;  <span class="comment">// 函数指针，指向了一个方法的具体实现</span></span><br><span class="line">  SEL _sel;        <span class="comment">// SEL作为key</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 散列函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">mask_t</span> <span class="title">cache_hash</span><span class="params">(SEL sel, <span class="keyword">mask_t</span> mask)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mask_t</span>)(<span class="keyword">uintptr_t</span>)sel &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><ul><li><p><strong>不管是在本类、父类、基类中找到的，只要不在本类的cache中，就填充缓存。</strong>详见4.3节</p></li><li><p>关于缓存的扩容以及限制：</p><ul><li>初始大小为4；</li><li>当缓存使用达到3/4后，进行缓存扩容，扩容系数为2；</li><li>扩容时，会清空缓存，否则hash值就不对了；</li><li>旧版本中，类的方法缓存大小是有没有限制的，在新的runtime中增加了限制；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initial cache bucket count. INIT_CACHE_SIZE must be a power of two. */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2),</span><br><span class="line">    MAX_CACHE_SIZE_LOG2  = <span class="number">16</span>,</span><br><span class="line">    MAX_CACHE_SIZE       = (<span class="number">1</span> &lt;&lt; MAX_CACHE_SIZE_LOG2),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">        capacity = MAX_CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reallocate</span>(oldCapacity, capacity, <span class="literal">true</span>);   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么类的方法列表不直接做成散列表呢，做成list，还要单独缓存，多费事？这个问题么，我觉得有以下三个原因：</p><ul><li>散列表是没有顺序的，Objective-C的方法列表是一个list，是有顺序的；Objective-C在查找方法的时候会顺着list依次寻找，并且category的方法在原始方法list的前面，需要先被找到，如果直接用hash存方法，方法的顺序就没法保证。</li><li>list的方法还保存了除了selector和imp之外其他很多属性</li><li>散列表是有空槽的，会浪费空间</li></ul></li></ul><h3 id="2-2-3-成员-class-data-bits-t-bits"><a href="#2-2-3-成员-class-data-bits-t-bits" class="headerlink" title="2.2.3 成员: class_data_bits_t bits"></a>2.2.3 成员: class_data_bits_t bits</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><blockquote><p><code>bits</code>：<code>class_data_bits_t</code>结构体类型，该结构体主要用于记录，保存类的数据的<code>class_rw_t</code>结构体的内存地址。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK        0xfffffffcUL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK        0x00007ffffffffff8UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;  <span class="comment">// 仅有一个成员 bits 指针。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getBit</span><span class="params">(<span class="keyword">uintptr_t</span> bit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取类的数据。获取 bits 成员的 4~47 位域(FAST_DATA_MASK)中保存的 class_rw_t 结构体地址。</span></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置类的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">class_rw_t</span> *newData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 仅在类注册、构建阶段才允许调用setData</span></span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">data</span>()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));</span><br><span class="line">        <span class="keyword">uintptr_t</span> newBits = (bits &amp; ~FAST_DATA_MASK) | (<span class="keyword">uintptr_t</span>)newData;</span><br><span class="line">        <span class="built_in">atomic_thread_fence</span>(memory_order_release);</span><br><span class="line">        bits = newBits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-class-rw-t与class-ro-t简介"><a href="#2-class-rw-t与class-ro-t简介" class="headerlink" title="2. class_rw_t与class_ro_t简介"></a>2. class_rw_t与class_ro_t简介</h4><p><code>class_rw_t</code>、<code>class_ro_t</code>结构体名中，<code>rw</code>是 read write 的缩写，<code>ro</code>是 read only 的缩写，可见<code>class_ro_t</code>的保存类的只读信息，这些信息在类完成注册后不可改变。</p><p>即分类等运行期添加的数据保存在<code>class_rw_t</code>结构体中，编译时期就能确定的部分保存在<code>ro</code>指针指向的<code>class_ro_t</code>结构体中。</p><p>以类的成员变量列表为例（成员变量列表保存在<code>class_ro_t</code>结构体中）。若应用类注册到内存后，使用类构建了若干实例，此时若能够添加成员变量，那必然需要对内存中的这些类重新分配内存，这个操作的花销是相当大的。若考虑再极端一些，为根类<code>NSObject</code>添加成员变量，则内存中基本所有 Objective-C 对象都需要重新分配内存，如此庞大的计算量在运行时是不可接受的。</p><h4 id="3-bits在编译、运行期间值的改变"><a href="#3-bits在编译、运行期间值的改变" class="headerlink" title="3. bits在编译、运行期间值的改变"></a>3. bits在编译、运行期间值的改变</h4><p>注意：<strong>在编译期，类的结构中的 class_data_bits_t的 class_rw_t</strong> *<strong>data() 取出的是一个指向 class_ro_t 的指针。</strong></p><img src="/images/runtime/06.png" alt="06" style="zoom:80%;" /><p>在运行时调用 realizeClass方法，会做以下3件事情：</p><ol><li>从 class_data_bits_t调用 data方法，将结果从 class_rw_t强制转换为 class_ro_t指针；</li><li>初始化一个 class_rw_t结构体；</li><li>设置结构体 ro的值以及 flag；</li><li>最后设置正确的 <code>data</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">auto</span> isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">rw-&gt;<span class="built_in">set_ro</span>(ro);</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">cls-&gt;<span class="built_in">setData</span>(rw);</span><br></pre></td></tr></table></figure><p>但是，在这段代码运行之后 <code>class_rw_t</code> 中的方法，属性以及协议列表均为空。这时需要 <code>realizeClass</code> 调用 <code>methodizeClass</code> 方法来<strong>将类自己实现的方法（包括分类）、属性和遵循的协议加载到 <code>methods</code>、 <code>properties</code> 和 <code>protocols</code> 列表中</strong>。</p><img src="/images/runtime/07.png" alt="06" style="zoom:80%;" /><p>更加详细的分析，请看<a href="https://link.jianshu.com/?t=https://github.com/Draveness">@Draveness</a> 的这篇文章<a href="https://draveness.me/method-struct/">深入解析 ObjC 中方法的结构</a>。</p><h3 id="2-2-4-方法-类加载过程中，状态读写"><a href="#2-2-4-方法-类加载过程中，状态读写" class="headerlink" title="2.2.4 方法: 类加载过程中，状态读写"></a>2.2.4 方法: 类加载过程中，状态读写</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_class结构体中与类的加载过程相关的方法：</span></span><br><span class="line"><span class="comment">// 查询是否正在初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_INITIALIZING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记为正在初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line">    <span class="built_in">ISA</span>()-&gt;<span class="built_in">setInfo</span>(RW_INITIALIZING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否已完成初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_INITIALIZED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitialized</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class metacls;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line"></span><br><span class="line">    cls = (Class)<span class="keyword">this</span>;</span><br><span class="line">    metacls = cls-&gt;<span class="built_in">ISA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关于alloc/dealloc/Retain/Release等特殊方法的判断及处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    metacls-&gt;<span class="built_in">changeInfo</span>(RW_INITIALIZED, RW_INITIALIZING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLoadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// any class registered for +load is definitely loadable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取load方法的IMP</span></span><br><span class="line"><span class="function">IMP <span class="title">objc_class::getLoadMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_list_t</span> *mlist;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">ISA</span>()-&gt;<span class="built_in">isMetaClass</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类的基础方法列表中查询load方法的IMP</span></span><br><span class="line">    mlist = <span class="built_in">ISA</span>()-&gt;<span class="built_in">data</span>()-&gt;ro-&gt;<span class="built_in">baseMethods</span>();</span><br><span class="line">    <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="built_in">sel_cname</span>(meth.name);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(name, <span class="string">&quot;load&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> meth.imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime是否已认识/实现类</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRealized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_REALIZED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否future class</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFuture</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_FUTURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-5-方法-类状态获取"><a href="#2-2-5-方法-类状态获取" class="headerlink" title="2.2.5 方法: 类状态获取"></a>2.2.5 方法: 类状态获取</h3><p><code>objc_class</code>结构体中类的基本状态查询的函数代码如下。注意<code>Class getMeta()</code>获取元类时：对于元类，<code>getMeta()</code>返回的结果与<code>ISA()</code>返回的结果不相同，对于非元类，两者则是相同的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isARC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;flags &amp; RO_IS_ARC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMetaClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;flags &amp; RO_META;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMetaClassMaybeUnrealized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bits.<span class="built_in">safe_ro</span>()-&gt;flags &amp; RO_META;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isMetaClass</span>()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRootClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> superclass == nil;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRootMetaclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ISA</span>() == (Class)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">mangledName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isRealized</span>()  ||  <span class="built_in">isFuture</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> ((<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)<span class="built_in">data</span>())-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">demangledName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">nameForLogging</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-6-方法-内存分配"><a href="#2-2-6-方法-内存分配" class="headerlink" title="2.2.6 方法: 内存分配"></a>2.2.6 方法: 内存分配</h3><p>根据类的信息构建对象时，需要根据类的继承链上的所有成员变量的内存布局为成员变量数据分配内存空间，分配内存空间的大小固定的，并按 WORD 对齐，调用<code>size_t class_getInstanceSize(Class cls)</code>实际是调用了<code>objc_class</code>结构体的<code>uint32_t alignedInstanceSize()</code>函数。</p><p>成员变量在实例内存空间中偏移量同样也是固定的，同样也是按 WORD 对齐。实例的第一个成员变量内存空间的在实例空间中的偏移量，实际是通过调用<code>objc_class</code>结构体的<code>uint32_t alignedInstanceStart()</code>函数获取。</p><p><code>objc_class</code>结构体中涉及内存分配的函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 类的实例的成员变量起始地址可能不按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">unalignedInstanceStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;instanceStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例的成员变量起始地址按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceStart</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的实例大小可能因为ivar的alignment值而不按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">unalignedInstanceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;instanceSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例大小按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceSize</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类的实例大小</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="keyword">size_t</span> extraBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = <span class="built_in">alignedInstanceSize</span>() + extraBytes;</span><br><span class="line">        <span class="comment">// CF requires all objects be at least 16 bytes. （TODO：不懂为啥）</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInstanceSize</span><span class="params">(<span class="keyword">uint32_t</span> newSize)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">if</span> (newSize != <span class="built_in">data</span>()-&gt;ro-&gt;instanceSize) &#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">data</span>()-&gt;flags &amp; RW_COPIED_RO);</span><br><span class="line">            *<span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span> *&gt;(&amp;<span class="built_in">data</span>()-&gt;ro-&gt;instanceSize) = newSize;</span><br><span class="line">        &#125;</span><br><span class="line">        bits.<span class="built_in">setFastInstanceSize</span>(newSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3-class-rw-t"><a href="#2-3-class-rw-t" class="headerlink" title="2.3 class_rw_t"></a>2.3 class_rw_t</h2><p>类的主要数据保存在<code>bits</code>中，<code>bits</code>以位图保存<code>class_rw_t</code>结构体，用于记录类的关键数据，如成员变量列表、方法列表、属性列表、协议列表等等，<code>class_rw_t</code>仅包含三个基本的位操作方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_INDEXED_ISA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_INDEXED_ISA 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;       <span class="comment">// 标记类的状态;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> version;     <span class="comment">// 标记类的类型，0表示类为非元类，7表示类为元类；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro; <span class="comment">// 保存类的只读数据，注册类后ro中的数据标记为只读，成员变量列表保存在ro中；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">method_array_t</span> methods;      <span class="comment">// 方法列表，其类型method_array_t  为二维数组容器；</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties; <span class="comment">// 属性列表，其类型property_array_t为二维数组容器；</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;  <span class="comment">// 协议列表，其类型protocol_array_t为二维数组容器；</span></span><br><span class="line">    </span><br><span class="line">    Class firstSubclass;    <span class="comment">// 类的首个子类，与nextSiblingClass记录所有类的继承链组织成的继承树；</span></span><br><span class="line">    Class nextSiblingClass; <span class="comment">// 类的下一个兄弟类；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *demangledName;    <span class="comment">// 类名，来自Swift的类会包含一些特别前缀，demangledName是处理后的类名；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index;      <span class="comment">// 标记类的对象的isa是否为index类型；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置set指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFlags</span><span class="params">(<span class="keyword">uint32_t</span> set)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">OSAtomicOr32Barrier</span>(set, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空clear指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearFlags</span><span class="params">(<span class="keyword">uint32_t</span> clear)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">OSAtomicXor32Barrier</span>(clear, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置set指定的位，清空clear指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeFlags</span><span class="params">(<span class="keyword">uint32_t</span> set, <span class="keyword">uint32_t</span> clear)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>((set &amp; clear) == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">uint32_t</span> oldf, newf;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldf = flags;</span><br><span class="line">            newf = (oldf | set) &amp; ~clear;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!<span class="built_in">OSAtomicCompareAndSwap32Barrier</span>(oldf, newf, (<span class="keyword">volatile</span> <span class="keyword">int32_t</span> *)&amp;flags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4-class-ro-t"><a href="#2-4-class-ro-t" class="headerlink" title="2.4 class_ro_t"></a>2.4 class_ro_t</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;         <span class="comment">// 标记类的状态。需要注意class_ro_t的flags的值和前面介绍的class_rw_t的flags的值是完全不同的；</span></span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart; <span class="comment">// 类的成员变量，在实例的内存空间中的起始偏移量；</span></span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;  <span class="comment">// 类的实例占用的内存空间大小；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;     <span class="comment">// strong成员变量内存布局。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;              <span class="comment">// 类名；</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList; <span class="comment">// 基础方法列表，在类定义时指定的方法列表；</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;<span class="comment">// 协议列表；</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;      <span class="comment">// 成员变量列表；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout; <span class="comment">// weak成员变量布局；</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;<span class="comment">// 基础属性列表，在类定义时指定的属性列表；</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">baseMethods</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">class_ro_t</span> *<span class="title">duplicate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>) + <span class="built_in"><span class="keyword">sizeof</span></span>(_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">memdup</span>(<span class="keyword">this</span>, size);</span><br><span class="line">            ro-&gt;_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>] = <span class="keyword">this</span>-&gt;_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> ro;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">memdup</span>(<span class="keyword">this</span>, size);</span><br><span class="line">            <span class="keyword">return</span> ro;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-4-1-ivarLayout与weakIvarLayout"><a href="#2-4-1-ivarLayout与weakIvarLayout" class="headerlink" title="2.4.1 ivarLayout与weakIvarLayout"></a>2.4.1 ivarLayout与weakIvarLayout</h3><h4 id="1-值的存储格式"><a href="#1-值的存储格式" class="headerlink" title="1. 值的存储格式"></a>1. 值的存储格式</h4><p>ivarLayout 和 weakIvarLayout 这两个编码值，结合起来，就可以确定<strong>自上而下</strong>，哪些 ivar 是strong、weak，确定了这两种之后，剩余的就都是基本类型和 __unsafe_unretained 的对象类型。</p><p>这两者都是 <code>const uint8_t *</code> 类型，但读取值的时候，需要注意，不是以char(1字节)为单位来读取的，而是：</p><ul><li><strong>4bit为一位，1字节为一对</strong>，即<strong>从两者首地址开始，1字节分为一对</strong>来读取</li><li>以两位 <strong>00</strong> 为结束符，就像 cstring 的 <strong>\0</strong> 一样</li></ul><p>ivarLayout 的每1位(4bit)依次表示：成员变量自上而下，多少个 <strong>非 strong</strong> 成员变量、多少个 <strong>strong</strong> 成员变量…(<strong>循环</strong>)…直到最后一个strong出现的位置(后面的就不记录了)。</p><p>weakIvarLayout 的每1位(4bit)依次表示：成员变量自上而下，多少个 <strong>非 weak</strong> 成员变量、多少个 <strong>weak</strong> 成员变量…(<strong>循环</strong>)…直到最后一个weak出现的位置(后面的就不记录了)。</p><h4 id="2-操作函数"><a href="#2-操作函数" class="headerlink" title="2. 操作函数"></a>2. 操作函数</h4><p>这两个值可以通过 runtime 提供的几个 API 来访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">uint8_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *<span class="title">class_getIvarLayout</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *<span class="title">class_getWeakIvarLayout</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setIvarLayout</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *layout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setWeakIvarLayout</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *layout)</span></span></span><br></pre></td></tr></table></figure><h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar0;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar1;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> ivar2;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar3;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar4;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar5;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar6;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar7;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar8;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> ivv;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> ivv1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> uint8_t * strongLayout = class_getIvarLayout(Foo.class);</span><br><span class="line"><span class="keyword">const</span> uint8_t * weakLayout = class_getWeakIvarLayout(Foo.class);</span><br><span class="line"></span><br><span class="line">(lldb) p strongLayout</span><br><span class="line">(<span class="keyword">const</span> uint8_t *) $<span class="number">0</span> = <span class="number">0x000000010d6c1246</span> <span class="string">&quot;\U00000011!#&quot;</span></span><br><span class="line">(lldb) p weakLayout</span><br><span class="line">(<span class="keyword">const</span> uint8_t *) $<span class="number">1</span> = <span class="number">0x000000010d6c124a</span> <span class="string">&quot;\U00000001!\U000000121&quot;</span></span><br><span class="line">(lldb) x/<span class="number">4</span>xb $<span class="number">0</span></span><br><span class="line"><span class="number">0x10d6c1246</span>: <span class="number">0x11</span> <span class="number">0x21</span> <span class="number">0x23</span> <span class="number">0x00</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   解释：</span></span><br><span class="line"><span class="comment">   0x11: 1个非strong、1个strong</span></span><br><span class="line"><span class="comment">   0x21: 2个非strong、1个strong</span></span><br><span class="line"><span class="comment">   0x23: 2个非strong、3个strong （后面还有个weak就不记录了）</span></span><br><span class="line"><span class="comment">   0x00: 结束符</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">(lldb) x/<span class="number">5</span>xb $<span class="number">1</span></span><br><span class="line"><span class="number">0x10d6c124a</span>: <span class="number">0x01</span> <span class="number">0x21</span> <span class="number">0x12</span> <span class="number">0x31</span> <span class="number">0x00</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   解释：</span></span><br><span class="line"><span class="comment">   0x01: 0个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x21: 2个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x12: 1个非weak、2个weak</span></span><br><span class="line"><span class="comment">   0x31: 3个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x00: 结束符</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><h4 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h4><p><a href="http://blog.sunnyxx.com/2015/09/13/class-ivar-layout/">原文链接：Objective-C Class Ivar Layout 探索</a></p><p>当我们定义一个类的实例变量的时候，可以指定其修饰符：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> _gayFriend; <span class="comment">// 无修饰符的对象默认会加 __strong</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> _girlFriend;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> _company;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这使得 ivar (instance variable) 可以像属性一样在 ARC 下进行正确的引用计数管理。</p><p>那么问题来了，假如这个类是动态生成的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">class</span> = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">&quot;Sark&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">objc_registerClassPair(<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure><p>该如何像上面一样来添加 ivar 的属性修饰符呢？假如依次设置strong、weak、strong修饰符</p><p>第一步：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在objc_registerClassPair(class);前加上这么两句</span></span><br><span class="line">class_setIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x01\x11\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">class_setWeakIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x11\x10\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br></pre></td></tr></table></figure><p>第二步：</p><p>此时，strong 和 weak 的内存管理并没有生效，继续研究发现， class 的 flags 中有一个标记位记录这个类是否 ARC，正常编译的类，且标识了 <strong>-fobjc-arc</strong> flag 时，这个标记位为 1，而动态创建的类并没有设置它。所以只能继续黑魔法，运行时把这个标记位设置上，探索过程不赘述了，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fixup_class_arc</span><span class="params">(Class class)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Class isa;</span><br><span class="line">        Class superclass;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">void</span> *_buckets;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">            <span class="keyword">uint32_t</span> _mask;</span><br><span class="line">            <span class="keyword">uint32_t</span> _occupied;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">uint16_t</span> _mask;</span><br><span class="line">            <span class="keyword">uint16_t</span> _occupied;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125; cache;</span><br><span class="line">        <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    &#125; *objcClass = (__bridge <span class="built_in">typeof</span>(objcClass))class;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK 0xfffffffcUL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK 0x00007ffffffffff8UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">        <span class="keyword">uint32_t</span> version;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span> flags;</span><br><span class="line">        &#125; *ro;</span><br><span class="line">    &#125; *objcRWClass = (<span class="built_in">typeof</span>(objcRWClass))(objcClass-&gt;bits &amp; FAST_DATA_MASK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_IS_ARR 1&lt;&lt;7    </span></span><br><span class="line">    objcRWClass-&gt;ro-&gt;flags |= RO_IS_ARR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这个 fixup 放在 <code>objc_registerClassPair(class);</code> 之后，这个动态的类终于可以像静态编译的类一样操作 ivar 了。</p><p>完整的示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">class</span> = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">&quot;Sark&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_setIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x01\x11\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">class_setWeakIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x11\x10\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">objc_registerClassPair(<span class="keyword">class</span>);</span><br><span class="line">fixup_class_arc(<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> sark = [<span class="keyword">class</span> new];</span><br><span class="line">Ivar strongIvar = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>);</span><br><span class="line">Ivar weakIvar = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>);</span><br><span class="line">Ivar strongIvar2 = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> boy = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">id</span> girl = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">id</span> boy2 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    object_setIvar(sark, strongIvar, boy);</span><br><span class="line">    object_setIvar(sark, weakIvar, girl);</span><br><span class="line">    object_setIvar(sark, strongIvar2, boy2);</span><br><span class="line">&#125; <span class="comment">// ARC 在这里会对大括号内的 girl、boy、boy2 做一次release</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %@, %@&quot;</span>, object_getIvar(sark, strongIvar),  <span class="comment">//&lt;NSObject: 0x600000934660&gt;</span></span><br><span class="line">                     object_getIvar(sark, weakIvar),    <span class="comment">//nil</span></span><br><span class="line">                     object_getIvar(sark, strongIvar2));<span class="comment">//&lt;NSObject: 0x6000009346a0&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-2-几点总结"><a href="#2-4-2-几点总结" class="headerlink" title="2.4.2 几点总结"></a>2.4.2 几点总结</h3><ul><li>property在编译期会生成 _propertyName 的ivar，和相应的get/set方法。</li><li>ivars在编译期确定，但不完全确定，offset属性在运行时会修改。</li><li>对象的大小是由ivars决定的，当有继承体系时，父类的ivars永远放在子类之前。</li><li>class_ro_t 的 instanceStart 和 instanceSize 会在运行时调整。</li><li>class_ro_t 的 ivarLayout 和 weakIvarLayout 存放的是强ivar和弱ivar的存储规则。</li></ul><h2 id="2-5-元类-Meta-Class"><a href="#2-5-元类-Meta-Class" class="headerlink" title="2.5 元类(Meta Class)"></a>2.5 元类(Meta Class)</h2><h3 id="2-5-1-为什么存在元类？"><a href="#2-5-1-为什么存在元类？" class="headerlink" title="2.5.1 为什么存在元类？"></a>2.5.1 为什么存在元类？</h3><p><strong>在调用类方法的时候，为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。</strong></p><ul><li>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。</li><li>类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</li></ul><p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有自己独一无二的meta-class，因为每个类的类方法基本不可能完全相同。</p><blockquote><p>以下元类的相关内容，都来自 <a href="https://link.jianshu.com/?t=http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">What is a meta-class in Objective-C?</a> 这篇文章。</p></blockquote><h3 id="2-5-2-元类的isa-—-类"><a href="#2-5-2-元类的isa-—-类" class="headerlink" title="2.5.2 元类的isa — 类"></a>2.5.2 元类的isa — 类</h3><p>元类，和类的结构是一样的 objc_class，所以也是一个对象。这表示你能够对元类调用方法。自然的，这表示它必须也有一个类指针。</p><ul><li>类创建对象，调用的是实例方法</li><li>元类创建类对象，调用的是类方法。</li></ul><p>所有元类使用基类的元类（即继承链顶端的类的元类）作为它们的类，而所有类的基类都是 NSObject（大多数类是这样的），所以大多数元类使用 NSObject 的元类作为它的类。</p><p>根据规则所有元类使用基类的元类作为它们的类，那么基类的元类就是它自己的类（它们的isa指针指向了自己）。这表明NSObject的元类的指针指向的是它自己（它是一个它自己的实例）。</p><h3 id="2-5-3-元类的superclass-—-父类"><a href="#2-5-3-元类的superclass-—-父类" class="headerlink" title="2.5.3 元类的superclass — 父类"></a>2.5.3 元类的superclass — 父类</h3><p>同样的，类使用 super_class 指针指向他们的 superclass，元类也有 super_class 指针来指向 superclass。</p><p>这里又有一个奇怪的地方，基类的元类设置的 superclass 是基类自己 (<strong>NSObject-&gt;isa-&gt;superclass = NSObject</strong>)。</p><p>这种继承结构导致的结果是所有结构中的实例、类以及元类都继承自结构中的基类。</p><h3 id="2-5-4-总结"><a href="#2-5-4-总结" class="headerlink" title="2.5.4 总结"></a>2.5.4 总结</h3><p>所有这些用文字描述起来可能比较容易让人困惑。<a href="https://link.jianshu.com/?t=http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">Greg Parker的文章</a>中有一张附图描述了实例、类和元类以及他们的super class是如何完美的共存的。</p><img src="/images/runtime/01.png" alt="01" style="zoom:85%;" /><p>可以看到，所有的meta class 与 Root class 的 isa 都指向 Root class 的meta class，这样能够形成一个闭环。</p><p>实现了：</p><ul><li>所有 NSObject 的实例方法，都能够被 <strong>任何实例、类、元类</strong> 来使用；</li><li>所有 NSObject 的类方法，都能够被 <strong>任何类、元类</strong> 来使用。</li></ul><p>即实现了<strong>Objc中的任意 objc_object 对象，都继承自NSObject。NSObject为所有的对象定义了一些相同的特性</strong>。</p><h2 id="2-6-类与对象操作函数"><a href="#2-6-类与对象操作函数" class="headerlink" title="2.6 类与对象操作函数"></a>2.6 类与对象操作函数</h2><p>runtime有很多的函数可以操作类和对象。通常，操作类的是class为前缀，操作对象的是objc或object_为前缀(因为class也是一种Object，所以有的objc或object为前缀的函数也可以操作类对象)。</p><h3 id="2-6-1-类型获取和判断函数"><a href="#2-6-1-类型获取和判断函数" class="headerlink" title="2.6.1 类型获取和判断函数"></a>2.6.1 类型获取和判断函数</h3><h4 id="1-类型获取"><a href="#1-类型获取" class="headerlink" title="1. 类型获取"></a>1. 类型获取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  传入字符串类名，返回对应的类对象</span></span><br><span class="line"><span class="comment">  Return the id of the named class.  If the class does not exist, call _objc_classLoader and then objc_classHandler, either of which may create a new class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!aClassName) <span class="keyword">return</span> Nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NO unconnected, YES class handler</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">look_up_class</span>(aClassName, NO, YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 传入的obj可能是instance对象、class对象、meta-class对象</span></span><br><span class="line"><span class="comment"> 返回:</span></span><br><span class="line"><span class="comment">  a) 如果是instance对象，返回class对象</span></span><br><span class="line"><span class="comment">  b) 如果是class对象，返回meta-class对象</span></span><br><span class="line"><span class="comment">  c) 如果是meta-class对象，返回NSObject（基类）的meta-class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;<span class="built_in">getIsa</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 返回的就是类对象</span></span><br><span class="line">- (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getClass</span>(self);</span><br><span class="line">&#125;</span><br><span class="line">+ (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-类型判断"><a href="#2-类型判断" class="headerlink" title="2. 类型判断"></a>2. 类型判断</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者的类是不是cls类</span></span><br><span class="line"><span class="comment">    id person = [[MJPerson alloc] init];</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isMemberOfClass:[MJPerson class]]);  // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isMemberOfClass:[NSObject class]]);  // 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [self class] == cls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者(类对象)的类(即元类)是不是cls。(cls需要传入元类，才有可能返回YES)</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isMemberOfClass:object_getClass([MJPerson class])]); // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isMemberOfClass:[NSObject class]]); // 0 类对象的类怎么可能还是class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getClass</span>((id)self) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者的类是不是cls类、或者cls子类</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isKindOfClass:[MJPerson class]]);  // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isKindOfClass:[NSObject class]]);  // 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [self class]; tcls; tcls = tcls.superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者(类对象)的类(即元类)是不是cls、或者cls子类。(cls需要传入元类，才有可能返回YES)</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isKindOfClass:object_getClass([NSObject class])]); // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isKindOfClass:[NSObject class]]); // 1 特殊的NSObject，NSObject是所有元类的最顶部父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="built_in">object_getClass</span>((id)self); tcls; tcls = tcls.superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-判断是否是元类"><a href="#3-判断是否是元类" class="headerlink" title="3. 判断是否是元类"></a>3. 判断是否是元类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断给定的Class是否是一个meta class</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_isMetaClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">isMetaClass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-类相关操作函数"><a href="#2-6-2-类相关操作函数" class="headerlink" title="2.6.2 类相关操作函数"></a>2.6.2 类相关操作函数</h3><h4 id="1-获取name"><a href="#1-获取name" class="headerlink" title="1. 获取name"></a>1. 获取name</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">class_getName</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="string">&quot;nil&quot;</span>;</span><br><span class="line">    <span class="comment">// fixme lldb calls class_getName() on unrealized classes (rdar://27258517)</span></span><br><span class="line">    <span class="comment">// ASSERT(cls-&gt;isRealized()  ||  cls-&gt;isFuture());</span></span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">demangledName</span>(<span class="comment">/* needs lock */</span><span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>名字修饰</strong>（name decoration），也称为<strong>名字重整</strong>、<strong>名字改编</strong>（name mangling），是现代计算机程序设计语言的编译器用于解决由于程序实体的名字必须唯一而导致的问题的一种技术。</p><p>demangledName: 去除修饰的名称。</p></blockquote><h4 id="2-获取super-class"><a href="#2-获取super-class" class="headerlink" title="2. 获取super_class"></a>2. 获取super_class</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的父类</span></span><br><span class="line"><span class="function">Class <span class="title">class_getSuperclass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;superclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-获取instance-size"><a href="#3-获取instance-size" class="headerlink" title="3. 获取instance_size"></a>3. 获取instance_size</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取实例大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">class_getInstanceSize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">alignedInstanceSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-成员变量-ivars-操作"><a href="#4-成员变量-ivars-操作" class="headerlink" title="4. 成员变量(ivars)操作"></a>4. 成员变量(ivars)操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls  ||  !name) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> _class_getVariable(cls, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getClassVariable</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">class_getInstanceVariable</span>(cls-&gt;<span class="built_in">ISA</span>(), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加成员变量(这个只能够向在runtime时创建的类添加成员变量)</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span><span class="params">(Class cls, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">size_t</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint8_t</span> alignment, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取整个成员变量列表(必须使用free()来释放这个数组)</span></span></span><br><span class="line"><span class="function">Ivar * <span class="title">class_copyIvarList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><h4 id="5-方法操作"><a href="#5-方法操作" class="headerlink" title="5. 方法操作"></a>5. 方法操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function">Method <span class="title">class_getInstanceMethod</span> <span class="params">( Class cls, SEL name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line"><span class="function">Method <span class="title">class_getClassMethod</span> <span class="params">( Class cls, SEL name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有方法的数组</span></span><br><span class="line"><span class="function">Method * <span class="title">class_copyMethodList</span> <span class="params">( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加方法. (和成员变量不同的是可以为类动态添加方法。如果有同名会返回NO，修改的话需要使用method_setImplementation)</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 替代方法的实现(内部也是调用的_method_setImplementation)</span></span></span><br><span class="line"><span class="function">IMP <span class="title">class_replaceMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回方法的具体实现</span></span></span><br><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation</span><span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation_stret</span><span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实例是否响应指定的selector</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_respondsToSelector</span><span class="params">(Class cls, SEL sel)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="6-协议操作"><a href="#6-协议操作" class="headerlink" title="6. 协议操作"></a>6. 协议操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProtocol</span><span class="params">(Class cls, Protocol *protocol_gen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_conformsToProtocol</span><span class="params">(Class cls, Protocol *proto_gen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类实现的协议列表</span></span><br><span class="line"><span class="function">Protocol * <span class="title">class_copyProtocolList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="7-获取版本号"><a href="#7-获取版本号" class="headerlink" title="7. 获取版本号"></a>7. 获取版本号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取版本号 0表示类为非元类，7表示类为元类；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">class_getVersion</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">data</span>()-&gt;version;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置版本号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setVersion</span> <span class="params">( Class cls, <span class="keyword">int</span> version )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="8-示例"><a href="#8-示例" class="headerlink" title="8. 示例"></a>8. 示例</h4><p>通过示例来消化下上面的那些函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *array;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *string;</span><br><span class="line">- (<span class="keyword">void</span>)method1;</span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line">+ (<span class="keyword">void</span>)classMethod1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// MyClass.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> () </span>&#123;</span><br><span class="line"><span class="built_in">NSInteger</span> _instance1;</span><br><span class="line"><span class="built_in">NSString</span> * _instance2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> integer;</span><br><span class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)classMethod1 &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method1 &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;call method method1&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123; &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2 &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;arg1 : %ld, arg2 : %@&quot;</span>, arg1, arg2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// main.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MySubClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">     <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">          MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">          Class cls = myClass.class;</span><br><span class="line">          <span class="comment">// 类名</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;class name: %s&quot;</span>, class_getName(cls));    </span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 父类</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;super class name: %s&quot;</span>, class_getName(class_getSuperclass(cls)));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 是否是元类</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is %@ a meta-class&quot;</span>, (class_isMetaClass(cls) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot;not&quot;</span>));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          Class meta_class = objc_getMetaClass(class_getName(cls));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&#x27;s meta-class is %s&quot;</span>, class_getName(cls), class_getName(meta_class));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 变量实例大小</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;instance size: %zu&quot;</span>, class_getInstanceSize(cls));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 成员变量</span></span><br><span class="line">          Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               Ivar ivar = ivars[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;instance variable&#x27;s name: %s at index: %d&quot;</span>, ivar_getName(ivar), i);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(ivars);</span><br><span class="line"></span><br><span class="line">          Ivar string = class_getInstanceVariable(cls, <span class="string">&quot;_string&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (string != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;instace variable %s&quot;</span>, ivar_getName(string));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 属性操作</span></span><br><span class="line">          objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               objc_property_t property = properties[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;property&#x27;s name: %s&quot;</span>, property_getName(property));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(properties);</span><br><span class="line"></span><br><span class="line">          objc_property_t array = class_getProperty(cls, <span class="string">&quot;array&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;property %s&quot;</span>, property_getName(array));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 方法操作</span></span><br><span class="line">          Method *methods = class_copyMethodList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               Method method = methods[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;method&#x27;s signature: %s&quot;</span>, method_getName(method));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(methods);</span><br><span class="line"></span><br><span class="line">          Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(method1));</span><br><span class="line">          <span class="keyword">if</span> (method1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;method %s&quot;</span>, method_getName(method1));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Method classMethod = class_getClassMethod(cls, <span class="keyword">@selector</span>(classMethod1));</span><br><span class="line">          <span class="keyword">if</span> (classMethod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;class method : %s&quot;</span>, method_getName(classMethod));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is%@ responsd to selector: method3WithArg1:arg2:&quot;</span>, class_respondsToSelector(cls, <span class="keyword">@selector</span>(method3WithArg1:arg2:)) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot; not&quot;</span>);</span><br><span class="line"></span><br><span class="line">          IMP imp = class_getMethodImplementation(cls, <span class="keyword">@selector</span>(method1));</span><br><span class="line">          imp();</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 协议</span></span><br><span class="line">          Protocol * __<span class="keyword">unsafe_unretained</span> * protocols = class_copyProtocolList(cls, &amp;outCount);</span><br><span class="line">          Protocol * protocol;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               protocol = protocols[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;protocol name: %s&quot;</span>, protocol_getName(protocol));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is%@ responsed to protocol %s&quot;</span>, class_conformsToProtocol(cls, protocol) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot; not&quot;</span>, protocol_getName(protocol));</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.452</span> RuntimeTest <span class="keyword">class</span> name: MyClass</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.453</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest <span class="keyword">super</span> <span class="keyword">class</span> name: <span class="built_in">NSObject</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest MyClass is not a meta-<span class="keyword">class</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest MyClass<span class="string">&#x27;s meta-class is MyClass</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance size: 48</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance variable&#x27;</span>s name: _instance1 at index: <span class="number">0</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.455</span> RuntimeTest instance variable<span class="string">&#x27;s name: _instance2 at index: 1</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance variable&#x27;</span>s name: _array at index: <span class="number">2</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.455</span> RuntimeTest instance variable<span class="string">&#x27;s name: _string at index: 3</span></span><br><span class="line"><span class="string">19:41:37.463 RuntimeTest instance variable&#x27;</span>s name: _integer at index: <span class="number">4</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest instace variable _string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest property<span class="string">&#x27;s name: array</span></span><br><span class="line"><span class="string">19:41:37.463 RuntimeTest property&#x27;</span>s name: string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.464</span> RuntimeTest property<span class="string">&#x27;s name: integer</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest property array</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest method&#x27;</span>s signature: method1</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.464</span> RuntimeTest method<span class="string">&#x27;s signature: method2</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest method&#x27;</span>s signature: method3WithArg1:arg2:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: integer</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: setInteger:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: array</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: setString:</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: setArray:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.466</span> RuntimeTest method<span class="string">&#x27;s signature: .cxx_destruct</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest method method1</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest class method : classMethod1</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest MyClass is responsd to selector: method3WithArg1:arg2:</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest call method method1</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest =====================================================</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest protocol name: NSCopying</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest protocol name: NSCoding</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest MyClass is responsed to protocol NSCoding</span></span><br><span class="line"><span class="string">19:41:37.468 RuntimeTest ======================================</span></span><br></pre></td></tr></table></figure><h3 id="2-6-3-动态创建类和对象"><a href="#2-6-3-动态创建类和对象" class="headerlink" title="2.6.3 动态创建类和对象"></a>2.6.3 动态创建类和对象</h3><h4 id="1-动态创建类"><a href="#1-动态创建类" class="headerlink" title="1. 动态创建类"></a>1. 动态创建类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 创建一个新类和元类。Creates a new class and metaclass.</span></span><br><span class="line"><span class="comment"> * @prama superclass 如果创建的是root class，则superclass为Nil</span></span><br><span class="line"><span class="comment"> * @prama sextraBytes 通常为0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> extraBytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新类后，使用class_addMethod，class_addIvar函数为新类添加方法、实例变量和属性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类。再之后就能够用了。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerClassPair</span><span class="params">(Class cls)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个类及其相关联的类。在运行中还存在或存在子类实例，就不能够调用这个。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_disposeClassPair</span><span class="params">(Class cls)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>问题：什么是”class pair（类对）”？函数 objc_allocateClassPair 只返回一个值：类。那么这个”class pair（类对）”的另一半呢？从方法注释可以看出来，是元类。</p></blockquote><p>使用示例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class cls = objc_allocateClassPair(MyClass.class, <span class="string">&quot;MySubClass&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addMethod(cls, <span class="keyword">@selector</span>(submethod1), (IMP)imp_submethod1, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">class_replaceMethod(cls, <span class="keyword">@selector</span>(method1), (IMP)imp_submethod1, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">class_addIvar(cls, <span class="string">&quot;_ivar1&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line">objc_property_attribute_t type = &#123;<span class="string">&quot;T&quot;</span>, <span class="string">&quot;@\&quot;NSString\&quot;&quot;</span>&#125;;</span><br><span class="line">objc_property_attribute_t ownership = &#123; <span class="string">&quot;C&quot;</span>, <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">objc_property_attribute_t backingivar = &#123; <span class="string">&quot;V&quot;</span>, <span class="string">&quot;_ivar1&quot;</span>&#125;;</span><br><span class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</span><br><span class="line"></span><br><span class="line">class_addProperty(cls, <span class="string">&quot;property2&quot;</span>, attrs, <span class="number">3</span>);</span><br><span class="line">objc_registerClassPair(cls);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> instance = [[cls alloc] init];</span><br><span class="line">[instance performSelector:<span class="keyword">@selector</span>(submethod1)];</span><br><span class="line">[instance performSelector:<span class="keyword">@selector</span>(method1)];</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></span><br><span class="line"><span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="2-动态创建对象"><a href="#2-动态创建对象" class="headerlink" title="2. 动态创建对象"></a>2. 动态创建对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类实例。会在heap里给类分配内存。这个方法和+alloc方法类似。</span></span><br><span class="line"><span class="function">id <span class="title">class_createInstance</span><span class="params">(Class cls, <span class="keyword">size_t</span> extraBytes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 在指定位置创建类实例</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 在bytes所指向的位置创建cls的实例。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * bytes必须至少指向对齐的零填充内存的class_getInstanceSize(cls)字节。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 设置新对象的isa。调用任何c++构造函数。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果成功返回bytes。如果cls或bytes为nil，或c++构造函数失败，则返回nil。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 注意: class_createInstance()和class_createInstances()对此进行了预检。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">id <span class="title">objc_constructInstance</span><span class="params">(Class cls, <span class="keyword">void</span> *bytes)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 销毁类实例</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 销毁实例而不释放内存。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 调用 C++ 析构函数。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 调用 ARC ivar 清理。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 移除除关联引用。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回obj。如果obj为nil，则什么都不做。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span>; <span class="comment">//不会释放移除任何相关引用</span></span><br></pre></td></tr></table></figure><p>测试下效果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看出class_createInstance和alloc的不同</span></span><br><span class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"><span class="keyword">id</span> str1 = [theObject init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str1 <span class="keyword">class</span>]);</span><br><span class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@&quot;test&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str2 <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] <span class="built_in">NSString</span></span><br><span class="line"><span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] __NSCFConstantString</span><br></pre></td></tr></table></figure><h3 id="2-6-4-实例对象相关操作函数"><a href="#2-6-4-实例对象相关操作函数" class="headerlink" title="2.6.4 实例对象相关操作函数"></a>2.6.4 实例对象相关操作函数</h3><p>这些函数是针对创建的实例对象的一系列操作函数。</p><h4 id="1-操作-整个对象-的函数"><a href="#1-操作-整个对象-的函数" class="headerlink" title="1. 操作 整个对象 的函数"></a>1. 操作 整个对象 的函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定对象的一份拷贝</span></span><br><span class="line"><span class="function">id <span class="title">object_copy</span><span class="params">(id oldObj, <span class="keyword">size_t</span> extraBytes)</span></span>;</span><br><span class="line"><span class="comment">// 释放指定对象占用的内存</span></span><br><span class="line"><span class="function">id <span class="title">object_dispose</span><span class="params">(id obj)</span></span>;</span><br></pre></td></tr></table></figure><p>应用场景</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把a转换成占用更多空间的子类b</span></span><br><span class="line"><span class="built_in">NSObject</span> *a = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> newB = object_copy(a, class_getInstanceSize(MyClass.class));</span><br><span class="line">object_setClass(newB, MyClass.class);</span><br><span class="line">object_dispose(a);</span><br></pre></td></tr></table></figure><h4 id="2-操作-对象的类-的函数"><a href="#2-操作-对象的类-的函数" class="headerlink" title="2. 操作 对象的类 的函数"></a>2. 操作 对象的类 的函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定对象的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">object_getClassName</span><span class="params">(id obj)</span></span>;</span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span>;</span><br><span class="line"><span class="comment">// 设置对象的类</span></span><br><span class="line"><span class="function">Class <span class="title">object_setClass</span><span class="params">(id obj, Class cls)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-6-5-获取类定义"><a href="#2-6-5-获取类定义" class="headerlink" title="2.6.5 获取类定义"></a>2.6.5 获取类定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取已注册的类定义的列表。返回值为已注册类的总数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_getClassList</span><span class="params">(Class *buffer, <span class="keyword">int</span> bufferLen)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></span></span><br><span class="line"><span class="function">Class *<span class="title">objc_copyClassList</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回指定类的类定义</span></span></span><br><span class="line"><span class="function">Class <span class="title">objc_lookUpClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getRequiredClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>; <span class="comment">// 与objc_getClass相同，但如果没有找到类，则终止进程。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定类的元类</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getMetaClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br></pre></td></tr></table></figure><p>演示如何使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numClasses;</span><br><span class="line">Class * classes = <span class="literal">NULL</span>;</span><br><span class="line">numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     classes = malloc(<span class="keyword">sizeof</span>(Class) * numClasses);</span><br><span class="line">     numClasses = objc_getClassList(classes, numClasses);</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;number of classes: %d&quot;</span>, numClasses);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++) &#123;</span><br><span class="line">          Class cls = classes[i];</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;class name: %s&quot;</span>, class_getName(cls));</span><br><span class="line">     &#125;</span><br><span class="line">     free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">81</span>] number of classes: <span class="number">1282</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: DDTokenRegexp</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: _NSMostCommonKoreanCharsKeySet</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: OS_xpc_dictionary</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSFileCoordinator</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSAssertionHandler</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: PFUbiquityTransactionLogMigrator</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSNotification</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSKeyValueNilSetEnumerator</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: OS_tcp_connection_tls_session</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: _PFRoutines</span><br><span class="line">......还有大量输出</span><br></pre></td></tr></table></figure><h1 id="三、成员变量、属性与关联对象"><a href="#三、成员变量、属性与关联对象" class="headerlink" title="三、成员变量、属性与关联对象"></a>三、成员变量、属性与关联对象</h1><h2 id="3-1-实例变量类型Ivar"><a href="#3-1-实例变量类型Ivar" class="headerlink" title="3.1 实例变量类型Ivar"></a>3.1 实例变量类型Ivar</h2><blockquote><p>实例变量是指在类的声明中，属性是用变量来表示的。 这种变量就称为实例变量，也叫对象变量、类成员变量；</p></blockquote><h3 id="3-1-1-Ivar结构"><a href="#3-1-1-Ivar结构" class="headerlink" title="3.1.1 Ivar结构"></a>3.1.1 Ivar结构</h3><p>Ivar是指向 ivar_t 结构体的指针，ivar指针地址是根据class结构体的地址加上基地址偏移字节得到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;   <span class="comment">// 基地址偏移字节</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;  <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">ptrdiff_t</span> <span class="title">ivar_getOffset</span><span class="params">(Ivar ivar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getName</span><span class="params">(Ivar ivar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量类型编码</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getTypeEncoding</span><span class="params">(Ivar ivar)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-Ivar的获取"><a href="#3-1-2-Ivar的获取" class="headerlink" title="3.1.2 Ivar的获取"></a>3.1.2 Ivar的获取</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Ivar *<span class="title">class_copyIvarList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><h3 id="3-1-3-实例变量操作函数"><a href="#3-1-3-实例变量操作函数" class="headerlink" title="3.1.3 实例变量操作函数"></a>3.1.3 实例变量操作函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改类实例的实例变量的值</span></span><br><span class="line"><span class="function">Ivar <span class="title">object_setInstanceVariable</span><span class="params">(id obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="comment">// 获取对象实例变量的值</span></span><br><span class="line"><span class="function">Ivar <span class="title">object_getInstanceVariable</span><span class="params">(id obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **value)</span></span>;</span><br><span class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">object_getIndexedIvars</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回对象中实例变量的值</span></span></span><br><span class="line"><span class="function">id <span class="title">object_getIvar</span><span class="params">(id obj, Ivar ivar)</span></span>;</span><br><span class="line"><span class="comment">// 设置对象中实例变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_setIvar</span><span class="params">(id obj, Ivar ivar, id value)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-2-属性类型property-t"><a href="#3-2-属性类型property-t" class="headerlink" title="3.2 属性类型property_t"></a>3.2 属性类型property_t</h2><h3 id="3-2-1-property-t结构和objc-property-t"><a href="#3-2-1-property-t结构和objc-property-t" class="headerlink" title="3.2.1 property_t结构和objc_property_t"></a>3.2.1 property_t结构和objc_property_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;       <span class="comment">// property的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes; <span class="comment">// property的属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> *<span class="title">objc_property_t</span>;</span></span><br></pre></td></tr></table></figure><p>属性attributes是一个字符串：该字符串以T开头，后面跟着@encode类型和一个逗号，以V结尾，后面跟着后台实例变量的名称。在这些属性之间，由以下描述符指定，以逗号分隔。官方文档 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW24">Declared Properties</a>。</p><img src="/images/runtime/02.png" alt="02" style="zoom:90%;" /><p>获取name、attributes的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取属性名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getName</span><span class="params">(<span class="keyword">objc_property_t</span> prop)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性特性描述字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getAttributes</span><span class="params">(<span class="keyword">objc_property_t</span> prop)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-property的获取"><a href="#3-2-2-property的获取" class="headerlink" title="3.2.2 property的获取"></a>3.2.2 property的获取</h3><p>获取类和协议的属性列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回一个包含类中声明的属性的堆块(heap block)，如果类没有声明属性，则返回nil。呼叫者必须释放区块。</span></span><br><span class="line"><span class="comment"> * 不复制任何超类的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">class_copyPropertyList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">protocol_copyPropertyList</span><span class="params">(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><p>通过给出的名称来在类和协议中获取属性的引用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">class_getProperty</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">protocol_getProperty</span><span class="params">(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-property的特性attributes"><a href="#3-2-3-property的特性attributes" class="headerlink" title="3.2.3 property的特性attributes"></a>3.2.3 property的特性attributes</h3><p>objc_property_attribute_t也是结构体，定义属性的attribute</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 特性名</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *value; <span class="comment">// 特性值</span></span><br><span class="line">&#125; <span class="keyword">objc_property_attribute_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性中指定的特性</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">property_copyAttributeValue</span><span class="params">(<span class="keyword">objc_property_t</span> property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName)</span></span>;</span><br><span class="line"><span class="comment">// 获取属性的特性列表</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_attribute_t</span> *<span class="title">property_copyAttributeList</span><span class="params">(<span class="keyword">objc_property_t</span> prop, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><h3 id="3-2-4-示例"><a href="#3-2-4-示例" class="headerlink" title="3.2.4 示例"></a>3.2.4 示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface Lender : NSObject &#123;</span><br><span class="line">     <span class="keyword">float</span> alone;</span><br><span class="line">&#125;</span><br><span class="line">@property <span class="keyword">float</span> alone;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取属性列表</span></span><br><span class="line">id LenderClass = <span class="built_in">objc_getClass</span>(<span class="string">&quot;Lender&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;</span><br><span class="line"><span class="keyword">objc_property_t</span> *properties = <span class="built_in">class_copyPropertyList</span>(LenderClass, &amp;outCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">objc_property_t</span> property = properties[i];</span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;%s %s\n&quot;</span>, <span class="built_in">property_getName</span>(property), <span class="built_in">property_getAttributes</span>(property)); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount2, j;</span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> * attries = <span class="built_in">property_copyAttributeList</span>(property, &amp;outCount2);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; outCount2; j++) &#123;</span><br><span class="line">        <span class="keyword">objc_property_attribute_t</span> attr = attries[j];</span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;%s %s\n&quot;</span>, attr.name, attr.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">log: ======= alone Tf,V_alone</span><br><span class="line">log: ======= T f</span><br><span class="line">log: ======= V _alone</span><br></pre></td></tr></table></figure><h2 id="3-3-关联对象"><a href="#3-3-关联对象" class="headerlink" title="3.3 关联对象"></a>3.3 关联对象</h2><p>关联对象是在运行时添加的类似成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置对象 的一个关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取对象 指定的关联对象</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//移除对象 所有关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面方法以键值对的形式动态的向对象添加，获取或者删除关联值。其中关联政策是一组枚举常量。这些常量对应着引用关联值机制，也就是Objc内存管理的引用计数机制。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">     OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</span><br><span class="line">     OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</span><br><span class="line">     OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</span><br><span class="line">     OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</span><br><span class="line">     OBJC_ASSOCIATION_COPY = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态的将一个Tap手势操作连接到任何UIView中。</span></span><br><span class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="built_in"><span class="keyword">void</span></span> (^)(<span class="keyword">void</span>))block</span><br><span class="line">&#123;</span><br><span class="line">     UITapGestureRecognizer *gesture = <span class="built_in">objc_getAssociatedObject</span>(self, &amp;kDTActionHandlerTapGestureKey);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!gesture)</span><br><span class="line">     &#123;</span><br><span class="line">          gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@<span class="built_in">selector</span>(__handleActionForTapGesture:)];</span><br><span class="line">          [self addGestureRecognizer:gesture];</span><br><span class="line">          <span class="comment">//将创建的手势对象和block作为关联对象</span></span><br><span class="line">          <span class="built_in">objc_setAssociatedObject</span>(self, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">objc_setAssociatedObject</span>(self, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手势识别对象的target和action</span></span><br><span class="line">- (<span class="keyword">void</span>)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (gesture.state == UIGestureRecognizerStateRecognized)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in"><span class="keyword">void</span></span>(^action)(<span class="keyword">void</span>) = <span class="built_in">objc_getAssociatedObject</span>(self, &amp;kDTActionHandlerTapBlockKey);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (action)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">action</span>();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、Method和消息"><a href="#四、Method和消息" class="headerlink" title="四、Method和消息"></a>四、Method和消息</h1><h2 id="4-1-method-t、SEL和IMP"><a href="#4-1-method-t、SEL和IMP" class="headerlink" title="4.1 method_t、SEL和IMP"></a>4.1 method_t、SEL和IMP</h2><h3 id="4-1-1-method-t结构和Method"><a href="#4-1-1-method-t结构和Method" class="headerlink" title="4.1.1 method_t结构和Method"></a>4.1.1 method_t结构和Method</h3><p>method_t结构，用于表示类定义中的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;          <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 编码，是个char指针，存储着方法的返回值类型、参数类型</span></span><br><span class="line">    IMP imp;           <span class="comment">// 指向函数实现的指针(函数地址)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></span><br></pre></td></tr></table></figure><p>iOS中提供了一个叫做@encode的指令，可以将具体的类型表示成字符串编码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   v16@0:8</span></span><br><span class="line"><span class="comment">   v - 返回值void</span></span><br><span class="line"><span class="comment">   @ - 参数1: id self</span></span><br><span class="line"><span class="comment">   : - 参数2: SEL _cmd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)test:(<span class="keyword">int</span>)age height:(<span class="keyword">float</span>)height;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   i24@0:8i16f20</span></span><br><span class="line"><span class="comment">   i  - 返回值</span></span><br><span class="line"><span class="comment">   24 - 表示接下来的参数总共占多少个字节</span></span><br><span class="line"><span class="comment">   @  - 参数1: id self</span></span><br><span class="line"><span class="comment">   0  - 对应参数1，表示参数1的数据是从第几个字节开始的。后面的8 16 20分别对应参数234对应的开始位置</span></span><br><span class="line"><span class="comment">   :  - 参数2: SEL _cmd</span></span><br><span class="line"><span class="comment">   i  - 参数3: int</span></span><br><span class="line"><span class="comment">   f  - 参数4: float</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="4-1-2-SEL"><a href="#4-1-2-SEL" class="headerlink" title="4.1.2 SEL"></a>4.1.2 SEL</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SEL代表方法\函数名，一般叫做选择器，底层结构跟char *类似.(可以简单的理解为是个字符串).</span></span><br><span class="line">  <span class="comment">// 可以通过@selector()和sel_registerName()获得.</span></span><br><span class="line">  <span class="comment">// 可以通过sel_getName()和NSStringFromSelector()转成字符串.</span></span><br><span class="line">  <span class="comment">// 不同类中相同名字的方法，所对应的方法选择器是相同的.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objc_selector编译时会根据每个方法名字参数序列生成唯一标识</span></span><br><span class="line">SEL sel1 = @<span class="built_in">selector</span>(load);</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;sel : %p&quot;</span>, sel1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">18</span>:<span class="number">40</span>:<span class="number">07.518</span> RuntimeTest[<span class="number">52</span>:<span class="number">46</span>] sel : <span class="number">0x7fff606203c3</span></span><br></pre></td></tr></table></figure><h3 id="4-1-3-IMP"><a href="#4-1-3-IMP" class="headerlink" title="4.1.3 IMP"></a>4.1.3 IMP</h3><p>是函数指针，指向方法的首地址，得到了IMP，就可以跳过Runtime消息传递机制直接执行函数，比直接向对象发消息高效。定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMP代表函数的具体实现</span></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</span><br></pre></td></tr></table></figure><h2 id="4-2-Method相关操作函数"><a href="#4-2-Method相关操作函数" class="headerlink" title="4.2 Method相关操作函数"></a>4.2 Method相关操作函数</h2><h3 id="4-2-1-获取Method的信息"><a href="#4-2-1-获取Method的信息" class="headerlink" title="4.2.1 获取Method的信息"></a>4.2.1 获取Method的信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方法名。如果希望获得方法明的C字符串，使用sel_getName(method_getName(method))</span></span><br><span class="line"><span class="function">SEL <span class="title">method_getName</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 返回方法的实现</span></span><br><span class="line"><span class="function">IMP <span class="title">method_getImplementation</span><span class="params">(Method m)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">method_getTypeEncoding</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">method_copyReturnType</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串：通过引用返回，这种参数又称为传出参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_getReturnType</span><span class="params">(Method m, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> dst_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的参数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">method_getNumberOfArguments</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">method_copyArgumentType</span><span class="params">(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串：通过引用返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_getArgumentType</span><span class="params">(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> dst_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> &#123;</span></span><br><span class="line">    SEL _Nullable name;               <span class="comment">/**&lt; The name of the method */</span></span><br><span class="line">    <span class="keyword">char</span> * _Nullable types;           <span class="comment">/**&lt; The types of the method arguments */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct objc_method_description *<span class="title">method_getDescription</span><span class="params">(Method m)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-获取和设置Method的IMP"><a href="#4-2-2-获取和设置Method的IMP" class="headerlink" title="4.2.2 获取和设置Method的IMP"></a>4.2.2 获取和设置Method的IMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置方法的实现</span></span><br><span class="line"><span class="function">IMP <span class="title">method_setImplementation</span><span class="params">(Method m, IMP imp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(Method m1, Method m2)</span></span>;</span><br></pre></td></tr></table></figure><p>NSObject提供了一个methodForSelector:方法可以获得Method的IMP指针，通过指针调用实现代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (IMP)instanceMethodForSelector:(SEL)sel;</span><br><span class="line">+ (IMP)methodForSelector:(SEL)sel;</span><br><span class="line">- (IMP)methodForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</span><br></pre></td></tr></table></figure><h3 id="4-2-3-直接调用Method"><a href="#4-2-3-直接调用Method" class="headerlink" title="4.2.3 直接调用Method"></a>4.2.3 直接调用Method</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现，返回的是方法实现时的返回，参数receiver不能为空，这个比method_getImplementation和method_getName快</span></span><br><span class="line"><span class="function">id <span class="title">method_invoke</span><span class="params">(id receiver, Method m, ... )</span></span>;</span><br><span class="line"><span class="comment">// 调用 (返回一个数据结构的) 方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_invoke_stret</span><span class="params">(id receiver, Method m, ...)</span> </span></span><br></pre></td></tr></table></figure><h3 id="4-2-4-SEL的操作函数"><a href="#4-2-4-SEL的操作函数" class="headerlink" title="4.2.4 SEL的操作函数"></a>4.2.4 SEL的操作函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">sel_getName</span><span class="params">(SEL sel)</span></span>;</span><br><span class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></span><br><span class="line"><span class="function">SEL <span class="title">sel_registerName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法</span></span><br><span class="line"><span class="function">SEL <span class="title">sel_getUid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 比较两个选择器</span></span><br><span class="line"><span class="function">BOOL <span class="title">sel_isEqual</span><span class="params">(SEL lhs, SEL rhs)</span></span>; <span class="comment">// Lhs --&gt; Left Hand Side，也就是算式左边的意思</span></span><br></pre></td></tr></table></figure><h2 id="4-3-Method调用流程objc-msgSend"><a href="#4-3-Method调用流程objc-msgSend" class="headerlink" title="4.3 Method调用流程objc_msgSend"></a>4.3 Method调用流程objc_msgSend</h2><p>消息函数，Objc中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。</p><p>OC中的方法调用，其实都是转换为下面几个函数的调用。编译器会根据情况在objc_msgSend，objc_msgSend_stret，objc_msgSendSuper，或objc_msgSendSuper_stret四个方法中选一个调用。</p><ul><li>如果是传递给超类就会调用带super的函数；</li><li>如果返回是数据结构而不是一个值就会调用带stret的函数；</li><li>在i386平台返回类型为浮点消息会调用objc_msgSend_fpret函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数将消息接收者和方法名(选择器)作为基础参数。</span></span><br><span class="line">   <span class="comment">// 使用self关键字来引用实例本身，self的内容即接收消息的对象是在Method运行时被传入</span></span><br><span class="line">   <span class="comment">// 还有方法选择器</span></span><br><span class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id _Nullable self, SEL _Nonnull op, ...)</span></span></span><br></pre></td></tr></table></figure><h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><p>objc_msgSend的执行流程可以分为3大阶段：消息发送、动态方法解析、消息转发</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 消息发送阶段</span></span><br><span class="line"><span class="comment">//在objc-msg-arm64.s中</span></span><br><span class="line">▼ _objc_msgSend</span><br><span class="line">  ▼ CacheLookup  <span class="comment">// 缓存查找</span></span><br><span class="line">    ▼ CheckMiss <span class="comment">// 如果缓存没有命中</span></span><br><span class="line">      ▼ __objc_msgSend_uncached</span><br><span class="line">        ▼ MethodTableLookup</span><br><span class="line">        <span class="comment">// 其中有一行 bl __class_lookupMethodAndLoadCache3. 此时在objc-msg-arm64.s已经查不到该方法了。前缀减去</span></span><br><span class="line">        <span class="comment">// 一个_（符号修饰）然后全局搜索，可以在objc-runtime-new.mm中找到该方法_class_lookupMethodAndLoadCache3</span></span><br><span class="line"><span class="comment">//objc-runtime-new.mm</span></span><br><span class="line">  ▼ _class_lookupMethodAndLoadCache3</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   // 仅用于汇编中的方法查找。其他代码应该使用lookUpImp()。这种查找避免了乐观的缓存扫描，因为汇编中已经尝试过。</span></span><br><span class="line"><span class="comment">   IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123;</span></span><br><span class="line"><span class="comment">        // NO是cache. cache==NO跳过乐观的解锁查找(但在其他地方使用缓存);</span></span><br><span class="line"><span class="comment">          return lookUpImpOrForward(cls, sel, obj, YES, NO, YES);</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    ▼ lookUpImpOrForward</span><br><span class="line">      ▶ cache_getImp            <span class="comment">// 查找当前类的cache</span></span><br><span class="line">      ▶ getMethodNoSuper_nolock <span class="comment">// 查找当前类的methods</span></span><br><span class="line">      ▶ cache_getImp            <span class="comment">// 查找父类(父类的父类...)的cache</span></span><br><span class="line">      ▶ getMethodNoSuper_nolock <span class="comment">// 查找父类(父类的父类...)的methods</span></span><br><span class="line">        ▼ search_method_list</span><br><span class="line">          ▶ findMethodInSortedMethodList  <span class="comment">//若有序，二分查找</span></span><br><span class="line">          ▶ <span class="comment">//若无序，线性查找</span></span><br><span class="line">      ▼ log_and_fill_cache  <span class="comment">// 不管是在本类、父类、基类中找到的，只要不在本类的cache中，就填充缓存</span></span><br><span class="line">        ▼ cache_fill</span><br><span class="line">          ▶ cache_fill_nolock</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 动态方法解析</span></span><br><span class="line">      ▼ _class_resolveMethod      <span class="comment">// 动态方法解析. 在运行时(动态)向特定类添加特定方法实现。</span></span><br><span class="line">        ▶ _class_resolveClassMethod    <span class="comment">// 如果是元类对象，调用类的该类方法(需要自己实现)，在该方法中，将要调用的方法添加到class/meta-class中。见MJPerson.m</span></span><br><span class="line">        ▶ _class_resolveInstanceMethod <span class="comment">// 如果是类对象，同上...</span></span><br><span class="line">        <span class="comment">//..动态解析过后，会重新走“消息发送”的流程</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 消息转发</span></span><br><span class="line">      ▶ _objc_msgForward_impcache <span class="comment">// 消息转发. No implementation found, and method resolver didn&#x27;t help. Use forwarding.</span></span><br></pre></td></tr></table></figure><p>大致流程图如下：</p><img src="/images/runtime/03.png" alt="03" style="zoom:80%;" /><h3 id="4-3-1-消息发送"><a href="#4-3-1-消息发送" class="headerlink" title="4.3.1 消息发送"></a>4.3.1 消息发送</h3><ul><li>消息发送给一个对象时，objc_msgSend通过对象的isa指针获得类的结构体，先在Cache里找，找到就执行</li><li>没找到就在分发列表里查找方法的selector</li><li>没找到就通过objc_class结构体中指向父类的指针找到父类，然后在父类分发列表找</li><li>直到root class（NSObject）</li></ul><p>如果root class仍然找不到方法，不会直接报错，会进入以下两个补救阶段。不过安全起见，一些场景中，可以先添加方法能否响应的判断：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先调用respondsToSelector:来判断一下</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(method)]) &#123;</span><br><span class="line">     [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-动态方法解析"><a href="#4-3-2-动态方法解析" class="headerlink" title="4.3.2 动态方法解析"></a>4.3.2 动态方法解析</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> functionForMethod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %p&quot;</span>, <span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">     <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">     <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@&quot;method1&quot;</span>]) &#123;</span><br><span class="line">          class_addMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(method1), (IMP)functionForMethod1, <span class="string">&quot;@:&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以动态的提供一个方法的实现。例如可以用@dynamic关键字在类的实现文件中写个属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个表明会为这个属性动态提供set get方法，就是编译器是不会默认生成setPropertyName:和propertyName方法，需要动态提供。</span></span><br><span class="line"><span class="keyword">@dynamic</span> propertyName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">     <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 如果是对象方法找不到，动态方法解析 会调用+(BOOL)resolveInstanceMethod:(SEL)sel</span></span><br><span class="line"><span class="comment"> 如果是类方法找不到， 动态方法解析 会调用+(BOOL)resolveClassMethod:(SEL)sel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;&#125;</span><br><span class="line">  </span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        <span class="comment">//v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html</span></span><br><span class="line">        <span class="comment">// 最后用class_addMethod完成添加特定方法实现的操作</span></span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)dynamicMethodIMP, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="4-3-3-消息转发"><a href="#4-3-3-消息转发" class="headerlink" title="4.3.3 消息转发"></a>4.3.3 消息转发</h3><h4 id="1-重定向接收者"><a href="#1-重定向接收者" class="headerlink" title="1. 重定向接收者"></a>1. 重定向接收者</h4><p>如果无法处理消息会继续调用下面的方法，同时在这里Runtime系统实际上是给了一个替换消息接收者的机会，但是替换的对象千万不要是self，那样会进入死循环。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用这个方法通常在对象内部</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是实例方法</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 将消息转发给alternateObject来处理</span></span><br><span class="line">     <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:))&#123;</span><br><span class="line">          <span class="keyword">return</span> alternateObject;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是类方法</span></span><br><span class="line">+ (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">   <span class="comment">// 这个return，不仅限于类对象，也可以是实例对象，前提是这个实例对象有名为aSelector的实例方法。因为前面已经说了，底层代码得到return的对象后，就会调用objc_msgSend，如果返回的实例对象，就相当于objc_msgSend(obj, @selector(test))，最后是能完成消息发送的</span></span><br><span class="line">   <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-最后进行转发"><a href="#2-最后进行转发" class="headerlink" title="2. 最后进行转发"></a>2. 最后进行转发</h4><p>如果以上两种都没法处理未知消息就需要完整消息转发了。调用如下方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须重写这个方法，消息转发使用这个方法获得的信息创建NSInvocation对象。如果没有实现，或者返回nil，消息转发结束。</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的selector，target和参数都封装在anInvocation中。forwardInvocation:像未知消息分发中心，将未知消息转发给其它对象。注意的是forwardInvocation:方法只有在消息接收对象无法正常响应消息时才被调用。</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是类方法</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line">+ (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure><p>范例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">     <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">          <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">               signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">     <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</span><br><span class="line">          [anInvocation invokeWithTarget:_helper];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-4-消息转发和多继承"><a href="#4-3-4-消息转发和多继承" class="headerlink" title="4.3.4 消息转发和多继承"></a>4.3.4 消息转发和多继承</h3><p>OC是否支持多继承？有没有模拟多继承特性的办法？</p><p>转发和继承相似，一个Object把消息转发出去就好像它继承了另一个Object的方法一样。</p><p>消息转发弥补了objc不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。</p><p>虽然转发可以实现继承功能，但是NSObject还是必须表面上很严谨，像<code>respondsToSelector:</code>和<code>isKindOfClass:</code>这类方法只会考虑继承体系，不会考虑转发链。</p><h3 id="4-3-5-Message消息的参考文章"><a href="#4-3-5-Message消息的参考文章" class="headerlink" title="4.3.5 Message消息的参考文章"></a>4.3.5 Message消息的参考文章</h3><ul><li><a href="https://mikeash.com/pyblog/friday-qa-2009-03-27-objectivec-message-forwarding.html">Message forwarding</a></li><li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-03-20-objectivec-messaging.html">objectivec messaging</a></li><li><a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html">The faster objc_msgSend</a></li></ul><h2 id="4-4-super和objc-msgSendSuper"><a href="#4-4-super和objc-msgSendSuper" class="headerlink" title="4.4 super和objc_msgSendSuper"></a>4.4 super和objc_msgSendSuper</h2><p><code>NSStringFromClass([self class])</code> 和 <code>NSStringFromClass([super class])</code> 输出都是self的类名。原因如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[super message]的底层实现:</span></span><br><span class="line"><span class="comment">//super调用，底层会转换为objc_msgSendSuper2函数的调用，接收2个参数</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">objc_super2</span> &#123;</span></span><br><span class="line">         id receiver;         <span class="comment">// receiver是self，表示消息接收者仍然是子类对象</span></span><br><span class="line">         Class current_class; <span class="comment">// 会从父类current_class.superclass开始查找方法的实现</span></span><br><span class="line">     &#125;;</span><br><span class="line">     SEL</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sends a message with a simple return value to the superclass of an instance of a class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param super 指向objc_super数据结构的指针。传递消息发送的上下文的值，包括要接收消息的类的实例和开始搜索方法实现的超类。including the instance of the class that is to receive the message and the superclass at which to start searching for the method implementation。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由此可知，消息仍然是receiver来处理，superclass指定了`消息发送`阶段，方法从isa-&gt;superclass-&gt;superclass.superclass...-&gt;NSObject链中superclass为起点开始向上寻找。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param op SEL类型的指针。传递将处理消息的方法的选择器。</span></span><br><span class="line"><span class="comment"> * @param ... A variable argument list containing the arguments to the method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return The return value of the method identified by \e op.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see objc_msgSend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">id <span class="title">objc_msgSendSuper</span><span class="params">(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span>;</span><br><span class="line"><span class="function">id <span class="title">objc_msgSendSuper2</span><span class="params">(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>结论：super只是改变了方法查找链的起始位置，调用者是不变的。</p><h2 id="4-5-Method-Swizzling"><a href="#4-5-Method-Swizzling" class="headerlink" title="4.5 Method Swizzling"></a>4.5 Method Swizzling</h2><p>是改变一个selector实际实现的技术，可以在运行时修改selector对应的函数来修改Method的实现。前面的消息转发很强大，但是需要能够修改对应类的源码，但是对于有些类无法修改其源码时又要更改其方法实现时可以使用Method Swizzling，通过重新映射方法来达到目的，但是跟消息转发比起来调试会困难。</p><h3 id="4-5-1-使用method-swizzling需要注意的问题"><a href="#4-5-1-使用method-swizzling需要注意的问题" class="headerlink" title="4.5.1 使用method swizzling需要注意的问题"></a>4.5.1 使用method swizzling需要注意的问题</h3><ul><li>Swizzling应该总在+load中执行：objectivec在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用，和+initialize比较+load能保证在类的初始化过程中被加载。</li><li>Swizzling应该总是在dispatch_once中执行：swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为method swizzling的最佳实践。</li><li>Selector，Method和Implementation：这几个之间关系可以这样理解，一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个Method，其中key是一个特定的名称，及SEL，与其对应的实现是IMP即指向底层C函数的指针。</li></ul><h3 id="4-5-2-实现一"><a href="#4-5-2-实现一" class="headerlink" title="4.5.2 实现一"></a>4.5.2 实现一</h3><p>举例说明如何使用Method Swizzling对一个类中注入一些我们的新的操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">          <span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line">          <span class="comment">// Class class = object_getClass((id)self);</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//通过method swizzling修改了UIViewController的@selector(viewWillAppear:)的指针使其指向了自定义的xxx_viewWillAppear</span></span><br><span class="line">          SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">          SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</span><br><span class="line"></span><br><span class="line">          Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">          Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">               originalSelector,</span><br><span class="line">               method_getImplementation(swizzledMethod),</span><br><span class="line">               method_getTypeEncoding(swizzledMethod));</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//如果类中不存在要替换的方法，就先用class_addMethod和class_replaceMethod函数添加和替换两个方法实现。但如果已经有了要替换的方法，就调用method_exchangeImplementations函数交换两个方法的Implementation。</span></span><br><span class="line">          <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">               class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                    swizzledSelector,</span><br><span class="line">                    method_getImplementation(originalMethod),</span><br><span class="line">               method_getTypeEncoding(originalMethod));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Method Swizzling</span></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">     [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;viewWillAppear: %@&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>method_exchangeImplementations做的事情和如下代码是一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMP imp1 = <span class="built_in">method_getImplementation</span>(m1);</span><br><span class="line">IMP imp2 = <span class="built_in">method_getImplementation</span>(m2);</span><br><span class="line"><span class="built_in">method_setImplementation</span>(m1, imp2);</span><br><span class="line"><span class="built_in">method_setImplementation</span>(m2, imp1);</span><br></pre></td></tr></table></figure><h3 id="4-5-3-实现二"><a href="#4-5-3-实现二" class="headerlink" title="4.5.3 实现二"></a>4.5.3 实现二</h3><p>另一种Method Swizzling的实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">     SEL originalSelector = <span class="keyword">@selector</span>(ReceiveMessage:);</span><br><span class="line">     SEL overrideSelector = <span class="keyword">@selector</span>(replacementReceiveMessage:);</span><br><span class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector);</span><br><span class="line">     Method overrideMethod = class_getInstanceMethod(<span class="keyword">self</span>, overrideSelector);</span><br><span class="line">     <span class="keyword">if</span> (class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod))) &#123;</span><br><span class="line">          class_replaceMethod(<span class="keyword">self</span>, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          method_exchangeImplementations(originalMethod, overrideMethod);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)replacementReceiveMessage:(<span class="keyword">const</span> <span class="keyword">struct</span> BInstantMessage *)arg1 &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;arg1 is %@&quot;</span>, arg1);</span><br><span class="line">     [<span class="keyword">self</span> replacementReceiveMessage:arg1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个关于Method Swizzling的资源可以参考</p><ul><li><a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling">How do I implement method swizzling?</a></li><li><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a></li><li><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objectivec">What are the Dangers of Method Swizzling in Objective C?</a></li><li><a href="https://github.com/rentzsch/jrswizzle">JRSwizzle</a></li></ul><h1 id="五、Category和Protocol"><a href="#五、Category和Protocol" class="headerlink" title="五、Category和Protocol"></a>五、Category和Protocol</h1><h2 id="5-1-分类Category"><a href="#5-1-分类Category" class="headerlink" title="5.1 分类Category"></a>5.1 分类Category</h2><h3 id="5-1-1-分类概述"><a href="#5-1-1-分类概述" class="headerlink" title="5.1.1 分类概述"></a>5.1.1 分类概述</h3><p>category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html">1</a></p><ul><li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。</li><li>声明私有方法</li></ul><p>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p><ul><li>模拟多继承</li><li>把framework的私有方法公开</li></ul><p>Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。</p><h3 id="5-1-2-category-t结构和Category"><a href="#5-1-2-category-t结构和Category" class="headerlink" title="5.1.2 category_t结构和Category"></a>5.1.2 category_t结构和Category</h3><p>指向分类的结构体的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 是指 class_name 而不是 category_name</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;    <span class="comment">// 指向扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到对应的类对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span> <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>    <span class="comment">// 类方法列表，Meta Class方法列表的子集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>     <span class="comment">// 分类所实现的协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span>  <span class="comment">// category中添加的所有属性</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> *<span class="title">Category</span>;</span></span><br></pre></td></tr></table></figure><p>从category的定义也可以看出category的：</p><ul><li>可为 (可以添加实例方法，类方法，甚至可以实现协议，添加属性(属性添加、使用，编译是能通过的，运行会crash))</li><li>不可为 (无法添加实例变量）<ul><li>编译后的类已经注册在runtime中，类结构体中的 ivars (实例变量的链表) 和 instance_size (实例变量的内存大小) 已经确定。</li><li>category_t 中并没有空间来存放类的成员变量Ivar。</li></ul></li></ul><p>Category里面的方法加载过程，objc源码中找到objc-os.mm，函数<code>_objc_init</code>就是runtime的加载入口由libSystem调用，开始初始化，之后objc-runtime-new.mm里的map_images会加载map到内存，<code>_read_images</code>开始初始化这个map，这时会load所有Class，Protocol和Category，NSObject的+load方法就是这个时候调用的。</p><h3 id="5-1-3-示例：分类的编译"><a href="#5-1-3-示例：分类的编译" class="headerlink" title="5.1.3 示例：分类的编译"></a>5.1.3 示例：分类的编译</h3><p>Lender+TT.h</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Lender.h&quot;</span></span></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Lender</span> (<span class="title">TT</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * lxyname;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>Lender+TT.m</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Lender+TT.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Lender</span> (<span class="title">TT</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;xxxxxxxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用clang的命令去看看category到底会变成什么(主要是看一下分类中的属性底层是什么)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT __attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(_objc_method),</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#123;&#123;(struct objc_selector *)<span class="string">&quot;test&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (<span class="keyword">void</span> *)_I_Lender_TT_test&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Lender_$_TT __attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">_prop_t</span>),</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#123;&#123;<span class="string">&quot;lxyname&quot;</span>,<span class="string">&quot;T@\&quot;NSString\&quot;,&amp;,N&quot;</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> <span class="title">OBJC_CLASS_</span>$_<span class="title">Lender</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_Lender_</span>$_<span class="title">TT</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>,__<span class="title">objc_const</span>&quot;))) =</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;Lender&quot;</span>,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_Lender,</span></span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_Lender_$_TT,  <span class="comment">//属性列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时期给分类结构的.cls赋值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CATEGORY_SETUP_$_Lender_$_TT(<span class="keyword">void</span> ) &#123;</span><br><span class="line">_OBJC_$_CATEGORY_Lender_$_TT.cls = &amp;OBJC_CLASS_$_Lender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.objc_inithooks$B&quot;</span>, long, read, write)</span></span><br><span class="line">__declspec(<span class="built_in">allocate</span>(<span class="string">&quot;.objc_inithooks$B&quot;</span>)) <span class="keyword">static</span> <span class="keyword">void</span> *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">(<span class="keyword">void</span> *)&amp;OBJC_CATEGORY_SETUP_$_Lender_$_TT,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>&quot;)))=</span> &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_Lender_$_TT,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到：</p><ol><li><p>首先编译器生成了实例方法列表 <code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT</code> 和属性列表 <code>_OBJC_$_PROP_LIST_Lender_$_TT</code>，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在 <code>TT</code> 这个category里面写的方法 <code>test</code>，而属性列表里面填充的也正是我们在 <code>TT</code> 里添加的 <code>lxyname</code> 属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。</p></li><li><p>其次，编译器生成了category本身 <code>_OBJC_$_CATEGORY_Lender_$_TT</code>，并用前面生成的列表来初始化category本身。</p></li><li><p>最后，编译器在<strong>DATA segment(段)下的objc_catlist section(节)</strong> 里保存了一个大小为1的category_t的数组<code>L_OBJC_LABEL_CATEGORY_$</code>（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。</p></li></ol><h3 id="5-1-4-分类的运行时处理"><a href="#5-1-4-分类的运行时处理" class="headerlink" title="5.1.4 分类的运行时处理"></a>5.1.4 分类的运行时处理</h3><p>见<a href="https://tenloy.github.io/2021/09/28/dyld-objc.html#4-2-loadAllCategories-%E5%88%86%E7%B1%BB%E5%8A%A0%E8%BD%BD">dyld与Objc—_objc_init、map_images、load_images的4.2小节：分类的加载</a></p><h2 id="5-2-类扩展-Extension"><a href="#5-2-类扩展-Extension" class="headerlink" title="5.2 类扩展(Extension)"></a>5.2 类扩展(Extension)</h2><p>extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见官方文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html">Customizing Existing Classes</a>）</p><p>但是category则完全不一样，它是在运行期决议的。 就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p><h2 id="5-3-Protocol"><a href="#5-3-Protocol" class="headerlink" title="5.3 Protocol"></a>5.3 Protocol</h2><p>Protocol其实就是一个对象结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">Protocol</span>;</span></span><br></pre></td></tr></table></figure><h2 id="5-4-操作函数"><a href="#5-4-操作函数" class="headerlink" title="5.4 操作函数"></a>5.4 操作函数</h2><h3 id="5-4-1-Category操作函数"><a href="#5-4-1-Category操作函数" class="headerlink" title="5.4.1 Category操作函数"></a>5.4.1 Category操作函数</h3><p>Category操作函数信息都包含在objc_class中，我们可以通过objc_class的操作函数来获取分类的操作函数信息。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method1 &#123;&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123;&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;测试objc_class中的方法列表是否包含分类中的方法&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">Method *methodList = class_copyMethodList(RuntimeCategoryClass.class, &amp;outCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">     Method method = methodList[i];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_getName(method_getName(method));</span><br><span class="line"></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;RuntimeCategoryClass&#x27;s method: %s&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (strcmp(name, sel_getName(<span class="keyword">@selector</span>(method2)))) &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;分类方法method2在objc_class的方法列表中&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.213</span> [<span class="number">561</span>:<span class="number">151847</span>] 测试objc_class中的方法列表是否包含分类中的方法</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.215</span> [<span class="number">561</span>:<span class="number">151847</span>] RuntimeCategoryClass<span class="string">&#x27;s method: method2</span></span><br><span class="line"><span class="string">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass&#x27;</span>s method: method1</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.215</span> [<span class="number">561</span>:<span class="number">151847</span>] 分类方法method2在objc_class的方法列表中</span><br></pre></td></tr></table></figure><h3 id="5-4-2-Protocol操作函数"><a href="#5-4-2-Protocol操作函数" class="headerlink" title="5.4.2 Protocol操作函数"></a>5.4.2 Protocol操作函数</h3><p>Runtime提供了Protocol的一系列函数操作，函数包括：</p><h4 id="1-获取协议"><a href="#1-获取协议" class="headerlink" title="1. 获取协议"></a>1. 获取协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定的协议</span></span><br><span class="line"><span class="function">Protocol *<span class="title">objc_getProtocol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></span><br><span class="line"><span class="function">Protocol **<span class="title">objc_copyProtocolList</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="2-查询协议的信息"><a href="#2-查询协议的信息" class="headerlink" title="2. 查询协议的信息"></a>2. 查询协议的信息</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回协议名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">protocol_getName</span><span class="params">(Protocol *proto)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试两个协议是否相等</span></span><br><span class="line"><span class="function">BOOL <span class="title">protocol_isEqual</span><span class="params">(Protocol *self, Protocol *other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定条件的方法描述数组</span></span><br><span class="line"><span class="function">struct objc_method_description *<span class="title">protocol_copyMethodDescriptionList</span><span class="params">(Protocol *p, </span></span></span><br><span class="line"><span class="function"><span class="params">                                   BOOL isRequiredMethod,BOOL isInstanceMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></span><br><span class="line"><span class="function">struct objc_method_description <span class="title">protocol_getMethodDescription</span><span class="params">(Protocol *p, SEL aSel, </span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredMethod, BOOL isInstanceMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中的属性列表</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">protocol_copyPropertyList</span><span class="params">(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议的指定属性</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">protocol_getProperty</span><span class="params">(Protocol *p, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br><span class="line"><span class="comment">// 获取协议遵守的协议</span></span><br><span class="line"><span class="function">Protocol ** <span class="title">protocol_copyProtocolList</span><span class="params">(Protocol *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看协议是否遵守了另一个协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">protocol_conformsToProtocol</span><span class="params">(Protocol *self, Protocol *other)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-动态创建协议"><a href="#3-动态创建协议" class="headerlink" title="3. 动态创建协议"></a>3. 动态创建协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新的协议实例</span></span><br><span class="line"><span class="function">Protocol *<span class="title">objc_allocateProtocol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addMethodDescription</span><span class="params">(Protocol *proto_gen, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredMethod, BOOL isInstanceMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加属性 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addProperty</span><span class="params">(Protocol *proto_gen, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attrs, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加一个已注册的协议。proto必须正在构造中。addition则不能，必须是已注册的。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addProtocol</span><span class="params">(Protocol *proto, Protocol *addition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时中注册新创建的协议。</span></span><br><span class="line"><span class="comment">// 创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerProtocol</span><span class="params">(Protocol *proto_gen)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="六、Block"><a href="#六、Block" class="headerlink" title="六、Block"></a>六、Block</h1><p>runtime中一些支持block操作的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></span><br><span class="line"><span class="function">IMP <span class="title">imp_implementationWithBlock</span><span class="params">(id block)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></span><br><span class="line"><span class="function">id <span class="title">imp_getBlock</span><span class="params">(IMP anImp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></span><br><span class="line"><span class="function">BOOL <span class="title">imp_removeBlock</span><span class="params">(IMP anImp)</span></span>;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyRuntimeBlock</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyRuntimeBlock</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">IMP imp = imp_implementationWithBlock(^(<span class="keyword">id</span> obj, <span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, str);</span><br><span class="line">&#125;);</span><br><span class="line">class_addMethod(MyRuntimeBlock.class, <span class="keyword">@selector</span>(testBlock:), imp, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];</span><br><span class="line">[runtime performSelector:<span class="keyword">@selector</span>(testBlock:) withObject:<span class="string">@&quot;hello world!&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">14</span>:<span class="number">03</span>:<span class="number">19.779</span> [<span class="number">1172</span>:<span class="number">395446</span>] hello world!</span><br></pre></td></tr></table></figure><h1 id="七、Runtime的应用"><a href="#七、Runtime的应用" class="headerlink" title="七、Runtime的应用"></a>七、Runtime的应用</h1><h2 id="7-1-获取系统提供的库相关信息"><a href="#7-1-获取系统提供的库相关信息" class="headerlink" title="7.1 获取系统提供的库相关信息"></a>7.1 获取系统提供的库相关信息</h2><p>主要函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有加载的objectivec框架和动态库的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">objc_copyImageNames</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定类所在动态库</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">class_getImageName</span><span class="params">(Class cls)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">objc_copyClassNamesForImage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure><p>示例：通过这些函数获取某个类所有的库，以及某个库中包含哪些类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;获取指定类所在动态库&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;UIView&#x27;s Framework: %s&quot;</span>, <span class="built_in">class_getImageName</span>(<span class="built_in">NSClassFromString</span>(@<span class="string">&quot;UIView&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;获取指定库或框架中所有类的类名&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** classes = <span class="built_in">objc_copyClassNamesForImage</span>(<span class="built_in">class_getImageName</span>(<span class="built_in">NSClassFromString</span>(@<span class="string">&quot;UIView&quot;</span>)), &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(@<span class="string">&quot;class name: %s&quot;</span>, classes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.689</span> [<span class="number">7</span>:<span class="number">1</span>] 获取指定类所在动态库</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.690</span> [<span class="number">7</span>:<span class="number">1</span>] UIView<span class="number">&#x27;</span>s Framework: /System/Library/Frameworks/UIKit.framework/UIKit</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.690</span> [<span class="number">7</span>:<span class="number">1</span>] 获取指定库或框架中所有类的类名</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> UIKeyboardPredictiveSettings</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewTopFrame</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIOnePartImageView</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewSelectionBar</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerWheelView</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewTestParameters</span><br></pre></td></tr></table></figure><h2 id="7-2-对App的用户行为进行追踪"><a href="#7-2-对App的用户行为进行追踪" class="headerlink" title="7.2 对App的用户行为进行追踪"></a>7.2 对App的用户行为进行追踪</h2><p>就是用户点击时把事件记录下来。一般比较做法就是在viewDidAppear里记录事件，这样会让这样记录事件的代码遍布整个项目中。继承或类别也会有问题。这时利用Method Swizzling把一个方法的实现和另一个方法的实现进行替换。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义一个类别，添加要Swizzled的方法</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Logging</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)swizzled_viewDidAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123; <span class="comment">// call original implementation</span></span><br><span class="line">     [<span class="keyword">self</span> swizzled_viewDidAppear:animated]; <span class="comment">// Logging</span></span><br><span class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来实现swizzle方法</span></span><br><span class="line"><span class="keyword">void</span> swizzleMethod(Class <span class="keyword">class</span>, SEL originalSelector, SEL swizzledSelector) &#123; <span class="comment">// the method might not exist in the class, but in its superclass</span></span><br><span class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">     Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector); <span class="comment">// class_addMethod will fail if original method already exists</span></span><br><span class="line">     <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); <span class="comment">// the method doesn’t exist and we just added one</span></span><br><span class="line">     <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">          class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后要确保在程序启动的时候调用swizzleMethod方法在之前的UIViewController的Logging类别里添加+load:方法，然后在+load:里把viewDidAppear替换掉</span></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">     swizzleMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidAppear:), <span class="keyword">@selector</span>(swizzled_viewDidAppear:));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更简化直接用新的IMP取代原IMP，不是替换，只需要有全局的函数指针指向原IMP即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (gOriginalViewDidAppear)(id, SEL, BOOL);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newViewDidAppear</span><span class="params">(UIViewController *self, SEL _cmd, BOOL animated)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// call original implementation</span></span><br><span class="line">     <span class="built_in">gOriginalViewDidAppear</span>(self, _cmd, animated); <span class="comment">// Logging</span></span><br><span class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([self class])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">     Method originalMethod = <span class="built_in">class_getInstanceMethod</span>(self, @<span class="built_in">selector</span>(viewDidAppear:));</span><br><span class="line">     gOriginalViewDidAppear = (<span class="keyword">void</span> *)<span class="built_in">method_getImplementation</span>(originalMethod);</span><br><span class="line">     <span class="keyword">if</span>(!<span class="built_in">class_addMethod</span>(self, @<span class="built_in">selector</span>(viewDidAppear:), (IMP) newViewDidAppear, <span class="built_in">method_getTypeEncoding</span>(originalMethod))) &#123;</span><br><span class="line">          <span class="built_in">method_setImplementation</span>(originalMethod, (IMP) newViewDidAppear);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Method Swizzling可以把事件代码或Logging，Authentication，Caching等跟主要业务逻辑代码解耦。这种处理方式叫做<a href="http://en.wikipedia.org/wiki/Cross-cutting_concern">Cross Cutting Concerns</a>。</p><p>用Method Swizzling动态给指定的方法添加代码解决Cross Cutting Concerns的编程方式叫<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect Oriented Programming</a>。</p><p>目前有些第三方库可以很方便的使用AOP，比如<a href="https://github.com/steipete/Aspects">Aspects</a>。这里是使用<a href="https://github.com/okcomp/AspectsDemo">Aspects的范例</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;内容骨架来自戴铭老师文章&lt;a href=&quot;https://ming1016.github.io/2015/04/01/objc-runtime/&quot;&gt;Objc Runtime 总结&lt;/a&gt;，因为发布有些久远，一些内容已经过时，修正了一下，并填充了一些</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>(七) dyld与Objc—_objc_init、map_images、load_images</title>
    <link href="https://tenloy.github.io/2021/09/28/dyld-objc.html"/>
    <id>https://tenloy.github.io/2021/09/28/dyld-objc.html</id>
    <published>2021-09-28T14:26:09.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前文回顾"><a href="#一、前文回顾" class="headerlink" title="一、前文回顾"></a>一、前文回顾</h2><p>上一篇<a href="https://tenloy.github.io/2021/09/27/compile-dynamic-link.html">(六) Mach-O 文件的动态链接、库、Dyld(含dlopen)</a>，大概梳理了dyld的加载流程，这一次主要展开<strong>“第八步 执行初始化方法”</strong>，其是我们日常紧密接触的OBJC Runtime初始化启动的上文。</p><p>先简单回顾一下Runtime的初始化之前的流程：</p><ol><li>内核XNU加载Mach-O</li><li>从XNU内核态将控制权转移到dyld用户态</li><li>dyld：<ol><li>设置运行环境</li><li>实例化ImageLoader加载所需的动态库、并进行链接(符号绑定、重定位)。每个image对应一个ImageLoader实例</li><li>进行images的初始化：先初始化动态库，再初始化可执行文件。这步过程中，<strong>Runtime会向dyld中注册回调函数。dyld会在每个image加载、初始化、移除时分别调用Runtime的回调函数：map_images、load_images、unmap_images</strong>. </li><li>最后找到主程序的入口main()函数并返回。</li></ol></li></ol><p>可以在程序中，通过符号断点的形式<code>Debug → breakpoints → create symbolic breakpoint</code>来看这几个函数的调用堆栈：</p><p>添加符号断点：</p><img src="/images/compilelink/35.png" alt="35" style="zoom:90%;" /><p>load_images的调用堆栈(之一)：</p><img src="/images/compilelink/31.png" alt="35" style="zoom:90%;" /><p>在进入 <code>libobjc</code> 之前，我们必须要先了解 OC 中类的底层结构，可以先阅读<a href="https://tenloy.github.io/2021/10/11/runtime-data-structure.html">下篇</a>(如果已经熟悉，那略过)。</p><h2 id="二、-objc-init"><a href="#二、-objc-init" class="headerlink" title="二、_objc_init()"></a>二、_objc_init()</h2><p>通过方法的文档注释，可以大概了解它的作用：启动初始化，注册dyld中image相关的回调通知，由libSystem在库(image)的初始化之前调用。</p><h3 id="2-1-objc-init-源码实现"><a href="#2-1-objc-init-源码实现" class="headerlink" title="2.1 _objc_init()源码实现"></a>2.1 _objc_init()源码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// runtime环境的各种初始化</span></span><br><span class="line">    <span class="built_in">environ_init</span>();   <span class="comment">// 环境变量初始化。读取影响运行时的环境变量。如果需要，还可以打印环境变量</span></span><br><span class="line">    <span class="built_in">tls_init</span>();       <span class="comment">// 关于线程key的绑定，如线程的析构函数</span></span><br><span class="line">    <span class="built_in">static_init</span>();    <span class="comment">// 运行C++静态构造函数</span></span><br><span class="line">    <span class="built_in">runtime_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>(); <span class="comment">// 初始化libobjc的异常处理系统，由map_images()调用。</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::<span class="built_in">init</span>();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化 trampoline machinery。通常这什么都不做，因为一切都是惰性初始化的，但对于某些进程，我们会主动加载 trampolines dylib。</span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册dyld事件的监听，监听每个image(动态库、可执行文件)的加载</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// runtime 监听到dyld中image加载后，调用 map_images 做解析和处理，至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理，在这之后，runtime 的那些方法（动态添加 Class、swizzle 等等才能生效）</span></span><br><span class="line">    <span class="comment">// 接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-tls-init"><a href="#2-2-tls-init" class="headerlink" title="2.2 tls_init()"></a>2.2 tls_init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程局部/本地存储(Thread Local Storage, TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。</span></span><br><span class="line"><span class="comment">// 线程私有数据(Thread Specific Data, TSD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// objc&#x27;s key for pthread_getspecific</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _objc_pthread_key TLS_DIRECT_KEY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">tls_key_t</span> _objc_pthread_key;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> tls init：线程本地存储的初始化。</span></span><br><span class="line"><span class="comment"> _objc_pthread_destroyspecific 是线程的销毁函数。以 TLS_DIRECT_KEY 为 Key，在线程的本地存储空间中保存线程对应对销毁函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="built_in">pthread_key_init_np</span>(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = <span class="built_in">tls_create</span>(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_key_init_np</code> 是属于 <code>libpthread</code> 库中的方法了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 为静态键设置析构函数，因为它不是用pthread_key_create()创建的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_init_np</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分配用于表示进程中线程特定数据的键，键对进程中的所有线程来说是全局的。</span></span><br><span class="line"><span class="comment"> * 创建线程特定数据时，所有线程最初都具有与该键关联的NULL值。</span></span><br><span class="line"><span class="comment"> * @param key 指向从进程中已分配的键</span></span><br><span class="line"><span class="comment"> * @param destructor 指向析构函数，destuctor的形参是线程与键关联的数据。在线程终止时调用该函数，以达到释放内存的目的</span></span><br><span class="line"><span class="comment"> * @return 成功返回0.其他任何返回值都表示出现了错误。如果出现下列任一情况，pthread_key_create()将失败并返回相应的值</span></span><br><span class="line"><span class="comment">       EAGAIN：key名称空间已用完</span></span><br><span class="line"><span class="comment">       ENOMEM：此进程中虚拟内存不足，无法创建新键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-runtime-init"><a href="#2-3-runtime-init" class="headerlink" title="2.3 runtime_init()"></a>2.3 runtime_init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> objc &#123;</span><br><span class="line">  <span class="comment">// 主要用来为类统计分类、追加分类到类、清除分类数据、清除类数据。</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">UnattachedCategories</span> :</span> <span class="keyword">public</span> ExplicitInitDenseMap&lt;Class, category_list&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> UnattachedCategories unattachedCategories; </span><br><span class="line">  <span class="comment">// allocatedClasses 是已使用 objc_allocateClassPair allocated 过的所有类（和元类）的表</span></span><br><span class="line">  <span class="keyword">static</span> ExplicitInitDenseSet&lt;Class&gt; allocatedClasses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runtime_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc::unattachedCategories.<span class="built_in">init</span>(<span class="number">32</span>); <span class="comment">// 初始化分类的存储容器, 是Map</span></span><br><span class="line">    objc::allocatedClasses.<span class="built_in">init</span>(); <span class="comment">// 初始化类的存储容器，是Set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-cache-t-init"><a href="#2-4-cache-t-init" class="headerlink" title="2.4 cache_t::init()"></a>2.4 cache_t::init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/restartable.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述用户空间的可恢复范围</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">mach_vm_address_t</span> location;     <span class="comment">// 指向可重启动section开头的指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>    length;       <span class="comment">// 锚定在location的section的长度</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>    recovery_offs;<span class="comment">// 应该用于恢复的初始位置的偏移量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>      flags;</span><br><span class="line">&#125; <span class="keyword">task_restartable_range_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TASK_RESTARTABLE_RANGES</span></span><br><span class="line">  <span class="comment">// mach_msg_type_number_t 当前是 unsigned int 的别名，定义别名利于不同的平台做兼容</span></span><br><span class="line">  <span class="keyword">mach_msg_type_number_t</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// kern_return_t 当前是 int 的别名</span></span><br><span class="line">  <span class="keyword">kern_return_t</span> kr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计objc_restartableRanges数组中location成员值不为空的task_restartable_range_t的数量</span></span><br><span class="line">  <span class="keyword">while</span> (objc_restartableRanges[count].location) &#123;</span><br><span class="line">      count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为当前任务注册一组可重启范围。Register a set of restartable ranges for the current task.</span></span><br><span class="line">  kr = <span class="built_in">task_restartable_ranges_register</span>(<span class="built_in">mach_task_self</span>(),</span><br><span class="line">                                        objc_restartableRanges, count);</span><br><span class="line">  <span class="keyword">if</span> (kr == KERN_SUCCESS) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册失败则停止运行</span></span><br><span class="line">  _objc_fatal(<span class="string">&quot;task_restartable_ranges_register failed (result 0x%x: %s)&quot;</span>,</span><br><span class="line">              kr, <span class="built_in">mach_error_string</span>(kr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HAVE_TASK_RESTARTABLE_RANGES</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局搜索 <code>objc_restartableRanges</code> 可看到，在 <code>_collecting_in_critical</code> 函数中有看到有对其的遍历读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">▼ <span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/* 第一次申请或扩容；扩容时，会清空现有数据. 扩容系数不同平台有3/4、7/8 */</span></span></span><br><span class="line">  ▼ void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity, bool freeOld);</span><br><span class="line">  <span class="comment">// 或 void cache_t::eraseNolock(const char *func); // 将整个缓存重置为未缓存查找</span></span><br><span class="line">    <span class="comment">/* 将指定的malloc的内存添加到稍后要释放的内存列表中。</span></span><br><span class="line"><span class="comment">       size用于收集的阈值。它不必精确地与块的大小相同。*/</span></span><br><span class="line">    ▼ <span class="function"><span class="keyword">void</span> <span class="title">cache_t::collect_free</span><span class="params">(<span class="keyword">bucket_t</span> *data, <span class="keyword">mask_t</span> capacity)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* 尝试释放累积的失效缓存. collectALot更努力地释放内存 */</span></span></span><br><span class="line">      ▼ void cache_t::collectNolock(bool collectALot); </span><br><span class="line">          <span class="comment">/* 用于判断当前是否可以对旧的方法缓存（扩容后的旧的方法缓存表）进行收集释放</span></span><br><span class="line"><span class="comment">             返回 true 表示objc_msgSend（或其他缓存读取器(cache reader)）当前正在缓存中查找，并</span></span><br><span class="line"><span class="comment">             且可能仍在使用某些garbage。返回 false 的话表示 garbage 中的 bucket_t 没有被在使用。</span></span><br><span class="line"><span class="comment">             即当前有其它线程正在读取使用我们的旧的方法缓存表时，此时不能对旧的方法缓存表进行内存释放*/</span></span><br><span class="line">        ▼ <span class="keyword">static</span> <span class="keyword">int</span> _collecting_in_critical(<span class="keyword">void</span>);  <span class="comment">//(critical 危急的；临界的；关键的)</span></span><br></pre></td></tr></table></figure><h3 id="2-5-dyld-objc-notify-register"><a href="#2-5-dyld-objc-notify-register" class="headerlink" title="2.5 _dyld_objc_notify_register()"></a>2.5 _dyld_objc_notify_register()</h3><p><code>_dyld_objc_notify_register</code> 函数仅供 objc runtime 使用，注册当 mapped、unmapped 和 initialized objc images 时要调用的处理程序。Dyld 将使用包含 <code>objc-image-info</code> section 的 images 数组回调 <code>mapped</code> 函数。</p><blockquote><p>在iOS 13系统中，iOS将全面采用新的dyld 3以替代之前版本的dyld 2。dyld 3带来了可观的性能提升，减少了APP的启动时间。</p></blockquote><p>在 dyld3 中，<code>_dyld_objc_notify_register</code> 函数的实现逻辑有一些改变，此处不再赘述了。</p><ul><li>map_images : dyld 将 image 加载进内存时 , 会触发该函数进行image的一些处理：如果是首次，初始化执行环境等，之后<code>_read_images</code>进行读取，进行类、元类、方法、协议、分类的一些加载。</li><li>load_images : dyld 初始化 image 会触发该方法，进行+load的调用</li><li>unmap_image : dyld 将 image 移除时 , 会触发该函数</li></ul><h2 id="三、map-images"><a href="#三、map-images" class="headerlink" title="三、map_images()"></a>三、map_images()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped(映射、加载) in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_images</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rwlock_writer_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map_images_nolock</span>(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-map-images-nolock"><a href="#3-1-map-images-nolock" class="headerlink" title="3.1 map_images_nolock()"></a>3.1 map_images_nolock()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理由dyld映射的给定图像。</span></span><br><span class="line"><span class="comment"> * 执行所有的类注册和修复(或延迟查找丢失的超类等)，并调用+load方法。</span></span><br><span class="line"><span class="comment"> * Info[]是自底向上的顺序，即libobjc将在数组中比任何链接到libobjc的库更早。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_images_nolock</span><span class="params">(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部静态变量，表示第一次调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> firstTime = YES;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hList 是统计 mhdrs 中的每个 mach_header 对应的 header_info</span></span><br><span class="line">    header_info *hList[mhCount];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> hCount;</span><br><span class="line">    <span class="keyword">size_t</span> selrefCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如有必要，执行首次初始化。</span></span><br><span class="line">    <span class="comment">// 此函数在 ordinary library 初始化程序之前调用。</span></span><br><span class="line">    <span class="comment">// 延迟初始化，直到找到使用 objc 的图像</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是第一次加载，则准备初始化环境</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        <span class="built_in">preopt_init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启 OBJC_PRINT_IMAGES 环境变量时，启动时则打印 images 数量。</span></span><br><span class="line">    <span class="comment">// 如：objc[10503]: IMAGES: processing 296 newly-mapped images... </span></span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: processing %u newly-mapped images...\n&quot;</span>, mhCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all images with Objective-C metadata.</span></span><br><span class="line">    hCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 class 的数量。根据总数调整各种表格的大小。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> totalClasses = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> unoptimizedTotalClasses = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> i = mhCount;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// typedef struct mach_header_64 headerType;</span></span><br><span class="line">            <span class="comment">// 取得指定 image 的 header 指针</span></span><br><span class="line">            <span class="keyword">const</span> headerType *mhdr = (<span class="keyword">const</span> headerType *)mhdrs[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 以 mdr 构建其 header_info，并添加到全局的 header 列表中（是一个链表，大概看源码到现在还是第一次看到链表的使用）。</span></span><br><span class="line">            <span class="comment">// 且通过 GETSECT(_getObjc2ClassList, classref_t const, &quot;__objc_classlist&quot;); 读取 __objc_classlist 区中的 class 数量添加到 totalClasses 中，</span></span><br><span class="line">            <span class="comment">// 以及未从 dyld shared cache 中找到 mhdr 的 header_info 时，添加 class 的数量到 unoptimizedTotalClasses 中。</span></span><br><span class="line">            <span class="keyword">auto</span> hi = <span class="built_in">addHeader</span>(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里有两种情况下 hi 为空：</span></span><br><span class="line">            <span class="comment">// 1. mhdr 的 magic 不是既定的 MH_MAGIC、MH_MAGIC_64、MH_CIGAM、MH_CIGAM_64 中的任何一个</span></span><br><span class="line">            <span class="comment">// 2. 从 dyld shared cache 中找到了 mhdr 的 header_info，并且 isLoaded 为 true（）</span></span><br><span class="line">            <span class="keyword">if</span> (!hi) &#123;</span><br><span class="line">                <span class="comment">// no objc data in this entry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// #define MH_EXECUTE 0x2 /* demand paged executable file demand 分页可执行文件 */ </span></span><br><span class="line">            <span class="keyword">if</span> (mhdr-&gt;filetype == MH_EXECUTE) &#123;</span><br><span class="line">                <span class="comment">// Size some data structures based on main executable&#x27;s size</span></span><br><span class="line">                <span class="comment">// 根据主要可执行文件的大小调整一些数据结构的大小</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">size_t</span> count;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ⬇️ GETSECT(_getObjc2SelectorRefs, SEL, &quot;__objc_selrefs&quot;);</span></span><br><span class="line">                <span class="comment">// 获取 __objc_selrefs 区中的 SEL 的数量</span></span><br><span class="line">                _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">                selrefCount += count;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// GETSECT(_getObjc2MessageRefs, message_ref_t, &quot;__objc_msgrefs&quot;); </span></span><br><span class="line">                <span class="comment">// struct message_ref_t &#123;</span></span><br><span class="line">                <span class="comment">//     IMP imp;</span></span><br><span class="line">                <span class="comment">//     SEL sel;</span></span><br><span class="line">                <span class="comment">// &#125;;</span></span><br><span class="line">                <span class="comment">// ⬇️ 获取 __objc_msgrefs 区中的 message 数量</span></span><br><span class="line">                _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">                selrefCount += count;</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            hList[hCount++] = hi;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">                <span class="comment">// 打印 image 信息</span></span><br><span class="line">                <span class="comment">// 如：objc[10565]: IMAGES: loading image for /usr/lib/system/libsystem_blocks.dylib (has class properties) (preoptimized)</span></span><br><span class="line">                _objc_inform(<span class="string">&quot;IMAGES: loading image for %s%s%s%s%s\n&quot;</span>, </span><br><span class="line">                             hi-&gt;<span class="built_in">fname</span>(),</span><br><span class="line">                             mhdr-&gt;filetype == MH_BUNDLE ? <span class="string">&quot; (bundle)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">isReplacement</span>() ? <span class="string">&quot; (replacement)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>() ? <span class="string">&quot; (has class properties)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">optimizedByDyld</span>()?<span class="string">&quot; (preoptimized)&quot;</span>:<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⬇️⬇️⬇️</span></span><br><span class="line">    <span class="comment">// Perform one-time runtime initialization that must be deferred until the executable itself is found. </span></span><br><span class="line">    <span class="comment">// 执行 one-time runtime initialization，必须推迟到找到可执行文件本身。</span></span><br><span class="line">    <span class="comment">// This needs to be done before further initialization.</span></span><br><span class="line">    <span class="comment">// 这需要在进一步初始化之前完成。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The executable may not be present in this infoList if the executable does not contain</span></span><br><span class="line">    <span class="comment">// Objective-C code but Objective-C is dynamically loaded later.</span></span><br><span class="line">    <span class="comment">// 如果可执行文件不包含 Objective-C 代码但稍后动态加载 Objective-C，则该可执行文件可能不会出现在此 infoList 中。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        <span class="comment">// 初始化 selector 表并注册内部使用的 selectors。</span></span><br><span class="line">        <span class="built_in">sel_init</span>(selrefCount);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ⬇️⬇️⬇️ 这里的 arr_init 函数超重要，可看到它内部做了三件事：</span></span><br><span class="line">        <span class="comment">// 1. 自动释放池的初始化（实际是在 TLS 中以 AUTORELEASE_POOL_KEY 为 KEY 写入 tls_dealloc 函数（自动释放池的销毁函数：内部所有 pages pop 并 free））</span></span><br><span class="line">        <span class="comment">// 2. SideTablesMap 初始化，也可理解为 SideTables 的初始化（为 SideTables 这个静态全局变量开辟空间）</span></span><br><span class="line">        <span class="comment">// 3. AssociationsManager 的初始化，即为全局使用的关联对象表开辟空间</span></span><br><span class="line">        <span class="comment">// void arr_init(void) </span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     AutoreleasePoolPage::init();</span></span><br><span class="line">        <span class="comment">//     SideTablesMap.init();</span></span><br><span class="line">        <span class="comment">//     _objc_associations_init();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">arr_init</span>();</span><br><span class="line">        </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一段是在较低版本下 DYLD_MACOSX_VERSION_10_13 之前的版本中禁用 +initialize fork safety，大致看看即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app is too old (&lt; 10.13).</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app has a</span></span><br><span class="line">        <span class="comment">//   __DATA,__objc_fork_ok section.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dyld_get_program_sdk_version</span>() &lt; DYLD_MACOSX_VERSION_10_13) &#123;</span><br><span class="line">            DisableInitializeForkSafety = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;INITIALIZE: disabling +initialize fork &quot;</span></span><br><span class="line">                             <span class="string">&quot;safety enforcement because the app is &quot;</span></span><br><span class="line">                             <span class="string">&quot;too old (SDK version &quot;</span> SDK_FORMAT <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                             <span class="built_in">FORMAT_SDK</span>(<span class="built_in">dyld_get_program_sdk_version</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; hCount; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> hi = hList[i];</span><br><span class="line">            <span class="keyword">auto</span> mh = hi-&gt;<span class="built_in">mhdr</span>();</span><br><span class="line">            <span class="keyword">if</span> (mh-&gt;filetype != MH_EXECUTE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">getsectiondata</span>(hi-&gt;<span class="built_in">mhdr</span>(), <span class="string">&quot;__DATA&quot;</span>, <span class="string">&quot;__objc_fork_ok&quot;</span>, &amp;size)) &#123;</span><br><span class="line">                DisableInitializeForkSafety = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;INITIALIZE: disabling +initialize fork &quot;</span></span><br><span class="line">                                 <span class="string">&quot;safety enforcement because the app has &quot;</span></span><br><span class="line">                                 <span class="string">&quot;a __DATA,__objc_fork_ok section&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// assume only one MH_EXECUTE image</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️ 下面就来到了最核心的地方</span></span><br><span class="line">    <span class="comment">// 以 header_info *hList[mhCount] 数组中收集到的 images 的 header_info 为参，直接进行 image 的读取</span></span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把开始时初始化的静态局部变量 firstTime 置为 NO</span></span><br><span class="line">    firstTime = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️</span></span><br><span class="line">    <span class="comment">// _read_images 看完再看下面的 loadImageFuncs 函数  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call image load funcs after everything is set up.</span></span><br><span class="line">    <span class="comment">// 一切设置完毕后调用 image 加载函数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> func : loadImageFuncs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; mhCount; i++) &#123;</span><br><span class="line">            <span class="built_in">func</span>(mhdrs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map_images_nolock</code> 就是：</p><ul><li>对 <code>const struct mach_header * const mhdrs[]</code> 参数的处理，把数组中的 <code>mach_header</code> 转换为 <code>header_info</code> 并存在 <code>header_info *hList[mhCount]</code> 数组中。</li><li>并统计 <code>totalClasses</code> 和 <code>unoptimizedTotalClasses</code> 的数量</li><li>然后调用下面的 <code>_read_images</code> 函数</li></ul><blockquote><p>在阅读_read_images()函数前，先来了解一下class在加载过程都有哪些状态，在objc中以怎样的数据结构来记录的。</p></blockquote><h3 id="3-2-class加载过程中的flag标志"><a href="#3-2-class加载过程中的flag标志" class="headerlink" title="3.2 class加载过程中的flag标志"></a>3.2 class加载过程中的flag标志</h3><p>当调用 runtime API 动态创建类的过程，包括三个步骤：</p><ul><li>调用<code>Class objc_allocateClassPair(...)</code>构建类；</li><li>添加必要的成员变量、方法等元素；</li><li>调用<code>void objc_registerClassPair(Class cls)</code>注册类；</li></ul><p>然而，runtime 从镜像（image）加载类的过程会更加精细，在加载类的不同阶段会被标记为不同的类型（还是<code>objc_class</code>结构体，只是<code>flags</code>不同），例如：</p><ul><li><strong>future class</strong>（未来要解析的类，也称懒加载类）<ul><li>named class（已确定名称类）：将<code>cls</code>标记为 named class，以<code>cls-&gt;mangledName()</code>类名为关键字添加到全局记录的<code>gdb_objc_realized_classes</code>哈希表中，表示 runtime 开始可以通过类名查找类（注意元类不需要添加）；</li><li>allocated class（已分配内存类）：将<code>cls</code>及其元类标记为 allocated class，并将两者均添加到全局记录的<code>allocatedClasses</code>哈希表中（无需关键字），表示已为类分配固定内存空间；</li></ul></li><li><strong>remapped class</strong>（已重映射类）</li><li><strong>realized class</strong>（已认识/实现类）</li><li>loaded class（已加载类）：已执行<code>load</code>方法的类</li><li>initialized class（已初始化类）：已执行<code>initialize()</code>方法的类</li></ul><blockquote><p>realized: adj. 已实现的; v. 意识到，认识到，理解；实现；把（概念等）具体表现出来.</p><p>OC 类在被使用之前（譬如调用类方法），需要进行一系列的初始化，譬如：指定 <code>superclass</code>、指定 <code>isa</code> 指针、<code>attach categories</code> 等等；libobjc 在 runtime 阶段就可以做这些事情，但是有些过于浪费，更好的选择是懒处理，这一举措极大优化了程序的执行速度。而 runtime 把对类的惰性初始化过程称为「realize」。</p><p>利用已经被 <code>realize</code> 的类含有 <code>RW_REALIZED</code> 和 <code>RW_REALIZING</code> 标记的特点，可以为项目找出无用类；因为没有被使用的类，一定没有被 <code>realized</code>。</p></blockquote><h4 id="3-2-1-class-rw-t-gt-flags"><a href="#3-2-1-class-rw-t-gt-flags" class="headerlink" title="3.2.1 class_rw_t-&gt;flags"></a>3.2.1 class_rw_t-&gt;flags</h4><p><code>class_rw_t</code>的<code>flags</code>为可读写。其中比较重要的一些值定义列举如下，均以RW_为前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该类是已实现/已认识/已初始化处理过的类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REALIZED           (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// 该类是尚未解析的unresolved future class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_FUTURE             (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// 该类已经初始化。完成执行initialize()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INITIALIZED        (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">// 该类正在初始化。正在执行initialize()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INITIALIZING       (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">// class_rw_t-&gt;ro是class_ro_t的堆拷贝。此时类的class_rw_t-&gt;ro是可写入的，拷贝之前ro的内存区域锁死不可写入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_COPIED_RO          (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">// class allocated but not yet registered</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_CONSTRUCTING       (1&lt;&lt;26)</span></span><br><span class="line"><span class="comment">// class allocated and registered</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_CONSTRUCTED        (1&lt;&lt;25)</span></span><br><span class="line"><span class="comment">// 该类的load方法已经调用过</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_LOADED             (1&lt;&lt;23)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="comment">// 该类的实例可能存在关联对象。默认编译选项下，无需定义该位，因为都可能有关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS (1&lt;&lt;22)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该类的实例具有特定的GC layout</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_INSTANCE_SPECIFIC_LAYOUT      (1 &lt;&lt; 21)</span></span><br><span class="line"><span class="comment">// 该类禁止在其实例上使用关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_FORBIDS_ASSOCIATED_OBJECTS        (1&lt;&lt;20)</span></span><br><span class="line"><span class="comment">// 该类正在实现，但是未实现完成</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REALIZING          (1&lt;&lt;19)</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-class-ro-t-gt-flags"><a href="#3-2-2-class-ro-t-gt-flags" class="headerlink" title="3.2.2 class_ro_t-&gt;flags"></a>3.2.2 class_ro_t-&gt;flags</h4><p><code>class_ro_t</code>的<code>flags</code>成员为只读。其中比较重要的一些值定义列举如下，均以<code>RO_</code>为前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类是元类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_META               (1&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// 类是根类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_ROOT               (1&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// 类有CXX构造/析构函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_CXX_STRUCTORS  (1&lt;&lt;2)</span></span><br><span class="line"><span class="comment">// 类有实现load方法</span></span><br><span class="line"><span class="comment">// #define RO_HAS_LOAD_METHOD    (1&lt;&lt;3)</span></span><br><span class="line"><span class="comment">// 隐藏类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HIDDEN             (1&lt;&lt;4)</span></span><br><span class="line"><span class="comment">// class has attribute(objc_exception): OBJC_EHTYPE_$_ThisClass is non-weak</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_EXCEPTION          (1&lt;&lt;5)</span></span><br><span class="line"><span class="comment">// class has ro field for Swift metadata initializer callback</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_SWIFT_INITIALIZER (1&lt;&lt;6)</span></span><br><span class="line"><span class="comment">// 类使用ARC选项编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_IS_ARC             (1&lt;&lt;7)</span></span><br><span class="line"><span class="comment">// 类有CXX析构函数，但没有CXX构造函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_CXX_DTOR_ONLY  (1&lt;&lt;8)</span></span><br><span class="line"><span class="comment">// class is not ARC but has ARC-style weak ivar layout </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_WEAK_WITHOUT_ARC (1&lt;&lt;9)</span></span><br><span class="line"><span class="comment">// 类禁止使用关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class is in an unloadable bundle - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FROM_BUNDLE        (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">// class is unrealized future class - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FUTURE             (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// class is realized - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_REALIZED           (1&lt;&lt;31)</span></span><br></pre></td></tr></table></figure><h3 id="3-3-read-images"><a href="#3-3-read-images" class="headerlink" title="3.3 _read_images()"></a>3.3 _read_images()</h3><p>观看下面内容之前，如果对 OC 中 <code>Class</code>、<code>Category</code>、<code>Protocol</code>的实现结构(底层的结构体实现及成员变量)不熟悉，建议先看一下<a href="">Runtime(一)：面向对象(Class和Object)的基本数据结构</a>、<a href="">Runtime(二)：Category、Protocol的实现与加载</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以 headerList 开头的链表中的 headers 进行初始处理</span></span><br><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    <span class="keyword">uint32_t</span> hIndex;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    </span><br><span class="line">    Class *resolvedFutureClasses = nil;</span><br><span class="line">    <span class="keyword">size_t</span> resolvedFutureClassCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态局部变量，如果是第一次调用 _read_images 则 doneOnce 值为 NO</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> doneOnce;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> launchTime = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测量 image 加载步骤的持续时间</span></span><br><span class="line">    <span class="comment">// 对应 objc-env.h 中的 OPTION( PrintImageTimes, OBJC_PRINT_IMAGE_TIMES, &quot;measure duration of image loading steps&quot;)</span></span><br><span class="line">    <span class="function">TimeLogger <span class="title">ts</span><span class="params">(PrintImageTimes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EACH_HEADER 是给下面的 for 循环使用的宏，遍历 hList 数组中的 header_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EACH_HEADER \</span></span><br><span class="line">    hIndex = <span class="number">0</span>;         \</span><br><span class="line">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="line">    hIndex++</span><br></pre></td></tr></table></figure><h4 id="1-是否是第一次加载"><a href="#1-是否是第一次加载" class="headerlink" title="1. 是否是第一次加载"></a>1. 是否是第一次加载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1⃣️</span></span><br><span class="line"><span class="comment">// 第一次调用 _read_images 时，doneOnce 值为 NO，会进入 if 执行里面的代码 </span></span><br><span class="line"><span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">    <span class="comment">// 把静态局部变量 doneOnce 置为 YES，之后调用 _read_images 都不会再进来</span></span><br><span class="line">    <span class="comment">// 第一次调用 _read_images 的时候，class、protocol、selector、category 都没有，</span></span><br><span class="line">    <span class="comment">// 需要创建容器来保存这些东西，此 if 内部，最后是创建一张存 class 的表。</span></span><br><span class="line">    doneOnce = YES;</span><br><span class="line">    </span><br><span class="line">    launchTime = YES;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一段是在低版本（swifit3 之前、OS X 10.11 之前）下禁用 non-pointer isa 时的一些打印信息，</span></span><br><span class="line"><span class="comment">// 为了减少我们的理解负担，这里直接进行了删除，想要学习的同学可以去看一下源码</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// OPTION( DisableTaggedPointers, OBJC_DISABLE_TAGGED_POINTERS, &quot;disable tagged pointer optimization of NSNumber et al.&quot;)</span></span><br><span class="line">    <span class="comment">// 禁用 NSNumber 等的 Tagged Pointers 优化时</span></span><br><span class="line">    <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">        <span class="comment">// 内部直接把 Tagged Pointers 用到的 mask 全部置为 0</span></span><br><span class="line">        <span class="built_in">disableTaggedPointers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// OPTION( DisableTaggedPointerObfuscation, OBJC_DISABLE_TAG_OBFUSCATION, &quot;disable obfuscation of tagged pointers&quot;)</span></span><br><span class="line">    <span class="comment">// 可开启 OBJC_DISABLE_TAG_OBFUSCATION，禁用 Tagged Pointer 的混淆。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机初始化 objc_debug_taggedpointer_obfuscator。</span></span><br><span class="line">    <span class="comment">// tagged pointer obfuscator 旨在使攻击者在存在缓冲区溢出或其他对某些内存的写控制的情况下更难将特定对象构造为标记指针。</span></span><br><span class="line">    <span class="comment">// 在设置或检索有效载荷值（payload values）时， obfuscator 与 tagged pointers 进行异或。</span></span><br><span class="line">    <span class="comment">// 它们在第一次使用时充满了随机性。</span></span><br><span class="line">    <span class="built_in">initializeTaggedPointerObfuscator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OPTION( PrintConnecting, OBJC_PRINT_CLASS_SETUP, &quot;log progress of class and category setup&quot;)</span></span><br><span class="line">    <span class="comment">// objc[26520]: CLASS: found 25031 classes during launch 在 objc-781 下在启动时有 25031 个类（包含所有的系统类和自定义类）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;CLASS: found %d classes during launch&quot;</span>, totalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// namedClasses</span></span><br><span class="line">    <span class="comment">// Preoptimized classes don&#x27;t go in this table.</span></span><br><span class="line">    <span class="comment">// 4/3 is NXMapTable&#x27;s load factor</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// isPreoptimized 如果我们有一个有效的优化共享缓存（valid optimized shared cache），则返回 YES。</span></span><br><span class="line">    <span class="comment">// 然后是不管三目运算符返回的是 unoptimizedTotalClasses 还是 totalClasses，它都会和后面的 4 / 3 相乘，</span></span><br><span class="line">    <span class="comment">// 注意是 4 / 3</span></span><br><span class="line">    <span class="keyword">int</span> namedClassesSize = (<span class="built_in">isPreoptimized</span>() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// gdb_objc_realized_classes 是一张全局的哈希表，虽然名字中有 realized，但是它的名字其实是一个误称，</span></span><br><span class="line">    <span class="comment">// 实际上它存放的是不在 dyld shared cache 中的 class，无论该 class 是否 realized。</span></span><br><span class="line">    gdb_objc_realized_classes = <span class="built_in">NXCreateMapTable</span>(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 objc-781 下执行到这里时，会有如下打印:</span></span><br><span class="line">    <span class="comment">// objc[19881]: 0.04 ms: IMAGE TIMES: first time tasks</span></span><br><span class="line">    <span class="comment">// 这个过程花了 0.04 毫秒</span></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: first time tasks&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修复预编译时-selector-错乱问题"><a href="#2-修复预编译时-selector-错乱问题" class="headerlink" title="2. 修复预编译时 @selector 错乱问题"></a>2. 修复预编译时 @selector 错乱问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 注册并修正 selector references. Fix up @selector references</span></span><br><span class="line">  <span class="comment">//（其实就是把 image 的 __objc_selrefs 区中的 selector 放进全局的 selector 集合中，修改其中不一致的地址）</span></span><br><span class="line"><span class="comment">// 也就是当 SEL *sels = _getObjc2SelectorRefs(hi, &amp;count); 中的 SEL 和通过 SEL sel = sel_registerNameNoLock(name, isBundle); 注册返回的 SEL 不同时，就把 sels 中的 SEL 修正为 sel_registerNameNoLock 中返回的地址。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 加锁 selLock</span></span><br><span class="line">      <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 遍历 header_info **hList 中的 header_info</span></span><br><span class="line">      <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">      </span><br><span class="line">          <span class="comment">// 如果指定的 hi 不需要预优化则跳过</span></span><br><span class="line">          <span class="keyword">if</span> (hi-&gt;<span class="built_in">hasPreoptimizedSelectors</span>()) <span class="keyword">continue</span>;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 根据 mhdr()-&gt;filetype 判断 image 是否是 MH_BUNDLE 类型</span></span><br><span class="line">          <span class="keyword">bool</span> isBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// GETSECT(_getObjc2SelectorRefs, SEL, &quot;__objc_selrefs&quot;);</span></span><br><span class="line">          <span class="comment">// 获取 __objc_selrefs 区中的 SEL</span></span><br><span class="line">          SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 记录数量</span></span><br><span class="line">          UnfixedSelectors += count;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// static objc::ExplicitInitDenseSet&lt;const char *&gt; namedSelectors;</span></span><br><span class="line">          <span class="comment">// 是一个静态全局 set，用来存放 Selector（名字，Selector 本身就是字符串）</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 遍历把 sels 中的所有 selector 放进全局的 selector 集合中   </span></span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          </span><br><span class="line">              <span class="comment">// sel_cname 函数内部实现是返回：(const char *)(void *)sel; 即把 SEL 强转为 char 类型</span></span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="built_in">sel_cname</span>(sels[i]);</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 注册 SEL，并返回其地址</span></span><br><span class="line">              SEL sel = <span class="built_in">sel_registerNameNoLock</span>(name, isBundle);</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 如果 SEL 地址发生变化，则把它设置为相同</span></span><br><span class="line">              <span class="keyword">if</span> (sels[i] != sel) &#123;</span><br><span class="line">                  sels[i] = sel;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里打印注册并修正 selector references 用的时间</span></span><br><span class="line">  <span class="comment">// 在 objc-781 下打印：objc[27056]: 0.44 ms: IMAGE TIMES: fix up selector references</span></span><br><span class="line">  <span class="comment">// 耗时 0.44 毫秒</span></span><br><span class="line">  ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up selector references&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-readClass-读取类信息，修复future-classes"><a href="#3-readClass-读取类信息，修复future-classes" class="headerlink" title="3. readClass()读取类信息，修复future classes"></a>3. readClass()读取类信息，修复future classes</h4><p>通过 readClass 读取出来类的信息，修复未解析的future classes.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line"><span class="comment">// 发现 classes。修复 unresolved future classes。标记 bundle classes。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns if any OS dylib has overridden its copy in the shared cache</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Exists in iPhoneOS 3.1 and later </span></span><br><span class="line"><span class="comment">// Exists in Mac OS X 10.10 and later</span></span><br><span class="line"><span class="keyword">bool</span> hasDyldRoots = <span class="built_in">dyld_shared_cache_some_image_overridden</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! <span class="built_in">mustReadClasses</span>(hi, hasDyldRoots)) &#123;</span><br><span class="line">        <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">        <span class="comment">// Image 已充分优化，我们无需调用 readClass()</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ClassList, classref_t const, &quot;__objc_classlist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 __objc_classlist 区中的 classref_t</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从编译后的类列表中取出所有类，获取到的是一个 classref_t 类型的指针 </span></span><br><span class="line">    <span class="comment">// classref_t is unremapped class_t* ➡️ classref_t 是未重映射的 class_t 指针</span></span><br><span class="line">    <span class="comment">// typedef struct classref * classref_t; // classref_t 是 classref 结构体指针</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> headerIsBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">    <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;<span class="built_in">hasPreoptimizedClasses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重点 ⚠️⚠️⚠️⚠️ 在这里：readClass。</span></span><br><span class="line">        <span class="comment">// 我们留在下面单独分析。</span></span><br><span class="line">        Class newCls = <span class="built_in">readClass</span>(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">            <span class="comment">// 类被移动但未被删除。目前，这种情况只发生在新类解析未来类时。</span></span><br><span class="line">            <span class="comment">// 非惰性地实现下面的类</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// realloc 原型是 extern void *realloc(void *mem_address, unsigned int newsize);</span></span><br><span class="line">            <span class="comment">// 先判断当前的指针是否有足够的连续空间，如果有，扩大 mem_address 指向的地址，并且将 mem_address 返回，</span></span><br><span class="line">            <span class="comment">// 如果空间不够，先按照 newsize 指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，</span></span><br><span class="line">            <span class="comment">// 而后释放原来 mem_address 所指内存区域（注意：原来指针是自动释放，不需要使用 free），</span></span><br><span class="line">            <span class="comment">// 同时返回新分配的内存区域的首地址，即重新分配存储器块的地址。</span></span><br><span class="line">            </span><br><span class="line">            resolvedFutureClasses = (Class *)<span class="built_in">realloc</span>(resolvedFutureClasses, (resolvedFutureClassCount+<span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(Class));</span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印发现 classes 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 3.17 ms: IMAGE TIMES: discover classes</span></span><br><span class="line"><span class="comment">// 耗时 3.17 毫秒（和前面的 0.44 毫秒比，多出不少）</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover classes&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="1-future-class的生成"><a href="#1-future-class的生成" class="headerlink" title="1) future class的生成"></a>1) future class的生成</h5><p><code>objc_class</code>的<code>isFuture()</code>函数，用于判断类是否为 future class。future class 对理解类的加载过程有重要作用。</p><p>首先看 <strong>future class 是如何生成的</strong> — <code>addFutureNamedClass()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 安装cls作为类结构，用于命名类(如果之后出现)。 </span></span><br><span class="line"><span class="comment"> 将传入的 cls 参数，配置为类名为 name的 future class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addFutureNamedClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 分配 cls 所需的 class_rw_t、class_ro_t 的内存空间；</span></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">calloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">class_ro_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 2. 将 cls 的类名置为 name；</span></span><br><span class="line">    ro-&gt;name = <span class="built_in">strdupIfMutable</span>(name);</span><br><span class="line">    <span class="comment">// 3. 将 class_rw_t 的 RO_FUTURE 位置为1，RO_FUTURE 等于 RW_FUTURE；</span></span><br><span class="line">    rw-&gt;ro = ro;</span><br><span class="line">    cls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    cls-&gt;<span class="built_in">data</span>()-&gt;flags = RO_FUTURE; </span><br><span class="line"><span class="comment">// 4. 以 name 为关键字(key)，将 cls 添加到一个全局的哈希表 futureNamedClasses；</span></span><br><span class="line">    old = <span class="built_in">NXMapKeyCopyingInsert</span>(<span class="built_in">futureNamedClasses</span>(), name, cls);</span><br><span class="line">    <span class="built_in">assert</span>(!old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NXMapTable *future_named_class_map = nil;</span><br><span class="line"><span class="comment">/* 返回一个map，key为 classname, value 为 unrealized future classes(Class实例)*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXMapTable *<span class="title">futureNamedClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) <span class="keyword">return</span> future_named_class_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// future_named_class_map is big enough for CF’s classes and a few others</span></span><br><span class="line">    future_named_class_map = </span><br><span class="line">        <span class="built_in">NXCreateMapTable</span>(NXStrValueMapPrototype, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> future_named_class_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为给定的类名分配一个未解析的未来类 unresolved future class</span></span><br><span class="line"><span class="comment"> * 如果已经分配，则返回任何现有分配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class _objc_allocateFutureClass(<span class="keyword">const</span> <span class="keyword">char</span> *name) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    NXMapTable *map = <span class="built_in">futureNamedClasses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cls = (Class)<span class="built_in">NXMapGet</span>(map, name))) &#123;</span><br><span class="line">        <span class="comment">// 存在名为name的future class</span></span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 分配用于保存objc_class的内存空间</span></span><br><span class="line">    cls = _calloc_class(<span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构建名为name的future class并全局记录到 futureNamedClasses 哈希表</span></span><br><span class="line">    <span class="built_in">addFutureNamedClass</span>(name, cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> Return the id of the named class.</span></span><br><span class="line"><span class="comment"> 如果该类不存在，则返回一个未初始化的类结构，该结构将在类加载时使用。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getFutureClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Class look_up_class(const char *name, </span></span><br><span class="line"><span class="comment">              bool includeUnconnected __attribute__((unused)), </span></span><br><span class="line"><span class="comment">              bool includeClassHandler __attribute__((unused))) // unconnected is OK，因为总有一天它会成为真正的class</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cls = <span class="built_in">look_up_class</span>(name, YES, NO);</span><br><span class="line">    <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintFuture) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;FUTURE: found %p already in use for %s&quot;</span>, </span><br><span class="line">                         (<span class="keyword">void</span>*)cls, name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还没有名为name的class或future class。做一个。</span></span><br><span class="line">    <span class="keyword">return</span> _objc_allocateFutureClass(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用链向上追溯到 <code>Class objc_getFutureClass</code>，该函数并没有在 runtime 源代码中被调用到。而用于从 <code>namedFutureClasses</code> 哈希表中获取 future class 的<code>popFutureClass(...)</code> 函数是有间接通过<code>readClass(...)</code>函数被广泛调用。因此，<strong>构建 future class 的逻辑大多隐藏在 runtime 的内部实现中未公布，只有使用 future class 的逻辑是开源的</strong>。</p><h5 id="2-future-class的获取"><a href="#2-future-class的获取" class="headerlink" title="2) future class的获取"></a>2) future class的获取</h5><p> <code>popFutureNamedClass</code> 用于从 <code>futureNamedClasses</code> 哈希表中弹出类名为<code>name</code>的 future class，这是获取全局记录的 future class 的唯一入口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Removes the named class from the unrealized future class list, because it has been realized.</span></span><br><span class="line"><span class="comment"> * Returns nil if the name is not used by a future class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">popFutureNamedClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class cls = nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) &#123;</span><br><span class="line">        cls = (Class)<span class="built_in">NXMapKeyFreeingRemove</span>(future_named_class_map, name);</span><br><span class="line">        <span class="keyword">if</span> (cls &amp;&amp; <span class="built_in">NXCountMapTable</span>(future_named_class_map) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NXFreeMapTable</span>(future_named_class_map);</span><br><span class="line">            future_named_class_map = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-future-class的使用-—-readClass"><a href="#3-future-class的使用-—-readClass" class="headerlink" title="3) future class的使用 — readClass"></a>3) future class的使用 — readClass</h5><p>readClass 用于读取<code>cls</code>中的类数据，关键处理逻辑表述如下：</p><ul><li>若 <code>futureNamedClasses</code> 哈希表中存在 <code>cls-&gt;mangledName()</code> 类名的 future class，则将<code>cls</code>重映射（remapping）到新的类 <code>newCls</code>（具体重映射过程在下面4小节中详细讨论），然后将 <code>newCls</code> 标记为 remapped class，以<code>cls</code>为关键字添加到全局记录的 <code>remappedClasses()</code> 哈希表中；</li><li>将<code>cls</code>标记为 named class，以 <code>cls-&gt;mangledName()</code> 类名为关键字添加到全局记录的 <code>gdb_objc_realized_classes</code> 哈希map中，表示 runtime 开始可以通过类名查找类（注意元类不需要添加）；</li><li>将<code>cls</code>及其元类标记为 allocated class，并将两者均添加到全局记录的 <code>allocatedClasses</code> 哈希set中，表示已为类分配固定内存空间；</li></ul><blockquote><p>注意：传入<code>readClass(...)</code>的<code>cls</code>参数是<code>Class</code>类型，而函数返回结果也是<code>Class</code>，为什么读取类信息是“从类中读取类信息”这样怪异的过程呢？</p><p>其实是因为<code>cls</code>参数来源于 runtime 未开源的、从镜像（image）中读取类的过程。该过程输出的<code>objc_class</code>存在特殊之处：要么输出 future class，要么输出正常(normal)类但是其<code>bits</code>指向的是<code>class_ro_t</code>结构体而非<code>class_rw_t</code>，之所以如此是因为从镜像读取的是编译时决议的静态数据，本来就应该保存在<code>class_ro_t</code>结构体中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* readClass</span></span><br><span class="line"><span class="comment">* Read a class and metaclass as written by a compiler.</span></span><br><span class="line"><span class="comment">* Returns the new class pointer. This could be: </span></span><br><span class="line"><span class="comment">* - cls</span></span><br><span class="line"><span class="comment">* - nil  (cls has a missing weak-linked superclass)</span></span><br><span class="line"><span class="comment">* - something else (space for this class was reserved by a future class)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock acquired by map_images or objc_readClassPair</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">Class <span class="title">readClass</span><span class="params">(Class cls, <span class="keyword">bool</span> headerIsBundle, <span class="keyword">bool</span> headerIsPreoptimized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;<span class="built_in">nonlazyMangledName</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类的继承链上，存在既不是根类（RO_ROOT位为0）又没有超类的类，则为missingWeakSuperclass</span></span><br><span class="line">    <span class="comment">// 注意：这是唯一的向remappedClasses中添加nil值的入口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">missingWeakSuperclass</span>(cls)) &#123;</span><br><span class="line">        <span class="built_in">addRemappedClass</span>(cls, nil);</span><br><span class="line">        cls-&gt;<span class="built_in">setSuperclass</span>(nil);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容旧版本libobjc的配置，可忽略</span></span><br><span class="line">    cls-&gt;<span class="built_in">fixupBackwardDeployingStableSwift</span>();</span><br><span class="line"></span><br><span class="line">    Class replacing = nil;</span><br><span class="line">    <span class="keyword">if</span> (mangledName != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Class newCls = <span class="built_in">popFutureNamedClass</span>(mangledName)) &#123;</span><br><span class="line">            <span class="comment">// 这个name已经被分配为future class，全局记录。</span></span><br><span class="line">            <span class="comment">// 将cls的内容拷贝到newCls(也就是future class)中，保存future class的rw中的数据。将cls-&gt;data设置为rw-&gt;ro</span></span><br><span class="line">            <span class="comment">// 以cls为关键字将构建的newCls添加到全局记录的remappedClasses哈希表中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls-&gt;<span class="built_in">isAnySwift</span>()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Can&#x27;t complete future class request for &#x27;%s&#x27; &quot;</span></span><br><span class="line">                            <span class="string">&quot;because the real class is too big.&quot;</span>,</span><br><span class="line">                            cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">class_rw_t</span> *rw = newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;<span class="built_in">ro</span>();</span><br><span class="line">            <span class="built_in">memcpy</span>(newCls, cls, <span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually set address-discriminated ptrauthed fields</span></span><br><span class="line">            <span class="comment">// so that newCls gets the correct signatures.</span></span><br><span class="line">            newCls-&gt;<span class="built_in">setSuperclass</span>(cls-&gt;<span class="built_in">getSuperclass</span>());</span><br><span class="line">            newCls-&gt;<span class="built_in">initIsa</span>(cls-&gt;<span class="built_in">getIsa</span>());</span><br><span class="line"></span><br><span class="line">            rw-&gt;<span class="built_in">set_ro</span>((<span class="keyword">class_ro_t</span> *)newCls-&gt;<span class="built_in">data</span>());</span><br><span class="line">            newCls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">            <span class="built_in">freeIfMutable</span>((<span class="keyword">char</span> *)old_ro-&gt;<span class="built_in">getName</span>());</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">addRemappedClass</span>(cls, newCls);</span><br><span class="line"></span><br><span class="line">            replacing = cls;</span><br><span class="line">            cls = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123;</span><br><span class="line">        <span class="comment">// class list built in shared cache</span></span><br><span class="line">        <span class="comment">// 已存在该类名的named class</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(mangledName == <span class="literal">nullptr</span> || <span class="built_in">getClassExceptSomeSwift</span>(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mangledName) &#123; <span class="comment">// 一些Swift泛型类可以惰性地生成它们的名称</span></span><br><span class="line">            <span class="comment">// 将类添加到 named classes</span></span><br><span class="line">            <span class="built_in">addNamedClass</span>(cls, mangledName, replacing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class meta = cls-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *metaRO = meta-&gt;bits.<span class="built_in">safe_ro</span>();</span><br><span class="line">            <span class="built_in">ASSERT</span>(metaRO-&gt;<span class="built_in">getNonMetaclass</span>() &amp;&amp; <span class="string">&quot;Metaclass with lazy name must have a pointer to the corresponding nonmetaclass.&quot;</span>);</span><br><span class="line">            <span class="built_in">ASSERT</span>(metaRO-&gt;<span class="built_in">getNonMetaclass</span>() == cls &amp;&amp; <span class="string">&quot;Metaclass nonmetaclass pointer must equal the original class.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将类添加到 allocated classes</span></span><br><span class="line">        <span class="built_in">addClassTableEntry</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="comment">// 设置RO_FROM_BUNDLE位</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;<span class="built_in">data</span>()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">data</span>()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-future-class小结"><a href="#4-future-class小结" class="headerlink" title="4) future class小结"></a>4) future class小结</h5><p>从上文<code>readClass(...)</code>代码<code>if (Class newCls = popFutureNamedClass(mangledName))</code>分支内<code>free((void *)old_ro)</code>语句，得出在<code>cls</code>映射到<code>newCls</code>过程中，完全丢弃了 future class 的<code>ro</code>数据。最后，结合以上所有代码，可以归纳以下结论：</p><ul><li><p>Future class 类的有效数据实际上仅有：类名和<code>rw</code>。<code>rw</code>中的数据作用也非常少，仅使用<code>flags</code>的<code>RO_FUTURE</code>（实际上就是<code>RW_FUTURE</code>）标记类是 future class；</p></li><li><p>Future class 的作用是为指定类名的类，提前分配好内存空间，调用<code>readClass(...)</code>函数读取类时，才正式写入类的数据。 Future class 是用于支持类的懒加载机制；</p></li></ul><h4 id="4-remapped-重新映射-classes"><a href="#4-remapped-重新映射-classes" class="headerlink" title="4. remapped(重新映射) classes"></a>4. remapped(重新映射) classes</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Fix up remapped classes</span></span><br><span class="line">    <span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line">    <span class="comment">// Class list 和 nonlazy class list 仍未映射。</span></span><br><span class="line">    <span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line">    <span class="comment">// Class refs 和 super refs 被重新映射为消息调度。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要是修复重映射 classes，!noClassesRemapped() 在这里为 false，所以一般走不进来，</span></span><br><span class="line">    <span class="comment">// 将未映射 class 和 super class 重映射，被 remap 的类都是非懒加载的类</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">noClassesRemapped</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="comment">// GETSECT(_getObjc2ClassRefs, Class, &quot;__objc_classrefs&quot;);</span></span><br><span class="line">            <span class="comment">// 获取 __objc_classrefs 区中的类引用</span></span><br><span class="line">            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历 classrefs 中的类引用，如果类引用已被重新分配或者是被忽略的弱链接类，</span></span><br><span class="line">            <span class="comment">// 就将该类引用重新赋值为从重映射类表中取出新类</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">// Fix up a class ref, in case the class referenced has been reallocated or is an ignored weak-linked class.</span></span><br><span class="line">                <span class="comment">// 修复 class ref，以防所引用的类已 reallocated 或 is an ignored weak-linked class。</span></span><br><span class="line">                <span class="built_in">remapClassRef</span>(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// fixme why doesn&#x27;t test future1 catch the absence of this?</span></span><br><span class="line">            <span class="comment">// GETSECT(_getObjc2SuperRefs, Class, &quot;__objc_superrefs&quot;);</span></span><br><span class="line">            <span class="comment">// 获取 __objc_superrefs 区中的父类引用</span></span><br><span class="line">            classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="built_in">remapClassRef</span>(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里打印修复重映射 classes 用的时间</span></span><br><span class="line">    <span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: remap classes</span></span><br><span class="line">    <span class="comment">// 耗时 0 毫秒，即 Fix up remapped classes 并没有执行 </span></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: remap classes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_FIXUP</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> cacheSupportsProtocolRoots = <span class="built_in">sharedCacheSupportsProtocolRoots</span>();</span><br></pre></td></tr></table></figure><h5 id="1-future-class-的重映射"><a href="#1-future-class-的重映射" class="headerlink" title="1) future class 的重映射"></a>1) future class 的重映射</h5><p>在上面 <code>readClass()</code> 中有提到类的重映射，重映射的类被标记为 remapped class，并以映射前的类为关键字，添加到全局的<code>remappedClass</code>哈希表中。回顾<code>readClass()</code>函数中，类的重映射代码如下，关于处理过程的详细描述已注释到代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 若该类名已被标记为future class，则弹出该类名对应的future class 赋值给newCls</span></span><br><span class="line"><span class="keyword">if</span> (Class newCls = <span class="built_in">popFutureNamedClass</span>(mangledName)) &#123;</span><br><span class="line">    <span class="comment">// 2. rw记录future class的rw</span></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw = newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// 3. future class的ro记为old_ro，后面释放其占用的内存空间并丢弃</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;ro;</span><br><span class="line">    <span class="comment">// 4. 将cls中的数据拷贝到newCls，主要是要沿用cls的isa、superclass和cache数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(newCls, cls, <span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line">    <span class="comment">// 5. rw记录cls的ro</span></span><br><span class="line">    rw-&gt;ro = (<span class="keyword">class_ro_t</span> *)newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// 6. 沿用future class的rw、cls的ro</span></span><br><span class="line">    newCls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    <span class="comment">// 7. 释放future class的ro占用的空间</span></span><br><span class="line">    <span class="built_in">freeIfMutable</span>((<span class="keyword">char</span> *)old_ro-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 将newCls以cls为关键字添加到remappedClasses哈希表中</span></span><br><span class="line">    <span class="built_in">addRemappedClass</span>(cls, newCls);</span><br><span class="line">    </span><br><span class="line">    replacing = cls;</span><br><span class="line">    cls = newCls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合上面代码的详细注释，可知<code>cls</code>重映射到<code>newCls</code>后，<code>newCls</code>的数据保留了<code>cls</code>中的<code>superclass</code>、<code>cache</code>成员，但是<code>bits</code>中指向<code>class_rw_t</code>结构体地址的位域（<code>FAST_DATA_MASK</code>）指向了<strong>新的<code>class_rw_t</code>结构体</strong>。该结构体的<code>ro</code>指针指向<code>cls-&gt;data()</code>所指向的内存空间中保存的<code>class_ro_t</code>结构体，其他数据则是直接沿用 从<code>namedFutureClasses</code>哈希表中弹出的 future class 的<code>class_rw_t</code>结构体（通过future class 的<code>data()</code>方法返回）中数据。</p><blockquote><p>注意：虽然<code>objc_class</code>的<code>data()</code>方法声明为返回<code>class_rw_t *</code>，但是究其本质，它只是返回了<code>objc_class</code>的<code>bits</code>成员的<code>FAST_DATA_MASK</code>标记的位域中保存的内存地址，该内存地址实际上可以保存任何类型的数据。在<code>Class readClass(Class cls, bool headerIsBundle, bool headerIsPreoptimized)</code>函数中，传入的<code>cls</code>所指向的<code>objc_class</code>结构体有其特殊之处：<code>cls</code>的<code>bits</code>成员的<code>FAST_DATA_MASK</code>位域，指向的内存空间保存的是<code>class_ro_t</code>结构体，并不是通常的<code>class_rw_t</code>。</p></blockquote><h5 id="2-通用类的重映射"><a href="#2-通用类的重映射" class="headerlink" title="2) 通用类的重映射"></a>2) 通用类的重映射</h5><p>通用的类重映射调用<code>static class remapClass(Class cls)</code>，注意当传入的<code>cls</code>类不在<code>remappedClasses</code>哈希表中时，直接返回<code>cls</code>本身；<code>static void remapClassRef(Class *clsref)</code>可对传入的<code>Class* clsref</code>重映射（改变<code>*clsref</code>的值），返回时<code>clsref</code>将 指向<code>*clsref</code>重映射后的类。类的重映射相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取remappedClasses，保存已重映射的所有类的全局哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXMapTable *<span class="title">remappedClasses</span><span class="params">(<span class="keyword">bool</span> create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 静态的全局哈希表，没有找到remove接口，只会无限扩张</span></span><br><span class="line">    <span class="keyword">static</span> NXMapTable *remapped_class_map = nil;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remapped_class_map) <span class="keyword">return</span> remapped_class_map;</span><br><span class="line">    <span class="keyword">if</span> (!create) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remapped_class_map is big enough to hold CF’s classes and a few others</span></span><br><span class="line">    <span class="built_in">INIT_ONCE_PTR</span>(remapped_class_map, </span><br><span class="line">                  <span class="built_in">NXCreateMapTable</span>(NXPtrValueMapPrototype, <span class="number">32</span>), </span><br><span class="line">                  <span class="built_in">NXFreeMapTable</span>(v));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> remapped_class_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将oldcls重映射得到的newcls，以oldcls为关键字插入到remappedClasses哈希表中</span></span><br><span class="line"><span class="comment">// 注意：从代码透露出来的信息是，remappedClasses中只保存 future class 重映射的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addRemappedClass</span><span class="params">(Class oldcls, Class newcls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintFuture) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;FUTURE: using %p instead of %p for %s&quot;</span>, </span><br><span class="line">                     (<span class="keyword">void</span>*)newcls, (<span class="keyword">void</span>*)oldcls, oldcls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line">    old = <span class="built_in">NXMapInsert</span>(<span class="built_in">remappedClasses</span>(YES), oldcls, newcls);</span><br><span class="line">    <span class="built_in">assert</span>(!old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取cls的重映射类</span></span><br><span class="line"><span class="comment">// 注意：当remappedClasses为空或哈希表中不存在`cls`关键字，是返回`cls`本身，否则返回`cls`重映射后的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">remapClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class c2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    NXMapTable *map = <span class="built_in">remappedClasses</span>(NO);</span><br><span class="line">    <span class="keyword">if</span> (!map  ||  <span class="built_in">NXMapMember</span>(map, cls, (<span class="keyword">void</span>**)&amp;c2) == NX_MAPNOTAKEY) &#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Class的指针的重映射，返回时传入的clsref将 指向*clsref重映射后的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remapClassRef</span><span class="params">(Class *clsref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class newcls = <span class="built_in">remapClass</span>(*clsref);    </span><br><span class="line">    <span class="keyword">if</span> (*clsref != newcls) *clsref = newcls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-remap小结"><a href="#3-remap小结" class="headerlink" title="3) remap小结"></a>3) remap小结</h5><p>最后归纳出以下结论：</p><ul><li>Future class 进行重映射后，会返回新的类，保存在<code>remappedClasses</code>全局哈希表中；</li><li>正常类重映射返回类本身；</li><li>重映射的真正的目的是支持类的懒加载，懒加载类暂存为 future class 只记录类名及 future class 属性，在调用<code>readClass</code>才正式载入类数据。</li></ul><h4 id="5-类中如果有协议，读取协议"><a href="#5-类中如果有协议，读取协议" class="headerlink" title="5. 类中如果有协议，读取协议"></a>5. 类中如果有协议，读取协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line"><span class="comment">// 发现 protocols，修正 protocol refs。</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">    Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">    <span class="built_in">ASSERT</span>(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个长度是 16 的 NXMapTable</span></span><br><span class="line">    NXMapTable *protocol_map = <span class="built_in">protocols</span>();</span><br><span class="line">    <span class="keyword">bool</span> isPreoptimized = hi-&gt;<span class="built_in">hasPreoptimizedProtocols</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip reading protocols if this is an image from the shared cache and we support roots</span></span><br><span class="line">    <span class="comment">// 如果这是来自 shared cache 的 image 并且我们 support roots，则跳过 reading protocols</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Note, after launch we do need to walk the protocol as the protocol in the shared cache is marked with isCanonical()</span></span><br><span class="line">    <span class="comment">// and that may not be true if some non-shared cache binary was chosen as the canonical definition</span></span><br><span class="line">    <span class="comment">// 启动后，我们确实需要遍历协议，因为 shared cache 中的协议用 isCanonical() 标记，如果选择某些非共享缓存二进制文件作为规范定义，则可能不是这样</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; isPreoptimized &amp;&amp; cacheSupportsProtocolRoots) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;PROTOCOLS: Skipping reading protocols in image: %s&quot;</span>, hi-&gt;<span class="built_in">fname</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ProtocolList, protocol_t * const, &quot;__objc_protolist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_protolist 区下的 protocol_t</span></span><br><span class="line">    <span class="keyword">protocol_t</span> * <span class="keyword">const</span> *protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// Read a protocol as written by a compiler.</span></span><br><span class="line">        <span class="built_in">readProtocol</span>(protolist[i], cls, protocol_map, </span><br><span class="line">                     isPreoptimized, isBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印发现并修正 protocols 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 5.45 ms: IMAGE TIMES: discover protocols</span></span><br><span class="line"><span class="comment">// 耗时 05.45 毫秒</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover protocols&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="6-映射协议"><a href="#6-映射协议" class="headerlink" title="6. 映射协议"></a>6. 映射协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up @protocol references</span></span><br><span class="line"><span class="comment">// Preoptimized images may have the right answer already but we don&#x27;t know for sure.</span></span><br><span class="line"><span class="comment">// Preoptimized images 可能已经有了正确的答案，但我们不确定。</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// At launch time, we know preoptimized image refs are pointing at the shared cache definition of a protocol.</span></span><br><span class="line">    <span class="comment">// 在启动时，我们知道 preoptimized image refs 指向协议的 shared cache 定义。</span></span><br><span class="line">    <span class="comment">// We can skip the check on launch, but have to visit @protocol refs for shared cache images loaded later.</span></span><br><span class="line">    <span class="comment">// 我们可以跳过启动时的检查，但必须访问 @protocol refs 以获取稍后加载的 shared cache images。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; cacheSupportsProtocolRoots &amp;&amp; hi-&gt;<span class="built_in">isPreoptimized</span>())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ProtocolRefs, protocol_t *, &quot;__objc_protorefs&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_protorefs 区的 protocol_t</span></span><br><span class="line">    <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// Fix up a protocol ref, in case the protocol referenced has been reallocated.</span></span><br><span class="line">        <span class="comment">// 修复 protocol ref，以防 protocol referenced 已重新分配。</span></span><br><span class="line">        <span class="built_in">remapProtocolRef</span>(&amp;protolist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 @protocol references 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: fix up @protocol references</span></span><br><span class="line"><span class="comment">// 因为是第一次启动，则并不进行</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up @protocol references&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="7-加载分类"><a href="#7-加载分类" class="headerlink" title="7. 加载分类"></a>7. 加载分类</h4><p>把 category 的数据追加到原类中去！很重要。</p><p>这里并不会执行，didInitialAttachCategories 是一个静态全局变量，默认是 false，对于启动时出现的 categories，discovery 被推迟到 <code>_dyld_objc_notify_register</code> 调用完成后的第一个 <code>load_images</code> 调用。所以这里 if 里面的 Discover categories 是不会执行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories. 发现类别。</span></span><br><span class="line"><span class="comment">// 仅在完成 initial category attachment 后才执行此操作。</span></span><br><span class="line"><span class="comment">// 对于启动时出现的 categories，discovery 被推迟到 _dyld_objc_notify_register 调用完成后的第一个 load_images 调用。</span></span><br><span class="line"><span class="comment">// 这里 if 里面的 category 数据加载是不会执行的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// didInitialAttachCategories 是一个静态全局变量，默认是 false，</span></span><br><span class="line"><span class="comment">// static bool didInitialAttachCategories = false; 在load_images()函数体中，才会置为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (didInitialAttachCategories) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="built_in">load_categories_nolock</span>(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 Discover categories. 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: discover categories</span></span><br><span class="line"><span class="comment">// 对于启动时出现的 categories，discovery 被推迟到 _dyld_objc_notify_register 调用完成后的第一个 load_images 调用。</span></span><br><span class="line"><span class="comment">// 所以这里 if 里面的 category 数据加载是不会执行的。</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover categories&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当其他线程在该线程完成其修复(thread finishes its fixups)之前调用新的category代码时，category discovery必须延迟以避免潜在的竞争。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +load 由 prepare_load_methods() 处理</span></span><br></pre></td></tr></table></figure><h4 id="8-realize非懒加载类-—-realized-class"><a href="#8-realize非懒加载类-—-realized-class" class="headerlink" title="8. realize非懒加载类 — realized class"></a>8. realize非懒加载类 — realized class</h4><p>懒加载：类没有实现 +load 函数，在使用的第一次才会加载，当我们给这个类的发送消息时，如果是第一次，在消息查找的过程中就会判断这个类是否加载，没有加载就会加载这个类。懒加载类在首次调用方法的时候，才会去调用 <code>realizeClassWithoutSwift</code> 函数去进行加载。</p><p>非懒加载：类的内部实现了 +load 函数，类的加载就会提前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="comment">// 实现非懒加载类（为了+load调用、静态实例）</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_nlclslist 区中的非懒加载类（即实现了 +load 函数的类）</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 重映射类， 获取正确的类指针</span></span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// static void addClassTableEntry(Class cls, bool addMeta = true) &#123; ... &#125;</span></span><br><span class="line">        <span class="comment">// 将一个类添加到用来存储所有类的全局的 set 中（auto &amp;set = objc::allocatedClasses.get();）。</span></span><br><span class="line">        <span class="comment">// 如果 addMeta 为 true（默认为 true），也自动添加类的元类到这个 set 中。</span></span><br><span class="line">        <span class="comment">// 这个类可以通过 shared cache 或 data segments 成为已知类，但不允许已经在 dynamic table 中。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// allocatedClasses 是 objc 命名空间中的一个静态变量。</span></span><br><span class="line">        <span class="comment">// A table of all classes (and metaclasses) which have been allocated with objc_allocateClassPair.</span></span><br><span class="line">        <span class="comment">// 已使用 objc_allocateClassPair 分配空间的存储所有 classes（和 metaclasses）的 Set。</span></span><br><span class="line">        <span class="comment">// namespace objc &#123;</span></span><br><span class="line">        <span class="comment">//     static ExplicitInitDenseSet&lt;Class&gt; allocatedClasses;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把 cls 放入 allocatedClasses 中，然后递归把 metaclass 放入 allocatedClasses 中</span></span><br><span class="line">        <span class="built_in">addClassTableEntry</span>(cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断 cls 是否是来自稳定的 Swift ABI 的 Swift 类</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;<span class="built_in">swiftMetadataInitializer</span>()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Swift class %s with a metadata initializer &quot;</span></span><br><span class="line">                            <span class="string">&quot;is not allowed to be non-lazy&quot;</span>,</span><br><span class="line">                            cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme also disallow relocatable classes We can&#x27;t disallow all Swift classes because of classes like Swift.__EmptyArrayStorage</span></span><br><span class="line">            <span class="comment">// 也禁止 relocatable classes 我们不能因为像 Swift.__EmptyArrayStorage 这样的类而禁止所有 Swift 类</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现 Swift 之外的 classes</span></span><br><span class="line">        <span class="comment">// 对类 cls 执行首次初始化，包括分配其读写数据。不执行任何 Swift 端初始化。返回类的真实类结构。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 大概是设置 ro rw 和一些标识位的过程，也包括递归实现父类（supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass), nil);）</span></span><br><span class="line">        <span class="comment">// 和元类（metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);），</span></span><br><span class="line">        <span class="comment">// 然后更新 cls 的父类和元类（cls-&gt;superclass = supercls; cls-&gt;initClassIsa(metacls);），</span></span><br><span class="line">        <span class="comment">// 将 cls 连接到其父类的子类列表（addSubclass(supercls, cls);）（操作 class_rw_t 的 Class firstSubclass; 和 Class nextSiblingClass; 两个成员变量），</span></span><br><span class="line">        <span class="comment">// 修正 cls 的方法列表、协议列表和属性列表，</span></span><br><span class="line">        <span class="comment">// 以及最后的附加任何未完成的 categories（主要包含 method list、protocol list、property list）</span></span><br><span class="line">        <span class="comment">//（objc::unattachedCategories.attachToClass）。</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 Realize non-lazy classes 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.23 ms: IMAGE TIMES: realize non-lazy classes</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize non-lazy classes&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="1-realizeClassWithoutSwift"><a href="#1-realizeClassWithoutSwift" class="headerlink" title="1) realizeClassWithoutSwift()"></a>1) realizeClassWithoutSwift()</h5><p>调用<code>readClass(...)</code>读取类数据只是载入了类的<code>class_ro_t</code>静态数据，因此仍需要进一步配置<code>objc_class</code>的<code>class_rw_t</code>结构体的数据。这个过程为 class realizing，姑且称之为认识/实现类。具体包括：</p><ul><li>配置<code>class_rw_t</code>的<code>RW_REALIZED</code>、<code>RW_REALIZING</code>位；</li><li>根据<code>class_ro_t</code>的<code>RO_META</code>位的值，配置<code>class_rw_t</code>的<code>version</code>；</li><li>因为静态载入的父类、元类有可能被重映射，因此要保证类的父类、元类完成class realizing；</li><li>配置<code>class_rw_t</code>的<code>superclass</code>；</li><li>初始化<code>objc_class</code>的<code>isa</code>指针；</li><li>配置<code>ivarLayout</code>、<code>instanceSize</code>、<code>instanceStart</code>。该步骤非常重要，新版本 runtime 支持 non-fragile instance variables，类的<code>instanceStart</code>、<code>instanceSize</code>会根据父类的<code>instanceSize</code>动态调整，且需要按 WORD 对齐（TODO：后续在独立的文章中详细介绍）；</li><li>配置<code>class_rw_t</code>的<code>RO_HAS_CXX_STRUCTORS</code>、<code>RO_HAS_CXX_DTOR_ONLY</code>、<code>RW_FORBIDS_ASSOCIATED_OBJECTS</code>；</li><li>添加子类/根类；</li><li>将<code>class_ro_t</code>中的基本方法列表、属性列表、协议列表，类的分类（category）中的方法列表等信息添加到<code>class_rw_t</code>中（TODO：后续在独立的文章中详细介绍）；</li></ul><p>实现 class realizing 的代码主要在<code>static Class realizeClassWithoutSwift(Class cls)</code>函数中，只需要知道其大致过程即可。具体代码及注释如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* 对类 cls 执行首次初始化，包括分配其读写(read-write)数据。</span></span><br><span class="line"><span class="comment">* 不执行任何 Swift 端初始化。</span></span><br><span class="line"><span class="comment">* 返回类的真实类结构(real class structure)</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClassWithoutSwift</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">        <span class="built_in">validateAlreadyRealizedClass</span>(cls);</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ASSERT</span>(cls == <span class="built_in">remapClass</span>(cls));  <span class="comment">// // 传入的类必须存在于remappedClasses全局哈希表中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">auto</span> isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// 曾经是 a future class. 所以 rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">        ro = cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>();  <span class="comment">// cls的rw指向class_rw_t结构体，ro指向class_ro_t结构体，维持原状</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(!isMeta);</span><br><span class="line">        cls-&gt;<span class="built_in">changeInfo</span>(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常类(Normal class). 需要为rw分配内存，并将ro指针指向 传入的cls-&gt;data()所指向的内存空间</span></span><br><span class="line">        rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">        rw-&gt;<span class="built_in">set_ro</span>(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cls-&gt;cache.<span class="built_in">initializeToEmptyOrPreoptimizedInDisguise</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FAST_CACHE_META</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) cls-&gt;cache.<span class="built_in">setBit</span>(FAST_CACHE_META);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Choose an index for this class.</span></span><br><span class="line">    <span class="comment">// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are available</span></span><br><span class="line">    cls-&gt;<span class="built_in">chooseClassArrayIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现父类和元类，如果它们还没有实现。</span></span><br><span class="line">    <span class="comment">//   对于根类，这需要在上面设置RW_REALIZED之后完成。</span></span><br><span class="line">    <span class="comment">//   对于根元类，这需要在选择类索引之后完成。</span></span><br><span class="line">    <span class="comment">// (假设这些类都没有 Swift 内容，或者 Swift 的初始化程序(initializers)已经被调用)</span></span><br><span class="line">    <span class="comment">// (如果我们添加对 Swift 类的 ObjC 子类的支持，请修复这个假设是错误的。)</span></span><br><span class="line">    supercls = <span class="built_in">realizeClassWithoutSwift</span>(<span class="built_in">remapClass</span>(cls-&gt;<span class="built_in">getSuperclass</span>()), nil); <span class="comment">// 父类 realizing</span></span><br><span class="line">    metacls = <span class="built_in">realizeClassWithoutSwift</span>(<span class="built_in">remapClass</span>(cls-&gt;<span class="built_in">ISA</span>()), nil);  <span class="comment">// 元类 realizing</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        <span class="comment">// 元类不需要来自non pointer ISA 的任何特性</span></span><br><span class="line">        <span class="comment">// 这允许在objc_retain/objc_release中为类提供一个faspath。</span></span><br><span class="line">        cls-&gt;<span class="built_in">setInstancesRequireRawIsa</span>(); <span class="comment">// 配置RW_REQUIRES_RAW_ISA位。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 为一些类或平台禁用 non-pointer isa</span></span><br><span class="line">        <span class="keyword">bool</span> instancesRequireRawIsa = cls-&gt;<span class="built_in">instancesRequireRawIsa</span>();</span><br><span class="line">        <span class="keyword">bool</span> rawIsaIsInherited = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> hackedDispatch = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableNonpointerIsa) &#123;</span><br><span class="line">            <span class="comment">// Non-pointer isa disabled by environment or app SDK version</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!hackedDispatch  &amp;&amp;  <span class="number">0</span> == <span class="built_in">strcmp</span>(ro-&gt;<span class="built_in">getName</span>(), <span class="string">&quot;OS_object&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// hack for libdispatch et al - isa also acts as vtable pointer</span></span><br><span class="line">            hackedDispatch = <span class="literal">true</span>;</span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;<span class="built_in">getSuperclass</span>()  &amp;&amp;</span><br><span class="line">                 supercls-&gt;<span class="built_in">instancesRequireRawIsa</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这也是通过addSubclass()传播的</span></span><br><span class="line">            <span class="comment">// 但是 nonpointer isa 设置需要更早.</span></span><br><span class="line">            <span class="comment">// 特殊情况：instancerequirerawisa不从根类传播到根元类</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">            rawIsaIsInherited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 配置RW_REQUIRES_RAW_ISA位</span></span><br><span class="line">        <span class="keyword">if</span> (instancesRequireRawIsa) &#123;</span><br><span class="line">            cls-&gt;<span class="built_in">setInstancesRequireRawIsaRecursively</span>(rawIsaIsInherited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于存在class remapping的可能性，因此需要更新父类及元类</span></span><br><span class="line">    cls-&gt;<span class="built_in">setSuperclass</span>(supercls);</span><br><span class="line">    cls-&gt;<span class="built_in">initClassIsa</span>(metacls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整ivarLayout —— Reconcile(协调) instance variable offsets / layout</span></span><br><span class="line">    <span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) <span class="built_in">reconcileInstanceVariables</span>(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整instanceSize —— Set fastInstanceSize if it wasn&#x27;t set already.</span></span><br><span class="line">    cls-&gt;<span class="built_in">setInstanceSize</span>(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy some flags from ro to rw</span></span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        cls-&gt;<span class="built_in">setHasCxxDtor</span>();</span><br><span class="line">        <span class="keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            cls-&gt;<span class="built_in">setHasCxxCtor</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 ro 或从父类传播关联对象禁止标志。</span></span><br><span class="line">    <span class="keyword">if</span> ((ro-&gt;flags &amp; RO_FORBIDS_ASSOCIATED_OBJECTS) ||</span><br><span class="line">        (supercls &amp;&amp; supercls-&gt;forbidsAssociatedObjects()))</span><br><span class="line">    &#123;</span><br><span class="line">        rw-&gt;flags |= RW_FORBIDS_ASSOCIATED_OBJECTS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此类连接到其父类的子类列表</span></span><br><span class="line">    <span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">        <span class="built_in">addSubclass</span>(supercls, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">addRootClass</span>(cls);  <span class="comment">// 添加父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rw中需要保存ro中的一些数据，例如ro中的基础方法列表、属性列表、协议列表</span></span><br><span class="line">    <span class="comment">// rw还需要载入分类的方法列表</span></span><br><span class="line">    <span class="comment">// Attach categories</span></span><br><span class="line">    <span class="built_in">methodizeClass</span>(cls, previously);  <span class="comment">// methodize: vt. 使…有条理；为…定顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-methodizeClass"><a href="#2-methodizeClass" class="headerlink" title="2) methodizeClass"></a>2) methodizeClass</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* methodizeClass</span></span><br><span class="line"><span class="comment">* Fixes up cls&#x27;s method list, protocol list, and property list.</span></span><br><span class="line"><span class="comment">* Attaches any outstanding categories.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;<span class="built_in">isMetaClass</span>();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;<span class="built_in">ro</span>();</span><br><span class="line">    <span class="keyword">auto</span> rwe = rw-&gt;<span class="built_in">ext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装类自己实现的方法和属性。Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="comment">// 将ro中的基本方法列表添加到rw的方法列表中</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *list = ro-&gt;<span class="built_in">baseMethods</span>();</span><br><span class="line">    <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        <span class="built_in">prepareMethodLists</span>(cls, &amp;list, <span class="number">1</span>, YES, <span class="built_in">isBundleClass</span>(cls), <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (rwe) rwe-&gt;methods.<span class="built_in">attachLists</span>(&amp;list, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将ro中的属性列表添加到rw的属性列表中</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; proplist) &#123;</span><br><span class="line">        rwe-&gt;properties.<span class="built_in">attachLists</span>(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将ro中的协议列表添加到rw的协议列表中</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; protolist) &#123;</span><br><span class="line">        rwe-&gt;protocols.<span class="built_in">attachLists</span>(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根元类特殊处理。</span></span><br><span class="line">    <span class="comment">// 根类可以获得额外的方法实现(如果它们还没有的话). 这些适用于类别替换(category replacements)之前。</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRootMetaclass</span>()) &#123;</span><br><span class="line">        <span class="built_in">addMethod</span>(cls, @<span class="built_in">selector</span>(initialize), (IMP)&amp;objc_noop_imp, <span class="string">&quot;&quot;</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach categories. 将分类中的方法列表添加到rw的方法列表中</span></span><br><span class="line">    <span class="keyword">if</span> (previously) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">            objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, previously,</span><br><span class="line">                                                     ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当类重定位时，带有类方法的类别categories可能会注册在类本身而不是元类metaclass上。告诉attachToClass去查找这些。</span></span><br><span class="line">            objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, previously,</span><br><span class="line">                                                     ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, cls,</span><br><span class="line">                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-处理没有使用的类"><a href="#9-处理没有使用的类" class="headerlink" title="9. 处理没有使用的类"></a>9. 处理没有使用的类</h4><p>第一次启动时并不会执行，我们也可以看到 <code>resolvedFutureClasses</code> 中并没有记录到需要执行 <code>realizeClassWithoutSwift</code> 的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line"><span class="comment">// 实现 newly-resolved future classes，以防 CF 操作它们</span></span><br><span class="line"><span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">        Class cls = resolvedFutureClasses[i];</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Swift class is not allowed to be future&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现类</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将此类及其所有子类标记为需要原始 isa 指针</span></span><br><span class="line">        cls-&gt;<span class="built_in">setInstancesRequireRawIsaRecursively</span>(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(resolvedFutureClasses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc[56474]: 0.00 ms: IMAGE TIMES: realize future classes</span></span><br><span class="line"><span class="comment">// 打印时间为 0.00 毫秒</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize future classes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTION( DebugNonFragileIvars, OBJC_DEBUG_NONFRAGILE_IVARS, &quot;capriciously rearrange non-fragile ivars&quot;)</span></span><br><span class="line"><span class="comment">//（反复无常地重新排列非脆弱的 ivars）</span></span><br><span class="line"><span class="comment">// 如果开启了 OBJC_DEBUG_NONFRAGILE_IVARS 这个环境变量，则会执行 realizeAllClasses() 函数，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-lazily realizes 所有已知 image 中所有未实现的类。(即对已知的 image 中的所有类：懒加载和非懒加载类全部进行实现)</span></span><br><span class="line"><span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">    <span class="built_in">realizeAllClasses</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print preoptimization statistics</span></span><br><span class="line"><span class="comment">// 打印预优化统计信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTION( PrintPreopt, OBJC_PRINT_PREOPTIMIZATION, &quot;log preoptimization courtesy of dyld shared cache&quot;)</span></span><br><span class="line"><span class="comment">// 日志预优化由 dyld shared cache 提供</span></span><br></pre></td></tr></table></figure><h4 id="10-log输出"><a href="#10-log输出" class="headerlink" title="10. log输出"></a>10. log输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (PrintPreopt) &#123;</span><br><span class="line">        <span class="comment">// 一些 log 输出...</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> EACH_HEADER</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、load-images"><a href="#四、load-images" class="headerlink" title="四、load_images()"></a>四、load_images()</h2><h3 id="4-1-load-images-源码实现"><a href="#4-1-load-images-源码实现" class="headerlink" title="4.1 load_images()源码实现"></a>4.1 load_images()源码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 处理 dyld 映射的 images 中的 +load </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_images</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// didInitialAttachCategories 标记加载分类的，默认值为 false，</span></span><br><span class="line">    <span class="comment">// didCallDyldNotifyRegister 标记 _dyld_objc_notify_register 是否调用完成</span></span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">loadAllCategories</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 mh 中不包含 +load 就直接不加锁 return（且 without taking locks）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hasLoadMethods 函数是根据 `headerType *mhdr` 的 `__objc_nlclslist` 区和 `__objc_nlcatlist` 区中是否有数据，来判断是否有 +load 函数要执行。(即是否包含非懒加载类和非懒加载分类) </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">hasLoadMethods</span>((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loadMethodLock 是一把递归互斥锁（加锁）</span></span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现(Discover) +load 方法</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// runtimeLock 加锁</span></span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收集所有要调用的 +load 方法(Class、SuperClass、Category中的)</span></span><br><span class="line">        <span class="built_in">prepare_load_methods</span>((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    <span class="comment">// 调用获取到的所有 +load 方法：从调用中，可以看到依次调用父类、子类、分类的load方法</span></span><br><span class="line">    <span class="built_in">call_load_methods</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-loadAllCategories-分类加载"><a href="#4-2-loadAllCategories-分类加载" class="headerlink" title="4.2 loadAllCategories() 分类加载"></a>4.2 loadAllCategories() 分类加载</h3><h4 id="4-2-1-loadAllCategories"><a href="#4-2-1-loadAllCategories" class="headerlink" title="4.2.1 loadAllCategories()"></a>4.2.1 loadAllCategories()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadAllCategories</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;<span class="built_in">getNext</span>()) &#123;</span><br><span class="line">        <span class="built_in">load_categories_nolock</span>(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-load-categories-nolock"><a href="#4-2-2-load-categories-nolock" class="headerlink" title="4.2.2 load_categories_nolock()"></a>4.2.2 load_categories_nolock()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_categories_nolock</span><span class="params">(header_info *hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasClassProperties = hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> processCatlist = [&amp;](<span class="keyword">category_t</span> * <span class="keyword">const</span> *catlist) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">            <span class="keyword">locstamped_category_t</span> lc&#123;cat, hi&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category&#x27;s target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Ignore the category.</span></span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                                 <span class="string">&quot;missing weak-linked target class&quot;</span>,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category.</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;<span class="built_in">isStubClass</span>()) &#123;</span><br><span class="line">                <span class="comment">// Stub(桩) classes永远不会实现(realized)。Stub classes在初始化之前不知道它们的元类，因此我们必须将带</span></span><br><span class="line">                <span class="comment">// 有类方法或属性的类别添加到Stub classes本身。methodizeClass() 将找到它们并将它们适当地添加到元类中。</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    cat-&gt;instanceProperties ||</span><br><span class="line">                    cat-&gt;classMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 首先，将category注册到其目标类(target class)。</span></span><br><span class="line">                <span class="comment">// 然后，如果class is realized，则重建类的方法列表（等）。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把分类中的，实例方法、协议、属性添加到类.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||  </span><br><span class="line">                    cat-&gt;protocols ||  </span><br><span class="line">                    cat-&gt;instanceProperties)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                        <span class="built_in">attachCategories</span>(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把分类中的，类方法、协议添加到元类</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;classMethods  ||  </span><br><span class="line">                    cat-&gt;protocols  ||  </span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                        <span class="built_in">attachCategories</span>(cls-&gt;<span class="built_in">ISA</span>(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 对应</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2CategoryList, category_t *, &quot;__objc_catlist&quot;);</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2CategoryList2, category_t * const, &quot;__objc_catlist2&quot;);</span></span><br><span class="line">    <span class="comment">// _getObjc2CategoryList 取得 DATA 段 &quot;__objc_catlist&quot; section 中的 category 数据</span></span><br><span class="line">    <span class="built_in">processCatlist</span>(hi-&gt;<span class="built_in">catlist</span>(&amp;count));</span><br><span class="line">    <span class="comment">// _getObjc2CategoryList2 取得 DATA 段 &quot;__objc_catlist2&quot; section 中的 category 数据</span></span><br><span class="line">    <span class="built_in">processCatlist</span>(hi-&gt;<span class="built_in">catlist2</span>(&amp;count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-attachCategories"><a href="#4-2-3-attachCategories" class="headerlink" title="4.2.3 attachCategories()"></a>4.2.3 attachCategories()</h4><ul><li><p>把所有Category的方法、属性、协议数据，合并到一个大数组中。后面参与编译的Category数据，会在数组的前面。</p></li><li><p>将合并后的分类数据(方法、属性、协议)，插入到类原来数据的前面。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将方法列表、属性和协议从categories附加到class。</span></span><br><span class="line"><span class="comment">// 假设cats_list中的所有categories都已加载，并按加载顺序排序，最老的类别优先。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">attachCategories</span>(Class cls, <span class="keyword">const</span> <span class="keyword">locstamped_category_t</span> *cats_list, <span class="keyword">uint32_t</span> cats_count, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(PrintReplacedMethods)) &#123;</span><br><span class="line">        <span class="built_in">printReplacements</span>(cls, cats_list, cats_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(PrintConnecting)) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;CLASS: attaching %d categories to%s class &#x27;%s&#x27;%s&quot;</span>,</span><br><span class="line">                     cats_count, (flags &amp; ATTACH_EXISTING) ? <span class="string">&quot; existing&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     cls-&gt;<span class="built_in">nameForLogging</span>(), (flags &amp; ATTACH_METACLASS) ? <span class="string">&quot; (meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     在发布期间，只有少数类的类别超过 64 个。</span></span><br><span class="line"><span class="comment"> 这使用了一个小stack，避免了 malloc。</span></span><br><span class="line"><span class="comment"> Categories 必须以正确的顺序添加，即从后到前。为了通过分块(chunking)来做到这一点，我们从前到后迭代cats_list，向后构建本地缓冲区，</span></span><br><span class="line"><span class="comment"> 并在块上调用attachLists。 attachLists将列表放在前面，因此最终结果按预期顺序排列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">method_list_t</span>   *mlists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">property_list_t</span> *proplists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolists[ATTACH_BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">    <span class="keyword">auto</span> rwe = cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">extAllocIfNeeded</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cats_count; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats_list[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;<span class="built_in">methodsForMeta</span>(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                <span class="built_in">prepareMethodLists</span>(cls, mlists, mcount, NO, fromBundle, __func__);</span><br><span class="line">                rwe-&gt;methods.<span class="built_in">attachLists</span>(mlists, mcount);</span><br><span class="line">                mcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist =</span><br><span class="line">            entry.cat-&gt;<span class="built_in">propertiesForMeta</span>(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (propcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;properties.<span class="built_in">attachLists</span>(proplists, propcount);</span><br><span class="line">                propcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;<span class="built_in">protocolsForMeta</span>(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (protocount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;protocols.<span class="built_in">attachLists</span>(protolists, protocount);</span><br><span class="line">                protocount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">prepareMethodLists</span>(cls, mlists + ATTACH_BUFSIZ - mcount, mcount,</span><br><span class="line">                           NO, fromBundle, __func__);</span><br><span class="line">        rwe-&gt;methods.<span class="built_in">attachLists</span>(mlists + ATTACH_BUFSIZ - mcount, mcount);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; ATTACH_EXISTING) &#123;</span><br><span class="line">            <span class="built_in">flushCaches</span>(cls, __func__, [](Class c)&#123;</span><br><span class="line">                <span class="comment">// constant caches have been dealt with in prepareMethodLists</span></span><br><span class="line">                <span class="comment">// if the class still is constant here, it&#x27;s fine to keep</span></span><br><span class="line">                <span class="keyword">return</span> !c-&gt;cache.<span class="built_in">isConstantOptimizedCache</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rwe-&gt;properties.<span class="built_in">attachLists</span>(proplists + ATTACH_BUFSIZ - propcount, propcount);</span><br><span class="line"></span><br><span class="line">    rwe-&gt;protocols.<span class="built_in">attachLists</span>(protolists + ATTACH_BUFSIZ - protocount, protocount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-hasLoadMethods"><a href="#4-3-hasLoadMethods" class="headerlink" title="4.3 hasLoadMethods()"></a>4.3 hasLoadMethods()</h3><p>根据 <code>headerType *mhdr</code> 的 <code>__objc_nlclslist</code> 区和 <code>__objc_nlcatlist</code> 区中是否有数据，来判断是否有 <code>+load</code> 函数要执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quick scan for +load methods that doesn&#x27;t take a lock.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 1. 首先去看类列表中，有没有load方法</span></span><br><span class="line">    <span class="comment">// 读取__DATA段(Segment)中的__objc_nlclslist区(section)中的非懒加载类的列表。判断count是否大于1，大于1说明有load方法，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 去所有的category中看，是否有load方法</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyCategoryList, category_t * const, &quot;__objc_nlcatlist&quot;);</span></span><br><span class="line">    <span class="comment">// 读取__DATA段中的__objc_nlcatlist区中非懒加载分类的列表</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-prepare-load-methods"><a href="#4-3-prepare-load-methods" class="headerlink" title="4.3 prepare_load_methods()"></a>4.3 prepare_load_methods()</h3><p>获取所有要调用的 +load 方法（父类、子类、分类）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取所有 __objc_nlclslist 区的数据，即获取所有非懒加载类</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #define RW_LOADED (1&lt;&lt;23) // class +load has been called</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于其构造方式，此列表始终首先处理 superclasses 的 +load 函数</span></span><br><span class="line">    <span class="comment">// 需要调用 +load 的 classes 列表</span></span><br><span class="line">    <span class="comment">// static struct loadable_class *loadable_classes = nil;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历这些非懒加载类，并将其 +load 函数添加到 loadable_classes 数组中，优先添加其父类的 +load 方法，</span></span><br><span class="line">    <span class="comment">// 用于下面 call_load_methods 函数调用 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 内部会递归调用，从传入的cls依次向上查找superClass，并调用add_class_to_loadable_list方法，将实现了load方法的类的：Class cls、IMP method收集</span></span><br><span class="line">        <span class="comment">// 父类、子类都通过该方法收集出来，父类们先被收集，即先被调用</span></span><br><span class="line">        <span class="built_in">schedule_class_load</span>(<span class="built_in">remapClass</span>(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyCategoryList, category_t * const, &quot;__objc_nlcatlist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取所有 __objc_nlcatlist 区的数据，即获取所有非懒加载分类</span></span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历这些分类</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// weak-linked class：</span></span><br><span class="line">        <span class="comment">//   如果我们在一个库中使用新版本系统的一些特性API，但又想程序可以在低版本系统上运行，这个时候对这些符号使用弱引用就好。</span></span><br><span class="line">        <span class="comment">//   使用了弱引用之后，即使在版本较旧的环境下跑，也可以运行，只是相应的符号是NULL。</span></span><br><span class="line">        <span class="comment">//   有一点需要说明的是，如果一个framework没有为新加入的符号加入弱引用，那也不必担心，我们只要在链接时弱引用(weak link)整个framework就好</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果没有找到分类所属的类就跳出当前循环，处理数组中的下一个分类</span></span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Swift class extensions and categories on Swift &quot;</span></span><br><span class="line">                        <span class="string">&quot;classes are not allowed to have +load methods&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果分类所属的类没有实现就先去实现</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要调用 +load 的 categories 列表</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">          static struct loadable_category *loadable_categories = nil;</span></span><br><span class="line"><span class="comment">          struct loadable_category &#123;</span></span><br><span class="line"><span class="comment">              Category cat;  // may be nil</span></span><br><span class="line"><span class="comment">              IMP method;</span></span><br><span class="line"><span class="comment">          &#125;;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历这些分类，并将Category cat、IMP method收集到 loadable_categories 数组中保存</span></span><br><span class="line">        <span class="built_in">add_category_to_loadable_list</span>(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-1-schedule-class-load"><a href="#4-3-1-schedule-class-load" class="headerlink" title="4.3.1 schedule_class_load"></a>4.3.1 schedule_class_load</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// schedule_class_load 将其 +load 函数添加到 loadable_classes 数组中，优先添加其父类的 +load 方法。（用于后续 call_load_methods 函数调用）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果 cls 不存在则 return（下面有一个针对 superclass 的递归调用）</span></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DEBUG 模式下的断言，cls 必须是实现过的（这个在 _read_images 中已经实现了）</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(cls-&gt;<span class="built_in">isRealized</span>());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// class +load has been called</span></span><br><span class="line">    <span class="comment">// #define RW_LOADED (1&lt;&lt;23)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RW_LOADED 是 class +load 已被调用的掩码</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">// 优先处理 superclass 的 +load 函数</span></span><br><span class="line">    <span class="built_in">schedule_class_load</span>(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static struct loadable_class *loadable_classes = nil;</span></span><br><span class="line">    <span class="comment">// struct loadable_class &#123;</span></span><br><span class="line">    <span class="comment">//    Class cls;  // may be nil</span></span><br><span class="line">    <span class="comment">//    IMP method;</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 cls 的 +load 函数添加到全局的 loadable_class 数组 loadable_classes 中，</span></span><br><span class="line">    <span class="comment">// loadable_class 结构体是用来保存类的 +load 函数的一个数据结构，其中 cls 是该类，method 则是 +load 函数的 IMP，</span></span><br><span class="line">    <span class="comment">// 这里也能看出 +load 函数是不走 OC 的消息转发机制的，它是直接通过 +load 函数的地址调用的！</span></span><br><span class="line">    <span class="built_in">add_class_to_loadable_list</span>(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 RW_LOADED 设置到类的 Flags 中</span></span><br><span class="line">    cls-&gt;<span class="built_in">setInfo</span>(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class cls has just become connected. Schedule it for +load if it implements a +load method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从 class 中获取 load 方法</span></span><br><span class="line">    method = cls-&gt;<span class="built_in">getLoadMethod</span>();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don&#x27;t bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;</span>, </span><br><span class="line">                     cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 判断当前 loadable_classes 这个数组是否已经被全部占用</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 3. 在当前数组的基础上扩大数组的大小：realloc</span></span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="built_in"><span class="keyword">sizeof</span></span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 把传入的 class 以及对应的方法的实现IMP加到列表中</span></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-call-load-methods"><a href="#4-4-call-load-methods" class="headerlink" title="4.4 call_load_methods()"></a>4.4 call_load_methods()</h3><p><code>+load</code> 函数的调用顺序：父类 -&gt; 子类 -&gt; 分类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment"> * Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment"> * Category +load methods are not called until after the parent class&#x27;s +load.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="comment">// 重入调用什么都不做；最外层的调用将完成工作。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果正在 loading 则 return，</span></span><br><span class="line">    <span class="comment">// 保证当前 +load 方法同时只有一次被调用</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建自动释放池</span></span><br><span class="line">    <span class="keyword">void</span> *pool = <span class="built_in">objc_autoreleasePoolPush</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 不停调用类的 + load 方法</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用 loadable_classes 中的的类的 +load 函数，并且把 loadable_classes_used 置为 0</span></span><br><span class="line">            <span class="built_in">call_class_loads</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 调用 分类中的 +load 函数， 只调用一次 call_category_loads</span></span><br><span class="line">        <span class="comment">// 因为上面的 call_class_loads 函数内部，已经把 loadable_classes_used 置为 0，所以除非有新的分类需要 +load，即 call_category_loads 返回 true，否则循环就结束了。 </span></span><br><span class="line">        more_categories = <span class="built_in">call_category_loads</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line">    <span class="comment">// 如果 loadable_classes_used 大于 0，或者有更多分类需要调用 +load，则循环继续。（一般 loadable_classes_used 到这里基本就是 0 了）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动释放池进行 pop</span></span><br><span class="line">    <span class="built_in">objc_autoreleasePoolPop</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记处理完成了，可以进行下一个了</span></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-关于-load-方法的几个QA"><a href="#4-5-关于-load-方法的几个QA" class="headerlink" title="4.5 关于 +load 方法的几个QA"></a>4.5 关于 +load 方法的几个QA</h3><p>Q: +load的应用？</p><p>A: <code>load</code> 可以说我们在日常开发中可以接触到的调用时间<strong>最靠前的方法</strong>，在主函数运行之前，<code>load</code> 方法就会调用。</p><p>由于它的调用<em>不是惰性</em>(non-lazy)的，且其只会在程序调用期间调用一次，最最重要的是，如果在类与分类中都实现了 <code>load</code> 方法，它们都会被调用，不像其它的在分类中实现的方法会被覆盖，这就使 <code>load</code> 方法成为了<a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>的绝佳时机。</p><p>因为 load 调用时机过早，并且当多个 Class 没有关联（继承与派生），我们无法知道 Class 中 load 方法的优先调用关系，所以一般不会在 load 方法中引入其他的类，这是在开发当中需要注意的。</p><p>不过在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的。</p><p>Q: 重载自己 Class 的 +load 方法时需不需要调父类？</p><p>A: runtime 负责按继承顺序递归调用，所以我们不能调 super</p><p>Q: 在自己 Class 的 +load 方法时能不能替换系统 framework（比如 UIKit）中的某个类的方法实现</p><p>A: 可以，因为动态链接过程中，所有依赖库的类是先于自己的类加载的</p><p>Q: 重载 +load 时需要手动添加 @autoreleasepool 么？</p><p>A: 不需要，在 runtime 调用 +load 方法前后是加了 objc_autoreleasePoolPush() 和 objc_autoreleasePoolPop() 的。</p><p>Q: 想让一个类的 +load 方法被调用是否需要在某个地方 import 这个文件</p><p>A: 不需要，只要这个类的符号被编译到最后的可执行文件中，+load 方法就会被调用（Reveal SDK 就是利用这一点，只要引入到工程中就能工作）</p><h2 id="五、类的加载过程总结"><a href="#五、类的加载过程总结" class="headerlink" title="五、类的加载过程总结"></a>五、类的加载过程总结</h2><p>类存在懒加载机制，懒加载类先标记为 future class，正式加载 future class 数据需要调用<code>readClass(...)</code>方法，对 future class 进行重映射（remapping）；</p><p>截止至完成 class realizing，类的加载过程大致如下图所示。</p><ul><li>future class列是懒加载类（future class）的流程，经过了“添加懒加载类-&gt;加载懒加载类信息-&gt;懒加载类重映射-&gt;实现懒加载类”四步；</li><li>normal class列是普通的非懒加载类的加载流程，只经过“加载类信息-&gt;实现类”两个步骤。</li></ul><img src="/images/compilelink/37.png" alt="36" style="zoom:88%;" /><p>类完成 class realizing 后，还需要执行类及分类中的<code>load()</code>方法，最后在程序运行过程中第一次调用类的方法时（实现逻辑在<code>IMP lookUpImpOrForward(...)</code>函数中）触发<code>isInitialized()</code>检查，若未初始化，则需要先执行类的<code>initialize()</code>方法。至此，类正式加载完成。</p><blockquote><p>注意：最后的 class initializing 严格意义上应该不属于类的加载过程，可以将其归为独立的类初始化阶段。类的加载在<code>load()</code>方法执行后就算是完成了。</p></blockquote><h2 id="六、unmap-images"><a href="#六、unmap-images" class="headerlink" title="六、unmap_images()"></a>六、unmap_images()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Process the given image which is about to be unmapped by dyld.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line"><span class="built_in">unmap_image</span>(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="built_in">unmap_image_nolock</span>(mh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-unmap-image-nolock"><a href="#6-1-unmap-image-nolock" class="headerlink" title="6.1 unmap_image_nolock()"></a>6.1 unmap_image_nolock()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line"><span class="built_in">unmap_image_nolock</span>(<span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: processing 1 newly-unmapped image...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    header_info *hi;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find the runtime&#x27;s header_info struct for the image</span></span><br><span class="line">    <span class="keyword">for</span> (hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;<span class="built_in">getNext</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi-&gt;<span class="built_in">mhdr</span>() == (<span class="keyword">const</span> headerType *)mh) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hi) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: unloading image for %s%s%s\n&quot;</span>, </span><br><span class="line">                     hi-&gt;<span class="built_in">fname</span>(),</span><br><span class="line">                     hi-&gt;<span class="built_in">mhdr</span>()-&gt;filetype == MH_BUNDLE ? <span class="string">&quot; (bundle)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">isReplacement</span>() ? <span class="string">&quot; (replacement)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _unload_image(hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove header_info from header list</span></span><br><span class="line">    <span class="built_in">removeHeader</span>(hi);</span><br><span class="line">    <span class="built_in">free</span>(hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-unload-image"><a href="#6-2-unload-image" class="headerlink" title="6.2 _unload_image()"></a>6.2 _unload_image()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _unload_image</span></span><br><span class="line"><span class="comment">* Only handles MH_BUNDLE for now.</span></span><br><span class="line"><span class="comment">* Locking: write-lock and loadMethodLock acquired by unmap_image</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _unload_image(header_info *hi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unload unattached categories and categories waiting for +load.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore __objc_catlist2. We don&#x27;t support unloading Swift</span></span><br><span class="line">    <span class="comment">// and we never will.</span></span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *catlist = hi-&gt;<span class="built_in">catlist</span>(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme for MH_DYLIB cat&#x27;s class may have been unloaded already</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// unattached list</span></span><br><span class="line">        objc::unattachedCategories.<span class="built_in">eraseCategoryForClass</span>(cat, cls);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// +load queue</span></span><br><span class="line">        <span class="built_in">remove_category_from_loadable_list</span>(cat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unload classes.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gather classes from both __DATA,__objc_clslist </span></span><br><span class="line">    <span class="comment">// and __DATA,__objc_nlclslist. arclite&#x27;s hack puts a class in the latter</span></span><br><span class="line">    <span class="comment">// only, and we need to unload that class if we unload an arclite image.</span></span><br><span class="line"></span><br><span class="line">    objc::DenseSet&lt;Class&gt; classes&#123;&#125;;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist;</span><br><span class="line"></span><br><span class="line">    classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (cls) classes.<span class="built_in">insert</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    classlist = hi-&gt;<span class="built_in">nlclslist</span>(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (cls) classes.<span class="built_in">insert</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First detach classes from each other. Then free each class.</span></span><br><span class="line">    <span class="comment">// This avoid bugs where this loop unloads a subclass before its superclass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class cls: classes) &#123;</span><br><span class="line">        <span class="built_in">remove_class_from_loadable_list</span>(cls);</span><br><span class="line">        <span class="built_in">detach_class</span>(cls-&gt;<span class="built_in">ISA</span>(), YES);</span><br><span class="line">        <span class="built_in">detach_class</span>(cls, NO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Class cls: classes) &#123;</span><br><span class="line">        <span class="built_in">free_class</span>(cls-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">        <span class="built_in">free_class</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX FIXME -- Clean up protocols:</span></span><br><span class="line">    <span class="comment">// &lt;rdar://problem/9033191&gt; Support unloading protocols at dylib/image unload time</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme DebugUnload</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li><a href="https://juejin.cn/post/6844903965201530888#heading-0">Runtime源代码解读2（类和对象）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、前文回顾&quot;&gt;&lt;a href=&quot;#一、前文回顾&quot; class=&quot;headerlink&quot; title=&quot;一、前文回顾&quot;&gt;&lt;/a&gt;一、前文回顾&lt;/h2&gt;&lt;p&gt;上一篇&lt;a href=&quot;https://tenloy.github.io/2021/09/27/compil</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(六) Mach-O 文件的动态链接、库、Dyld(含dlopen)</title>
    <link href="https://tenloy.github.io/2021/09/27/compile-dynamic-link.html"/>
    <id>https://tenloy.github.io/2021/09/27/compile-dynamic-link.html</id>
    <published>2021-09-27T14:26:09.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、动态链接"><a href="#一、动态链接" class="headerlink" title="一、动态链接"></a>一、动态链接</h2><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有的程序模块都链接成一个个单独的可执行文件。</p><p>动态链接涉及运行时的链接及多个文件的装载，必需要有操作系统的支持，因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。目前主流的操作系统几乎都支持动态链接这种方式。</p><p>link 这个过程就是将加载进来的二进制变为可用状态的过程。简单来说就是：<code>rebase =&gt; binding</code>。先来介绍动态链接中的几个概念：</p><h3 id="1-1-rebase"><a href="#1-1-rebase" class="headerlink" title="1.1 rebase"></a>1.1 rebase</h3><p>rebase就是指针修正的过程。</p><p>一个mach-o的二进制文件中，包含了<strong>text</strong>段和<strong>data</strong>段。而<strong>data</strong>段中的数据也会存在<strong>引用</strong>关系。 我们知道在代码中，我们可以用<strong>指针</strong>来引用，那么在一个文件中怎么代表引用呢，那就是<strong>偏移</strong>(相对于text段开始的偏移)。 </p><p>当二进制加载到内存中的时候，起始地址就是申请的内存的起始地址（slide)，不会是0，那么如何再能够找到这些引用的正确内存位置呢？ 把<strong>偏移</strong>加上(slide)就好了。 这个过程就是rebase的过程。</p><img src="/images/compilelink/38.png" alt="38" style="zoom:70%;" /><h3 id="1-2-bind"><a href="#1-2-bind" class="headerlink" title="1.2 bind"></a>1.2 bind</h3><blockquote><p>“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即它们所使用的范围不一样。</p></blockquote><p>bind就是符号绑定的过程。</p><p>为什么要bind? 因为符号在不同的库里面。</p><p>举个简单的例子，我们代码里面调用了 <code>NSClassFromString</code>. 但是<code>NSClassFromString</code>的代码和符号都是在 <code>Foundation.framework</code> 这个动态库里面。而在程序未加载之前，我们的代码是不知道<code>NSLog</code>在哪里的，于是编译器就编译了一个 <strong>stub</strong> 来调用 <code>NSClassFromString</code>:</p><img src="/images/compilelink/39.png" alt="39" style="zoom:97%;" /><p>可以看到，我们的代码里面直接从 pc + 0x3701c的地方取出来一个值，然后直接br， 也就是认为这个值就是 <code>NSClassFromString</code>的真实地址了。我们再看看这个位置的值是啥：</p><img src="/images/compilelink/40.png" alt="40" style="zoom:100%;" /><p>也就是说，这块地址的8个字节会在<strong>bind</strong>之后存入的就是 <code>NSClassFromString</code>的代码地址， 那么就实现了真正调用 <code>NSClassFromString</code>的过程。</p><p>上面我们知道了为啥要<strong>bind</strong>. 那是如何bind的呢？ bind又分为哪些呢？</p><h4 id="1-2-1-怎么bind"><a href="#1-2-1-怎么bind" class="headerlink" title="1.2.1 怎么bind"></a>1.2.1 怎么bind</h4><p>首先 mach-o 的 LoadCommand里面的会有一个cmd来描述 dynamic loader info，数据结构与示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下的偏移量是相对于目标文件/可执行文件的起始地址，注意后者的起始地址一般不会是0，寻址时要加上</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dyld_info_command</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   cmd;            <span class="comment">/* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   cmdsize;        <span class="comment">/* sizeof(struct dyld_info_command) */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   rebase_off;     <span class="comment">/* file offset to rebase info  */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   rebase_size;    <span class="comment">/* size of rebase info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   bind_off;       <span class="comment">/* file offset to binding info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   bind_size;      <span class="comment">/* size of binding info  */</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Some C++ programs require dyld to unique symbols so that all images in the process use the same copy of some code/data. </span></span><br><span class="line"><span class="comment">    This step is done after binding. </span></span><br><span class="line"><span class="comment">    The content of the weak_bind info is an opcode stream like the bind_info. But it is sorted alphabetically by symbol name. This enable dyld to walk all images with weak binding information in order and look for collisions. </span></span><br><span class="line"><span class="comment">    If there are no collisions, dyld does no updating. That means that some fixups are also encoded in the bind_info. </span></span><br><span class="line"><span class="comment">    For instance, all calls to &quot;operator new&quot; are first bound to libstdc++.dylib using the information in bind_info. Then if some image overrides operator new that is detected when the weak_bind information is processed and the call to operator new is then rebound.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   weak_bind_off;  <span class="comment">/* file offset to weak binding info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   weak_bind_size; <span class="comment">/* size of weak binding info  */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   lazy_bind_off;  <span class="comment">/* file offset to lazy binding info */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   lazy_bind_size; <span class="comment">/* size of lazy binding infs */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   export_off;     <span class="comment">/* file offset to export info */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   export_size;    <span class="comment">/* size of export infs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解析出来会得到这样的信息：</p><ul><li><code>rebase</code>：就是针对 “mach-o在加载到虚拟内存中不是固定的首地址” 这一现象做数据修正的过程。一般可执行文件在没有ASLR造成的首地址不固定的情况下，装载进虚拟地址中的首地址都是固定的，比如：Linux下一般都是<code>0x08040000</code>，Windows下一般都是<code>0x0040000</code>，Mach-O的TEXT地址在__PageZero之后的<code>0x100000000</code>地址.</li><li><code>binding</code>：就是将这个二进制调用的外部符号进行绑定的过程。 比如我们objc代码中需要使用到NSObject，即符号<code>_OBJC_CLASS_$_NSObject</code>，但是这个符号又不在我们的二进制中，在系统库 Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。</li><li><code>lazyBinding</code>：就是在加载动态库的时候不会立即binding，当时当第一次调用这个方法的时候再实施binding。 做到的方法也很简单： 通过<code>dyld_stub_binder</code>这个符号来做。 lazy binding的方法第一次会调用到dyld_stub_binder, 然后dyld_stub_binder负责找到真实的方法，并且将地址bind到桩上，下一次就不用再bind了。</li><li><code>weakBinding</code>：OC的代码貌似不会编译出<code>Weak Bind</code>. 目前遇到的<code>Weak Bind</code>都是C++的 <code>template</code> 的方法。特点就是：Weak bind的符号每加载进来二进制都会bind到最新的符号上。比如2个动态库里面都有同样的<code>weak bind</code>符号，那么所有的的符号引用都会bind到后加载进来的那个符号上。</li></ul><img src="/images/compilelink/41.png" alt="41" style="zoom:90%;" /><p>可以看到，这里面记录了二进制data段里面哪些是 rebase信息，哪些是binding信息：</p><img src="/images/compilelink/42.png" alt="42" style="zoom:78%;" /><p>可以看到binding info的数据结构，bind的过程根据不同的opcode解析出不同的信息，在opcode为<code>BIND_OPCODE_DO_BIND</code>的时候，会执行<code>bindLocation</code>来进行bind。</p><p>截取了 bindLocation 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">ImageLoaderMachO::bindLocation</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context,...)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// do actual update</span></span><br><span class="line">    <span class="keyword">uintptr_t</span>* locationToFix = (<span class="keyword">uintptr_t</span>*)location;</span><br><span class="line">    <span class="keyword">uint32_t</span>* loc32;</span><br><span class="line">    <span class="keyword">uintptr_t</span> newValue = value+addend;</span><br><span class="line">    <span class="keyword">uint32_t</span> value32;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_POINTER:</span><br><span class="line">            <span class="comment">// test first so we don&#x27;t needless dirty pages</span></span><br><span class="line">            <span class="keyword">if</span> ( *locationToFix != newValue )</span><br><span class="line">                *locationToFix = newValue;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_TEXT_ABSOLUTE32:</span><br><span class="line">            loc32 = (<span class="keyword">uint32_t</span>*)locationToFix;</span><br><span class="line">            value32 = (<span class="keyword">uint32_t</span>)newValue;</span><br><span class="line">            <span class="keyword">if</span> ( *loc32 != value32 )</span><br><span class="line">                *loc32 = value32;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_TEXT_PCREL32:</span><br><span class="line">            loc32 = (<span class="keyword">uint32_t</span>*)locationToFix;</span><br><span class="line">            value32 = (<span class="keyword">uint32_t</span>)(newValue - (((<span class="keyword">uintptr_t</span>)locationToFix) + <span class="number">4</span>));</span><br><span class="line">            <span class="keyword">if</span> ( *loc32 != value32 )</span><br><span class="line">                *loc32 = value32;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            dyld::<span class="built_in">throwf</span>(<span class="string">&quot;bad bind type %d&quot;</span>, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出， bind过程也不是单纯的就是把符号地址填过来就好了， 还有type和addend的逻辑。不过一般不多见，大部分都是<code>BIND_TYPE_POINTER</code>.</p><p>addend 一般用于要bind某个数组中的某个子元素时，记录这个子元素在数组的偏移。</p><h4 id="1-2-2-Lazy-Bind"><a href="#1-2-2-Lazy-Bind" class="headerlink" title="1.2.2 Lazy Bind"></a>1.2.2 Lazy Bind</h4><p>延迟加载是为了启动速度。上面看到bind的过程，发现bind的过程需要查到对应的符号再进行bind. 如果在启动的时候，所有的符号都立即bind成功，那么势必拖慢启动速度。</p><p>其实很多符号都是LazyBind的。就是第一次调用到才会真正的bind.</p><p>其实刚才截图的 <code>imp___la_symbol_ptr__objc_getClass</code> 就是一个 LazyBind 的符号。 图中的 0x10d6e8 指向了 <code>stub_helper</code> 这个section中的代码。</p><img src="/images/compilelink/43.png" alt="43" style="zoom:90%;" /><p>如上图中</p><ul><li>先取了 <code>0x10d6f0</code> 的 4个字节数据存入 w16. 这个数据其实是 lazy bind info段的偏移</li><li>然后走到 0x10d6d0, 取出 ImageLoader cache, 存入 x17</li><li>把 lazy bind info offset 和 ImageLoaderCache 存入栈上。</li><li>然后取出 dyld_stub_binder的地址，存入x16. 跳转 dyld_stub_binder</li><li>dyld_stub_binder 会根据传入的 lazy bind info的 offset来执行真正的bind. bind结束后，刚才看到的 <code>0x10d6e8</code> 这个地址就变成了 <code>NSClassFromString</code>。就完成了LazyBind的过程。</li></ul><p><code>dyld_stub_binder</code>的源码此处不再展示。</p><h4 id="1-2-3-Weak-Bind"><a href="#1-2-3-Weak-Bind" class="headerlink" title="1.2.3 Weak Bind"></a>1.2.3 Weak Bind</h4><p>OC的代码貌似不会编译出<code>Weak Bind</code>. 目前遇到的<code>Weak Bind</code>都是C++的 <code>template</code> 的方法。特点就是：Weak bind的符号每加载进来二进制都会bind到最新的符号上。比如2个动态库里面都有同样的<code>weak bind</code>符号，那么所有的的符号引用都会bind到后加载进来的那个符号上。</p><h2 id="二、库-静态库和动态库"><a href="#二、库-静态库和动态库" class="headerlink" title="二、库: 静态库和动态库"></a>二、库: 静态库和动态库</h2><p>库(Library)，是我们在开发中的重要角色，库的作用在于代码共享、模块分割以及提升良好的工程管理实践。说白了就是一段编译好的二进制代码，加上头文件就可以供别人使用。</p><p>为什么要用库？一种情况是某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件(<strong>静态库和动态库的共同点就是不会暴露内部具体的代码信息</strong>)。另外一种情况是，对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间。</p><p>根据库在使用的时候 Link 时机或者说方式(静态链接、动态链接)，库分为静态库和动态库。</p><h3 id="2-1-静态库"><a href="#2-1-静态库" class="headerlink" title="2.1 静态库"></a>2.1 静态库</h3><p>静态库即静态链接库（Windows 下的 .lib，linux 下的.a，Mac 下的 .a .framework）。之所以叫做静态，是因为静态库在<code>链接时</code>会被完整地拷贝一份到可执行文件中(会使最终的可执行文件体积增大)。被多个程序使用就会有多份冗余拷贝。如果更新静态库，需要重新编译一次可执行文件，重新链接新的静态库。</p><h3 id="2-2-动态库"><a href="#2-2-动态库" class="headerlink" title="2.2 动态库"></a>2.2 动态库</h3><p>动态库即动态链接库。与静态库相反，动态库在编译时并不会被拷贝到可执行文件中，可执行文件中只会存储指向动态库的引用(使用了动态库的符号、及对应库的路径等)。等到程序<code>运行时</code>，动态库才会被真正加载进来，此时，先根据记录的库路径找到对应的库，再通过记录的名字符号找到绑定的地址。</p><p>动态库的优点是：</p><ul><li><strong>减少可执行文件体积</strong>：相比静态链接，动态链接在编译时不需要打进去(不需要拷贝到每个可执行文件中)，所以可执行文件的体积要小很多。</li><li><strong>代码共用</strong>：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份(因为这个原因，动态库也被称作<strong>共享库</strong>)。</li><li><strong>易于维护</strong>：使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。</li></ul><p>常见的可执行文件的形式：</p><ul><li>Linux系统中，ELF动态链接文件被称为<strong>动态共享对象</strong>(<code>DSO，Dynamic SharedObjects</code>)，简称共享对象，一般都是以 <code>.so</code> 为扩展名的一些文件；</li><li>Windows系统中，动态链接文件被称为<strong>动态链接库</strong>(<code>Dynamical Linking Library</code>)，通常就是我们平时很常见的以 <code>.dll</code> 为扩展名的文件；</li><li>OS X 和其他 UN*X 不同，它的库不是“共享对象(.so)”，因为 OS X 和 ELF 不兼容，而且这个概念在 Mach-O 中不存在。OS 中的动态链接文件一般称为<strong>动态库</strong>文件，带有 <code>.dylib</code>、<code>.framework</code>及链接符号<code>.tbd</code>。可以在 <code>/usr/lib</code> 目录下找到(这一点和其他所有的 UN*X 一样，不同的是在OS X 和 iOS 中没有/lib目录)</li><li>OS X 与其他 UN*X 另一点不同是：没有<code>libc</code>。开发者可能熟悉其他 UN*X 上的C运行时库(或Windows上的MSVCRT) 。但是在 OS X 上对应的库<code>/usr/lib/libc.dylib</code>只不过是指向<code>libSystem.B.dylib</code>的符号链接。</li><li>以C语言运行库为例，补充一下<strong>运行库</strong>的概念：任何一个C程序，它的背后都有一套庞大的代码来进行支撑，以使得该程序能够正常运行。这套代码至少包括入口函数，及其所依赖的函数所构成的函数集合。当然，它还理应包括各种标准库函数的实现。这样的一个代码集合称之为运行时库（Runtime Library）。而C语言的运行库，即被称为C运行库（CRT）。<strong>运行库顾名思义是让程序能正常运行的一个库。</strong></li></ul><h3 id="2-3-两个非常重要的库-LibSystem、libobjc"><a href="#2-3-两个非常重要的库-LibSystem、libobjc" class="headerlink" title="2.3  两个非常重要的库 LibSystem、libobjc"></a>2.3  两个非常重要的库 LibSystem、libobjc</h3><p>libSystem 提供了 LibC(运行库) 的功能，还包含了在其他 UN*X 上原本由其他一些库提供的功能，列几个熟知的：</p><ul><li>GCD libdispatch</li><li>C语言库 libsystem_c</li><li>Block libsystem_blocks</li><li>加密库(比如常见的md5函数) libcommonCrypto</li></ul><p>还有些库(如数学库 libm、线程库 libpthread)虽然在/usr/lib中看到虽然有这些库的文件，但都是libSystem.B.dylib的替身/快捷方式，即都是指向libSystem的符号链接。</p><p>libSystem 库是系统上所有二进制代码的绝对先决条件，即所有的二进制文件都依赖这个库，不论是C、C++还是Objective-C的程序。这是因为这个库是对底层系统调用和内核服务的接口，如果没有这些接口就什么事也干不了。这个库还是/usr/ib/system目录下一些库的保护伞库(通过<code>LC_REEXPORT_LIB</code>加载命令重新导出了符号) 。</p><p>总结来说：<strong>libSystem在运行库的基础上，增加了一些对底层系统调用和内核服务的抽象接口。</strong>所以在下面的流程中，会发现<strong>libSystem是先于其他动态库初始化</strong>的。</p><p><strong>libobjc</strong>与libsystem一样，都是默认添加的lib，包含iOS开发天天接触的objc runtime.</p><h3 id="2-4-补充两个概念-模块与image"><a href="#2-4-补充两个概念-模块与image" class="headerlink" title="2.4 补充两个概念: 模块与image"></a>2.4 补充两个概念: 模块与image</h3><ul><li><code>程序模块</code>：从本质上讲，普通可执行程序和动态库中都包含指令和数据，这一点没有区别。在使用动态库的情况下，程序本身被分为了程序主要模块(<code>Program1</code>)和动态链接文件(<code>Lib.so</code> <code>Lib.dylib</code> <code>Lib.dll</code>)，但实际上它们都可以看作是整个程序的一个模块，所以当我们提到程序模块时可以指程序主模块也可以指动态链接库。</li><li><code>映像(image)</code> ，通常也是指这两者。可执行文件/动态链接文件，在装载时被直接映射到进程的虚拟地址空间中运行，它是进程的虚拟空间的映像，所以很多时候，也被叫做映像/镜像文件(Image File)。</li></ul><h3 id="2-5-a-dylib与-framework的区别"><a href="#2-5-a-dylib与-framework的区别" class="headerlink" title="2.5 .a/.dylib与.framework的区别"></a>2.5 .a/.dylib与.framework的区别</h3><p>前者是纯二进制文件，文件不能直接使用，需要有.h文件的配合(我们在使用系统的.dylib动态库时，经常发现没有头文件，其实这些库的头文件都位于一个已知位置，如<code>usr/include</code>(新系统中这个文件夹由SDK附带了，见 <a href="https://apple.stackexchange.com/questions/372032/usr-include-missing-on-macos-catalina-with-xcode-11">[/usr/include missing on macOS Catalina (with Xcode 11)]</a> )，库文件位于<code>usr/lib</code>，使得这些库全局可用)，后者除了二进制文件、头文件还有资源文件，代码可以直接导入使用(<code>.a + .h + sourceFile = .framework</code>)。</p><p>Framework 是苹果公司的 Cocoa/Cocoa Touch 程序中使用的一种资源打包方式，可以将代码文件、头文件、资源文件（nib/xib、图片、国际化文本）、说明文档等集中在一起，方便开发者使用。<strong>Framework 其实是资源打包的方式，和静态库动态库的本质是没有什么关系</strong>(<strong>所以framework文件可以是静态库也可以是动态库，iOS 中用到的所有系统 framework 都是动态链接的</strong>)。</p><p>在其它大部分平台上，动态库都可以用于不同应用间共享， 共享可执行文件，这就大大节省了内存。但是iOS平台在 iOS 8 之前，苹果不允许第三方框架使用动态方式加载，开发者可以使用的动态 Framework 只有苹果系统提供的 UIKit.Framework，Foundation.Framework 等。开发者要进行模块化，只能打包成静态库文件：<code>.a + 头文件</code>、<code>.framework</code>(这时候的 Framework 只支持打包成静态库的 Framework)，前种方式打包不够方便，使用时也比较麻烦，没有后者的便捷性。</p><p>iOS 8/Xcode 6 推出之后，允许开发者有条件地创建和使用动态库，支持了动态 Framework。开发者打包的动态 Framework 和系统的 UIKit.Framework 还是有很大区别。后者不需要拷贝到目标程序中，是一个链接。而前者在打包和提交 app 时会<strong>被放到 app  main bundle 的根目录中，运行在沙盒里</strong>，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载，因此苹果又把这种 Framework 称为 Embedded Framework(可植入性 Framework)。</p><p>不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。</p><p>数量上，苹果公司建议最多使用6个非系统动态库。</p><p>然后就是，在上传App Store打包的时候，苹果会对我们的代码进行一次 Code Singing，包括 app 可执行文件和所有Embedded 的动态库，所以如果是动态从服务器更新的动态库，是签名不了的，sandbox验证动态库的签名非法时，就会造成crash。因此应用插件化、软件版本实时模块升级等功能在iOS上无法实现。不过在 in house(企业发布) 包和develop 包中可以使用。</p><h2 id="三、Mach-O-文件的动态链接-—-dyld"><a href="#三、Mach-O-文件的动态链接-—-dyld" class="headerlink" title="三、Mach-O 文件的动态链接 — dyld"></a>三、Mach-O 文件的动态链接 — dyld</h2><h3 id="3-1-dyld2与dyld3"><a href="#3-1-dyld2与dyld3" class="headerlink" title="3.1 dyld2与dyld3"></a>3.1 dyld2与dyld3</h3><blockquote><p><a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html">dyld</a> 是 the dynamic link editor 的缩写，它是苹果的<em>动态链接器</em>。在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作。</p></blockquote><p>在2017WWDC，Apple推出了Dyld3。在iOS 13系统中，iOS全面采用新的dyld 3以替代之前版本的dyld 2。dyld 3带来了可观的性能提升，减少了APP的启动时间。</p><p>Dyld2是从程序开始时才开始执行的，而Dyld3则将Dyld2的一些过程进行了分解。</p><img src="/images/compilelink/44.png" alt="44" style="zoom:60%;" /><p>Dyld3最大的特点是部分进程外的，分为out-of-process，和in-process。即操作系统在当前app进程之外完成了一部分dyld2在进程内的工作。以达到提升app启动性能和增强安全的目的。</p><p>out-process会做：</p><ul><li>分析Mach-O Headers</li><li>分析以来的动态库</li><li>查找需要的Rebase和Bind的符号</li><li>将上面的分析结果写入缓存。</li></ul><p>in-process会做：</p><ul><li>读取缓存的分析结果</li><li>验证分析结果</li><li>加载Mach-O文件</li><li>Rebase&amp;Bind</li><li>Initializers</li></ul><p>使用了Dyld3后，App的启动速度会进一步提高。</p><p>而WWDC2019 苹果宣布针对Dyld3做了以下优化：</p><ul><li><strong>避免链接无用的framework；</strong></li><li><strong>避免在app启动时链接动态库；</strong></li><li><strong>硬链接所有依赖项</strong></li></ul><h3 id="3-2-dyld的工作机制"><a href="#3-2-dyld的工作机制" class="headerlink" title="3.2 dyld的工作机制"></a>3.2 dyld的工作机制</h3><p>在<a href="https://www.jianshu.com/p/bff19e0a80d4">Mach-O 文件的装载</a>完成，即内核加载器做完相关的工作后，对于需要动态链接(使用了动态库)的可执行文件(大部分可执行文件都是动态链接的)来说，<strong>控制权会转交给链接器，链接器进而接着处理文件头中的其他加载命令</strong>。真正的库加载和符号解析的工作都是通过<code>LC_LOAD_DYLINKER</code>加载命令指定的动态链接器在用户态完成的。通常情况下，使用的是 <code>/usr/lib/dyld</code> 作为动态链接器，不过这条加载命令可以指定任何程序作为参数。</p><p>链接器接管刚创建的进程的控制权，因为内核将进程的入口点设置为链接器的入口点。</p><blockquote><p>dyld是一个用户态的进程。dyld不属于内核的一部分，而是作为一个单独的开源项目由苹果进行维护的(当然也属于Darwin的一部分) ，点击查看<a href="http://www.opensource.apple.com/source/dyld">项目网址</a>。从内核的角度看，dyld是一个可插入的组件，可以替换为第三方的链接器。dyld对应的二进制文件有两个，分别是<code>/usr/lib/dyld</code>、<code>/urs/lib/system/libdyld.dylib</code>，前者<code>通用二进制格式(FAT)</code>，filetype为<code>MH_DYLINKER</code>，后者是普通的动态链接库格式(Mach-O)。</p></blockquote><img src="/images/compilelink/30.png" style="zoom:80%;" /><p>从调用堆栈上看dyld、libdyld.dylib的作用：</p><img src="/images/compilelink/31.png" style="zoom:90%;" /><p>前者<code>dyld</code>是<strong>一段可执行的程序</strong>，内核将其映射至进程地址空间，将控制权交给它进行执行，递归加载所需的动态库，其中也会将动态链接器的另一种形式的<code>libdyld.dylib</code>加载，因为动态链接器dyld其不但在应用的装载阶段起作用，在主程序运行的时候，其充当<strong>一个库</strong>的角色，还提供了<code>dlopen</code>、<code>dlsym</code>等api，可以让主程序<strong>显式运行时链接</strong>(见下文)。(关于这一点，没有找到明确的文档说明。如果有人有正确的理解，请一定要评论区告诉我一下，感激不尽)</p><blockquote><p>Linux中，动态链接库的存在形式稍有不同，Linux动态链接器本身是一个共享对象(动态库)，它的路径是/lib/ld-linux.so.2，这实际上是个软链接，它指向/lib/ld-x.y.z.so， 这个才是真正的动态连接器文件。共享对象其实也是ELF文件，它也有跟可执行文件一样的ELF文件头（包括e_entry、段表等）。动态链接器是个非常特殊的共享对象，它不仅是个共享对象，还是个可执行的程序，可以直接在命令行下面运行。因为ld.so是共享对象，又是动态链接器，所以本来应由动态链接器进行的共享对象的重定位，就要靠自己来，又称“自举”。自举完成后ld.so以一个共享对象的角色，来实现动态链接库的功能。</p></blockquote><p>我们需要了解一下<code>LC_LOAD_DYLIB</code>这个加载命令，这个命令会告诉链接器在哪里可以找到这些符号，即动态库的相关信息(ID、时间戳、版本号、兼容版本号等)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">lc_str</span> <span class="title">name</span>;</span>              <span class="comment">/* library&#x27;s path name */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> timestamp;             <span class="comment">/* library&#x27;s build time stamp */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> current_version;       <span class="comment">/* library&#x27;s current version number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> compatibility_version; <span class="comment">/* library&#x27;s compatibility vers number */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;         <span class="comment">/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB, LC_REEXPORT_DYLIB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmdsize;     <span class="comment">/* includes pathname string */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> <span class="title">dylib</span>;</span>   <span class="comment">/* the library identification */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链接器要加载每一个指定的库，并且搜寻匹配的符号。每个被链接的库(Mach-O格式)都有一个符号表，符号表将符号名称和地址关联起来。符号表在Mach-O目标文件中的地址可以通过<code>LC_SYMTAB</code>加载命令指定的 symoff 找到。对应的符号名称在 stroff， 总共有 nsyms 条符号信息。</p><p>下面是<code>LC_SYMTAB</code>的load_command：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/loader.h&gt;中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmd;<span class="comment">/* 加载命令的前两个参数都是cmd和cmdsize，cmd为加载命令的类型，符号表对应的值为LC_SYMTAB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* symtab_command结构体的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>symoff;<span class="comment">/* 符号表在文件中的偏移（位置） */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>nsyms;<span class="comment">/* 符号表入口的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>stroff;<span class="comment">/* 字符串表在文件中的偏移(位置) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>strsize;<span class="comment">/* 字符串表的大小(字节数) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 &lt;mach-o/dyld.h&gt; 动态库头文件中，也为我们提供了查询所有动态库 image 的方法(也可以使用<code>otool -L 文件路径</code>命令来查看，但看着没代码全)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listImages</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">uint32_t</span> ic = _dyld_image_count();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got %d images\n&quot;</span>, ic);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic; ++ i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %p\t%s\t(slide: %p)\n&quot;</span>,</span><br><span class="line">               i,</span><br><span class="line">               _dyld_get_image_header(i),</span><br><span class="line">               _dyld_get_image_name(i),</span><br><span class="line">               _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listImages();  <span class="comment">//调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>: </span><br><span class="line">  ...</span><br><span class="line">  <span class="number">45</span>: <span class="number">0x1ab331000</span>/usr/lib/libobjc.A.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  <span class="number">46</span>: <span class="number">0x1e1767000</span>/usr/lib/libSystem.B.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  ...</span><br><span class="line">  <span class="number">70</span>: <span class="number">0x107220000</span>/usr/lib/system/introspection/libdispatch.dylib(slide: <span class="number">0x107220000</span>)</span><br><span class="line">  <span class="number">71</span>: <span class="number">0x1ab412000</span>/usr/lib/system/libdyld.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="四、dyld工作流程详解"><a href="#四、dyld工作流程详解" class="headerlink" title="四、dyld工作流程详解"></a>四、dyld工作流程详解</h2><p>通过源码来看一下dyld的工作流程，只是部分片段，详细的可以下载源码。</p><h3 id="4-1-dyld-start"><a href="#4-1-dyld-start" class="headerlink" title="4.1 __dyld_start"></a>4.1 __dyld_start</h3><p>下面的汇编代码很简单，如果不清楚，可以看一下这篇汇编入门文章<a href="https://www.jianshu.com/p/23a9110cff96">iOS需要了解的ARM64汇编</a>。</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if __arm64__</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.align</span> <span class="number">2</span></span><br><span class="line">.globl __dyld_start</span><br><span class="line"><span class="symbol">__dyld_start:</span></span><br><span class="line"><span class="comment">; 操作fp栈帧寄存器，sp栈指针寄存器，配置函数栈帧</span></span><br><span class="line"><span class="keyword">mov</span> x28, <span class="built_in">sp</span></span><br><span class="line"><span class="keyword">and</span>     <span class="built_in">sp</span>, x28, #~<span class="number">15</span><span class="comment">// force 16-byte alignment of stack</span></span><br><span class="line"><span class="keyword">mov</span>x0, <span class="number">#0</span></span><br><span class="line"><span class="keyword">mov</span>x1, <span class="number">#0</span></span><br><span class="line">stpx1, x0, [<span class="built_in">sp</span>, #-<span class="number">16</span>]!<span class="comment">// make aligned terminating frame</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">fp</span>, <span class="built_in">sp</span><span class="comment">// set up fp to point to terminating frame</span></span><br><span class="line"><span class="keyword">sub</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#16</span>             <span class="comment">// make room for local variables</span></span><br><span class="line"><span class="comment">; L(long 64位) P(point)，在前面的汇编一文中，我们已经知道：r0 - r30 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。 </span></span><br><span class="line"><span class="comment">; 当使用 x0 - x30访问时，它就是一个64位的数。</span></span><br><span class="line"><span class="comment">; 当使用 w0 - w30访问时，访问的是这些寄存器的低32位</span></span><br><span class="line"><span class="comment">#if __LP64__       </span></span><br><span class="line"><span class="keyword">ldr</span>     x0, [x28]               <span class="comment">// get app&#x27;s mh into x0</span></span><br><span class="line"><span class="keyword">ldr</span>     x1, [x28, <span class="number">#8</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line"><span class="keyword">add</span>     x2, x28, <span class="number">#16</span>            <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="keyword">ldr</span>     w0, [x28]               <span class="comment">// get app&#x27;s mh into x0</span></span><br><span class="line"><span class="keyword">ldr</span>     w1, [x28, <span class="number">#4</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line"><span class="keyword">add</span>     w2, w28, <span class="number">#8</span>             <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="keyword">adrp</span>x3,___dso_handle<span class="comment">@page</span></span><br><span class="line"><span class="keyword">add</span> x3,x3,___dso_handle<span class="comment">@pageoff // get dyld&#x27;s mh in to x4</span></span><br><span class="line"><span class="keyword">mov</span>x4,<span class="built_in">sp</span>                   <span class="comment">// x5 has &amp;startGlue</span></span><br><span class="line"><span class="comment">; 从上面的汇编代码可以看到，主要是在设置dyldbootstrap::start函数调用栈的配置，在前面的汇编一文中，我们已经知道函数的参数，主要通过x0-x7几个寄存器来传递</span></span><br><span class="line"><span class="comment">; 可以看到函数需要的几个参数app_mh，argc，argv，dyld_mh，&amp;startGlue分别被放置到了x0 x1 x2 x4 x5寄存器上</span></span><br><span class="line">    <span class="comment">; call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue)</span></span><br><span class="line"><span class="keyword">bl</span>__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm</span><br><span class="line"><span class="keyword">mov</span>x16,x0                  <span class="comment">// save entry point address in x16</span></span><br></pre></td></tr></table></figure><h3 id="4-2-dyldbootstrap-start"><a href="#4-2-dyldbootstrap-start" class="headerlink" title="4.2 dyldbootstrap::start()"></a>4.2 dyldbootstrap::start()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//  主要做的是dyld的引导工作，一般这个工作通常由 dyld 和 crt(C运行时库 C Run-Time Libray )来完成。但dyld自身加载的时候，只能由自己来做。</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Emit kdebug tracepoint to indicate dyld bootstrap has started &lt;rdar://46878536&gt;</span></span><br><span class="line">    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果有slide，那么需要重定位，必须在使用任何全局变量之前，进行该操作</span></span><br><span class="line">    rebaseDyld(dyldsMachHeader); </span><br><span class="line">    <span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">    <span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">    ++apple;</span><br><span class="line">    <span class="comment">// 为stack canary设置一个随机值</span></span><br><span class="line">    <span class="comment">// stack canary：栈的警惕标志(stack canary)，得名于煤矿里的金丝雀，用于探测该灾难的发生。具体办法是在栈的返回地址的存储位置之前放置一个整形值，该值在装入程序时随机确定。栈缓冲区攻击时从低地址向高地址覆盖栈空间，因此会在覆盖返回地址之前就覆盖了警惕标志。返回返回前会检查该警惕标志是否被篡改。</span></span><br><span class="line">    __guard_setup(apple);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">    <span class="comment">// 执行 dyld 中所有的C++初始化函数。run all C++ initializers inside dyld</span></span><br><span class="line">    runDyldInitializers(argc, argv, envp, apple);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 完成所有引导工作，调用dyld::main(). now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> appsSlide = appsMachHeader-&gt;getSlide();</span><br><span class="line">    <span class="keyword">return</span> dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-dyld-main"><a href="#4-3-dyld-main" class="headerlink" title="4.3 dyld::_main()"></a>4.3 dyld::_main()</h3><p>dyld也是Mach-O文件格式的，文件头中的 filetype 字段为<code>MH_DYLINKER</code>，区别与可执行文件的 <code>MH_EXECUTE</code>，所以dyld也是有main()函数的(默认名称是mian()，也可以自己修改入口地址的)。</p><p>因为这个函数太长，写在一起不好阅读，所以按照流程功能点，自上而下分为一个个代码片段。关键的函数会在代码中注释说明</p><h4 id="方法名及说明"><a href="#方法名及说明" class="headerlink" title="方法名及说明"></a>方法名及说明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dyld的入口指针，内核加载dyld，跳转到__dyld_start函数：进行了一些寄存器设置，然后就调用了该函数。Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">// 返回主程序模块的mian()函数地址，__dyld_start中会跳到该地址。Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line"><span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line"><span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><h4 id="第一步-配置上下文信息，设置运行环境，处理环境变量"><a href="#第一步-配置上下文信息，设置运行环境，处理环境变量" class="headerlink" title="第一步 配置上下文信息，设置运行环境，处理环境变量"></a>第一步 配置上下文信息，设置运行环境，处理环境变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第一步，设置运行环境</span></span><br><span class="line">    <span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line"><span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">hexToBytes</span>(_simple_getenv(apple, <span class="string">&quot;executable_cdhash&quot;</span>), <span class="number">40</span>, mainExecutableCDHashBuffer) )</span><br><span class="line"><span class="comment">// 获取主程序的hash</span></span><br><span class="line">mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_SIMULATOR</span></span><br><span class="line"><span class="comment">// Trace dyld&#x27;s load</span></span><br><span class="line"><span class="built_in">notifyKernelAboutImage</span>((macho_header*)&amp;__dso_handle, _simple_getenv(apple, <span class="string">&quot;dyld_file&quot;</span>));</span><br><span class="line"><span class="comment">// Trace the main executable&#x27;s load</span></span><br><span class="line"><span class="built_in">notifyKernelAboutImage</span>(mainExecutableMH, _simple_getenv(apple, <span class="string">&quot;executable_file&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 获取主程序的macho_header结构</span></span><br><span class="line">sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line"><span class="comment">// 获取主程序的slide值</span></span><br><span class="line">sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line">    ......</span><br><span class="line"><span class="built_in">CRSetCrashLogMessage</span>(<span class="string">&quot;dyld: launch started&quot;</span>);</span><br><span class="line"><span class="comment">// 传入Mach-O头部以及一些参数设置上下文信息</span></span><br><span class="line"><span class="built_in">setContext</span>(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line"><span class="comment">// 获取主程序路径</span></span><br><span class="line">sExecPath = _simple_getenv(apple, <span class="string">&quot;executable_path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld</span></span><br><span class="line"><span class="keyword">if</span> (!sExecPath) sExecPath = apple[<span class="number">0</span>];</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">if</span> ( sExecPath[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span> ) &#123;</span><br><span class="line"><span class="comment">// have relative path, use cwd to make absolute</span></span><br><span class="line"><span class="keyword">char</span> cwdbuff[MAXPATHLEN];</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">getcwd</span>(cwdbuff, MAXPATHLEN) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// maybe use static buffer to avoid calling malloc so early...</span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cwdbuff) + <span class="built_in">strlen</span>(sExecPath) + <span class="number">2</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, cwdbuff);</span><br><span class="line"><span class="built_in">strcat</span>(s, <span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(s, sExecPath);</span><br><span class="line">sExecPath = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remember short name of process for later logging</span></span><br><span class="line"><span class="comment">// 获取进程名称</span></span><br><span class="line">sExecShortName = ::<span class="built_in">strrchr</span>(sExecPath, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( sExecShortName != <span class="literal">NULL</span> )</span><br><span class="line">++sExecShortName;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sExecShortName = sExecPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置进程受限模式</span></span><br><span class="line">    <span class="built_in">configureProcessRestrictions</span>(mainExecutableMH, envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 检测环境变量</span></span><br><span class="line"><span class="built_in">checkEnvironmentVariables</span>(envp);</span><br><span class="line"><span class="comment">// 在DYLD_FALLBACK为空时设置默认值</span></span><br><span class="line"><span class="built_in">defaultUninitializedFallbackPaths</span>(envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_OPTS则调用printOptions()打印参数</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line"><span class="built_in">printOptions</span>(argv);</span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_ENV则调用printEnvironmentVariables()打印环境变量</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line"><span class="built_in">printEnvironmentVariables</span>(envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 获取当前程序架构</span></span><br><span class="line"><span class="built_in">getHostInfo</span>(mainExecutableMH, mainExecutableSlide);</span><br></pre></td></tr></table></figure><h4 id="第二步-加载共享缓存"><a href="#第二步-加载共享缓存" class="headerlink" title="第二步 加载共享缓存"></a>第二步 加载共享缓存</h4><p>在iOS系统中，UIKit，Foundation等基础库是每个程序都依赖的，需要通过dyld（位于/usr/lib/dyld）一个一个加载到内存，然而如果在每个程序运行的时候都重复的去加载一次，势必造成运行缓慢，为了优化启动速度和提高程序性能，共享缓存机制就应运而生。iOS的dyld采用了一个共享库预链接缓存，苹果从iOS 3.0开始将所有的基础库都移到了这个缓存中，合并成一个大的缓存文件，放到/System/Library/Caches/com.apple.dyld/目录下(OS X中是在/private/var/db/dyld目录)，按不同的架构保存分别保存着，如dyld_shared_cache_armv7。而且在OS X中还有一个辅助的.map文件，而iOS中没有。</p><p>如果在iOS上搜索大部分常见的库，比如所有二进制文件都依赖的libSystem，是搜索不到的，这个库的文件不在文件系统中，而是被缓存文件包含。关于如何从共享缓存中提取我们想看的库，可以参考链接<a href="https://www.dllhook.com/post/238.html#toc_1">dyld详解第一部分</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第二步，加载共享缓存 <span class="comment">// load shared cache</span></span></span><br><span class="line">   <span class="comment">// 检查共享缓存是否开启，iOS必须开启</span></span><br><span class="line"><span class="built_in">checkSharedRegionDisable</span>((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * mapSharedCache加载共享缓存库，其中调用loadDyldCache函数，展开loadDyldCache，有这么几种情况：</span></span><br><span class="line"><span class="comment">        * 仅加载到当前进程mapCachePrivate（模拟器仅支持加载到当前进程）</span></span><br><span class="line"><span class="comment">        * 共享缓存是第一次被加载，就去做加载操作mapCacheSystemWide</span></span><br><span class="line"><span class="comment">        * 共享缓存不是第一次被加载，那么就不做任何处理</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">  <span class="built_in">mapSharedCache</span>();</span><br><span class="line">&#125;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// add dyld itself to UUID list</span></span><br><span class="line"><span class="built_in">addDyldImageToUUIDList</span>();</span><br></pre></td></tr></table></figure><h4 id="第三步-实例化主程序image"><a href="#第三步-实例化主程序image" class="headerlink" title="第三步 实例化主程序image"></a>第三步 实例化主程序image</h4><h5 id="1-源码解读"><a href="#1-源码解读" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><p>ImageLoader：前面已经提到image(映像文件)常见的有可执行文件、动态链接库。ImageLoader 作用是将这些文件加载进内存，且<strong>每一个文件对应一个ImageLoader实例来负责加载。</strong></p><p>从下面可以看到大概的顺序：先将动态链接的 image 递归加载，再依次进行可执行文件的链接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第三步 实例化主程序，会实例化一个主程序ImageLoader</span></span><br><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 展开 instantiateFromLoadedImage 函数, 可以看到主要分三步:</span></span><br><span class="line"><span class="comment"> * isCompatibleMachO()：检查mach-o的subtype是否是当前cpu可以支持；</span></span><br><span class="line"><span class="comment"> * instantiateMainExecutable()： 就是实例化可执行文件，这个期间会解析LoadCommand，这个之后会发送 dyld_image_state_mapped 通知；</span></span><br><span class="line"><span class="comment"> * addImage()： 添加到 allImages中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sMainExecutable = <span class="built_in">instantiateFromLoadedImage</span>(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">gLinkContext.mainExecutableCodeSigned = <span class="built_in">hasCodeSignatureLoadCommand</span>(mainExecutableMH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that shared cache is loaded, setup an versioned dylib overrides</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_VERSIONED_PATHS</span></span><br><span class="line"><span class="built_in">checkVersionedPaths</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dyld_all_image_infos image list does not contain dyld</span></span><br><span class="line"><span class="comment">// add it as dyldPath field in dyld_all_image_infos</span></span><br><span class="line"><span class="comment">// for simulator, dyld_sim is in image list, need host dyld added</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_SIMULATOR</span></span><br><span class="line"><span class="comment">// get path of host dyld from table of syscall vectors in host dyld</span></span><br><span class="line"><span class="keyword">void</span>* addressInDyld = gSyscallHelpers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// get path of dyld itself</span></span><br><span class="line"><span class="keyword">void</span>*  addressInDyld = (<span class="keyword">void</span>*)&amp;__dso_handle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">char</span> dyldPathBuffer[MAXPATHLEN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">proc_regionfilename</span>(<span class="built_in">getpid</span>(), (<span class="keyword">uint64_t</span>)(<span class="keyword">long</span>)addressInDyld, dyldPathBuffer, MAXPATHLEN);</span><br><span class="line"><span class="keyword">if</span> ( len &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">dyldPathBuffer[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// proc_regionfilename() does not zero terminate returned string</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != <span class="number">0</span> )</span><br><span class="line">gProcessInfo-&gt;dyldPath = <span class="built_in">strdup</span>(dyldPathBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-instantiateFromLoadedImage"><a href="#2-instantiateFromLoadedImage" class="headerlink" title="2. instantiateFromLoadedImage"></a>2. instantiateFromLoadedImage</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// try mach-o loader</span></span><br><span class="line"><span class="comment">//if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123;</span></span><br><span class="line">ImageLoader* image = ImageLoaderMachO::<span class="built_in">instantiateMainExecutable</span>(mh, slide, path, gLinkContext);</span><br><span class="line"><span class="built_in">addImage</span>(image);</span><br><span class="line"><span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//throw &quot;main executable not a known format&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法中，我们大致可以看到加载有三步：</p><ul><li><code>isCompatibleMachO</code> 是检查mach-o的subtype是否是当前cpu可以支持； </li><li><code>instantiateMainExecutable</code> 就是实例化可执行文件， 这个期间会解析LoadCommand， 这个之后会发送 dyld_image_state_mapped 通知； </li><li><code>addImage</code> 添加到 allImages中。</li></ul><h4 id="第四步-加载插入的动态库"><a href="#第四步-加载插入的动态库" class="headerlink" title="第四步 加载插入的动态库"></a>第四步 加载插入的动态库</h4><p>通过遍历 DYLD_INSERT_LIBRARIES 环境变量，调用 loadInsertedDylib 加载。</p><p>在三方App的Mach-O文件中通过修改DYLD_INSERT_LIBRARIES的值来加入我们自己的动态库，从而注入代码，hook别人的App。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第四步 加载插入的动态库</span></span><br><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="keyword">if</span>( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line"><span class="built_in">loadInsertedDylib</span>(*lib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line"><span class="comment">// 记录插入的动态库数量</span></span><br><span class="line">sInsertedDylibCount = sAllImages.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h4 id="第五步-链接主程序-重点link"><a href="#第五步-链接主程序-重点link" class="headerlink" title="第五步 链接主程序(重点link())"></a>第五步 链接主程序(重点link())</h4><h5 id="1-源码解读-1"><a href="#1-源码解读-1" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第五步 链接主程序</span></span><br><span class="line"><span class="comment">// link main executable</span></span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line"><span class="keyword">if</span> ( mainExcutableAlreadyRebased ) &#123;</span><br><span class="line"><span class="comment">// previous link() on main executable has already adjusted its internal pointers for ASLR </span></span><br><span class="line">    <span class="comment">// work around that by rebasing by inverse amount</span></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">rebase</span>(gLinkContext, -mainExecutableSlide);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        link() 函数的递归调用函数堆栈形式</span></span><br><span class="line"><span class="comment">          ▼ ImageLoader::link() //启动主程序的连接进程   —— ImageLoader.cpp，ImageLoader类中可以发现很多由dyld调用来实现二进制加载逻辑的函数。</span></span><br><span class="line"><span class="comment">            ▼ recursiveLoadLibraries() //进行所有需求动态库的加载</span></span><br><span class="line"><span class="comment">              ▶︎ //确定所有需要的库</span></span><br><span class="line"><span class="comment">              ▼ context.loadLibrary() //来逐个加载。context对象是一个简单的结构体，包含了在方法和函数之间传递的函数指针。这个结构体的loadLibrary成员在libraryLocator()函数（dyld.cpp）中初始化，它完成的功能也只是简单的调用load()函数。</span></span><br><span class="line"><span class="comment">                ▼ load() // 源码在dyld.cpp，会调用各种帮助函数。</span></span><br><span class="line"><span class="comment">                  ▶︎ loadPhase0() → loadPhase1() → ... → loadPhase5() → loadPhase5load() → loadPhase5open() → loadPhase6() 递归调用  //每一个函数都负责加载进程工作的一个具体任务。比如，解析路径或者处理会影响加载进程的环境变量。</span></span><br><span class="line"><span class="comment">                  ▼ loadPhase6() // 该函数从文件系统加载需求的dylib到内存中。然后调用一个ImageLoaderMachO类的实例对象。来完成每个dylib对象Mach-O文件具体的加载和连接逻辑。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="built_in">link</span>(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">sMainExecutable-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line"><span class="keyword">if</span> ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">gLinkContext.bindFlat = <span class="literal">true</span>;</span><br><span class="line">gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-ImageLoader-link"><a href="#2-ImageLoader-link" class="headerlink" title="2. ImageLoader::link()"></a>2. ImageLoader::link()</h5><blockquote><p>加载二进制的过程： instantiate(实例化) –&gt; addImage –&gt; link –&gt; runInitializers </p><p>其中link就是动态链接的过程</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::link</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> neverUnload, <span class="keyword">const</span> RPathChain&amp; loaderRPaths, <span class="keyword">const</span> <span class="keyword">char</span>* imagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear error strings</span></span><br><span class="line">(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> t0 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">  <span class="comment">// 1. recursiveLoadLibraries 这一步就是根据 LoadCommand 中的 LC_LOAD_DYLIB 把依赖的动态库和Framework加载进来。也就是对这些动态库 instantiate 的过程。 只是动态库不会用instantiateMainExecutable方法来加载了，最终用的是 instantiateFromFile 来加载。</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveLoadLibraries</span>(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">context.<span class="built_in">notifyBatch</span>(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line"><span class="comment">// we only do the loading step for preflights</span></span><br><span class="line"><span class="keyword">if</span> ( preflightOnly )</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> t1 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">context.<span class="built_in">clearAllDepths</span>();</span><br><span class="line">  <span class="comment">// 2. recursiveUpdateDepth 刷新depth, 就是库依赖的层级。层级越深，depth越大。</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  unsigned int ImageLoader::updateDepth(unsigned int maxDepth)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    STACK_ALLOC_ARRAY(ImageLoader*, danglingUpwards, maxDepth);</span></span><br><span class="line"><span class="comment">    unsigned int depth = this-&gt;recursiveUpdateDepth(maxDepth, danglingUpwards);</span></span><br><span class="line"><span class="comment">    for (auto&amp; danglingUpward : danglingUpwards) &#123;</span></span><br><span class="line"><span class="comment">      if ( danglingUpward-&gt;fDepth != 0)</span></span><br><span class="line"><span class="comment">        continue;</span></span><br><span class="line"><span class="comment">      danglingUpward-&gt;recursiveUpdateDepth(maxDepth, danglingUpwards);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return depth;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">updateDepth</span>(context.<span class="built_in">imageCount</span>());</span><br><span class="line"></span><br><span class="line">__block <span class="keyword">uint64_t</span> t2, t3, t4, t5;</span><br><span class="line">&#123;</span><br><span class="line">dyld3::<span class="built_in">ScopedTimer</span>(DBG_DYLD_TIMING_APPLY_FIXUPS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">t2 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">    <span class="comment">// 3. recursiveRebase rebase的过程，recursiveRebase就会把主二进制和依赖进来的动态库全部rebase.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void ImageLoader::recursiveRebaseWithAccounting(const LinkContext&amp; context)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      this-&gt;recursiveRebase(context);</span></span><br><span class="line"><span class="comment">      vmAccountingSetSuspended(context, false);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveRebaseWithAccounting</span>(context);</span><br><span class="line">context.<span class="built_in">notifyBatch</span>(dyld_image_state_rebased, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">t3 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">      <span class="comment">// 4. 主二进制和依赖进来的动态库全部执行 bind</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      void ImageLoader::recursiveBindWithAccounting(const LinkContext&amp; context, bool forceLazysBound, bool neverUnload)</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        this-&gt;recursiveBind(context, forceLazysBound, neverUnload, nullptr);</span></span><br><span class="line"><span class="comment">        vmAccountingSetSuspended(context, false);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveBindWithAccounting</span>(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">t4 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">      <span class="comment">// 5. weakBind. 执行weakBind，这里看到如果是主二进制在link的话，是不会在这个时候执行weak bind的，在dyld::_main里面可以看到，是在link完成之后再执行的weakBind.</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">weakBind</span>(context);</span><br><span class="line">t5 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interpose any dynamically loaded images</span></span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.<span class="built_in">size</span>() != <span class="number">0</span>) ) &#123;</span><br><span class="line"><span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_APPLY_INTERPOSING, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 6. recursiveApplyInterposing. (主二进制link时候也不执行)</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveApplyInterposing</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now that all fixups are done, make __DATA_CONST segments read-only</span></span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveMakeDataReadOnly</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">        context.<span class="built_in">notifyBatch</span>(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> t6 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( context.registerDOFs != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">std::vector&lt;DOFInfo&gt; dofs;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveGetDOFSections</span>(context, dofs);</span><br><span class="line">    <span class="comment">// 7. registerDOFs. 注册DTrace Object Format。DTrace(Dynamic Trace)是一个提供了 zero disable cost 的动态追踪框架，也就是说当代码中的探针关闭时，不会有额外的资源消耗 - 即使在生产版本中我们也可以将探针留在代码中。只有使用的时候才产生消耗。</span></span><br><span class="line">    <span class="comment">// DTrace 是动态的，也就是说我们可以将它附加在一个已经在运行的程序上，也可以不打断程序将它剥离。不需要重新编译或启动。</span></span><br><span class="line">context.<span class="built_in">registerDOFs</span>(dofs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint64_t</span> t7 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear error strings</span></span><br><span class="line">(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">fgTotalRebaseTime += t3 - t2;</span><br><span class="line">fgTotalBindTime += t4 - t3;</span><br><span class="line">fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">fgTotalDOF += t7 - t6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// done with initial dylib loads</span></span><br><span class="line">fgNextPIEDylibAddress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-反向依赖"><a href="#3-反向依赖" class="headerlink" title="3. 反向依赖"></a>3. 反向依赖</h5><p>每个库之间的符号并非只能单向依赖。即库与库之间是可以相互依赖符号的。</p><blockquote><p>单向依赖：即 A.dylib 依赖 B.dylib。那么B中就不能依赖A中的符号。</p></blockquote><blockquote><p>一次dyld加载进来的二进制之间可以相互依赖符号。</p></blockquote><p>原因很简单，就是因为上面看到动态链接过程中，并不是完全加载完一个被依赖的动态库，再加载下一个的。而是 recursiveLoadLibraies，recursiveRebase，recursiveBind。 所有的单步操作都会等待前一步所有的库完成。因此当 recursiveBind的时候，所有的动态库二进制已经加载进来了，符号就可以互相找了。</p><p>一次dyld的过程只会一次动态link，这次link的过程中的库符号可以互相依赖的，但是如果你通过<code>dlopen</code>、<code>-[NSBundle loadBundle]</code>的方式来延迟加载的动态库就不能反向依赖了，必须单向依赖，因为这是另外一次dyld的过程了。</p><p>反向依赖还要有个条件，条件就是符号必须存在，如果因为编译优化把符号给strip了，那就没法bind了，还是会加载失败的。</p><h4 id="第六步-链接插入的动态库"><a href="#第六步-链接插入的动态库" class="headerlink" title="第六步 链接插入的动态库"></a>第六步 链接插入的动态库</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第六步 链接插入的动态库</span></span><br><span class="line"><span class="comment">// link any inserted libraries</span></span><br><span class="line"><span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line"><span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">link</span>(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">image-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line"><span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">image-&gt;<span class="built_in">registerInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i=sInsertedDylibCount+<span class="number">1</span>; i &lt; sAllImages.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i];</span><br><span class="line"><span class="keyword">if</span> ( image-&gt;<span class="built_in">inSharedCache</span>() )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">image-&gt;<span class="built_in">registerInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply interposing to initial set of images</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sImageRoots.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">sImageRoots[i]-&gt;<span class="built_in">applyInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">gLinkContext.<span class="built_in">notifyBatch</span>(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind and notify for the inserted images now interposing has been registered</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">image-&gt;<span class="built_in">recursiveBind</span>(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第七步-弱符号绑定weakBind"><a href="#第七步-弱符号绑定weakBind" class="headerlink" title="第七步 弱符号绑定weakBind"></a>第七步 弱符号绑定weakBind</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第七步 执行弱符号绑定。weakBind: 从代码中可以看出这一步会对所有含有弱符号的镜像合并排序进行bind。OC中没发现应用场景，可能是C++的吧</span></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">weakBind</span>(gLinkContext);</span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">recursiveMakeDataReadOnly</span>(gLinkContext);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CRSetCrashLogMessage</span>(<span class="string">&quot;dyld: launch, running initializers&quot;</span>);</span><br><span class="line">      <span class="comment">//......</span></span><br></pre></td></tr></table></figure><h4 id="第八步-执行初始化方法initialize"><a href="#第八步-执行初始化方法initialize" class="headerlink" title="第八步 执行初始化方法initialize"></a>第八步 执行初始化方法initialize</h4><h5 id="1-源码解读-2"><a href="#1-源码解读-2" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><p>dyld会优先初始化动态库，然后初始化主程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第八步 执行初始化方法initialize() </span></span><br><span class="line">      <span class="comment">// run all initializers</span></span><br><span class="line"><span class="comment">//attribute((constructor)) 修饰的函数就是在这一步执行的, 即在主程序的main()函数之前。__DATA中有个Section __mod_init_func就是记录这些函数的。</span></span><br><span class="line"><span class="comment">//与之对应的是attribute((destructor))修饰的函数, 是主程序 main() 执行之后的一些全局函数析构操作, 也是记录在一个Section __mod_term_func中.</span></span><br><span class="line"><span class="built_in">initializeMainExecutable</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知所有的监视进程，本进程要进入main()函数了。 notify any montoring proccesses that this process is about to enter main()</span></span><br><span class="line"><span class="built_in">notifyMonitoringDyldMain</span>();</span><br><span class="line">      <span class="comment">//......</span></span><br></pre></td></tr></table></figure><h5 id="2-initializeMainExecutable"><a href="#2-initializeMainExecutable" class="headerlink" title="2. initializeMainExecutable()"></a>2. initializeMainExecutable()</h5><p>调用函数堆栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先初始化动态库</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123; </span><br><span class="line">   sImageRoots[i]-&gt;<span class="built_in">runInitializers</span>(gLinkContext, initializerTimes[<span class="number">0</span>]); </span><br><span class="line">&#125;  <span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line"><span class="comment">// 再初始化可执行文件 </span></span><br><span class="line">  <span class="comment">// run initializers for main executable and everything it brings up</span></span><br><span class="line">▼ sMainExecutable-&gt;<span class="built_in">runInitializers</span>() </span><br><span class="line">  ▼ ImageLoader::<span class="built_in">processInitializers</span>()</span><br><span class="line">    ▼ ImageLoader::<span class="built_in">recursiveInitialization</span>()      <span class="comment">// 循环遍历images list中所有的imageloader，recursive(递归)初始化。Calling recursive init on all images in images list</span></span><br><span class="line">      ▼ ImageLoaderMachO::<span class="built_in">doInitialization</span>()      <span class="comment">// 初始化这个image. initialize this image</span></span><br><span class="line">        ▶︎ ImageLoaderMachO::<span class="built_in">doImageInit</span>()         <span class="comment">// 解析LC_ROUTINES_COMMAND 这个加载命令，可以参考loader.h中该命令的说明，这个命令包含了动态共享库初始化函数的地址，该函数必须在库中任意模块初始化函数(如C++ 静态构造函数等)之前调用</span></span><br><span class="line">        ▶︎ ImageLoaderMachO::<span class="built_in">doModInitFunctions</span>()  <span class="comment">// 内部会调用C++全局对象的构造函数、__attribute__((constructor))修饰的C函数</span></span><br><span class="line">        <span class="comment">// 以上两个函数中，libSystem相关的都是要首先执行的，而且在上述递归加载动态库过程，libSystem是默认引入的，所以栈中会出现libSystem_initializer的初始化方法</span></span><br><span class="line">      ▼ context.<span class="built_in">notifySingle</span>(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">        ▶︎ (*sNotifyObjCInit)(image-&gt;<span class="built_in">getRealPath</span>(), image-&gt;<span class="built_in">machHeader</span>());</span><br><span class="line">        <span class="comment">// 通知objc, 该image已经完成初始化。objc会调用load_images()</span></span><br><span class="line">▶︎ (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br></pre></td></tr></table></figure><p>在上面的<code>doImageInit</code>、<code>doModInitFunctions</code>函数中，会发现都有判断<code>libSystem</code>库是否已加载的代码，即<strong>libSystem要首先加载、初始化</strong>。在上文中，我们已经强调了这个库的重要性。之所以在这里又提到，是因为这个库也起到了将dyld与objc关联起来的作用：</p><img src="/images/compilelink/32.png" style="zoom:80%;" /><h5 id="2-dyld到objc的流程-详细见下篇"><a href="#2-dyld到objc的流程-详细见下篇" class="headerlink" title="2. dyld到objc的流程(详细见下篇)"></a>2. dyld到objc的流程(详细见下篇)</h5><p>可以从上面的调用堆栈中看到，从dyld到objc的流程：</p><ol><li><p><code>libSystem</code> 库的初始化</p></li><li><p><code>libdispatch</code> 库的初始化：<code>libdispatch</code> 是实现 GCD 的核心用户空间库。在 <code>void libdispatch_init(void)</code> 方法中会调用 <code>void _os_object_init(void)</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_include(<span class="meta-string">&lt;objc/objc-internal.h&gt;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;objc/objc-internal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>                                  <span class="comment">// __asm__ 使函数调用编译为“调用_objc_retain”</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> id _Nullable <span class="title">objc_retain</span><span class="params">(id _Nullable obj)</span> __<span class="title">asm__</span><span class="params">(<span class="string">&quot;_objc_retain&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">objc_release</span><span class="params">(id _Nullable obj)</span> __<span class="title">asm__</span><span class="params">(<span class="string">&quot;_objc_release&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_prepare(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_parent(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_child(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __has_include(&lt;objc/objc-internal.h&gt;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>*_os_objc_destructInstance(id obj) &#123;</span><br><span class="line">    <span class="comment">// noop if only Libystem is loaded</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _os_object_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    _objc_init();</span><br><span class="line">    Block_callbacks_RR callbacks = &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">sizeof</span></span>(Block_callbacks_RR),</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_retain,</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_release,</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;_os_objc_destructInstance</span><br><span class="line">    &#125;;</span><br><span class="line">    _Block_use_RR2(&amp;callbacks);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *v = <span class="built_in">getenv</span>(<span class="string">&quot;OBJC_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">    v = <span class="built_in">getenv</span>(<span class="string">&quot;DISPATCH_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">    v = <span class="built_in">getenv</span>(<span class="string">&quot;LIBDISPATCH_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>然后就是 <a href="https://opensource.apple.com/tarballs/objc4/">objc的源码</a> <code>objc-os.mm</code>中的 <code>_object_init</code> 函数了：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// runtime环境的各种初始化</span></span><br><span class="line">    <span class="built_in">environ_init</span>();   <span class="comment">// 环境变量初始化。读取影响运行时的环境变量。如果需要，还可以打印环境变量</span></span><br><span class="line">    <span class="built_in">tls_init</span>();       <span class="comment">// 关于线程key的绑定，如线程的析构函数</span></span><br><span class="line">    <span class="built_in">static_init</span>();    <span class="comment">// 运行C++静态构造函数</span></span><br><span class="line">    <span class="built_in">runtime_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>(); <span class="comment">// 初始化libobjc的异常处理系统，由map_images()调用。</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::<span class="built_in">init</span>();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化 trampoline machinery。通常这什么都不做，因为一切都是惰性初始化的，但对于某些进程，我们会主动加载 trampolines dylib。</span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册dyld事件的监听，监听每个image(动态库、可执行文件)的加载，该方法是dyld提供的，内部调用了dyld::registerObjCNotifiers这个方法，记录了这三个分别对应map，init，unmap事件的回调函数。会在相应时机触发</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// runtime 监听到dyld中image加载后，调用 map_images 做解析和处理，至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理，在这之后，runtime 的那些方法（动态添加 Class、swizzle 等等才能生效）</span></span><br><span class="line">    <span class="comment">// 接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dyld_objc_notify_register</code> 这个方法在苹果开源的dyld里面可以找到，然后看到调用了<code>dyld::registerObjCNotifiers</code>这个方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// record functions to call</span></span><br><span class="line">  sNotifyObjCMapped   = mapped;</span><br><span class="line">  sNotifyObjCInit     = init;</span><br><span class="line">  sNotifyObjCUnmapped = unmapped;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call &#x27;mapped&#x27; function with all images mapped so far</span></span><br><span class="line">       <span class="comment">// 第一次先触发一次ObjCMapped</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">notifyBatchPartial</span>(dyld_image_state_bound, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">//内部会触发sNotifyObjCMapped的调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">      <span class="comment">// ignore request to abort during registration</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字面意思可以明白，传进来的分别是 map, init, unmap事件的回调。 dyld的事件通知有以下几种，分别会在特定的时机发送：(注意：map、init、unmap对应到下面枚举中的名称并不一致)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">dyld_image_states</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dyld_image_state_mapped                 = <span class="number">10</span>,       <span class="comment">// No batch notification for this</span></span><br><span class="line">  dyld_image_state_dependents_mapped      = <span class="number">20</span>,       <span class="comment">// Only batch notification for this</span></span><br><span class="line">  dyld_image_state_rebased                = <span class="number">30</span>, </span><br><span class="line">  dyld_image_state_bound                  = <span class="number">40</span>,</span><br><span class="line">  dyld_image_state_dependents_initialized = <span class="number">45</span>,       <span class="comment">// Only single notification for this</span></span><br><span class="line">  dyld_image_state_initialized            = <span class="number">50</span>,</span><br><span class="line">  dyld_image_state_terminated             = <span class="number">60</span>        <span class="comment">// Only single notification for this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这三个函数就很熟悉了，位于<code>objc-runtime-new.mm</code>中，objc运行时老生常谈的几个方法(关于OBJC的部分，内容太多，这里简单介绍，下篇细谈)，每次有新的镜像加载时都会在指定时机触发这几个方法：</p><ul><li>map_images : 每当 dyld 将一个 image 加载进内存时 , 会触发该函数进行image的一些处理：如果是首次，初始化执行环境等，之后<code>_read_images</code>进行读取，进行类、元类、方法、协议、分类的一些加载。</li><li>load_images : 每当 dyld 初始化一个 image 会触发该方法，会对该 image 进行+load的调用</li><li>unmap_image : 每当 dyld 将一个 image 移除时 , 会触发该函数</li></ul><img src="/images/compilelink/33.png" style="zoom:75%;" /><p>值得说明的是，这个初始化的过程远比写出来的要复杂，这里只提到了 runtime 这个分支，还有像 GCD、XPC 等重头的系统库初始化分支没有提及（当然，有缓存机制在，也不会重复初始化），总结起来就是 main 函数执行之前，系统做了非常多的加载和初始化工作，但都被很好的隐藏了，我们无需关心。</p><p>然后，从上面最后的代码(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, NULL, NULL); 以及注释<code>register cxa_atexit() handler to run static terminators in all loaded images when this process exits</code>可以看出注册了<code>cxa_atexit()</code>函数，当此进程退出时，该处理程序会运行所有加载的image中的静态终止程序(static terminators)。</p><h4 id="第九步-查找主程序入口点并返回，-dyld-start会跳转进入"><a href="#第九步-查找主程序入口点并返回，-dyld-start会跳转进入" class="headerlink" title="第九步 查找主程序入口点并返回，__dyld_start会跳转进入"></a>第九步 查找主程序入口点并返回，__dyld_start会跳转进入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第九步 查找入口点 main() 并返回，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">    <span class="comment">// find entry point for main executable</span></span><br><span class="line">result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_MAIN</span>();</span><br><span class="line"><span class="keyword">if</span> ( result != <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="comment">// main executable uses LC_MAIN, we need to use helper in libdyld to call into main()</span></span><br><span class="line"><span class="keyword">if</span> ( (gLibSystemHelpers != <span class="literal">NULL</span>) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= <span class="number">9</span>) )</span><br><span class="line">*startGlue = (<span class="keyword">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">halt</span>(<span class="string">&quot;libdyld.dylib support not present for LC_MAIN&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span></span><br><span class="line">result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_UNIXTHREAD</span>();</span><br><span class="line">*startGlue = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* message) &#123;</span><br><span class="line"><span class="built_in">syncAllImages</span>();</span><br><span class="line"><span class="built_in">halt</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: launch failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h3><p>引自<a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a>一文中的片段，<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html">《 Mike Ash 这篇 blog 》</a>对 dyld 作用顺序的概括：</p><ol><li> 从 kernel 留下的原始调用栈引导和启动自己</li><li> 将程序依赖的动态链接库<strong>递归</strong>加载进内存，当然这里有<strong>缓存机制</strong></li><li> non-lazy 符号立即 link 到可执行文件，lazy 的存表里</li><li> Runs static initializers for the executable</li><li> 找到可执行文件的 main 函数，准备参数并调用</li><li> 程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口</li><li> 程序main函数 return 后执行 static terminator</li><li> 某些场景下 main 函数结束后调 libSystem 的 <strong>_exit</strong> 函数</li></ol><p>然后，使用调用堆栈，来看下dyld的工作流程，只注释了认为重要的部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 内核XNU加载Mach-O</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 从 XNU内核态 将控制权转移到 dyld用户态</span></span><br><span class="line">▼ dyld</span><br><span class="line">  ▼ __dyld_start   <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::<span class="built_in">start</span>()   <span class="comment">//dyldInitialization.cpp，负责dyld的引导工作</span></span><br><span class="line">      ▼ dyld::_main()   <span class="comment">// dyld.cpp</span></span><br><span class="line">    ▶︎ <span class="comment">// 第一步，设置运行环境</span></span><br><span class="line">    ▶︎ <span class="comment">// 第二步，加载共享缓存</span></span><br><span class="line">    ▶︎ <span class="comment">// 第三步 实例化主程序，会实例化一个主程序ImageLoader</span></span><br><span class="line">    ▼ <span class="built_in">instantiateFromLoadedImage</span>()  </span><br><span class="line">        ▶︎ <span class="built_in">isCompatibleMachO</span>()  <span class="comment">// 检查mach-o的subtype是否是当前cpu可以支持；</span></span><br><span class="line">        ▶︎ <span class="built_in">instantiateMainExecutable</span>()  <span class="comment">// 实例化可执行文件，这个期间会解析LoadCommand，这个之后会发送 dyld_image_state_mapped 通知；</span></span><br><span class="line">        ▶︎ <span class="built_in">addImage</span>()  <span class="comment">// 将可执行文件这个image，添加到 allImages中</span></span><br><span class="line">    ▶︎ <span class="comment">// 第四步，循环调用该函数，加载插入的动态库</span></span><br><span class="line">    ▶︎ <span class="built_in">loadInsertedDylib</span>()  </span><br><span class="line">    ▶︎ <span class="comment">// 第五步，调用link()函数，链接主程序</span></span><br><span class="line">    ▼ <span class="built_in">link</span>()  </span><br><span class="line">  ▼ ImageLoader::<span class="built_in">link</span>() <span class="comment">//启动主程序的连接进程   —— ImageLoader.cpp，ImageLoader类中可以发现很多由dyld调用来实现二进制加载逻辑的函数。</span></span><br><span class="line">▼ <span class="built_in">recursiveLoadLibraries</span>() <span class="comment">//进行所有需求动态库的加载</span></span><br><span class="line">  ▶︎ <span class="comment">//确定所有需要的库</span></span><br><span class="line">  ▼ context.<span class="built_in">loadLibrary</span>() <span class="comment">//来逐个加载。context对象是一个简单的结构体，包含了在方法和函数之间传递的函数指针。这个结构体的loadLibrary成员在libraryLocator()函数（dyld.cpp）中初始化，它完成的功能也只是简单的调用load()函数。</span></span><br><span class="line">    ▼ <span class="built_in">load</span>() <span class="comment">// 源码在dyld.cpp，会调用各种帮助函数。</span></span><br><span class="line">      ▶︎ <span class="built_in">loadPhase0</span>() → <span class="built_in">loadPhase1</span>() → ... → <span class="built_in">loadPhase5</span>() → <span class="built_in">loadPhase5load</span>() → <span class="built_in">loadPhase5open</span>() → <span class="built_in">loadPhase6</span>() 递归调用  <span class="comment">//每一个函数都负责加载进程工作的一个具体任务。比如，解析路径或者处理会影响加载进程的环境变量。</span></span><br><span class="line">      ▼ <span class="built_in">loadPhase6</span>() <span class="comment">// 该函数从文件系统加载需求的dylib到内存中。然后调用一个ImageLoaderMachO类的实例对象。来完成每个dylib对象Mach-O文件具体的加载和连接逻辑。</span></span><br><span class="line">    ▶︎ <span class="comment">// 第六步，调用link()函数，链接插入的动态库</span></span><br><span class="line">    ▶︎ <span class="comment">// 第七步，对主程序进行弱符号绑定weakBind</span></span><br><span class="line">    ▶︎ sMainExecutable-&gt;<span class="built_in">weakBind</span>(gLinkContext);</span><br><span class="line">    ▶︎ <span class="comment">// 第八步，执行初始化方法 initialize。attribute((constructor)) 修饰的函数就是在这一步执行的, 即在主程序的main()函数之前。__DATA中有个Section __mod_init_func就是记录这些函数的。</span></span><br><span class="line">    ▼ <span class="built_in">initializeMainExecutable</span>()  <span class="comment">// dyld会优先初始化动态库，然后初始化主程序。</span></span><br><span class="line">          ▼ sMainExecutable-&gt;<span class="built_in">runInitializersrunInitializers</span>()  <span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">            ▼ ImageLoader::<span class="built_in">processInitializers</span>()</span><br><span class="line">              ▼ ImageLoader::<span class="built_in">recursiveInitialization</span>()  <span class="comment">// 循环遍历images list中所有的imageloader，recursive(递归)初始化。Calling recursive init on all images in images list</span></span><br><span class="line">                ▼ ImageLoaderMachO::<span class="built_in">doInitialization</span>()  <span class="comment">// 初始化这个image. initialize this image</span></span><br><span class="line">                  ▼ ImageLoaderMachO::<span class="built_in">doImageInit</span>()  <span class="comment">//解析LC_ROUTINES_COMMAND 这个加载命令，可以参考loader.h中该命令的说明，这个命令包含了动态共享库初始化函数的地址，该函数必须在库中任意模块初始化函数(如C++ 静态构造函数等)之前调用</span></span><br><span class="line">                  ▼ ImageLoaderMachO::<span class="built_in">doModInitFunctions</span>()  <span class="comment">// 内部会调用C++全局对象的构造函数、__attribute__((constructor))修饰的C函数</span></span><br><span class="line">                  <span class="comment">// 以上两个函数中，libSystem相关的都是要首先执行的，而且在上述递归加载动态库过程，libSystem是默认引入的，所以栈中会出现libSystem_initializer的初始化方法</span></span><br><span class="line">          ▶︎ (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line">    ▶︎ <span class="comment">// 第九步，查找入口点 main() 并返回，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">        ▶︎ (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_MAIN</span>();</span><br></pre></td></tr></table></figure><img src="/images/compilelink/34.png" style="zoom:80%;" /><p>关于更多的理论知识，可以阅读下<a href="https://juejin.im/post/6844903922654511112#heading-23">iOS程序员的自我修养-MachO文件动态链接（四）</a>、<a href="https://juejin.im/post/6844903926051897358">实践篇—fishhook原理</a>(：程序运行期间通过修改符号表(nl_symbol_ptr和la_symbol_ptr)，来替换要hook的符号对应的地址)，将《程序员的自我修养》中的理论结合iOS系统中的实现机制做了个对比介绍。</p><h2 id="五、加载动态库方式二-dlopen"><a href="#五、加载动态库方式二-dlopen" class="headerlink" title="五、加载动态库方式二: dlopen"></a>五、加载动态库方式二: dlopen</h2><blockquote><p>加载动态库的另一种方式：显式运行时链接dlopen</p></blockquote><p>上面的这种动态链接，其实还可以称为<strong>装载时链接</strong>，与静态链接相比，其实都是属于在程序运行之前进行的链接。还有另一种动态链接称为<strong>显式运行时链接</strong>(<strong>Explicit Runtime Linking</strong>)。</p><p>装载时链接：是在程序开始运行时(前)<strong>通过dyld动态加载</strong>。通过dyld加载的动态库需要在编译时进行链接，链接时会做标记，绑定的地址在加载后再决定。</p><p>显式运行时链接：即在运行时<strong>通过动态链接器dyld提供的API dlopen 和 dlsym 来加载</strong>。这种方式，在编译时是不需要参与链接的。</p><ul><li>dlopen会把共享库载入运行进程的地址空间，载入的共享库也会有未定义的符号，这样会触发更多的共享库被载入。</li><li>dlopen也可以选择是立刻解析所有引用还是滞后去做。</li><li>dlopen打开动态库后返回的是模块的指针(句柄/文件描述符(FD))</li><li>dlsym的作用就是通过dlopen返回的动态库指针和函数的符号，得到函数的地址然后使用。</li></ul><p><strong>不过，通过这种运行时加载远程动态库的 App，苹果公司是不允许上线 App Store 的，所以只能用于线下调试环节。</strong></p><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ul><li><a href="">《深入理解Mach OS X &amp; iOS 操作系统》</a></li><li><a href="https://www.cnblogs.com/guohai-stronger/p/11915571.html">MachO文件详解–逆向开发</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/06/20/dyldyu-objc/">dyld与ObjC</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/10/12/dyld2/">Dyld之二: 动态链接过程</a></li><li><a href="https://www.dllhook.com/post/238.html#toc_14">dyld详解</a></li><li><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></li><li><a href="https://juejin.cn/post/6844904068867948552">iOS探索 浅尝辄止dyld加载流程</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、动态链接&quot;&gt;&lt;a href=&quot;#一、动态链接&quot; class=&quot;headerlink&quot; title=&quot;一、动态链接&quot;&gt;&lt;/a&gt;一、动态链接&lt;/h2&gt;&lt;p&gt;动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(五) Mach-O 文件之进程(虚拟)地址空间、ASLR</title>
    <link href="https://tenloy.github.io/2021/09/26/compile-vm-asrl.html"/>
    <id>https://tenloy.github.io/2021/09/26/compile-vm-asrl.html</id>
    <published>2021-09-26T14:26:04.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ASLR引入"><a href="#一、ASLR引入" class="headerlink" title="一、ASLR引入"></a>一、ASLR引入</h2><p>进程在自己私有的虚拟地址空间中启动。按照传统方式，进程每一次启动时采用的都是固定的可预见的方式。然而，这意味着某个给定程序在某个给定架构上的进程初始虚拟内存镜像都是基本一致的。而且更严重的问题在于，即使是在进程正常运行的生命周期中，大部分内存分配的操作都是按照同样的方式进行的，因此使得内存中的地址分布具有非常强的可预测性。</p><p>尽管这有助于调试，但是也给黑客提供了更大的施展空间。黑客主要采用的方法是代码注入：通过重写内存中的函数指针，黑客就可以将程序的执行路径转到自己的代码，将程序的输入转变为自己的输入。重写内存最常用的方法是采用缓冲区溢出(即利用未经保护的内存复制操作越过上数组的边界)，可参考<a href="https://www.jianshu.com/p/4703ad3efbb9">缓冲区溢出攻击</a>，将函数的返回地址重写为自己的指针。不仅如此，黑客还有更具创意的技术，例如破坏printf()格式化字符串以及基于堆的缓冲区溢出。此外，任何用户指针甚至结构化的异常处理程序都可以导致代码注入。这里的关键问题在于判断重写哪些指针，也就是说，可靠地判断注入的代码应该在内存中的什么位置。</p><p>不论被破解程序的薄弱环节在哪里：缓冲区溢出、格式化字符串攻击或其他方式，黑客都可以花大力气破解一个不安全的程序，找到这个程序的地址空间布局，然后精心设计一种方法，这种方法可以可靠地重现程序中的薄弱环节，并且可以在类似的系统上暴露出一样的薄弱环节。</p><p>现在大部分操作系统中都采用了一种称为地址空间布局随机化(ASLR) 的技术，这是一种避免攻击的有效保护。进程每一次启动时，地址空间都会被简单地随机化：<strong>只是偏移，而不是搅乱</strong>。基本的布局(程序文本、数据和库)仍然是一样的。然而，这些部分具体的地址都不同了——区别足够大，可以阻挡黑客对地址的猜测。<strong>实现方法是通过内核将Mach-O的段“平移”某个随机系数</strong>。</p><h2 id="二、ASLR"><a href="#二、ASLR" class="headerlink" title="二、ASLR"></a>二、ASLR</h2><p>地址空间布局随机化(Address Space Layout Randomization，ASLR)是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。iOS4.3开始引入了ASLR技术。</p><p>下面分别来看一下，未使用ASLR、使用了ASLR下，进程虚拟地址空间内的分布。下图中左侧是mach-O可执行文件，右侧是链接之后的虚拟地址空间，如果对<code>__TEXT</code>、<code>__DATA</code>等Segment概念不清楚的地方，可以看一些第二篇关于Mach-O文件结构的介绍。</p><h3 id="2-1-未使用ASLR"><a href="#2-1-未使用ASLR" class="headerlink" title="2.1 未使用ASLR"></a>2.1 未使用ASLR</h3><ul><li>函数代码存放在__TEXT段中</li><li>全局变量存放在__DATA段中</li><li>可执行文件的内存地址是0x0</li><li>代码段（__TEXT）的内存地址就是LC_SEGMENT(__TEXT)中的VM Address：arm64设备下，为<code>0x100000000</code>；非arm64下为<code>0x4000</code></li><li>可以使用<code>size -l -m -x</code>来查看Mach-O的内存分布</li></ul><img src="/images/compilelink/26.png" alt="26" style="zoom:55%;" /><h3 id="2-2-使用了ASLR"><a href="#2-2-使用了ASLR" class="headerlink" title="2.2 使用了ASLR"></a>2.2 使用了ASLR</h3><ul><li>LC_SEGMENT(__TEXT)的VM Address为<code>0x100000000</code></li><li>ASLR随机产生的Offset（偏移）为<code>0x5000</code></li></ul><img src="/images/compilelink/27.png" alt="26" style="zoom:55%;" /><h3 id="2-3-符号地址计算"><a href="#2-3-符号地址计算" class="headerlink" title="2.3 符号地址计算"></a>2.3 符号地址计算</h3><blockquote><p>函数(变量)符号的内存地址、可执行文件地址计算</p></blockquote><h4 id="2-3-1-函数内存地址计算"><a href="#2-3-1-函数内存地址计算" class="headerlink" title="2.3.1 函数内存地址计算"></a>2.3.1 函数内存地址计算</h4><ul><li><strong>File Offset:</strong> 在当前架构(MachO)文件中的偏移量。</li><li> <strong>VM Address:</strong> 编译链接后，射到虚拟地址中的内存起始地址。 <code>VM Address = File Offset + __PAGEZERO Size</code>(__PAGEZERO段在MachO文件中没有实际大小，在VM中展开)</li><li><strong>Load Address:</strong> 在运行时加载到虚拟内存的起始位置。Slide是加载到内存的偏移，这个偏移值是一个随机值，每次运行都不相同。<code>Load Address = VM Address + Slide(ASLR Offset)</code></li></ul><p>由于dsym符号表是编译时生成的地址，crash堆栈的地址是运行时地址，这个时候需要经过转换才能正确的符号化。crash日志里的符号地址被称为Stack Address，而编译后的符号地址被称为Symbol Address，他们之间的关系如下：<code>Stack Address = Symbol Address + Slide</code></p><p>符号化就是通过Stack Address到dsym文件中寻找对应符号信息的过程。</p><p>Hopper、IDA图形化工具中的地址都是未使用ASLR前的VM Address</p><h4 id="2-3-2-ASLR-Offset的获取"><a href="#2-3-2-ASLR-Offset的获取" class="headerlink" title="2.3.2 ASLR Offset的获取"></a>2.3.2 ASLR Offset的获取</h4><p>ASLR Offset有的地方也叫做<code>slide</code>，获取方法：</p><ul><li><p>在运行时由API <code>dyld_get_image_vmaddr_slide()</code>，来获取image虚拟地址的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型如下：</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">intptr_t</span>   _dyld_get_image_vmaddr_slide(<span class="keyword">uint32_t</span> image_index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般使用方法如下：</span></span><br><span class="line"><span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> index  = _dyld_get_image_vmaddr_slide(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>lldb</code>命令<code>image list -o -f</code> 进行获取（本地、远程<code>debugserver</code>调试都可以），如下图：</p><img src="/images/compilelink/28.png" alt="26" style="zoom:80%;" /></li><li><p>根据运行时crash中的 <code>binary image</code>信息 和 ELF 文件的 <code>load command</code> 计算的到。比如下例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是crash信息，其中包括了抛出异常的线程的函数调用栈信息，日志下方有binary image信息，都只摘取了部分：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 第一列，调用顺序</span></span><br><span class="line"><span class="comment"> 第二列，对应函数所属的 binary image</span></span><br><span class="line"><span class="comment"> 第三列，stack address</span></span><br><span class="line"><span class="comment"> 第四列，地址的符号＋偏移的表示法，运算结果等于第三列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Last Exception Backtrace:  </span><br><span class="line"><span class="number">0</span>   CoreFoundation                <span class="number">0x189127100</span> __exceptionPreprocess + <span class="number">132</span>  </span><br><span class="line"><span class="number">1</span>   libobjc.A.dylib               <span class="number">0x1959e01fc</span> objc_exception_throw + <span class="number">60</span>  </span><br><span class="line"><span class="number">2</span>   CoreFoundation                <span class="number">0x189127040</span> +[NSException raise:format:] + <span class="number">128</span>  </span><br><span class="line"><span class="number">3</span>   CrashDemo                     <span class="number">0x100a8666c</span> <span class="number">0x10003c000</span> + <span class="number">10790508</span>  </span><br><span class="line"><span class="number">4</span>   libsystem_platform.dylib      <span class="number">0x19614bb0c</span> _sigtramp + <span class="number">56</span>  </span><br><span class="line"><span class="number">5</span>   CrashDemo                     <span class="number">0x1006ef164</span> <span class="number">0x10003c000</span> + <span class="number">7024996</span>  </span><br><span class="line"><span class="number">6</span>   CrashDemo                     <span class="number">0x1006e8580</span> <span class="number">0x10003c000</span> + <span class="number">6997376</span>  </span><br><span class="line"><span class="number">7</span>   CrashDemo                     <span class="number">0x1006e8014</span> <span class="number">0x10003c000</span> + <span class="number">6995988</span>  </span><br><span class="line"><span class="number">8</span>   CrashDemo                     <span class="number">0x1006e7c94</span> <span class="number">0x10003c000</span> + <span class="number">6995092</span>  </span><br><span class="line"><span class="number">9</span>   CrashDemo                     <span class="number">0x1006f2460</span> <span class="number">0x10003c000</span> + <span class="number">7038048</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 第一列，虚拟地址空间区块；</span></span><br><span class="line"><span class="comment"> 第二列，映射文件名；</span></span><br><span class="line"><span class="comment"> 第三列：加载的image的UUID；</span></span><br><span class="line"><span class="comment"> 第四列，映射文件路径 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Binary Images:  </span><br><span class="line"><span class="number">0x10003c000</span> - <span class="number">0x100f7bfff</span> CrashDemo arm64  &lt;b5ae3570a013386688c7007ee2e73978&gt; /var/mobile/Applications/<span class="number">05</span>C398CE<span class="number">-21E9</span><span class="number">-43</span>C2<span class="number">-967F</span><span class="number">-26</span>DD0A327932/CrashDemo.app/CrashDemo  </span><br><span class="line"><span class="number">0x12007c000</span> - <span class="number">0x1200a3fff</span> dyld arm64  &lt;<span class="number">628</span>da833271c3f9bb8d44c34060f55e0&gt; /usr/lib/dyld</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是使用 otool 工具查看到的 MedicalRecordsFolder（我的程序）的 加载命令 。</span></span><br><span class="line">$otool -l CrashDemo.app/CrashDemo   </span><br><span class="line">CrashDemo.app/CrashDemo:  </span><br><span class="line">Load command <span class="number">0</span>  </span><br><span class="line">      cmd LC_SEGMENT_64  </span><br><span class="line">  cmdsize <span class="number">72</span>  </span><br><span class="line">  segname __PAGEZERO  </span><br><span class="line">   vmaddr <span class="number">0x0000000000000000</span>  </span><br><span class="line">   vmsize <span class="number">0x0000000100000000</span>  </span><br><span class="line">  fileoff <span class="number">0</span>  </span><br><span class="line"> filesize <span class="number">0</span>  </span><br><span class="line">  maxprot <span class="number">0x00000000</span>  </span><br><span class="line"> initprot <span class="number">0x00000000</span>  </span><br><span class="line">   nsects <span class="number">0</span>  </span><br><span class="line">    flags <span class="number">0x0</span>  </span><br><span class="line">Load command <span class="number">1</span>  </span><br><span class="line">      cmd LC_SEGMENT_64  </span><br><span class="line">  cmdsize <span class="number">792</span>  </span><br><span class="line">  segname __TEXT  </span><br><span class="line">   vmaddr <span class="number">0x0000000100000000</span>  </span><br><span class="line">   vmsize <span class="number">0x000000000000c000</span>  </span><br><span class="line">  fileoff <span class="number">0</span>  </span><br><span class="line"> filesize <span class="number">49152</span>  </span><br><span class="line">  maxprot <span class="number">0x00000005</span>  </span><br><span class="line"> initprot <span class="number">0x00000005</span>  </span><br><span class="line">   nsects <span class="number">9</span>  </span><br><span class="line">    flags <span class="number">0x0</span>  </span><br><span class="line">……  </span><br><span class="line">Load command <span class="number">2</span> </span><br><span class="line">……  </span><br></pre></td></tr></table></figure><p>在 binary image 第一行可以看出进程空间的 0x10003c000 - 0x100f7bfff 这个区域在运行时被映射为 CrashDemo 内的内容，也就是我们的 ELF 文件(区域起始地址为0x10003c000)。<br>而在 Load Command 中看到的<code>__TEXT</code>的段起始地址却是 0x0000000100000000。<br>显而易见：slide = 0x10003c000(Load Address) - 0x100000000(VM Address) = 0x3c000；之后，就可以通过公式<code>symbol address = stack address - slide;</code> 来计算stack address 在crash log 中已经找到了。</p></li></ul><h4 id="2-3-3-Symbol-Address符号化"><a href="#2-3-3-Symbol-Address符号化" class="headerlink" title="2.3.3 Symbol Address符号化"></a>2.3.3 Symbol Address符号化</h4><ul><li><p>利用<code>dwarfdump</code>可以从dsym文件中得到symbol Address对应的内容：</p><ul><li>拿到crash日志后，我们要先确定dsym文件是否匹配。可以使用下面命令查看dsym文件所有架构的UUID：<code>dwarfdump --uuid CrashDemo.app.dSYM </code>，然后跟crash日志中Binary Images中的UUID相比对。</li><li>用得到的Symbol Address去 dsym 文件中查询，命令如下：<code>dwarfdump --arch arm64 --lookup [Symbol Address] CrashDemo.app.dSYM</code>，就可以定位下来具体的代码、函数名、所处的文件、行等信息了</li></ul></li><li><p>如果只是简单的获取符号名，可以用<code>atos</code>来符号化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atos -o [dsym file path] -l [Load Address] -arch [arch <span class="built_in">type</span>] [Stack Address]</span><br></pre></td></tr></table></figure><ul><li>不需要指定Symbol Address，只需要Load Address、Stack Address即可。</li></ul></li></ul><h2 id="三、进程地址空间"><a href="#三、进程地址空间" class="headerlink" title="三、进程地址空间"></a>三、进程地址空间</h2><p>由于ASLR的作用，进程的地址空间变得流动性非常大。但是尽管具体的地址会随机“滑动”某个小的偏移量，但整体布局保持不变。</p><p>内存空间分为以下几个段：</p><ul><li><strong>__PAGEZERO</strong>：在32位的系统中，这是内存中单独的一个页面(4KB)，而且这个页面所有的访问权限都被撤消了。在 64 位系统上，这个段对应了一个完整的32位地址空间(即前4GB)。这个段有助于捕捉空指针引用(因为空指针实际上就是 0)，或捕捉将整数当做指针引用(因为32位平台下的 4095 以下的值，以及64位平台下4GB以下的值都在这个范围内)。由于这个范围内所有访问权限(读、写和执行)都被撤消了，所以在这个范围内的任何解引用操作都会引发来自 MMU 的硬件页错误， 进而产生一个内核可以捕捉的陷阱。内核将这个陷阱转换为C++异常或表示总线错误的POSIX信号(SIGBUS) 。</li></ul><blockquote><p>PAGEZERO不是设计给进程使用的，但是多少成为了恶意代码的温床。想要通过“额外”代码感染Mach-O的攻击者往往发现可以很方便地通过PAGEZERO实现这个目的。PAGEZERO通常不属于目标文件的一部分(其对应的加载指令LC_SEGMENT将filesize指定为0)，但是对此并没有严格的要求.</p></blockquote><ul><li><strong>__TEXT</strong>：这个段存放的是程序代码。和其他所有操作系统一样，文本段被设置为r-x，即只读且可执行。这不仅可以防止二进制代码在内存中被修改，还可以通过共享这个只读段优化内存的使用。通过这种方式，同一个程序的多个实例可以仅使用一份TEXT副本。文本段通常包含多个区，实际的代码在_text区中。文本段还可以包含其他只读数据，例如常量和硬编码的字符串。</li><li><strong>__LINKEDIT</strong>：由dyld使用，这个区包含了字符串表、符号表以及其他数据。</li><li><strong>__IMPORT</strong>：用于 i386 的二进制文件的导入表。</li><li><strong>__DATA</strong>：用于可读/可写的数据。</li><li><strong>__MALLOC_TINY</strong>：用于小于一个页面大小的内存分配。</li><li><strong>__MALLOC_SMALL</strong>：用于几个页面大小的内存分配。</li></ul><p>下面是使用<code>vmmap(1)</code>输出的一个实例<code>程序a</code>在<code>32位</code>硬件设备上运行的进程地址空间，显示了区域的名称、地址范围、权限(当前权限和最高权限)以及映射的名称(通常对应的是Mach-O目标文件，如果有的话)。</p><p>32位进程的虚拟地址空间布局：</p><img src="/images/compilelink/29.png" alt="26" style="zoom:90%;" /><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>应该注意的是，尽管ASLR是很显著的改进，但也不是万能药。黑客仍然能找到聪明的方法破解程序。事实上，目前臭名昭著的“Star 3.0”漏洞就攻破了ASLR，这个漏洞越狱了 iPad 2 上的iOS 4.3。这种破解使用了Retum-Oriented Programming(ROP)攻击技术，通过缓冲区溢出破坏栈，以设置完整的栈帧， 模拟对libSystem的调用。同样的技术也用在iOS 5.0.1的“corona”漏洞中，这个漏洞成功地攻入了所有的苹果设备，包括当时最新的iPhone 4S。</p><p>预防攻击的唯一之道就是编写更加安全的代码，并且采用严格的代码审查，既要包含自动的技术，也要有人工的介入。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li>《深入解析Mac OS X &amp; iOS 操作系统》</li><li><a href="https://blog.csdn.net/zhongad007/article/details/90022617">动态调试之ASLR</a></li><li><a href="https://blog.csdn.net/xiaofei125145/article/details/50456614">iOS crash log 解析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、ASLR引入&quot;&gt;&lt;a href=&quot;#一、ASLR引入&quot; class=&quot;headerlink&quot; title=&quot;一、ASLR引入&quot;&gt;&lt;/a&gt;一、ASLR引入&lt;/h2&gt;&lt;p&gt;进程在自己私有的虚拟地址空间中启动。按照传统方式，进程每一次启动时采用的都是固定的可预见的方</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(四) Mach-O 文件的装载</title>
    <link href="https://tenloy.github.io/2021/09/25/compile-load.html"/>
    <id>https://tenloy.github.io/2021/09/25/compile-load.html</id>
    <published>2021-09-25T14:26:00.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/compilelink/25.png" alt="25" style="zoom:80%;" /><p>先附上源码地址：结合 <a href="https://opensource.apple.com/tarballs/xnu/">XNU</a> 源码(应该不是最新的，且不怎么全，不过用来分析学习也差不多了)，来看加载器的流程，效果更好。重要的两个类：</p><ul><li><code>bsd/kern/kern_exec.c</code>：进程执行的相关操作：线程创建、数据初始化等。</li><li><code>bsd/kern/mach_loader.c</code>：Mach-O文件解析加载相关。第二节中提到的Mach-O文件中的内核加载器负责处理的load command 对应的内核中处理的函数都在该文件中，比如处理<code>LC_SEGMET</code>命令的<code>load_segment</code>函数、处理<code>LC_LOAD_DYLINKER</code>命令的<code>load_dylinker</code>函数(负责调用命令指定的动态链接器)。</li></ul><h2 id="一、装载概述"><a href="#一、装载概述" class="headerlink" title="一、装载概述"></a>一、装载概述</h2><p>在链接完成之后，应用开始运行之前，有一段装载过程，我们都知道程序执行时所需要的指令和数据必须在内存中才能够被正常运行。</p><p>最简单的办法就是将程序运行所需要的指令和数据全都装入内存中，这样程序就可以顺利运行，这就是最简单的<code>静态装入</code>的办法。</p><p>但是很多情况下程序所需要的内存数量大于物理内存的数量，当内存的数量不够时，根本的解决办法就是添加内存。相对于磁盘来说，内存是昂贵且稀有的，这种情况自计算机磁盘诞生以来一直如此。所以人们想尽各种办法，希望能够在不添加内存的情况下让更多的程序运行起来，尽可能有效地利用内存。后来研究发现，程序运行时是有<code>局部性原理</code>的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是<code>动态装入</code>的基本原理。（这也是<code>虚拟地址空间</code>机制要解决的问题，这里不再赘述，大学都学过）</p><p>覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态装载方法，它们所采用的思想都差不多，原则上都是利用了程序的局部性原理。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。</p><h2 id="二、装载理论篇"><a href="#二、装载理论篇" class="headerlink" title="二、装载理论篇"></a>二、装载理论篇</h2><p>在虚拟存储中，现代的硬件MMU都提供地址转换的功能。有了硬件的地址转换和页映射机制，操作系统动态加载可执行文件的方式跟静态加载有了很大的区别。</p><p>事实上，从操作系统的角度来看，一个进程最关键的特征是它拥有独立的虚拟地址空间，这使得它有别于其他进程。很多时候一个程序被执行同时都伴随着一个新的进程的创建，那么我们就来看看这种最通常的情形：<strong>创建一个进程，然后装载相应的可执行文件并且执行</strong>。在有虚拟存储的情况下，上述过程最开始只需要做三件事情：</p><ul><li>创建一个独立的虚拟地址空间。</li><li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。</li><li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</li></ul><p><strong>首先是创建虚拟地址空间</strong>。一个虚拟空间由<code>一组页映射函数</code>将<code>虚拟空间的各个页</code>映射至相应的<code>物理空间</code>，所以创建一个虚拟空间实际上并不是创建空间而是<code>创建映射函数所需要的相应的数据结构</code>，在i386 的Linux下，创建虚拟地址空间实际上只是分配一个页目录（Page Directory）就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置。</p><p><strong>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</strong>。上面那一步的<code>页映射关系函数是虚拟空间到物理内存的映射关系</code>，这一步所做的是<code>虚拟空间与可执行文件的映射关系</code>。我们知道，当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。</p><p>但是很明显的一点是，当操作系统捕获到缺页错误时，它应知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。从某种角度来看，这一步是整个装载过程中最重要的一步，也是传统意义上“装载”的过程。</p><blockquote><p>由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件（Image）。</p></blockquote><p>很明显，这种映射关系只是保存在操作系统内部的一个数据结构。Linux中将进程虚拟空间中的一个段叫做<strong>虚拟内存区域</strong>（VMA, Virtual Memory Area）；在Windows中将这个叫做<strong>虚拟段</strong>（Virtual Section），其实它们都是同一个概念。</p><blockquote><p>VMA是一个很重要的概念，它对于我们理解程序的装载执行和操作系统如何管理进程的虚拟空间有非常重要的帮助。</p></blockquote><p>操作系统在内部保存这种结构，很明显是因为当程序执行发生段错误时，它可以<code>通过查找这样的一个数据结构来定位错误页在可执行文件中的位置</code>。</p><p><strong>将CPU指令寄存器设置成可执行文件入口，启动运行</strong>。第三步其实也是最简单的一步，操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步看似简单，实际上在操作系统层面上比较复杂，它涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。不过从进程的角度看这一步可以简单地认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址(通常是text区的地址)。</p><ul><li>ELF文件头中，有<code>e_entry</code>字段保存入口地址</li><li>Mach-O文件中的<code>LC_MAIN</code>加载指令作用就是设置程序主程序的入口点地址和栈大小)</li></ul><h2 id="三、Mach-O文件的装载"><a href="#三、Mach-O文件的装载" class="headerlink" title="三、Mach-O文件的装载"></a>三、Mach-O文件的装载</h2><p><a href="https://www.jianshu.com/p/332b183c055a">(二) Mach-O 文件结构</a> 介绍 <code>Mach Heade</code> 中的 <code>Load Command</code> 加载命令，结合其用途，就可以简单看出可执行文件的装载流程：</p><ul><li><p>首先，是由内核加载器(定义在<code>bsd/kern/mach_loader.c</code>文件中)来处理一些需要由内核加载器直接使用的加载命令。<strong>内核的部分(内核加载器)负责新进程的基本设置——分配虚拟内存，创建主线程，以及处理任何可能的代码签名/加密的工作</strong>。（这也是本篇内容主要讲的）</p></li><li><p>接着，对于需要动态链接(使用了动态库)的可执行文件(大部分可执行文件都是动态链接的)来说，<strong>控制权会转交给链接器，链接器进而接着处理文件头中的其他加载命令</strong>。真正的库加载和符号解析的工作都是通过<code>LC_LOAD_DY LINKER</code>命令指定的<code>动态链接器</code>在用户态完成的。（下一篇文章再细讲<code>dyld</code>及<code>动态链接</code>）</p></li></ul><p>下面通过代码来看一下具体的过程。下面通过一个调用栈图来说明， 这里面每个方法都做了很多事情，这里只注释了到_dyld_start的关键操作，很简略。有兴趣可以详细看源码<code>kern_exec.c</code>、<code>mach_loader.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">▼ execve       <span class="comment">// 用户点击了app，用户态会发送一个系统调用 execve 到内核</span></span><br><span class="line">  ▼ __mac_execve  <span class="comment">// 主要是为加载镜像进行数据的初始化，以及资源相关的操作，以及创建线程</span></span><br><span class="line">    ▼ exec_activate_image <span class="comment">// 拷贝可执行文件到内存中，并根据不同的可执行文件类型选择不同的加载函数，所有的镜像的加载要么终止在一个错误上，要么最终完成加载镜像。</span></span><br><span class="line">      <span class="comment">// 在 encapsulated_binary 这一步会根据image的类型选择imgact的方法</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 该方法为Mach-o Binary对应的执行方法；</span></span><br><span class="line"><span class="comment">       * 如果image类型为Fat Binary，对应方法为exec_fat_imgact；</span></span><br><span class="line"><span class="comment">       * 如果image类型为Interpreter Script，对应方法为exec_shell_imgact</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ▼ exec_mach_imgact   </span><br><span class="line">        ▶︎ <span class="comment">// 首先对Mach-O做检测，会检测Mach-O头部，解析其架构、检查imgp等内容，判断魔数、cputype、cpusubtype等信息。如果image无效，会直接触发assert(exec_failure_reason == OS_REASON_NULL); 退出。</span></span><br><span class="line">          <span class="comment">// 拒绝接受Dylib和Bundle这样的文件，这些文件会由dyld负责加载。然后把Mach-O映射到内存中去，调用load_machfile()</span></span><br><span class="line">        ▼ load_machfile</span><br><span class="line">          ▶︎ <span class="comment">// load_machfile会加载Mach-O中的各种load monmand命令。在其内部会禁止数据段执行，防止溢出漏洞攻击，还会设置地址空间布局随机化（ASLR），还有一些映射的调整。</span></span><br><span class="line">            <span class="comment">// 真正负责对加载命令解析的是parse_machfile()</span></span><br><span class="line">          ▼ parse_machfile  <span class="comment">//解析主二进制macho</span></span><br><span class="line">            ▶︎ <span class="comment">/* </span></span><br><span class="line"><span class="comment">               * 首先，对image头中的filetype进行分析，可执行文件MH_EXECUTE不允许被二次加载(depth = 1)；动态链接编辑器MH_DYLINKER必须是被可执行文件加载的(depth = 2)</span></span><br><span class="line"><span class="comment">               * 然后，循环遍历所有的load command，分别调用对应的内核函数进行处理</span></span><br><span class="line"><span class="comment">               *   LC_SEGMET：load_segment函数：对于每一个段，将文件中相应的内容加载到内存中：从偏移量为 fileoff 处加载 filesize 字节到虚拟内存地址 vmaddr 处的 vmsize 字节。每一个段的页面都根据 initprot 进行初始化，initprot 指定了如何通过读/写/执行位初始化页面的保护级别。</span></span><br><span class="line"><span class="comment">               *   LC_UNIXTHREAD：load_unixthread函数，见下文</span></span><br><span class="line"><span class="comment">               *   LC_MAIN：load_main函数</span></span><br><span class="line"><span class="comment">               *   LC_LOAD_DYLINKER：获取动态链接器相关的信息，下面load_dylinker会根据信息，启动动态链接器</span></span><br><span class="line"><span class="comment">               *   LC_CODE_SIGNATURE：load_code_signature函数，进行验证，如果无效会退出。理论部分，回见第二节load_command `LC_CODE_SIGNATURE `部分。</span></span><br><span class="line"><span class="comment">               *   其他的不再多说，有兴趣可以自己看源码</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">            ▼ load_dylinker <span class="comment">// 解析完 macho后，根据macho中的 LC_LOAD_DYLINKER 这个LoadCommand来启动这个二进制的加载器，即 /usr/bin/dyld</span></span><br><span class="line">              ▼ parse_machfile <span class="comment">// 开始解析 dyld 这个mach-o文件</span></span><br><span class="line">                ▼ load_unixthread <span class="comment">// 解析 dyld 的 LC_UNIXTHREAD 命令，这个过程中会解析出entry_point</span></span><br><span class="line">                  ▼ load_threadentry  <span class="comment">// 获取入口地址</span></span><br><span class="line">                    ▶︎ thread_entrypoint  <span class="comment">// 里面只有i386和x86架构的，没有arm的，但是原理是一样的</span></span><br><span class="line">                  ▶︎ <span class="comment">//上一步获取到地址后，会再加上slide，ASLR偏移，到此，就获取到了dyld的入口地址，也就是 _dyld_start 函数的地址</span></span><br><span class="line">        ▼ activate_exec_state</span><br><span class="line">          ▶︎ thread_setentrypoint <span class="comment">// 设置entry_point。直接把entry_point地址写入到用户态的寄存器里面了。</span></span><br><span class="line">          <span class="comment">//这一步开始，_dyld_start就真正开始执行了。</span></span><br><span class="line"></span><br><span class="line">▼ dyld</span><br><span class="line">  ▼ __dyld_start  <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::start() </span><br><span class="line">      ▼ dyld::_main()</span><br><span class="line">        ▼ <span class="comment">//函数的最后，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">        ▼ 这是下篇内容</span><br></pre></td></tr></table></figure><h2 id="四、Linux-ELF文件的装载（了解）"><a href="#四、Linux-ELF文件的装载（了解）" class="headerlink" title="四、Linux ELF文件的装载（了解）"></a>四、Linux ELF文件的装载（了解）</h2><p>首先在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用 <code>execve()</code>系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。 execve() 系统调用被定义在unistd.h，它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 三个参数分别是被执行的程序文件名、执行参数和环境变量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </span><br></pre></td></tr></table></figure><p>Glibc对该系统调用进行了包装，提供了 execl()、execlp()、execle()、execv()、execvp()等5个不同形式的exec系列API，它们只是在调用的参数形式上有所区别，但最终都会调用到 execve() 这个系统中。</p><p>在进入 execve() 系统调用之后，Linux内核就开始进行真正的装载工作。</p><ul><li><p><code>sys_execve()</code>，在内核中，该函数是execve()系统调用相应的入口，定义在arch\i386\kernel\Process.c。 该函数进行一些参数的检查复制之后，调用 do_execve()。</p></li><li><p><code>do_execve()</code>，该函数会首先查找被执行的文件，如果找到文件，则读取文件的前128个字节。目的是判断文件的格式，每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，常常被称做<code>魔数</code>（Magic Number），通过对魔数的判断可以确定文件的格式和类型。比如：</p><ul><li>ELF的可执行文件格式的头4个字节为0x7F、’e’、’l’、’f’；</li><li>Java的可执行文件格式的头4个字节为’c’、’a’、’f’、’e’；</li><li>如果被执行的是Shell脚本或perl、python等这种解释型语言的脚本，那么它的第一行往往是 “#!/bin/sh” 或 “#!/usr/bin/perl” 或 “#!/usr/bin/python” ，这时候前两个字节<code>&#39;#&#39;</code>和<code>&#39;!&#39;</code>就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</li></ul><p>当do_execve()读取了这128个字节的文件头部之后，然后调用search_binary_handle()。</p></li><li><p><code>search_binary_handle()</code>，该函数会去搜索和匹配合适的可执行文件装载处理过程。<strong>Linux中所有被支持的可执行文件格式都有相应的装载处理过程</strong>，此函数会通过判断文件头部的魔数确定文件的格式，并且调用相应的装载处理过程。比如：</p><ul><li>ELF可执行文件的装载处理过程叫做 load_elf_binary()； </li><li>a.out可执行文件的装载处理过程叫做 load_aout_binary()；</li><li>装载可执行脚本程序的处理过程叫做 load_script()。</li></ul></li><li><p><code>load_elf_binary()</code>，这个函数被定义在fs/Binfmt_elf.c，代码比较长，它的主要步骤是：</p><ol><li>检查ELF可执行文件格式的有效性，比如魔数、程序头表中段（Segment）的数量。</li><li>寻找动态链接的“.interp”段，设置动态链接器路径。</li><li>根据ELF可执行文件的程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据。</li><li>初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是 DT_FINI 的地址（动态链接相关）。</li><li>将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序入口就是ELF文件的文件头中 <code>e_entry</code> 所指的地址；对于动态链接的ELF可执行文件，程序入口点是动态链接器。</li></ol></li></ul><p>当 load_elf_binary() 执行完毕，返回至 do_execve() 再返回至 sys_execve() 时， 上面的第5步中已经把系统调用的返回地址改成了被装载的ELF程序(或动态链接器)的入口地址了。所以当 <code>sys_execve()</code>系统调用从内核态返回到用户态时，EIP 寄存器直接跳转到了ELF程序的入口地址，于是新的程序开始执行，ELF可执行文件装载完成。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="">《深入理解Mach OS X &amp; iOS 操作系统》</a></li><li><a href="">《程序员的自我修养》</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/06/30/dyld2/">Dyld系列之一：_dyld_start之前</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/compilelink/25.png&quot; alt=&quot;25&quot; style=&quot;zoom:80%;&quot; /&gt;

&lt;p&gt;先附上源码地址：结合 &lt;a href=&quot;https://opensource.apple.com/tarballs/xnu/&quot;&gt;XNU&lt;</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(三) Mach-O 文件的静态链接</title>
    <link href="https://tenloy.github.io/2021/09/24/compile-static-link.html"/>
    <id>https://tenloy.github.io/2021/09/24/compile-static-link.html</id>
    <published>2021-09-24T14:25:56.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、链接概述"><a href="#一、链接概述" class="headerlink" title="一、链接概述"></a>一、链接概述</h2><p>链接通常是一个让人比较费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？链接过程到底包含了什么内容？为什么要链接？</p><p>很久以前，人们编写程序时，将所有源代码都写在同一个文件中，发展到后来一个程序源代码的文件长达数百万行，以至于人们没有能力维护这个程序。</p><p>后来，出现了模块化。现代的大型软件往往拥有成千上万个模块，这些模块之间相互依赖又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读、理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等。</p><p>在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是须解决的问题。<code>模块之间如何组合的问题可以归结为模块之间如何通信的问题</code>，最常见的属于静态语言的C/C++模块之间通信有两种方式，一种是模块间的<strong>函数调用</strong>，另外一种是模块间的<strong>变量访问</strong>。函数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是<code>模块间符号的引用</code>。模块间依靠符号来通信类似于拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者一拼接刚好完美组合。这个模块的拼接过程就是：<strong>链接</strong></p><img src="/images/compilelink/18.jpg" alt="18" style="zoom:100%;" /><p>综上所述，链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。现代的高级语言的诸多特性和功能，使得编译器、链接器更为复杂，功能更为强大，但从原理上来讲，链接器的工作无非就是把一些指令对其他符号地址的引用加以修正。<strong>链接过程主要包括了地址和空间分配（Address and StorageAllocation）、符号决议（Symbol Resolution）和重定位 （Relocation）等这些步骤。</strong>（<code>符号可以理解为函数名和变量名</code>）</p><p>链接分为静态链接、动态链接。本篇只讲静态链接及静态链接器。</p><ul><li>静态链接是把目标文件（一个或多个）和需要的静态库链接成可执行文件。</li><li>动态链接是在可执行文件<code>装载</code>、<code>运行</code>时进行的文件的链接。</li></ul><h2 id="二、静态链接"><a href="#二、静态链接" class="headerlink" title="二、静态链接"></a>二、静态链接</h2><h3 id="2-1-链接器"><a href="#2-1-链接器" class="headerlink" title="2.1 链接器"></a>2.1 链接器</h3><p>lld链接器是LLVM的一个子项目，旨在为LLVM开发一个内置的，平台独立的链接器，去除对所有第三方链接器的依赖。在2017年5月，lld已经支持ELF、PE/COFF、和Mach-O。在lld支持不完全的情况下，用户可以使用其他项目，如 GNU ld 链接器。</p><p>lld支持链接时优化。当LLVM链接时优化被启用时，LLVM可以输出bitcode而不是本机代码，而本机代码生成由链接器优化处理。</p><h3 id="2-2-静态链接过程"><a href="#2-2-静态链接过程" class="headerlink" title="2.2 静态链接过程"></a>2.2 静态链接过程</h3><h4 id="2-2-1-两步链接"><a href="#2-2-1-两步链接" class="headerlink" title="2.2.1 两步链接"></a>2.2.1 两步链接</h4><p>我们知道，可执行文件中的代码段和数据段都是由输入的目标文件中合并而成的。那么链接过程就产生了第一个问题：对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？或者说，输出文件中的空间如何分配给输入文件？</p><ol><li><p><strong>按序叠加</strong>：一个最简单的方案就是将输入的目标文件按照次序叠加起来。（比如按照编译顺序，先编译的在前）。</p><p><strong>缺点</strong>：在有很多输入文件的情况下，输出文件将会有很多零散的段。假如有数百个目标文件，且都分别有.text段、.data段、.bss段，那最后的输出文件将会有成百上千个零散的段。这种做法非常浪费空间，因为每个段都须要有一定的地址和空间对齐要求(<strong>x86中，段的装载地址和空间的对齐单位是页，也就是4096字节</strong>)。</p></li><li><p><strong>相似段合并</strong>：将相同性质的段合并到一起。</p></li></ol><img src="/images/compilelink/19.jpg" alt="18" style="zoom:90%;" /><p>现在的链接器空间分配的策略基本上都会使相似段(Section)合并，使用这种方法的链接器一般都采用一种叫两步链接（Two-pass Linking）的方法。也就是说整个链接过程分两步：</p><h4 id="2-2-2-符号表与符号"><a href="#2-2-2-符号表与符号" class="headerlink" title="2.2.2 符号表与符号"></a>2.2.2 符号表与符号</h4><p>以下示例来自<a href="https://juejin.im/post/6844903912198127623#heading-5">iOS程序员的自我修养-MachO文件静态链接（三）</a>，过程很简单，就是对于目标文件、可执行文件的MachOView的分析，目标文件、可执行文件是链接过程的输入、输出，通过对两个文件中的<code>符号表Symbols</code>、<code>代码段__TEXT.__text</code>来看一下引用符号的空间与地址分配、地址绑定过程。关于目标文件、可执行文件的生成上一篇文章已经讲过，本篇文章就直接看分析结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c 文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global_var;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    func(a+global_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">=========================</span><br><span class="line"><span class="comment">// b.c 文件</span></span><br><span class="line"><span class="keyword">int</span> global_var = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    global_var = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成a.o b.o</span></span><br><span class="line">xcrun -sdk iphoneos clang -c a.c b.c -target arm64-apple-ios12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># a.o和b.o链接成可执行文件ab</span></span><br><span class="line">xcrun -sdk iphoneos clang a.o b.o -o ab -target arm64-apple-ios12.2</span><br></pre></td></tr></table></figure><p>请注意，生成的a.o和b.o目标文件，都是基于arm64。a.o和b.o目标文件通过静态链接后生成可执行文件ab。（由于基于arm64，其实链接过程，也有动态链接库libSystem.B.dylib(系统库)参与,但本文忽略动态链接的参与，只讨论静态链接）。</p><img src="/images/compilelink/20.png" alt="18" style="zoom:80%;" /><p>在可执行文件ab中，之所以<code>__TEXT.text</code>段的虚拟地址为<code>0x100000000</code>，而在文件中的位置(偏移)为<code>0</code>，是因为在链接生成可执行文件时，产生的一个特殊的段<code>__PAGEZERO</code>，这个段，在可执行文件中不占空间<code>File Offest</code>、<code>File Size</code>都为0，而在虚拟地址空间中，占用了很大的空间，<code>VMSize</code>为<code>0x100000000(4G)</code>.</p><p>在进入重定位之前，这里还需要再介绍一下符号表相关的知识点：符号表的加载命令、符号表的结构。</p><h5 id="1-符号表的加载命令"><a href="#1-符号表的加载命令" class="headerlink" title="1. 符号表的加载命令"></a>1. 符号表的加载命令</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/loader.h&gt;中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmd;<span class="comment">/* 加载命令的前两个参数都是cmd和cmdsize，cmd为加载命令的类型，符号表对应的值为LC_SYMTAB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* symtab_command结构体的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>symoff;<span class="comment">/* 符号表在文件中的偏移（位置） */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>nsyms;<span class="comment">/* 符号表入口的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>stroff;<span class="comment">/* 字符串表在文件中的偏移(位置) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>strsize;<span class="comment">/* 字符串表的大小(字节数) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-符号表"><a href="#2-符号表" class="headerlink" title="2. 符号表"></a>2. 符号表</h5><p>符号表也是一个数组，里面元素是结构体nlist_64。符号表示意图见下方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist_64</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> n_strx;   <span class="comment">/* 字符串表的index，可以找到符号对应的字符串（index into the string table） */</span></span><br><span class="line">    &#125; n_un;                <span class="comment">/* 历史原因，忽略 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>  n_type;       <span class="comment">/* type flag, see below */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>  n_sect;       <span class="comment">/* section的编号或NO_SECT（section number or NO_SECT） */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> n_value;      <span class="comment">/* 符号的地址值（value of this symbol (or stab offset)） */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它先不管，要是有兴趣，可以去头文件&lt;mach-o/nlist.h&gt;查看。</span></span><br></pre></td></tr></table></figure><p>左侧是a.o的符号表，右侧是可执行文件的(全局)符号表：</p><img src="/images/compilelink/21.png" alt="18" style="zoom:80%;" /><p>相比于<code>a.o</code>、<code>b.o</code>目标文件，此时，可执行文件<code>ab</code>中的全局符号表中，每个符号都有了对应的(虚拟空间)地址，这是重定位的前提。</p><h5 id="3-符号表中符号的几种类型"><a href="#3-符号表中符号的几种类型" class="headerlink" title="3. 符号表中符号的几种类型"></a>3. 符号表中符号的几种类型</h5><blockquote><p><a href="https://www.jianshu.com/p/bda60193808d">引自-符号和符号表</a></p></blockquote><p>每个可重定位模块都有一个符号表，它包含了在本模块中定义和引用的符号，有三种链接器符号：</p><table><thead><tr><th>类型</th><th>特征</th><th>举例</th></tr></thead><tbody><tr><td><strong>Global symbols</strong>（模块内部定义的<strong>全局符号</strong>）</td><td>由本模块定义并能被其他模块引用的符号</td><td>例如，非static C函数和非 static的C全局变量（指不带static的全局变量）</td></tr><tr><td><strong>External symbols</strong>（外部定义的<strong>全局符号</strong>）</td><td>由其他模块定义并被本模块引用了的全局符号</td><td>例如，在本模块中extern声明的其它模块中定义的符号</td></tr><tr><td><strong>Local symbols</strong>（本模块的<strong>局部符号</strong>）</td><td>仅由本模块内定义和引用的本地符号</td><td>例如，在本模块中定义的带static 的C函数和全局变量。</td></tr></tbody></table><p><strong>注意：链接器局部符号</strong></p><ul><li><strong>不是指程序中的局部变量</strong>（分配在栈中的临时性变量），链接器是不关心这种局部变量的。</li><li><strong>个人理解</strong>：局部符号在本模块内定义并引用，按照符号解析的功能来看，其是不参与符号解析的。这也是为什么多个目标文件中出现同名的局部符号，在链接时，却不会报<code>符号重定义</code>的原因。并且查看链接后的可执行文件，符号表中，是可以同时存在多个同名局部符号的。</li></ul><h4 id="2-2-3-第一步-空间与地址分配"><a href="#2-2-3-第一步-空间与地址分配" class="headerlink" title="2.2.3 第一步 空间与地址分配"></a>2.2.3 第一步 空间与地址分配</h4><p>“链接器为目标文件分配地址和空间”这句话中的“地址和空间”其实有两个含义：</p><ul><li>第一个是在输出的可执行文件中的空间；</li><li>第二个是在装载后的虚拟地址中的虚拟地址空间。</li></ul><p>对于有实际数据的段，比如“.text”和“.data”来说，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；而对于“.bss”这样的段来说，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。</p><p>事实上，我们在这里谈到的空间分配只关注于虚拟地址空间的分配，因为这个关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接过程关系并不是很大。</p><h5 id="1-相似段合并"><a href="#1-相似段合并" class="headerlink" title="1. 相似段合并"></a>1. 相似段合并</h5><p>扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个<code>全局符号表</code>。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。</p><p>应该说地址与空间分配，地址：分配到哪；空间：分配多大。链接器的地址与空间分配，既是指在可执行文件中的分配，也指在虚拟地址空间中的分配。</p><ul><li><code>可执行文件的地址空间</code>与目标文件中一样，地址从0开始。</li><li><code>虚拟地址空间</code>中的地址并非从0开始，比如Linux下，ELF可执行文件中的数据，在进程虚拟地址空间中，默认从0x08048000开始分配。</li></ul><p>我们在这里谈到的空间分配只关注于虚拟地址空间的分配，因为这个关系到下一步重定位中，关于地址计算的步骤(重定位中，地址修正是修正为符号的虚拟地址空间中的地址)，而且可执行文件本身的空间分布、分配与链接过程关系并不是很大。</p><p>这一步过程：</p><ul><li>会将多个输入模块(目标文件)的数据收集，相似段进行合并，见上图。</li><li>重新计算段在可执行文件中的偏移、大小。</li><li>重新计算段在虚拟地址空间中的偏移、大小。</li></ul><p>这些信息在<code>LC_SEGMENT_64</code>中看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;          <span class="comment">/* Load Command类型，这里LC_SEGMENT_64代表将文件中64位的段映射到进程的地址空间。LC_SEGMENT_64和LC_SEGMENT的结构差别不大 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;      <span class="comment">/* 代表Load commands的大小 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];  <span class="comment">/* 16字节的段名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;       <span class="comment">/* 段映射到虚拟地址中的内存起始地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;       <span class="comment">/* 段映射到虚拟地址中的内存大小 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;      <span class="comment">/* 段在当前架构(MachO)文件中的偏移量，如果是胖二进制文件，也指的是相对于当前MachO文件的偏移 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;     <span class="comment">/* 段在文件中的大小 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   maxprot;      <span class="comment">/* 段页面的最高内存保护 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   initprot;     <span class="comment">/* 初始内存保护 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;       <span class="comment">/* segment包含的section的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 段页面标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-符号地址的确定-rebase"><a href="#2-符号地址的确定-rebase" class="headerlink" title="2. 符号地址的确定(rebase)"></a>2. 符号地址的确定(rebase)</h5><p>当前面一步完成之后，链接器开始计算各个符号的虚拟地址。(这一步修正地址的符号是本文件内定义的(数据、函数)符号，关于外部符号的引用重定位在第二步)</p><p>一个mach-o的二进制文件中，包含了<strong>text</strong>段和<strong>data</strong>段。我们知道在代码中，我们可以用<strong>指针</strong>来引用，那么在一个文件中怎么代表引用呢，那就是<strong>偏移</strong>(<strong>目标文件中符号表中的符号的地址，都是相对于text段起始的偏移</strong>)。</p><p>当目标文件、动态库文件等二进制文件加载到内存中的时候，起始地址就是申请的内存的起始地址（slide)，不会是0，那么如何再能够找到这些引用的正确内存位置呢？ 把<strong>偏移</strong>加上(slide)就好了。</p><img src="/images/compilelink/38.png" alt="38" style="zoom:70%;" /><h4 id="2-2-4-第二步-符号解析与重定位"><a href="#2-2-4-第二步-符号解析与重定位" class="headerlink" title="2.2.4 第二步 符号解析与重定位"></a>2.2.4 第二步 符号解析与重定位</h4><p>使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。事实上第二步是链接过程的核心，特别是重定位过程。</p><h5 id="1-符号解析"><a href="#1-符号解析" class="headerlink" title="1. 符号解析"></a>1. 符号解析</h5><p>符号解析：解析每个模块中<code>引用的符号</code>，将其与某个目标模块中的<code>符号定义</code>建立关联。</p><ul><li>每个定义的符号在代码段或数据段中都被分配了存储空间，将符号引用与符号定义建立关联后，就可在重定位时将引用的符号的地址重定位为相关联的定义的符号的地址。</li><li>如果没找到定义，会给出一个类似<code>“undefined reference to &#39;xxx&#39;”</code>、<code> “Undefined symbols”</code>类似的链接错误。导致这个问题的原因很多，最常见的一般都是链接时缺少了某个库、输入目标文件路径不正确、符号的声明与定义不一样等。</li><li>如果找到了，进行符号决议(绑定)：<ul><li>如果找到了一个，直接绑定；</li><li>如果链接器在输入模块中找到了一个以上的外部符号定义，会按照它的规则选择其中一个符号定义或者报错。<code>强弱符号</code>规则：<ul><li>对于C/C++语言来说，编译器默认函数和已初始化的全局变量为强符号，未初始化的全局变量为弱符号。</li><li>强符号只能被定义一次，否则报符号重复定义错误。符号的重复定义错误与类型无关，只要经过符号修饰机制后产生的符号相同，就报符号重复<code>“ld: dumplicate symbols”</code></li><li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选强符号。(Xcode中默认设置了clang编译参数，遇到强弱符号会报重复定义错误)</li><li>如果一个符号在所有目标文件中都是弱符号，会选择占用空间最大的一个（《程序员的自我修养》）</li></ul></li><li>动态库链接中还有<code>全局符号介入</code>规则(如果相同符号名的符号已存在，则后加入的符号被忽略))。</li></ul></li></ul><blockquote><p>符号决议有时候也被叫做符号绑定（Symbol Binding）、名称绑定 （Name Binding）、名称决议（Name Resolution），甚至还有叫做地址绑定（Address Binding）、指令绑定（Instruction Binding）的。</p><p>大体上它们的意思都一样，但从细节角度来区分，它们之间还是存在一定区别的，比如“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即它们所使用的范围不一样。在静态链接，我们将统一称为符号决议。</p></blockquote><p><strong>符号解析时会选择一个确切的定义，即每个全局符号仅占一处存储空间。</strong></p><p><strong>编码建议：</strong></p><ul><li>尽量避免使用全局变量</li><li>一定要用时：<ul><li>尽量使用内部链接定义，如用static修饰</li><li>全局变量要赋初值，<strong>避免潜在的强弱符号造成的不可知错误</strong>，赋初值后，编译器检测到重复定义会报错，提醒开发者修正。</li></ul></li><li><strong>头文件中，不能写<code>Global symbols</code>的定义</strong>(否则若头文件若被多处<code>#include</code>，预处理后展开，文件内容替换该行，就相当于直接在多个源文件中出现全局符号定义，会报错)。如果要定义全局变量，一定要用static修饰，设置为<code>Local symbols</code>。</li></ul><p>符号解析完成，全局符号表中符号都有对应的定义处的地址。接下来就是重定位工作：<strong>根据重定位表<code>Relocations</code>中符号信息，在全局符号表<code>Symbols</code>中找到符号的<code>定义地址</code>，然后找到符号在代码段<code>__TEXT.text</code>中的使用地址，进行指令的地址修正。</strong></p><h5 id="2-重定位"><a href="#2-重定位" class="headerlink" title="2. 重定位"></a>2. 重定位</h5><p>重定位就是指针修正的过程。</p><p>假设有A、B两个目标文件，B中引用了A中的一个变量并对其进行赋值，对应AT&amp;T汇编为<code>movl $0x2a, var</code>。</p><p>由于在编译目标文件B的时候，编译器并不知道变量var的目标地址，所以编译器在没法确定地址的情况下，将这条mov指令的目标地址置为 0，等待链接器在将目标文件A和B链接起来的时候再将其修正。我们假设A和B链接后，变量var的地址确定下来为0x1000，那么链接器将会把这个指令的目标地址部分修改成0x10000。这个地址修正的过程也被叫做<strong>重定位（Relocation）</strong>，每个要被修正的地方叫一个<strong>重定位入口（Relocation Entry）</strong>。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址。</p><p>从上面的示例中，可以看到：a文件使用了B文件中的global_var和func两个符号，那是怎么知道这两个符号的地址呢？</p><p>在a.o目标文件中：</p><img src="/images/compilelink/22.png" alt="18" style="zoom:70%;" /><ul><li>global_var（地址0）和func（地址0x2c，这条指令本身地址）都是假地址。编译器暂时用0x0和0x2c替代着，把真正地址计算工作留给链接器。</li><li>通过前面的空间与地址分配可以得知，链接器在完成地址与空间分配后，就可以确定所有符号的虚拟地址了。</li><li>此时，链接器根据符号的地址对每个需要重定位的指令进行地址修正。</li></ul><p>在链接后的ab可执行文件中：</p><img src="/images/compilelink/23.png" alt="18" style="zoom:70%;" /><p>可以看到global_var（地址0x100008000，指向data段，值为1）和func（地址0x100007f90，指向func函数地址）都是真正的地址。</p><p>链接器是怎么知道a模块里哪些指令要被调整，这些指令如何调整。事实上a.o里，有一个重定位表，专门保存这些与重定位相关的信息。而且每个section的section_64的header的reloff（重定位入口的文件偏移，即在重定位表里的偏移）和nreloc（几个需要重定位的符号），让链接器知道a模块的哪个section里的指令需要调整。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];   <span class="comment">/* Section 的名字 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* Section 所在的 Segment 名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;           <span class="comment">/* Section 映射到虚拟地址的偏移（所在的内存地址） */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;           <span class="comment">/* Section 的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;         <span class="comment">/* Section 在当前架构文件中的偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;          <span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;         <span class="comment">/* 重定位入口的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;         <span class="comment">/* 重定位入口的数目 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;          <span class="comment">/* Section标志属性 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;      <span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;      <span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;      <span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-重定位表"><a href="#3-重定位表" class="headerlink" title="3. 重定位表"></a>3. 重定位表</h5><p>重定位表可以认为是一个数组，数组里的元素为结构体relocation_info。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/reloc.h&gt;里</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">relocation_info</span> &#123;</span></span><br><span class="line">   <span class="keyword">int32_t</span>    r_address;<span class="comment">/* 重定位的符号在自己所在section中的偏移(地址)；offset in the section to what is being relocated */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   r_symbolnum:<span class="number">24</span>,<span class="comment">/* 如果r_extern == 0(外部符号)，则表示符号在符号表中的索引，如果r_extern == 0，则表示section的序数；symbol index if r_extern == 1 or section ordinal if r_extern == 0 */</span></span><br><span class="line">              r_pcrel:<span class="number">1</span>, <span class="comment">/* was relocated pc relative already */</span></span><br><span class="line">              r_length:<span class="number">2</span>,<span class="comment">/* 重定位符号的长度；0=byte, 1=word, 2=long, 3=quad */</span></span><br><span class="line">              r_extern:<span class="number">1</span>,<span class="comment">/* 不包含引用符号的值(即为外部符号)；does not include value of sym referenced */</span></span><br><span class="line">              r_type:<span class="number">4</span>;        <span class="comment">/* if not 0, machine specific relocation type */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r_address和r_length足够让我们知道要重定位的字节了；</span></span><br></pre></td></tr></table></figure><img src="/images/compilelink/24.png" alt="18" style="zoom:70%;" /><p>可以看出：</p><ul><li>a.o文件的重定位表中记录符号了_func和_global_var两个需要重定位的符号，并且<code>r_address</code>给出了两个符号在代码段section的位置，<code>r_symbolnum</code>指向了符号在符号表的index。</li><li>链接时候，a.o里面有这两符号的引用，然后b.o里面有这两符号的定义，一起合并到全局符号表里（见下方符号表部分中的示意图）。</li><li>在全局符号表里，可以找到这两个符号的虚拟内存位置和其它信息，就可以完成重定位工作(对指令进行地址修正)了。</li></ul><h3 id="2-3-静态库链接"><a href="#2-3-静态库链接" class="headerlink" title="2.3 静态库链接"></a>2.3 静态库链接</h3><p>一个静态库可以简单看成一组目标文件的集合，即多个目标文件经过压缩打包后形成的一个文件。</p><p>静态库链接：是指自己的模块与静态库里的某个模块（用到的某个目标文件，或多个目标文件）链接成可执行文件。其实和静态链接概念一样，只是这里，我们这里取了静态库里的某个/多个目标文件与我们自己的目标文件一起作为输入。</p><p>Q：为什么静态运行库里面一个目标文件只包含一个函数？比如libc.a静态库里面printf.o只有printf()函数、strlen.o只有strlen()函数，为什么要这样组织？</p><p>A：我们知道，<strong>链接器在链接静态库的时候是<code>以目标文件为单位</code>的</strong>。比如我们引用了静态库中的printf()函数，那么链接器就会把库中包含printf()函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件（函数）就不要链接到最终的输出文件中。</p><h2 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a>三、参考链接</h2><ul><li><a href="https://juejin.im/post/6844903912198127623#heading-5">iOS程序员的自我修养-MachO文件静态链接（三）</a></li><li><a href="">《程序员的自我修养》</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、链接概述&quot;&gt;&lt;a href=&quot;#一、链接概述&quot; class=&quot;headerlink&quot; title=&quot;一、链接概述&quot;&gt;&lt;/a&gt;一、链接概述&lt;/h2&gt;&lt;p&gt;链接通常是一个让人比较费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？链接过程到底包含了</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(二) Mach-O 文件结构</title>
    <link href="https://tenloy.github.io/2021/09/23/compile-macho.html"/>
    <id>https://tenloy.github.io/2021/09/23/compile-macho.html</id>
    <published>2021-09-23T14:25:50.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇说到源码经过预处理、编译、汇编之后生成目标文件，这一章介绍一下iOS、Mac OS中目标文件的格式<code>Mach-O的结构</code>，方便了解之后的<code>链接</code>生成可执行文件的过程。</p><p>先附上相关源码地址：与Mach-O 文件格式有关的结构体定义都可以从 <code>/usr/include/mach-o/loader.h</code> 中找到(直接在xcode项目中找到<code>loader.h</code>，然后Show In Finder即可)。</p><h2 id="一、进程与二进制格式"><a href="#一、进程与二进制格式" class="headerlink" title="一、进程与二进制格式"></a>一、进程与二进制格式</h2><p>进程在众多操作系统中都有提及，它是作为一个正在执行的程序的实例，这是 UNIX 的一个基本概念。而进程的出现是特殊文件在内从中加载得到的结果，这种文件必须使用操作系统可以认知的格式，这样才对该文件引入依赖库，初始化运行环境以及顺利地执行创造条件。</p><p><strong>Mach-O</strong>（Mach Object File Format）是 macOS 上的可执行文件格式，类似于 Linux 和大部分 UNIX 的原生格式 <strong>ELF</strong>（Extensible Firmware Interface）。macOS 支持三种可执行格式：解释器脚本格式、通用二进制格式和 Mach-O 格式(关于三者区别，在下面说到Mach-O Header的时候介绍)。</p><h2 id="二、相关工具"><a href="#二、相关工具" class="headerlink" title="二、相关工具"></a>二、相关工具</h2><p>命令行工具</p><ul><li><p>file 命令，查看Mach-O文件的基本信息：<code>file 文件路径</code></p></li><li><p>otool 命令，查看Mach-O特定部分和段的内容</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看Mach-O文件的header信息</span></span><br><span class="line">otool -h 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Mach-O文件的load commands信息</span></span><br><span class="line">otool -l 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多使用方法，终端输入otool -help查看</span></span><br></pre></td></tr></table></figure><ul><li>lipo 命令，来处理多架构Mach-O文件，常用命令如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看架构信息</span></span><br><span class="line">lipo -info 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#导出某种类型的架构</span></span><br><span class="line">lipo 文件路径 -thin 架构类型 -output 输出文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并多种架构类型</span></span><br><span class="line">lipo 文件路径1 文件路径2 -output 输出文件路径</span><br></pre></td></tr></table></figure><p>GUI工具</p><ul><li>MachOView：文件浏览。<a href="https://github.com/gdbinit/MachOView">MachOView官网</a></li><li>hopper：反汇编工具</li></ul><h2 id="三、Mach-O-文件格式"><a href="#三、Mach-O-文件格式" class="headerlink" title="三、Mach-O 文件格式"></a>三、Mach-O 文件格式</h2><p>Mach-O 文件格式在官方文档中有一个描述图，很多教程中都引用到。<a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html">官网文档</a></p><img src="/images/compilelink/12.png" alt="12" style="zoom:90%;" /><p>可以看的出 Mach-O 主要由 3 部分组成，下面一一讲述。Load Command的作用是指导内核加载器、动态链接器怎么将可执行文件装载到内存进行执行。所以Load Command放到最后一部分。</p><h3 id="3-1-示例"><a href="#3-1-示例" class="headerlink" title="3.1 示例"></a>3.1 示例</h3><p>用 helloworld 来做个试验：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// main.cpp</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>clang -g main.cpp -o main</code> 生成执行文件。然后拖入到 <em>MachOView</em> 中来查看一下加载 Segment 的结构（当然使用 <em>Synalyze It!</em> 也能捕捉到这些信息的，但是 <em>MachOView</em> 更对结构的分层更加一目了然）：</p><img src="/images/compilelink/13.jpg" alt="12" style="zoom:80%;" /><h3 id="3-2-Mach-O-头"><a href="#3-2-Mach-O-头" class="headerlink" title="3.2 Mach-O 头"></a>3.2 Mach-O 头</h3><p>Mach-O 头（Mach Header）描述了 Mach-O 的 CPU 架构、大小端、文件类型以及加载命令等信息。它的作用是让内核在读取该文件创建虚拟进程空间的时候，检查文件的合法性以及当前硬件的特性是否能支持程序的运行。</p><p>以下只给出 64 位定义的代码，因为 32 位的区别是缺少了一个预留字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC    0xfeedface    <span class="comment">/* the mach magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM    0xcefaedfe    <span class="comment">/* NXSwapInt(MH_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    magic;            <span class="comment">/* magic(魔数)：用来确认文件的格式，操作系统在加载可执行文件的时候会确认魔数是否正确，如果不正确会拒绝加载。 */</span></span><br><span class="line">    <span class="keyword">cpu_type_t</span>    cputype;        <span class="comment">/* CPU架构 */</span></span><br><span class="line">    <span class="keyword">cpu_subtype_t</span>    cpusubtype;  <span class="comment">/* CPU子版本 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    filetype;         <span class="comment">/* 文件类型，常见的Mach-O文件有：MH_OBJECT(目标文件)、MH_EXECUTABLE(可执行二进制文件)、MH_DYLIB(动态库)等等。这些文件类型定义在 loader.h 文件中同样可以找到 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    ncmds;            <span class="comment">/* 加载器中加载命令的数量 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    sizeofcmds;       <span class="comment">/* 加载器中所有加载命令的总大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;            <span class="comment">/* dyld 加载需要的一些标志，其中MH_PIE表示启用地址空间布局随机化(ASLR)。其他的值在loader.h文件中同样可以找到 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved;         <span class="comment">/* 64位的保留字段 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>魔数会表明文件的格式。filetype会表明具体是什么文件类型(都是猫，也分黑猫、白猫)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// magic：常见的魔数(Mac是小端模式)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mach-O文件。用途：macOS 的原生二进制格式</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_MAGIC0xfeedface  <span class="comment">/* 32位设备上的魔数，大端模式(符合人类阅读习惯，高位数据在前) */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_CIGAM0xcefaedfe  <span class="comment">/* 32位、小端(高位地址在后)，CIGAM就是MAGIC反过来写，从命名上也可以看出端倪 */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_MAGIC_64 0xfeedfacf  <span class="comment">/* 64位、大端 */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_CIGAM_64 0xcffaedfe  <span class="comment">/* 64位、小端 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用二进制格式FAT。用途：包含多种架构支持的二进制格式，只在 macOS 上支持。(在文章末尾简单介绍一下，有兴趣可以瞜一眼)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC     0xcafebabe</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM     0xbebafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC) */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC_64  0xcafebabf</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM_64  0xbfbafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC_64) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//脚本格式。用途：主要用于 shell 脚本，但是也常用语其他解释器，如 Perl, AWK 等。也就是我们常见的脚本文件中在 `#!` 标记后的字符串，即为执行命令的指令方式，以文件的 stdin 来传递命令。</span></span><br><span class="line">  <span class="comment">// 魔数为 \x7FELF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filetype：常见的Mach-O格式的文件类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_OBJECT  0x1<span class="comment">/* 可重定位的目标文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_EXECUTE0x2<span class="comment">/* 可执行二进制文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DYLIB  0x6<span class="comment">/* 动态绑定共享库 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DYLINKER0x7<span class="comment">/* 动态链接编辑器，如dyld */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_BUNDLE  0x8<span class="comment">/* 动态绑定bundle(包)文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DSYM  0xa<span class="comment">/* 调试所用的符号文件 */</span></span></span><br></pre></td></tr></table></figure><p>举例：利用otool工具查看Mach-o文件的头部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ otool -hv bibi.decrypted </span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line">   MH_MAGIC     ARM         V7  0x00     EXECUTE    59       6016   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</span><br><span class="line"></span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line">MH_MAGIC_64   ARM64        ALL  0x00     EXECUTE    59       6744   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</span><br></pre></td></tr></table></figure><h3 id="3-3-Data"><a href="#3-3-Data" class="headerlink" title="3.3 Data"></a>3.3 Data</h3><p>数据区（Data）：Data 中每一个段（Segment）的数据都保存在此，段的概念和 ELF 文件中段的概念类似，都拥有一个或多个 Section ，用来存放数据和代码。</p><blockquote><p>Raw segment data存放了所有的原始数据，而Load commands相当于Raw segment data的索引目录</p></blockquote><h4 id="3-3-1-Segment-段"><a href="#3-3-1-Segment-段" class="headerlink" title="3.3.1 Segment(段)"></a>3.3.1 Segment(段)</h4><p>其中，LC_SEGMENT_64定义了一个64位的段，当文件加载后映射到地址空间(包括段里面节的定义)。64位段的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;          <span class="comment">/* Load Command类型，这里LC_SEGMENT_64代表将文件中64位的段映射到进程的地址空间。LC_SEGMENT_64和LC_SEGMENT的结构差别不大 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;      <span class="comment">/* 代表Load commands的大小 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];  <span class="comment">/* 16字节的段名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;       <span class="comment">/* 段映射到虚拟地址中的内存起始地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;       <span class="comment">/* 段映射到虚拟地址中的内存大小 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;      <span class="comment">/* 段在当前架构(MachO)文件中的偏移量，如果是胖二进制文件，也指的是相对于当前MachO文件的偏移 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;     <span class="comment">/* 段在文件中的大小 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   maxprot;      <span class="comment">/* 段页面的最高内存保护，用八进制表示(4=r(read)，2=w(write)，1=x(execute执行权限)) */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   initprot;     <span class="comment">/* 段页面最初始的内存保护 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;       <span class="comment">/* 段(segment)包含的区(section)的个数(如果存在的话) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 段页面标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>系统将 fileoff 偏移处 filesize 大小的内容加载到虚拟内存的 vmaddr 处，大小为vmsize，段页面的权限由initprot进行初始化。它的权限可以动态改变，但是不能超过maxprot的值，例如 _TEXT 初始化和最大权限都是可读/可执行/不可写。</strong></p><p>常见的<code>LC_SEGMENT</code> Segment (cmd为<code>LC_SEGMET</code>)，其<code>segname[16]</code>有以下几种值：</p><ul><li><strong>__PAGEZERO</strong>：空指针陷阱段，映射到虚拟内存空间的第1页，用于捕捉对 NULL 指针的引用。</li><li><strong>__TEXT</strong>：代码段/只读数据段。</li><li><strong>__DATA</strong>：读取和写入数据的段。</li><li><strong>__LINKEDIT</strong>：动态链接器需要使用的信息，包括符号表、重定位表、绑定信息、懒加载信息等。</li><li><strong>__OBJC</strong>：包含会被Objective Runtime使用到的一些数据。(从Macho文档上看，他包含了一些编译器私有的节。没有任何公开的资料描述)</li></ul><h4 id="3-3-2-Section-节"><a href="#3-3-2-Section-节" class="headerlink" title="3.3.2 Section(节)"></a>3.3.2 Section(节)</h4><p>从示例图中可以看到，部分的 Segment (<code>__TEXT</code> 和 <code>__DATA</code>) 可以进一步分解为 Section。</p><p>之所以按照 Segment(段) -&gt; Section(节) 的结构组织方式，是因为在同一个 Segment 下的 Section，在内存中的权限相同(编译时，编译器把相同权限的section放在一起，成为segment)，可以不完全按照 Page 的大小进行内存对齐，节省内存的空间。而 Segment 对外整体暴露，在装载程序时，完整映射成一个vma(Virtual Memory Address)，更好的做到内存对齐，减少内存碎片（可以参考《OS X &amp; iOS Kernel Programming》第一章内容）。</p><p>Section 具体的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];   <span class="comment">/* Section 的名字 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* Section 所在的 Segment 名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;           <span class="comment">/* Section 映射到虚拟地址的偏移（所在的内存地址） */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;           <span class="comment">/* Section 的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;         <span class="comment">/* Section 在当前架构文件中的偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;          <span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;         <span class="comment">/* 重定位入口的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;         <span class="comment">/* 重定位入口的数目 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;          <span class="comment">/* Section标志属性 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;      <span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;      <span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;      <span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合示例图，下面列举一些常见(并非全部)的 Section：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __TEXT Segment(段)下面的节：</span></span><br><span class="line">  __text              <span class="comment">// 程序可执行的代码区域</span></span><br><span class="line">  __stubs             <span class="comment">// 间接符号存根。本质上是一小段代码，跳转到懒加载/延迟绑定(lazybinding)指针表(即__DATA.la_symbol_ptr)。找到对应项指针指向的地址。</span></span><br><span class="line">  __sub_helper        <span class="comment">// 辅助函数。帮助解决懒加载符号加载，上述提到的lazybinding的表(__DATA.la_symbol_ptr)中对应项的指针在没有找到真正的符号地址的时候，都指向这。</span></span><br><span class="line">  __objc_methname     <span class="comment">// 方法名</span></span><br><span class="line">  __objc_classname    <span class="comment">// 类名</span></span><br><span class="line">  __objc_methtype     <span class="comment">// 方法签名</span></span><br><span class="line">  __cstring           <span class="comment">// 去重后的只读的C风格字符串，包含OC的部分字符串和属性名</span></span><br><span class="line">  __const             <span class="comment">// 初始化过的常量</span></span><br><span class="line">  __unwind_info       <span class="comment">// 用户存储处理异常情况信息</span></span><br><span class="line">  __eh_frame          <span class="comment">// 调试辅助信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __DATA Segment(段)下面的节：</span></span><br><span class="line">  __data              <span class="comment">// 初始化过的可变的数据</span></span><br><span class="line">  __const             <span class="comment">// 没有初始化过的常量</span></span><br><span class="line">  __bss               <span class="comment">// 没有初始化的静态变量</span></span><br><span class="line">  __common            <span class="comment">// 没有初始化过的符号声明</span></span><br><span class="line">  __nl_symbol_ptr     <span class="comment">// 非延迟导入/非懒加载(lazy-binding)符号指针表，每个表项中的指针都指向一个在dyld加载过程中，搜索完成的符号。即在dyld加载时会立即绑定值。</span></span><br><span class="line">  __la_symbol_ptr     <span class="comment">// 延迟导入/懒加载(lazy-binding)符号指针表，每个表项中的指针一开始指向stub_helper。在第 1 次调用时才会绑定值。</span></span><br><span class="line">  __got               <span class="comment">// 非懒加载全局指针表</span></span><br><span class="line">  __mod_init_func     <span class="comment">// 初始化/constructor(构造)函数</span></span><br><span class="line">  __mod_term_func     <span class="comment">// destructor(析构)函数</span></span><br><span class="line">  __cfstring          <span class="comment">// OC字符串</span></span><br><span class="line">  __objc_classlist    <span class="comment">// 程序中的类列表</span></span><br><span class="line">  __objc_nlclslist    <span class="comment">// 程序中自己实现了+load方法的类</span></span><br><span class="line">  __objc_protolist    <span class="comment">// 协议的列表</span></span><br><span class="line">  __objc_classrefs    <span class="comment">// 被引用的类列表</span></span><br><span class="line">  __objc_ivar         <span class="comment">// 成员变量</span></span><br></pre></td></tr></table></figure><h3 id="3-4-stubs-与-stub-helper"><a href="#3-4-stubs-与-stub-helper" class="headerlink" title="3.4 __stubs 与 __stub_helper"></a>3.4 <code>__stubs</code> 与 <code>__stub_helper</code></h3><blockquote><p>用来实现 LazyBind 的两个section：<code>__TEXT.__stubs</code>、<code>__TEXT.__stub_helper</code></p></blockquote><p>在 wikipedia 有一个关于 <a href="https://en.wikipedia.org/wiki/Method_stub">Method stub</a> 的词条，大意就是：Stub 是指用来替换一部分功能的程序段。桩程序可以用来模拟已有程序的行为（比如一个远端机器的过程）或是对将要开发的代码的一种临时替代。</p><p>总结来说：</p><ul><li>stub就是一段代码，功能为：跳转到 <code>__DATA.__la_symbol_ptr</code>( <code>__DATA</code> Segment 中的 <code>__la_symbol_ptr</code> Section) 对应表项的数据，所指向的地址。</li><li><code>__la_symbol_ptr</code> 里面的所有表项的数据在初始时都会被 binding 成 <code>__stub_helper</code>。</li><li>当懒加载符号第一次使用到的时候，按照上面的结构，会跳转到<code>__stub_helper</code>这个section的代码，然后代码中会调用<code>dyld_stub_binder</code>来执行真正的bind。 bind结束后，就将<code>__la_symbol_ptr</code>中该懒加载符号 原本对应的指向<code>__stub_helper</code>的地址 修改为 符号的真实地址。</li><li>之后的调用中，虽然依旧会跳到 <code>__stub</code> 区域，但是 <code>__la_symbol_ptr</code>表由于在之前的调用中获取到了符号的真实地址而已经修正完成，所以无需在进入 <code>dyld_stub_binder</code> 阶段，可以直接使用符号。</li></ul><p>这样就完成了LazyBind的过程。Stub 机制 其实和 <code>wikipedia</code> 上的说法一致，设置一个桩函数(模拟、占位函数)并采用 <strong>lazy</strong> 思想做成延迟 binding 的流程。</p><p>在《深入解析 Mac OS X &amp; iOS操作系统》中有详细的验证，也可以参考<a href="http://satanwoo.github.io/2017/06/13/Macho-1/">深入剖析Macho (1)</a> 自己动手验证一下。</p><h3 id="3-5-Load-Command"><a href="#3-5-Load-Command" class="headerlink" title="3.5 Load Command"></a>3.5 Load Command</h3><p>Mach-O文件头中包含了非常详细的指令，这些指令在被调用时清晰地指导了如何设置并加载二进制数据。这些指令，或称为“加载命令”，紧跟在基本的mach_header之后。</p><p>每一条命令，在<code>load.c</code>文件中，都有对应的结构体，来记录信息。共同点是都采用“<code>类型-长度-值</code>”的格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_command</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>cmd;       <span class="comment">/* 32位的cmd值(表示类型) ，下面列举了部分 */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>cmdsize;   <span class="comment">/* 32位的cmdsize值(32位二进制为4的倍数，64位二进制为8的倍数) */</span></span><br><span class="line">  ...                      <span class="comment">/* 记录命令本身的一些信息 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面列举一些load command的类型(对应的cmd值)，这里只列举了部分，全面的可以看源码，总共50多种load command。按照加载命令是由内核加载器、动态链接器处理分开记录。</span></span><br><span class="line"><span class="comment">// 内核加载器处理的加载命令：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SEGMENT                0x1  <span class="comment">/* 定义一个段(Segment)，加载后被映射到内存中，包括里面的节(Section) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_LOAD_DYLINKER          0xe  <span class="comment">/* 默认的加载器路径。通常路径是“/usr/lib/dyld” */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_UUID                   0x1b   <span class="comment">/* 用于标识Mach-0文件的ID，匹配二进制文件与符号表。在分析崩溃堆栈信息能用到，通过地址在符号表中找到符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_CODE_SIGNATURE         0x1d  <span class="comment">/* 代码签名信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_ENCRYPTION_INFO_64     0x2C   <span class="comment">/* 文件是否加密的标志，加密内容的偏移和大小 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态链接器处理的加载命令：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SYMTAB                 0x2  <span class="comment">/* 为文件定义符号表和字符串表，在链接文件时被链接器使用，同时也用于调试器映射符号到源文件。符号表定义的本地符号仅用于调试，而已定义和未定义的 external 符号被链接器使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DYSYMTAB               0xb  <span class="comment">/* 将符号表中给出符号的额外符号信息提供给动态链接器。 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_ID_DYLIB               0xd  <span class="comment">/* 依赖的动态库，包括动态库名称、当前版本号、兼容版本号。可以使用“otool-L xxx”命令查看 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_RPATH                 (0x1c | LC_REQ_DYLD)    <span class="comment">/* RunpathSearchPaths，@rpath搜索的路径 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_DYLD_INFO              0x22  <span class="comment">/* compressed dyld information */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DYLD_INFO_ONLY        (0x22 | LC_REQ_DYLD)  <span class="comment">/* 记录了有关链接的重要信息，包括在__LINKEDIT中动态链接相关信息的具体偏移和大小。ONLY表示这个加载指令是程序运行所必需的，如果旧的链接器无法识别它，程序就会出错 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_VERSION_MIN_IPHONEOS   0x25   <span class="comment">/* 系统要求的最低版本 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_FUNCTION_STARTS        0x26   <span class="comment">/* 函数起始地址表，使调试器和其他程序能很容易地看到一个地址是否在函数内 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_MAIN                  (0x28 | LC_REQ_DYLD)    <span class="comment">/* 程序的入口。dyld获取该地址，然后跳转到该处执行。replacement for LC_UNIXTHREAD */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DATA_IN_CODE           0x29   <span class="comment">/* 定义在代码段内的非指令的表   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SOURCE_VERSION         0x2A   <span class="comment">/* 构建二进制文件的源代码版本号 */</span></span></span><br></pre></td></tr></table></figure><p>有一些命令是由<code>内核加载器</code>(定义在<code>bsd/kern/mach_loader.c</code>文件中) 直接使用的， 其他命令是由<code>动态链接器</code>处理的。</p><img src="/images/compilelink/14.png" alt="12" style="zoom:70%;" /><img src="/images/compilelink/15.png" alt="12" style="zoom:70%;" /><p>在Mach-O文件加载解析时，多个Load Command会告诉操作系统应当如何加载文件中每个Segment的数据，对系统内核加载器和动态链接器起引导作用。(不同的数据对应不同的加载命令，可以看到<code>segment_command_64</code>、<code>symtab_command</code>、<code>dylib_command</code>等，下面我们会讲解Segment的加载命令，下一节讲静态链接时，会涉及符号表symtab的加载命令)。</p><p>下面，以三个内核加载器负责解析处理的load command，来简单看下：</p><h4 id="3-5-1-LC-CODE-SIGNATURE-数字签名"><a href="#3-5-1-LC-CODE-SIGNATURE-数字签名" class="headerlink" title="3.5.1 LC_CODE_SIGNATURE(数字签名)"></a>3.5.1 LC_CODE_SIGNATURE(数字签名)</h4><p>Mach-O二进制文件有一个重要特性就是可以进行数字签名。尽管在 OS X 中仍然没怎么使用数字签名，不过由于代码签名和新改进的沙盒机制绑定在一起，所以签名的使用率也越来越高。在 iOS 中，代码签名是强制要求的，这也是苹果尽可能对系统封锁的另一种尝试：在 iOS 中只有苹果自己的签名才会被认可。在 OS X 中，code sign(1) 工具可以用于操纵和显示代码签名。man手册页，以及 Apple’s code signing guide 和 Mac OS X Code Signing In Depth文档都从系统管理员的角度详细解释了代码签名机制。</p><p><code>LC_CODE_SIGNATURE</code> 包含了 Mach-O 二进制文件的代码签名，如果这个签名和代码本身不匹配(或者如果在iOS上这条命令不存在)，那么内核会立即给进程发送一个SIGKILL信号将进程杀掉，没有商量的余地，毫不留情。</p><p>在iOS 4之前，还可以通过两条sysctl(8)命令覆盖负责强制执行(利用内核的MAC，即Mandatory AccessControl)的内核变量，从而实现禁用代码签名检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w security.mac.proc_enforce &#x3D; 0 &#x2F;&#x2F;禁用进程的MAC</span><br><span class="line">sysctl -w security.mac.vnode_enforce&#x3D;0 &#x2F;&#x2F;禁用VNode的MAC</span><br></pre></td></tr></table></figure><p>而在之后版本的iOS中，苹果意识到只要能够获得root权限，越狱者就可以覆盖内核变量。因此这些变量变成了只读变量。untethered越狱(即完美越狱)因为利用了一个内核漏洞所以可以修改这些变量。由于这些变量的默认值都是启用签名检查，所以不完美越狱会导致非苹果签名的应用程序崩溃——除非i设备以完美越狱的方式引导。</p><p>此外，通过 Saurik 的 ldid 这类工具可以在 Mach-O 中嵌入伪代码签名。这个工具可以替代OS X的code sign(1)，允许生成自我签署认证的伪签名。这在iOS中尤为重要，因为签名和沙盒模型的应用程序“entitlement”绑定在一起， 而后者在iOS中是强制要求的。entitlement 是声明式的许可(以plist的形式保存)，必须内嵌在Mach-O中并且通过签名盖章，从而允许执行安全敏感的操作时具有运行时权限。</p><p>OS X 和 iOS 都有一个特殊的系统调用csops(#169)用于代码签名的操作</p><h4 id="3-5-2-LC-SEGMENT-进程虚拟内存设置"><a href="#3-5-2-LC-SEGMENT-进程虚拟内存设置" class="headerlink" title="3.5.2 LC_SEGMENT(进程虚拟内存设置)"></a>3.5.2 LC_SEGMENT(进程虚拟内存设置)</h4><p>LC_SEGMENT(或LC_SEGMENT_64) 命令是最主要的加载命令，这条命令指导内核如何设置新运行的进程的内存空间。这些“段”直接从Mach-O二进制文件加载到内存中。</p><p>每一条LC_SEGMENT[64] 命令都提供了段布局的所有必要细节信息。见上文的数据结构成员变量。</p><p>有了LC_SEGMENT命令，设置进程虚拟内存的过程就变成遵循LC_SEGMENT命令的简单操作。对于每一个段，将文件中相应的内容加载到内存中：<strong>从偏移量为 fileoff 处加载 filesize 字节到虚拟内存地址 vmaddr 处的 vmsize 字节</strong>。每一个段的页面都根据 initprot 进行初始化，initprot 指定了如何通过读/写/执行位初始化页面的保护级别。段的保护设置可以动态改变，但是不能超过 maxprot 中指定的值(在iOS中，+x和+w是互斥的)。</p><h4 id="3-5-3-LC-MAIN-设置主线程入口地址"><a href="#3-5-3-LC-MAIN-设置主线程入口地址" class="headerlink" title="3.5.3 LC_MAIN(设置主线程入口地址)"></a>3.5.3 LC_MAIN(设置主线程入口地址)</h4><p>从Mountain Lion开始，一条新的加载命令<code>LC_MAIN</code>替代了<code>LC_UNIX_THREAD</code>命令。</p><ul><li>后者的作用是：开启一个unix线程，初始化栈和寄存器，通常情况下，除了指令指针(Intel的IP)或程序计数器(ARM的r15)之外，所有的寄存器值都为0。</li><li>前者作用是<strong>设置程序主线程的入口点地址和栈大小</strong>。</li></ul><p>这条命令比LC_UNIXTHREAD命令更实用一些， 因为无论如何除了程序计数器之外所有的寄存器都设置为0了。由于没有LC_UNIXTHREAD命令， 所以不可以在之前版本的 OS X 上运行使用了LC_MAIN的二进制文件(在加载时会导致dyld(1)崩溃)。</p><img src="/images/compilelink/16.png" alt="12" style="zoom:90%;" /><p>LC_Main对应的加载命令如下，记录了可执行文件的入口函数<code>int main(int argc, char * argv[])</code>的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry_point_command</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>  cmd;        <span class="comment">/* LC_MAIN only used in MH_EXECUTE filetypes */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>  cmdsize;    <span class="comment">/* 24 */</span></span><br><span class="line">  <span class="keyword">uint64_t</span>  entryoff;   <span class="comment">/* file (__TEXT) offset of main() */</span></span><br><span class="line">  <span class="keyword">uint64_t</span>  stacksize;  <span class="comment">/* if not zero, initial stack size */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从定义上可以看到入口函数的地址计算：<code>Entry Point = vm_addr(__TEXT) + entryOff + Slide</code></p><p>从<a href="https://opensource.apple.com/source/dyld/">dyld的源码</a>里能看到对Entry Point的获取和调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dyld</span><br><span class="line">  ▼ __dyld_start  <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::start()   <span class="comment">// dyldInitialization.cpp</span></span><br><span class="line">      ▼ dyld::_main()</span><br><span class="line">        ▼ <span class="comment">//函数的最后，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> dyldbootstrap &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line">    <span class="comment">// sets up some registers and call this function.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">uintptr_t</span></span><br><span class="line">    _main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">            <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">            <span class="keyword">uintptr_t</span>* startGlue) &#123;</span><br><span class="line">        <span class="comment">// find entry point for main executable</span></span><br><span class="line">        result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;getEntryFromLC_MAIN();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单看一下这几种load command所表示的信息。关于进程地址空间分布、线程入口在第四节 —— 装载会从进程启动到运行详细梳理一下流程。</p><h2 id="四、通用二进制格式（Universal-Binary）"><a href="#四、通用二进制格式（Universal-Binary）" class="headerlink" title="四、通用二进制格式（Universal Binary）"></a>四、通用二进制格式（Universal Binary）</h2><p>通常也被称为<code>胖二进制格式（Fat Binary）</code>，Apple 提出这个概念是为了解决一些历史原因，macOS（更确切的应该说是 OS X）最早是构建于 PPC 架构智商，后来才移植到 Intel 架构（从 Mac OS X Tiger 10.4.7 开始），通用二进制格式的二进制文件可以在 PPC 和 x86 两种处理器上执行。</p><p>说到底，通用二进制格式只不过是对多架构的二进制文件的打包集合文件，而 macOS 中的多架构二进制文件也就是适配不同架构的 Mach-O 文件。即一个通用二进制格式包含了很多个 Mach-O 格式文件。它有以下特点：</p><ul><li>因为需要存储多种架构的代码，所以通用二进制文件要比单架构二进制文件要大</li><li>因为两种种架构之间可以共用一些资源，所以两种架构的通用二进制文件大小不会达到单一架构版本的两倍。</li><li>运行过程中只会调用其中的部分代码，所以运行起来不会占用额外的内存</li></ul><p><strong>Fat Header</strong> 的数据结构在 <code>&lt;mach-o/fat.h&gt;</code> 头文件中有定义，可以参看 <code>/usr/include/mach-o/fat.h</code> 找到定义头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC    0xcafebabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM    0xbebafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    magic;           <span class="comment">/* FAT_MAGIC 或 FAT_MAGIC_64 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nfat_arch;       <span class="comment">/* 结构体实例的个数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_arch</span> &#123;</span></span><br><span class="line">    <span class="keyword">cpu_type_t</span>     cputype;      <span class="comment">/* cpu 说明符 (int) */</span></span><br><span class="line">    <span class="keyword">cpu_subtype_t</span>  cpusubtype;   <span class="comment">/* 指定 cpu 确切型号的整数 (int) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       offset;       <span class="comment">/* CPU 架构数据相对于当前文件开头的偏移值 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       size;         <span class="comment">/* 数据大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       align;        <span class="comment">/* 数据内润对其边界，取值为 2 的幂 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>cputype</code> 和 <code>cpusubtype</code> 两个字段这里不讲述，可以参看 <code>/usr/include/mach/machine.h</code> 头中对其的定义，另外 <a href="https://developer.apple.com/documentation/kernel/mach_header?language=objc">Apple 官方文档</a>中也有简单的描述。</p><p>在 <code>fat_header</code> 中，<code>magic</code> 也就是我们之前在表中罗列的 <em>magic</em> 标识符，也可以类比成 UNIX 中 ELF 文件的 <em>magic</em> 标识。加载器会通过这个符号来判断这是什么文件，通用二进制的 <em>magic</em> 为 <code>0xcafebabe</code>。<code>nfat_arch</code> 字段指明当前的通用二进制文件中包含了多少个不同架构的 Mach-O 文件。<code>fat_header</code> 后会跟着多个 <code>fat_arch</code>，并与多个 Mach-O 文件及其描述信息（文件大小、CPU 架构、CPU 型号、内存对齐方式）相关联。</p><p>这里可以通过 <code>file</code> 命令来查看简要的架构信息，这里以 iOS 平台 WeChat 4.5.1 版本为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ file Desktop/WeChat.app/WeChat</span><br><span class="line">Desktop/WeChat.app/WeChat: Mach-O universal binary with 2 architectures: [arm_v7: Mach-O executable arm_v7] [arm64]</span><br><span class="line">Desktop/WeChat.app/WeChat (<span class="keyword">for</span> architecture armv7):    Mach-O executable arm_v7</span><br><span class="line">Desktop/WeChat.app/WeChat (<span class="keyword">for</span> architecture arm64):    Mach-O 64-bit executable arm64</span><br></pre></td></tr></table></figure><p>进一步，也可以使用 <code>otool</code> 工具来打印其 <code>fat_header</code> 详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">~ otool -f -V Desktop/WeChat.app/WeChat</span><br><span class="line">Fat headers</span><br><span class="line">fat_magic FAT_MAGIC</span><br><span class="line">nfat_arch 2</span><br><span class="line">architecture armv7</span><br><span class="line">    cputype CPU_TYPE_ARM</span><br><span class="line">    cpusubtype CPU_SUBTYPE_ARM_V7</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 16384</span><br><span class="line">    size 56450224</span><br><span class="line">    align 2^14 (16384)</span><br><span class="line">architecture arm64</span><br><span class="line">    cputype CPU_TYPE_ARM64</span><br><span class="line">    cpusubtype CPU_SUBTYPE_ARM64_ALL</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 56475648</span><br><span class="line">    size 64571648</span><br><span class="line">    align 2^14 (16384)</span><br></pre></td></tr></table></figure><p>之后我们用 <em>Synalyze It!</em> 来查看 WeChat 的 Mach64 Header 的效果：</p><img src="/images/compilelink/17.jpg" alt="12" style="zoom:80%;" /><ul><li>  从第一个段中得到 <code>magic = 0xcafebabe</code> ，说明是 <code>FAT_MAGIC</code>。</li><li>  第二段中所存储的字段为 <code>nfat_arch = 0x00000002</code>，说明该 App 中包含了两种 CPU 架构。</li><li>  后续的则是 <code>fat_arch</code> 结构体中的内容，<code>cputype(0x0000000c)</code>、<code>cpusubtype(0x00000009)</code>、<code>offset(0x00004000)</code>、<code>size(0x03505C00)</code> 等等。如果只含有一种 CPU 架构，是没有 fat 头定义的，这部分则可跳过，从而直接过去 <code>arch</code> 数据。</li></ul><blockquote><p><strong>注意，在mach-o中，数据结构中的地址表示：如果是value、address等，那一般是绝对地址；如果是偏移量offset等，一般都是相对于目标文件/可执行文件（注意，尤其是后者，起始地址不会是0，寻址时要加上起始地址）。</strong></p></blockquote><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="https://juejin.im/post/6844903959618912263#heading-10">iOS逆向学习之四（初识Mach-O）</a></li><li><a href="https://www.desgard.com/iOS-Source-Probe/C/mach-o/Mach-O%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%8E%A2%E7%B4%A2.html">Mach-O 文件格式探索</a></li><li><a href="">《iOS应用逆向与安全》— 刘培庆</a></li><li><a href="http://satanwoo.github.io/2017/06/13/Macho-1/">深入剖析Macho(1)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇说到源码经过预处理、编译、汇编之后生成目标文件，这一章介绍一下iOS、Mac OS中目标文件的格式&lt;code&gt;Mach-O的结构&lt;/code&gt;，方便了解之后的&lt;code&gt;链接&lt;/code&gt;生成可执行文件的过程。&lt;/p&gt;
&lt;p&gt;先附上相关源码地址：与Mach-O 文件格</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(一) Clang/LLVM 介绍、OC 程序的编译过程</title>
    <link href="https://tenloy.github.io/2021/09/22/compile-clang-llvm.html"/>
    <id>https://tenloy.github.io/2021/09/22/compile-clang-llvm.html</id>
    <published>2021-09-22T14:25:45.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、编译、链接工具-—-Clang-LLVM"><a href="#一、编译、链接工具-—-Clang-LLVM" class="headerlink" title="一、编译、链接工具 — Clang/LLVM"></a>一、编译、链接工具 — Clang/LLVM</h2><blockquote><p><a href="https://llvm.org/">官网定义：</a></p><ul><li>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies(LLVM项目是一系列分模块、可重用的编译<strong>工具链</strong>). Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.</li><li>Clang is an “LLVM native” C/C++/Objective-C compiler. </li></ul></blockquote><h3 id="1-1-LLVM的诞生"><a href="#1-1-LLVM的诞生" class="headerlink" title="1.1 LLVM的诞生"></a>1.1 LLVM的诞生</h3><p>2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的克里斯·拉特纳(Chris Lattner，twitter为 <a href="https://twitter.com/clattner_llvm">clattner_llvm</a>） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。</p><p>2005年，由于GCC 对于 Objective-C 的支持比较差，效率和性能都没有办法达到苹果公司的要求，而且它还难以推动 GCC 团队。于是，苹果公司决定自己来掌握编译相关的工具链，于是将Chris Lattner招入麾下，发起了 Clang 软件项目。</p><ul><li>Clang 作为 LLVM 编译器工具集的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言。Clang支持C、C++、Objective C。</li><li>测试证明Clang编译Objective-C代码时速度为GCC的3倍，还能针对用户发生的编译错误准确地给出建议。</li><li>此后，苹果使用的 GCC 全面替换成了 LLVM。</li></ul><p>2010年，Chris Lattner开始主导开发 Swift 语言。这也使得 Swift 这门集各种高级语言特性的语言，能够在非常高的起点上，出现在开发者面前。</p><p>2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。</p><h3 id="1-2-LLVM及其子项目"><a href="#1-2-LLVM及其子项目" class="headerlink" title="1.2 LLVM及其子项目"></a>1.2 LLVM及其子项目</h3><h4 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h4><p>llvm特点：</p><ul><li>模块化</li><li>统一的中间代码IR，而前端、后端可以不一样。而GCC的前端、后端耦合在了一起，所以支持一门新语言或者新的平台，非常困难。</li><li>功能强大的Pass系统，根据依赖性自动对Pass（包括分析、转换和代码生成Pass）进行排序，管道化以提高效率。</li></ul><p>llvm有广义和狭义两种定义：</p><ul><li>在广义中，llvm特指一整个编译器框架，<strong>是一个模块化和可重用的编译器和工具链技术的集合</strong>，由前端、优化器、后端组成，clang只是用于c/c++的一种前端，llvm针对不同的语言可以设计不同的前端，同样的针对不同的平台架构（amd，arm，misp），也会有不同后端设计</li><li>在狭义中 ，特指llvm后端，指优化器（pass）对IR进行一系列优化直到目标代码生成的过程</li></ul><p>简单罗列LLVM几个主要的子项目，详见<a href="https://llvm.org/">官网</a>：</p><ul><li><p>LLVM Core libraries：LLVM核心库提供了一个独立于源和目标架构的现代<a href="https://llvm.org/docs/Passes.html">优化器optimizer</a>，以及对许多流行cpu(以及一些不太常见的cpu)的<a href="https://llvm.org/docs/CodeGenerator.html">代码生成(code generation)</a>支持。这些库是围绕一种被称为LLVM中间表示(“LLVM IR”)的良好指定的代码表示构建的。</p></li><li><p>Clang：一个 C/C++/Objective-C 编译器，提供高效快速的编译效率，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。(见下文详述)</p></li><li><p>lld： 是LLVM开发一个内置的，平台独立的链接器，去除对所有第三方链接器的依赖。在2017年5月，lld已经支持ELF、PE/COFF、和Mach-O。在lld支持不完全的情况下，用户可以使用其他项目，如 GNU ld 链接器。<br>lld支持链接时优化。当LLVM链接时优化被启用时，LLVM可以输出bitcode而不是本机代码，而本机代码生成由链接器优化处理。</p></li><li><p>LLDB：基于 LLVM 和 Clang提供的库构建的一个优秀的本地调试器，使用了 Clang ASTs、表达式解析器、LLVM JIT、LLVM 反汇编器等。</p></li></ul><h4 id="1-2-2-Clang"><a href="#1-2-2-Clang" class="headerlink" title="1.2.2 Clang"></a>1.2.2 Clang</h4><p>从<a href="http://llvm.org/svn/llvm-project/cfe/trunk/lib/">Clang的源码</a>目录中可以大致看出Clang提供的功能：</p><img src="/images/compilelink/01.png" alt="01" style="zoom:80%;" /><h5 id="1-Clang提供了哪些功能？"><a href="#1-Clang提供了哪些功能？" class="headerlink" title="1. Clang提供了哪些功能？"></a>1. Clang提供了哪些功能？</h5><p>Clang 为一些需要分析代码语法、语义信息的工具提供了基础设施。分别是：</p><ul><li><p><strong>LibClang</strong>。LibClang提供了一个稳定的高级 C 接口，Xcode 使用的就是 LibClang。LibClang 可以访问 Clang 的上层高级抽象的能力，比如获取所有 Token、遍历语法树、代码补全等。由于 API 很稳定，Clang 版本更新对其 影响不大。但是，LibClang 并不能完全访问到 Clang AST 信息。</p></li><li><p><strong>Clang Plugins</strong>。可以在 AST 上做些操作，这些操作能够集成到编译中，成为编译的一部分。插件是在运 行时由编译器加载的动态库，方便集成到构建系统中。<br>使用 Clang Plugins 一般都是希望能够完全控制 Clang AST，同时能够集成在编译流程中，可以影响编译的过程，进行中断或者提示。<br>应用：实现命名规范、代码规范等一些扩展功能</p></li><li><p><strong>LibTooling</strong>。是一个 C++ 接口，所写的工具不依赖于构建系统，可以作为一个命令单独使用。与 Clang Plugins 相比，LibTooling 无法影响编译过程；与 LibClang 相比，LibTooling 的接口没有那么稳定。<br>应用：做代码转换，比如把 OC 转 JavaScript 或 Swift；代码检查。</p></li></ul><h5 id="2-Clang的优点"><a href="#2-Clang的优点" class="headerlink" title="2. Clang的优点"></a>2. Clang的优点</h5><p>Clang 是 C、C++、Objective-C 的编译前端，而 Swift 有自己的编译前端 （也就是 Swift 前端多出的 SIL optimizer）。Clang 有哪些优势？</p><ul><li>对于使用者来说，Clang 编译的速度非常快，对内存的使用率非常低，并且兼容 GCC。</li><li>对于代码诊断来说， Clang 也非常强大，Xcode 也是用的 Clang。使用 Clang 编译前端，可以精确地显示出问题所在的行和具体位置，并且可以确切地说明出现这个问题的原因，并指出错误的类型是什么，使得我们可以快速掌握问题的细节。这样的话，我们不用看源码，仅通过 Clang 突出标注的问题范围也能够了解到问题的情况。</li><li>Clang 对 typedef 的保留和展开也处理得非常好。typedef 可以缩写很长的类型，保留 typedef 对于粗粒度诊断分析很有帮助。但有时候，我们还需要了解细节，对 typedef 进行展开即可。</li><li>Fix-it 提示也是 Clang 提供的一种快捷修复源码问题的方式。在宏的处理上，很多宏都是深度嵌套的， Clang 会自动打印实例化信息和嵌套范围信息来帮助你进行宏的诊断和分析。</li><li>Clang 的架构是模块化的。除了代码静态分析外，利用其输出的接口还可以开发用于代码转义、代码生成、代码重构的工具，方便与 IDE 进行集成。</li></ul><p>Clang 是基于 C++ 开发的，如果你想要了解 Clang 的话，需要有一定的 C++ 基础。但是，Clang 源码本身质量非常高，有很多值得学习的地方，比如说目录清晰、功能解耦做得很好、分类清晰方便组合和复用、代码风格统一而且规范、注释量大便于阅读等。</p><h3 id="1-3-Clang-LLVM架构"><a href="#1-3-Clang-LLVM架构" class="headerlink" title="1.3 Clang-LLVM架构"></a>1.3 Clang-LLVM架构</h3><p>Clang-LLVM架构，即用Clang作为前端的LLVM(编译工具集)。</p><p>Clang-LLVM下，一个源文件的编译过程：</p><img src="/images/compilelink/02.png" alt="01" style="zoom:65%;" /><p>iOS 开发完整的编译流程图：</p><img src="/images/compilelink/03.png" alt="01" style="zoom:80%;" /><p>LLVM架构的主要组成部分：</p><ul><li><p><strong>前端</strong>：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang(Clang-LLVM)。<br>LLVM支持三种表达形式：人类可读的汇编(<code>.ll</code>后缀，是LLVM IR文件，其有自己的语法)、在C++中对象形式、序列化后的bitcode形式(<code>.bc</code>后缀)。</p></li><li><p><strong>Pass</strong>(v.通过/传递/变化 n.经过/通行证/<strong>通道</strong>/<strong>流程</strong>/<strong>阶段</strong>) ：是 LLVM 优化(optimize)工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。<br>Pass用来将程序的中间表示之间相互变换。一般情况下，Pass可以用来优化代码，这部分通常是我们关注的部分。我们可以自己编写Pass，做一些代码混淆优化等操作。</p></li><li><p><strong>后端</strong>：后端用来生成实际的机器码。至3.4版本的LLVM已经支持多种后端指令集，比如主流的x86、x86-64、z/Architecture、ARM和PowerPC等</p></li></ul><p>虽然如今大多数编译器都采用的是这种架构，但是LLVM不同的就是对于不同的语言它都提供了同一种中间表示。传统的编译器的架构如下:</p><img src="/images/compilelink/04.png" alt="01" style="zoom:100%;" /><p>LLVM的架构如下：</p><img src="/images/compilelink/05.png" alt="01" style="zoom:75%;" /><p>当编译器需要支持多种源代码和目标架构时，基于LLVM的架构，设计一门新的语言只需要去实现一个新的前端就行了，支持新的后端架构也只需要实现一个新的后端，其它部分完成可以复用，不用重新设计。在基于LLVM进行代码混淆时，只需要关注中间层代码(IR)表示。</p><h3 id="1-4-应用"><a href="#1-4-应用" class="headerlink" title="1.4 应用"></a>1.4 应用</h3><ul><li>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。</li><li>swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。</li><li>Gallium3D 中使用 LLVM 进行 JIT 优化</li><li>Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度</li><li>LLVM-Lua 用LLVM 来编译 lua 代码</li><li>gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。</li></ul><p>下面，通过具体的代码、命令，来看一下iOS中源代码详细的编译、链接过程</p><h2 id="二、编译、静态链接过程"><a href="#二、编译、静态链接过程" class="headerlink" title="二、编译、静态链接过程"></a>二、编译、静态链接过程</h2><blockquote><p>从源码到可执行文件 — iOS应用编译、静态链接过程</p></blockquote><p>我们在开发的时候的时候，如果想要生成一个可执行文件或应用，我们点击run就完事了，那么在点击run之后编译器背后又做了哪些事情呢？</p><p>我们先来一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINEEight 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eight = DEFINEEight;</span><br><span class="line">    <span class="keyword">int</span> six = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> rank = eight + six;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rank);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个文件，我们可以通过命令行直接编译，然后链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch armv7 -F Foundation -fobjc-arc -c main.m -o main.o</span><br><span class="line">xcrun -sdk iphoneos clang main.o -arch armv7 -fobjc-arc -framework Foundation -o main</span><br></pre></td></tr></table></figure><p>然后将该可执行文件copy到手机目录 /usr/bin 下面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xx-iPhone:/usr/bin root<span class="comment"># ./main</span></span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>下面深入剖析其中的过程。</p><h3 id="Clang常用命令与参数"><a href="#Clang常用命令与参数" class="headerlink" title="Clang常用命令与参数"></a>Clang常用命令与参数</h3><p><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">参考链接</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看编译的步骤</span></span><br><span class="line">clang -ccc-print-phases main.m</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rewrite Objective-C source to C++，将OC源代码重写为C++(仅供参考，与真正的运行时代码还是有细微差别的)</span></span><br><span class="line"><span class="comment">// 如果想了解真正的代码，可以使用-emit-llvm参数查看.ll中间代码</span></span><br><span class="line">clang -rewrite-objc main.m</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看操作内部命令</span></span><br><span class="line">clang -##<span class="meta"># main.m -o main</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接生成可执行文件</span></span><br><span class="line">clang main.m <span class="comment">// 默认生成的文件名为a.out</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">    -cc1：Clang编译器前端具有几个额外的Clang特定功能，这些功能不通过GCC兼容性驱动程序接口公开。 -cc1参数表示将使用编译器前端，而不是驱动程序。 clang -cc1功能实现了核心编译器功能。</span></span><br><span class="line"><span class="comment">-E：只进行预编译处理(preprocessor)</span></span><br><span class="line"><span class="comment">-S：只进行预编译、编译工作</span></span><br><span class="line"><span class="comment">-c：只进行预处理、编译、汇编工作</span></span><br><span class="line"><span class="comment">-fmodules：允许modules的语言特性。</span></span><br><span class="line"><span class="comment">在使用#include、#import时，会看到预处理时已经把宏替换了，并且导入了头文件。但是这样的话会引入很多不会去改变的系统库比如Foundation。</span></span><br><span class="line"><span class="comment">所以有了pch预处理文件，可以在这里去引入一些通用的头文件。</span></span><br><span class="line"><span class="comment">后来Xcode新建的项目里面去掉了pch文件，引入了moduels的概念，把一些通用的库打成modules的形式，然后导入。现在Xcode中默认是打开的，即编译源码时会加上-fmodules参数。也是因为modules机制的出现，pch不再默认自动创建。</span></span><br><span class="line"><span class="comment">使用了该参数，在导入库的地方，只需要 @import Foundation; 就行</span></span><br><span class="line"><span class="comment">可以看到使用了@import之后，clang -fmodules xx 生成的文件中，不再有上万行的系统库的代码引入，精简了很多。</span></span><br><span class="line"><span class="comment">-fsyntax-only：防止编译器生成代码,只是语法级别的说明和修改</span></span><br><span class="line"><span class="comment">-Xclang &lt;arg&gt;：向clang编译器传递参数</span></span><br><span class="line"><span class="comment">-dump-tokens：运行预处理器,拆分内部代码段为各种token</span></span><br><span class="line"><span class="comment">-ast-dump：构建抽象语法树AST,然后对其进行拆解和调试</span></span><br><span class="line"><span class="comment">-fobjc-arc：为OC对象生成retain和release的调用</span></span><br><span class="line"><span class="comment">-emit-llvm：使用LLVM描述汇编和对象文件</span></span><br><span class="line"><span class="comment">-o &lt;file&gt;：输出到目标文件</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><p>查看更多的<code>clang</code>使用方法可以在终端输入<code>clang --hep</code>查看,也可以点击下面的链接:<a href="https://link.jianshu.com/?t=https://gist.github.com/masuidrive/5231110">https://link.jianshu.com/?t=https://gist.github.com/masuidrive/5231110</a></p><h3 id="2-1-预处理（Preprocess）"><a href="#2-1-预处理（Preprocess）" class="headerlink" title="2.1 预处理（Preprocess）"></a>2.1 预处理（Preprocess）</h3><p>预编译过程主要处理源代码文件中的以”#”开头的预编译指令，<strong>不检查语法错误</strong>。规则如下：</p><ul><li>将所有的 “#define” 删除，并且展开所有的宏定义。 </li><li>处理所有条件预编译指令，比如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”。</li><li>处理 “#include” 预编译指令，将被包含的文件内容插入到(全部复制到)该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。#include 可以导入任何(合法/不合法)文件，都能展开。</li><li>删除所有的注释“//”和“/* */”，会变成空行。 </li><li>保留所有的 #pragma 编译器指令，因为编译器须要使用它们。</li><li>添加行号和文件名标识，比如# 2 “main.m” 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。<br>  格式是“<code># 行号 文件名 标志</code>”，参数解释如下：<ul><li>行号与文件名：表示从它后一行开始的内容来源于哪一个文件的哪一行</li><li>标志：可以是1,2,3,4四个数字，每个数字的含义如下：<br>1：表示新文件的开始<br>2：表示从一个被包含的文件中返回<br>3：表示后面的内容来自系统头文件<br>4：表示后面的内容应当被当做一个隐式的extern ‘C’块</li></ul></li></ul><p>经过预编译后的<code> .i 文件</code>不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到 .i 文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p><p>可以通过执行以下命令，<code>-E</code>表示只进行预编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang -E main.m </span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line">clang -E -fmodules main.m <span class="comment"># 此时需要源码中改为@import</span></span><br></pre></td></tr></table></figure><p>执行完这个命令之后，我们会发现导入了很多的头文件内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"># 408 &quot;&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX.sdk&#x2F;usr&#x2F;include&#x2F;stdio.h&quot; 2 3 4</span><br><span class="line"># 2 &quot;main.m&quot; 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int eight &#x3D; 8;</span><br><span class="line">    int six &#x3D; 6;</span><br><span class="line">    int rank &#x3D; eight + six;</span><br><span class="line">    printf(&quot;%d\n&quot;,rank);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的预处理已经把宏替换了，并且导入了头文件。</p><h3 id="2-2-词法分析-Lexical-Analysis"><a href="#2-2-词法分析-Lexical-Analysis" class="headerlink" title="2.2 词法分析 (Lexical Analysis)"></a>2.2 词法分析 (Lexical Analysis)</h3><p>预处理之后，就是编译。编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。</p><p>首先，Clang 会对代码进行词法分析，将代码切分成 Token。你可以在<a href="https://opensource.apple.com/source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def">这个链接</a><br>中，看到 Clang 定义的所有 Token 类型。我们可以把这些 Token 类型，分为下面这 4 类。 </p><ul><li>关键字：语法中的关键字，比如 if、else、while、for 等;</li><li>标识符：变量名;</li><li>字面量：值、数字、字符串; </li><li>特殊符号：加减乘除、左右括号等符号。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fsyntax-only -Xclang -dump-tokens main.m</span><br></pre></td></tr></table></figure><p>每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int &#39;int&#39; [StartOfLine]Loc&#x3D;&lt;main.m:4:1&gt;</span><br><span class="line">identifier &#39;main&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:4:5&gt;</span><br><span class="line">l_paren &#39;(&#39;Loc&#x3D;&lt;main.m:4:9&gt;</span><br><span class="line">r_paren &#39;)&#39;Loc&#x3D;&lt;main.m:4:10&gt;</span><br><span class="line">l_brace &#39;&#123;&#39;Loc&#x3D;&lt;main.m:4:11&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:5:5&gt;</span><br><span class="line">identifier &#39;eight&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:15&gt;</span><br><span class="line">numeric_constant &#39;8&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:17 &lt;Spelling&#x3D;main.m:2:21&gt;&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:5:28&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:6:5&gt;</span><br><span class="line">identifier &#39;six&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:13&gt;</span><br><span class="line">numeric_constant &#39;6&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:15&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:6:16&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:7:5&gt;</span><br><span class="line">identifier &#39;rank&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:14&gt;</span><br><span class="line">identifier &#39;eight&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:16&gt;</span><br><span class="line">plus &#39;+&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:22&gt;</span><br><span class="line">identifier &#39;six&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:24&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:7:27&gt;</span><br><span class="line">identifier &#39;printf&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:8:5&gt;</span><br><span class="line">l_paren &#39;(&#39;Loc&#x3D;&lt;main.m:8:11&gt;</span><br><span class="line">string_literal &#39;&quot;%d\n&quot;&#39;Loc&#x3D;&lt;main.m:8:12&gt;</span><br><span class="line">comma &#39;,&#39;Loc&#x3D;&lt;main.m:8:18&gt;</span><br><span class="line">identifier &#39;rank&#39;Loc&#x3D;&lt;main.m:8:19&gt;</span><br><span class="line">r_paren &#39;)&#39;Loc&#x3D;&lt;main.m:8:23&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:8:24&gt;</span><br><span class="line">return &#39;return&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:9:5&gt;</span><br><span class="line">numeric_constant &#39;0&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:9:12&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:9:13&gt;</span><br><span class="line">r_brace &#39;&#125;&#39; [StartOfLine]Loc&#x3D;&lt;main.m:10:1&gt;</span><br><span class="line">eof &#39;&#39;Loc&#x3D;&lt;main.m:10:2&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-语法、语义分析"><a href="#2-3-语法、语义分析" class="headerlink" title="2.3 语法、语义分析"></a>2.3 语法、语义分析</h3><p>这个阶段有两个模块Parser(语法syntax分析器)、Sema(语义分析Semantic)配合完成：</p><ul><li>Parser：遍历每个Token做词句分析，根据当前语言的语法，验证语法是否正确，最后生成一个 节点（Nodes）并记录相关的信息。</li><li>Semantic：在Lex 跟 syntax Analysis之后, 已经确保 词 句已经是正确的形式，semantic 接着做return values, size boundaries, uninitialized variables 等检查，如果发现语义上有错误给出提示；如果没有错误就会将 Token 按照语法组合成语义，生成 Clang 语义节点(Nodes)，然后将这些节点按照层级关系构成抽象语法树(AST)。</li></ul><p>AST可以说是Clang的核心，大部分的优化, 判断都在AST处理（例如寻找Class, 替换代码…等)。此步骤会将 Clang Attr  转换成 AST 上的 AttributeList，能在clang插件上透过 <code>Decl::getAttr&lt;T&gt;</code> 获取</p><blockquote><p>Clang Attributes：是 Clang 提供的一种源码注解，方便开发者向编译器表达某种要求，参与控制如 Static Analyzer、Name Mangling、Code Generation 等过程, 一般以 <code>__attribute__(xxx)</code> 的形式出现在代码中, Ex: <code>NS_CLASS_AVAILABLE_IOS(9_0)</code></p></blockquote><p>结构跟其他Compiler的AST相同。与其他编译器不同的是 Clang的AST是由C++构成类似Class、Variable的层级表示，其他的则是以汇编语言编写。这代表着AST也能有对应的api，这让AST操作, 获取信息都比较容易，甚至还夹带着地址跟代码位置。</p><blockquote><p>AST Context: 存储所有AST相关资讯, 且提供ASTMatcher等遍历方法</p></blockquote><p>在 Clang的定义中，节点主要分成：Type(类型)，Decl(声明)，Stmt(陈述)，其他的都是这三种的派生。Type具体到某个语言的类型时便可以派生出 PointerType(指针类型)、ObjCObjectType(objc对象类型)、BuiltinType(内置基础数据类型)这些表示。通过这三者的联结、重复或选择（alternative)就能构成一门编程语言。举个例子，下图的一段代码：详细可以看<a href="https://www.stephenw.cc/2018/01/08/clang-ast/">了解 Clang AST</a></p><img src="/images/compilelink/06.png" alt="01" style="zoom:70%;" /><p>FunctionDecl、ParmVarDecl 都是基于 Decl派生的类，CompoundStmt、ReturnStmt、DeclStmt都是基于 Stmt派生的类。）</p><p>从上图中可以看到：</p><ul><li>一个FunctionDecl（函数的实现）由一个 ParmVarDecl联结 CompoundStmt组成。</li><li>函数的 CompoundStmt 由 DeclStmt和 ReturnStmt联结组成。</li><li>还可以发现这段代码的ParmVarDecl由 BuiltinType 和一个标识符字面量联结组成。</li></ul><p>很明显一门编程语言中还有很多其他形态，我们都可以用这种方式描述出来。所以说从抽象的角度看，拥有无限种形态的编程语言便可以用有限的形式来表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fsyntax-only -Xclang -ast-dump main.m</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">&#96;-FunctionDecl 0x7fcbb9947b20 &lt;main.m:4:1, line:10:1&gt; line:4:5 main &#39;int ()&#39;</span><br><span class="line">  &#96;-CompoundStmt 0x7fcbb9947fc8 &lt;col:11, line:10:1&gt;</span><br><span class="line">    |-DeclStmt 0x7fcbb9947c50 &lt;line:5:5, col:28&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947bd0 &lt;col:5, line:2:21&gt; line:5:9 used eight &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-IntegerLiteral 0x7fcbb9947c30 &lt;line:2:21&gt; &#39;int&#39; 8</span><br><span class="line">    |-DeclStmt 0x7fcbb9947d00 &lt;line:6:5, col:16&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947c80 &lt;col:5, col:15&gt; col:9 used six &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-IntegerLiteral 0x7fcbb9947ce0 &lt;col:15&gt; &#39;int&#39; 6</span><br><span class="line">    |-DeclStmt 0x7fcbb9947e20 &lt;line:7:5, col:27&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947d30 &lt;col:5, col:24&gt; col:9 used rank &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-BinaryOperator 0x7fcbb9947e00 &lt;col:16, col:24&gt; &#39;int&#39; &#39;+&#39;</span><br><span class="line">    |     |-ImplicitCastExpr 0x7fcbb9947dd0 &lt;col:16&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |     | &#96;-DeclRefExpr 0x7fcbb9947d90 &lt;col:16&gt; &#39;int&#39; lvalue Var 0x7fcbb9947bd0 &#39;eight&#39; &#39;int&#39;</span><br><span class="line">    |     &#96;-ImplicitCastExpr 0x7fcbb9947de8 &lt;col:24&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |       &#96;-DeclRefExpr 0x7fcbb9947db0 &lt;col:24&gt; &#39;int&#39; lvalue Var 0x7fcbb9947c80 &#39;six&#39; &#39;int&#39;</span><br><span class="line">    |-CallExpr 0x7fcbb9947f20 &lt;line:8:5, col:23&gt; &#39;int&#39;</span><br><span class="line">    | |-ImplicitCastExpr 0x7fcbb9947f08 &lt;col:5&gt; &#39;int (*)(const char *, ...)&#39; &lt;FunctionToPointerDecay&gt;</span><br><span class="line">    | | &#96;-DeclRefExpr 0x7fcbb9947e38 &lt;col:5&gt; &#39;int (const char *, ...)&#39; Function 0x7fcbb9932e70 &#39;printf&#39; &#39;int (const char *, ...)&#39;</span><br><span class="line">    | |-ImplicitCastExpr 0x7fcbb9947f68 &lt;col:12&gt; &#39;const char *&#39; &lt;NoOp&gt;</span><br><span class="line">    | | &#96;-ImplicitCastExpr 0x7fcbb9947f50 &lt;col:12&gt; &#39;char *&#39; &lt;ArrayToPointerDecay&gt;</span><br><span class="line">    | |   &#96;-StringLiteral 0x7fcbb9947e98 &lt;col:12&gt; &#39;char [4]&#39; lvalue &quot;%d\n&quot;</span><br><span class="line">    | &#96;-ImplicitCastExpr 0x7fcbb9947f80 &lt;col:19&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |   &#96;-DeclRefExpr 0x7fcbb9947eb8 &lt;col:19&gt; &#39;int&#39; lvalue Var 0x7fcbb9947d30 &#39;rank&#39; &#39;int&#39;</span><br><span class="line">    &#96;-ReturnStmt 0x7fcbb9947fb8 &lt;line:9:5, col:12&gt;</span><br><span class="line">      &#96;-IntegerLiteral 0x7fcbb9947f98 &lt;col:12&gt; &#39;int&#39; 0</span><br></pre></td></tr></table></figure><p>在抽象语法树中的每个节点都标注了其对应源码中的位置，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。</p><p>语法树直观图:</p><img src="/images/compilelink/07.png" alt="01" style="zoom:90%;" /><h4 id="2-3-1-静态分析-Static-Analyzer"><a href="#2-3-1-静态分析-Static-Analyzer" class="headerlink" title="2.3.1 静态分析 (Static Analyzer)"></a>2.3.1 静态分析 (Static Analyzer)</h4><p>一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OVERVIEW: Clang Static Analyzer Checkers List</span><br><span class="line"></span><br><span class="line">USAGE: -analyzer-checker &lt;CHECKER or PACKAGE,...&gt;</span><br><span class="line"></span><br><span class="line">CHECKERS:</span><br><span class="line">  alpha.clone.CloneChecker        Reports similar pieces of code.</span><br><span class="line">  alpha.core.BoolAssignment       Warn about assigning non-&#123;0,1&#125; values to Boolean variables</span><br><span class="line">  alpha.core.CallAndMessageUnInitRefArg      Check for logical errors for function calls and Objective-C message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables)</span><br><span class="line">  alpha.core.CastSize             Check when casting a malloc&#39;ed type T, whether the size is a multiple of the size of T</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><a href="http://clang-analyzer.llvm.org/scan-build.html">scan-build</a> 是用于静态分析代码的工具，它包含在 clang 的源码包中。使用scan-build可以从命令行运行分析器，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">roten@localhost scan-build % .&#x2F;scan-build --use-analyzer&#x3D;xcode xcodebuild -project Demo123.xcodeproj    &#x2F;&#x2F; 需要设置 --use-analyzer指定 clang 的路径</span><br><span class="line"></span><br><span class="line">scan-build: Using &#39;&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang&#39; for static analysis</span><br><span class="line">Build settings from command line:</span><br><span class="line">    CLANG_ANALYZER_EXEC &#x3D; &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang</span><br><span class="line">    CLANG_ANALYZER_OTHER_FLAGS &#x3D; </span><br><span class="line">    CLANG_ANALYZER_OUTPUT &#x3D; plist-html</span><br><span class="line">    CLANG_ANALYZER_OUTPUT_DIR &#x3D; &#x2F;var&#x2F;folders&#x2F;1r&#x2F;n7kwlmgn74l3pvvht646f6fm0000gp&#x2F;T&#x2F;scan-build-2020-09-01-140523-22105-1</span><br><span class="line">    RUN_CLANG_STATIC_ANALYZER &#x3D; YES</span><br><span class="line"></span><br><span class="line">note: Using new build system</span><br><span class="line">note: Planning build</span><br><span class="line">note: Constructing build description</span><br><span class="line">Build system information</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">** BUILD SUCCEEDED **</span><br><span class="line"></span><br><span class="line">scan-build: Removing directory &#39;&#x2F;var&#x2F;folders&#x2F;1r&#x2F;n7kwlmgn74l3pvvht646f6fm0000gp&#x2F;T&#x2F;scan-build-2020-09-01-140523-22105-1&#39; because it contains no reports.</span><br><span class="line">scan-build: No bugs found.</span><br></pre></td></tr></table></figure><p>关于静态分析更多可以查看 ：<a href="http://clang-analyzer.llvm.org/">Clang 静态分析器</a></p><p>clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。</p><h3 id="2-4-IR代码生成-CodeGen"><a href="#2-4-IR代码生成-CodeGen" class="headerlink" title="2.4 IR代码生成 (CodeGen)"></a>2.4 IR代码生成 (CodeGen)</h3><p>CodeGen负责将语法树从顶至下遍历，翻译成LLVM IR，LLVM IR是Frontend的输出，也是LLVM Backerend的输入，桥接前后端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;main.m&#39;</span><br><span class="line">source_filename &#x3D; &quot;main.m&quot;</span><br><span class="line">target datalayout &#x3D; &quot;e-m:o-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple &#x3D; &quot;x86_64-apple-macosx10.15.0&quot;</span><br><span class="line"></span><br><span class="line">@.str &#x3D; private unnamed_addr constant [4 x i8] c&quot;%d\0A\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline optnone ssp uwtable</span><br><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">  %1 &#x3D; alloca i32, align 4</span><br><span class="line">  %2 &#x3D; alloca i32, align 4</span><br><span class="line">  %3 &#x3D; alloca i32, align 4</span><br><span class="line">  %4 &#x3D; alloca i32, align 4</span><br><span class="line">  store i32 0, i32* %1, align 4</span><br><span class="line">  store i32 8, i32* %2, align 4</span><br><span class="line">  store i32 6, i32* %3, align 4</span><br><span class="line">  %5 &#x3D; load i32, i32* %2, align 4</span><br><span class="line">  %6 &#x3D; load i32, i32* %3, align 4</span><br><span class="line">  %7 &#x3D; add nsw i32 %5, %6</span><br><span class="line">  store i32 %7, i32* %4, align 4</span><br><span class="line">  %8 &#x3D; load i32, i32* %4, align 4</span><br><span class="line">  %9 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %8)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @printf(i8*, ...) #1</span><br><span class="line"></span><br><span class="line">attributes #0 &#x3D; &#123; noinline optnone ssp uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;darwin-stkchk-strong-link&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;probe-stack&quot;&#x3D;&quot;___chkstk_darwin&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #1 &#x3D; &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;darwin-stkchk-strong-link&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;probe-stack&quot;&#x3D;&quot;___chkstk_darwin&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags &#x3D; !&#123;!0, !1, !2, !3, !4, !5, !6, !7&#125;</span><br><span class="line">!llvm.ident &#x3D; !&#123;!8&#125;</span><br><span class="line"></span><br><span class="line">!0 &#x3D; !&#123;i32 2, !&quot;SDK Version&quot;, [2 x i32] [i32 10, i32 15]&#125;</span><br><span class="line">!1 &#x3D; !&#123;i32 1, !&quot;Objective-C Version&quot;, i32 2&#125;</span><br><span class="line">!2 &#x3D; !&#123;i32 1, !&quot;Objective-C Image Info Version&quot;, i32 0&#125;</span><br><span class="line">!3 &#x3D; !&#123;i32 1, !&quot;Objective-C Image Info Section&quot;, !&quot;__DATA,__objc_imageinfo,regular,no_dead_strip&quot;&#125;</span><br><span class="line">!4 &#x3D; !&#123;i32 4, !&quot;Objective-C Garbage Collection&quot;, i32 0&#125;</span><br><span class="line">!5 &#x3D; !&#123;i32 1, !&quot;Objective-C Class Properties&quot;, i32 64&#125;</span><br><span class="line">!6 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!7 &#x3D; !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!8 &#x3D; !&#123;!&quot;Apple clang version 11.0.0 (clang-1100.0.33.12)&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-1-中间代码优化-Optimize"><a href="#2-4-1-中间代码优化-Optimize" class="headerlink" title="2.4.1 中间代码优化 (Optimize)"></a>2.4.1 中间代码优化 (Optimize)</h4><p>可以在中间代码层次去做一些优化工作，我们在Xcode的编译设置里面也可以设置优化级别<code>-O1</code>,<code>-O3</code>,<code>-Os</code>对应着不同的入参，有比如类似死代码清理，内联化，表达式重组，循环变量移动这样的 Pass。Pass就是LLVM系统转化和优化的工作的一个节点，每个节点做一些工作，这些工作加起来就构成了LLVM整个系统的优化和转化。</p><img src="/images/compilelink/08.png" alt="01" style="zoom:95%;" /><img src="/images/compilelink/09.png" alt="01" style="zoom:85%;" /><p>我们还可以去写一些自己的Pass，官方有比较完整的 Pass 教程： <a href="https://releases.llvm.org/5.0.2/docs/WritingAnLLVMPass.html">Writing an LLVM Pass — LLVM 5 documentation</a>。</p><h3 id="2-5-生成字节码-LLVM-Bitcode"><a href="#2-5-生成字节码-LLVM-Bitcode" class="headerlink" title="2.5 生成字节码 (LLVM Bitcode)"></a>2.5 生成字节码 (LLVM Bitcode)</h3><p>我们在Xcode7中默认生成bitcode就是这种的中间形式存在，开启了bitcode，那么苹果后台拿到的就是这种中间代码，苹果可以对bitcode做一个进一步的优化，如果有新的后端架构，仍然可以用这份bitcode去生成。</p><blockquote><p>Bitcode是编译后的程序的中间表现，包含Bitcode并上传到App Store Connect的Apps会在App Store上编译和链接。包含Bitcode可以在不提交新版本App的情况下，允许Apple在将来的时候再次优化你的App 二进制文件。<br>对于iOS Apps，Enable bitcode 默认为YES，是可选的（可以改为NO）。对于WatchOS和tvOS，bitcode是强制的。如果你的App支持bitcode，App Bundle（项目中所有的target）中的所有的Apps和frameworks都需要包含Bitcode。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -c main.m -o main.bc</span><br></pre></td></tr></table></figure><img src="/images/compilelink/10.png" alt="01" style="zoom:90%;" /><h3 id="2-6-生成相关汇编"><a href="#2-6-生成相关汇编" class="headerlink" title="2.6 生成相关汇编"></a>2.6 生成相关汇编</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc main.m -o main.s</span><br></pre></td></tr></table></figure><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.section</span>__TEXT,__text,regular,pure_instructions</span><br><span class="line">.build_version macos, <span class="number">10</span>, <span class="number">15</span>sdk_version <span class="number">10</span>, <span class="number">15</span></span><br><span class="line">.globl_main                   ## -- Begin <span class="meta">function</span> main</span><br><span class="line">.p2align<span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line"><span class="symbol">_main:</span>                                  ## <span class="comment">@main</span></span><br><span class="line">.cfi_startproc</span><br><span class="line"><span class="comment">## %bb.0:</span></span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">.cfi_offset %rbp, -<span class="number">16</span></span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register %rbp</span><br><span class="line">subq<span class="number">$32</span>, %rsp</span><br><span class="line">movl<span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line">movl<span class="number">$8</span>, -<span class="number">8</span>(%rbp)</span><br><span class="line">movl<span class="number">$6</span>, -<span class="number">12</span>(%rbp)</span><br><span class="line">movl-<span class="number">8</span>(%rbp), %eax</span><br><span class="line">addl-<span class="number">12</span>(%rbp), %eax</span><br><span class="line">movl%eax, -<span class="number">16</span>(%rbp)</span><br><span class="line">movl-<span class="number">16</span>(%rbp), %esi</span><br><span class="line">leaqL_.str(%rip), %rdi</span><br><span class="line">movb<span class="number">$0</span>, %al</span><br><span class="line">callq_printf</span><br><span class="line">xorl%esi, %esi</span><br><span class="line">movl%eax, -<span class="number">20</span>(%rbp)         ## <span class="number">4</span>-byte Spill</span><br><span class="line">movl%esi, %eax</span><br><span class="line">addq<span class="number">$32</span>, %rsp</span><br><span class="line">popq%rbp</span><br><span class="line">retq</span><br><span class="line">.cfi_endproc</span><br><span class="line">                                        <span class="comment">## -- End function</span></span><br><span class="line"><span class="meta">.section</span>__TEXT,__cstring,cstring_literals</span><br><span class="line"><span class="symbol">L_.str:</span>                                 ## <span class="comment">@.str</span></span><br><span class="line"><span class="meta">.asciz</span><span class="string">&quot;%d\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.section</span>__<span class="meta">DATA</span>,__objc_imageinfo,regular,no_dead_strip</span><br><span class="line"><span class="symbol">L_OBJC_IMAGE_INFO:</span></span><br><span class="line"><span class="meta">.long</span><span class="number">0</span></span><br><span class="line"><span class="meta">.long</span><span class="number">64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">.subsections_via_symbols</span></span><br></pre></td></tr></table></figure><h3 id="2-7-生成目标文件"><a href="#2-7-生成目标文件" class="headerlink" title="2.7 生成目标文件"></a>2.7 生成目标文件</h3><p>编译阶段完成，接下来就是汇编阶段。汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了。</p><p>这些文件以 .o 结尾。如果用 Xcode 构建应用程序，可以在工程的 derived data 目录中，Objects-normal 文件夹下找到这些文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -c main.m -o main.o</span><br></pre></td></tr></table></figure><img src="/images/compilelink/11.png" alt="01" style="zoom:90%;" /><h3 id="2-8-生成可执行文件"><a href="#2-8-生成可执行文件" class="headerlink" title="2.8 生成可执行文件"></a>2.8 生成可执行文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang main.o -o main  <span class="comment"># 生成可执行文件</span></span><br><span class="line">./main  <span class="comment"># 执行 可执行文件 代码</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印结果：14</span><br></pre></td></tr></table></figure><h3 id="2-9-记录一个Clang命令报错"><a href="#2-9-记录一个Clang命令报错" class="headerlink" title="2.9 记录一个Clang命令报错"></a>2.9 记录一个Clang命令报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;include&#x2F;stdint.h:59:11: error: #include nested too deeply  </span><br><span class="line"># include &lt;stdint.h&gt;  </span><br><span class="line">          ^  </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;include&#x2F;stdint.h:82:11: error: #include nested too deeply</span><br><span class="line"># include &lt;inttypes.h&gt;</span><br><span class="line">          ^</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案：</p><ol><li><p>可能是xcode-select 没装，于是执行xcode-select –install 进行工具安装。</p></li><li><p>如果问题还在。brew doctor一下就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/includes</span><br><span class="line">brew doctor 2&gt;&amp;1 | grep <span class="string">&quot;/usr/local/include&quot;</span> | awk <span class="string">&#x27;&#123;$1=$1;print&#125;&#x27;</span> | xargs -I _ mv _ /tmp/includes </span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://github.com/SOHU-Co/kafka-node/issues/881">https://github.com/SOHU-Co/kafka-node/issues/881</a></p></li></ol><h2 id="三、小结：iOS从编码到打包"><a href="#三、小结：iOS从编码到打包" class="headerlink" title="三、小结：iOS从编码到打包"></a>三、小结：iOS从编码到打包</h2><ul><li>首先我们编写完成代码之后，会通过LLVM编译器预处理我们的代码，比如将宏放在指定的位置</li><li>预处理结束之后，LLVM会对代码进行词法分析和语法分析，生成AST。AST是抽象语法树，主要用来进行快速遍历，实现静态代码检查的功能。</li><li>AST会生成IR，IR是一种更加接近机器码的语言，通过IR可以生成不同平台的机器码。对于iOS平台，IR生成的可执行文件就是Mach-O.</li><li>然后通过链接器将符号和地址绑定在一起，并且将项目中的多个Mach-O文件(目标文件)合并成一个Mach-O文件(可执行文件)。(<strong>关于Mach-O、链接下一节讲</strong>)</li><li>将可执行文件与资源文件、storyboard、xib等打包，最后通过签名等操作生成.app文件，然后对.app文件进行压缩就生成了我们可以安装的ipa包。</li><li>当然，ipa包的安装途径有两种：<ul><li>通过开发者账号上传到App Store，然后在App Store上下载安装。</li><li>通过PP助手、iFunBox、Xcode等工具来安装</li></ul></li></ul><h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><ul><li><a href="http://blog.alonemonkey.com/2016/12/21/learning-llvm/">关于LLVM，这些东西你必须知道!</a> 本篇文章大部分来自此文章。按照自己的理解记忆方式删减、添加了一些知识。原文中还补充有：<ul><li>Clang的三大基础设施(libclang、LibTooling、ClangPlugin)的应用、代码示例</li><li>动手写Pass的代码示例</li></ul></li><li><a href="https://xiaozhuanlan.com/topic/4916328705">深入剖析 iOS 编译 Clang / LLVM — 戴铭</a></li><li><a href="">《程序员的自我修养》</a></li><li><a href="https://juejin.im/post/6844903716709990414#heading-6">(Xcode) 編譯器小白筆記 - LLVM前端Clang</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、编译、链接工具-—-Clang-LLVM&quot;&gt;&lt;a href=&quot;#一、编译、链接工具-—-Clang-LLVM&quot; class=&quot;headerlink&quot; title=&quot;一、编译、链接工具 — Clang/LLVM&quot;&gt;&lt;/a&gt;一、编译、链接工具 — Clang/LL</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>常见架构模式: MVC、MVP、MVVM、VIPER</title>
    <link href="https://tenloy.github.io/2021/09/20/architectural-pattern.html"/>
    <id>https://tenloy.github.io/2021/09/20/architectural-pattern.html</id>
    <published>2021-09-20T17:22:58.000Z</published>
    <updated>2022-02-09T09:25:55.034Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>译自：<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">iOS Architecture Patterns</a>(模式图也已汉化)。在<a href="http://slides.com/borlov/arch/fullscreen#/">这里</a>可以看到一个幻灯片</p></blockquote><p>在 iOS 中使用 MVC 架构感觉很奇怪？ 迁移到MVVM架构又怀有疑虑？听说过 VIPER 又不确定是否真的值得切换？</p><p>相信你会找到以上问题的答案，如果没找到请在评论中指出。</p><p>你将要整理出你在 iOS 环境下所有关于架构模式的知识。我们将带领大家简要的回顾一些流行的架构，并且在理论和实践上对它们进行比较，通过一些小的例子深化你的认知。如果对文中提到的一些关键词有兴趣，可以点击连接去查看更详细的内容。</p><p>掌控设计模式可能会使人上瘾，所以要当心，你可能会对一些问题清晰明了，不再像阅读之前那样迷惑，比如下面这些问题：</p><ul><li>谁应该来负责网络请求？Model 还是 Controller ？</li><li>应该怎样向一个新的页面的 ViewModel 传入一个 Model ?</li><li>谁来创建一个 VIPER 模块，是 Router 还是 Presenter ?</li></ul><img src="/images/pattern/01.jpg" alt="01" style="zoom:90%;" /><h2 id="一、为什么要关注架构设计？"><a href="#一、为什么要关注架构设计？" class="headerlink" title="一、为什么要关注架构设计？"></a>一、为什么要关注架构设计？</h2><p>因为假如你不关心架构，那么总有一天，需要在同一个庞大的类中调试若干复杂的事情，你会发现在这样的条件下，根本不可能在这个类中快速的找到以及有效的修改任何bug.当然，把这样的一个类想象为一个整体是困难的，因此，有可能一些重要的细节总会在这个过程中会被忽略。如果现在的你正是处于这样一个开发环境中，很有可能具体的情况就像下面这样：</p><ul><li>这个类是一个UIViewController的子类</li><li>数据直接在UIViewController中存储</li><li>UIView类几乎不做任何事情</li><li>Model 仅仅是一个数据结构</li><li>单元测试覆盖不了任何用例</li></ul><p>即使是你遵循了Apple的指导原则并且实现了其 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">MVC</a> 模式，以上这些情况仍旧会出现。不必惊慌，Apple所提出的 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">MVC</a> 模式存在一些问题，我们之后会详述。</p><p>在此，我们可以定义一个好的架构应该具备的特点：</p><ol><li>任务均衡分摊给具有清晰角色的实体</li><li>可测试性通常都来自与上一条（对于一个合适的架构是非常容易）</li><li>易用性和低成本维护</li></ol><h3 id="1-1-为什么采用分布式"><a href="#1-1-为什么采用分布式" class="headerlink" title="1.1 为什么采用分布式?"></a>1.1 为什么采用分布式?</h3><p>采用分布式可以在我们要弄清楚一些事情的原理时保持一个均衡的负载。如果你认为你的开发工作越多，你的大脑越能习惯复杂的思维，其实这是对的。但是，不能忽略的一个事实是，这种思维能力并不是线性增长的，而且也并不能很快的到达峰值。所以，能够战胜这种复杂性的最简单的方法就是在遵循 <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">单一功能原则</a> 的前提下，将功能划分给不同的实体。</p><h3 id="1-2-为什么需要易测性？"><a href="#1-2-为什么需要易测性？" class="headerlink" title="1.2 为什么需要易测性？"></a>1.2 为什么需要易测性？</h3><p>其实这条要求对于哪些习惯了单元测试的人并不是一个问题，因为在添加了新的特性或者要增加一些类的复杂性之后通常会失效。这就意味着，测试可以避免开发者在运行时才发现问题—-当应用到达用户的设备，每一次维护都需要浪费长达至少<a href="http://appreviewtimes.com/">一周</a>的时间才能再次分发给用户。</p><h3 id="1-3-为什么需要易用性？"><a href="#1-3-为什么需要易用性？" class="headerlink" title="1.3 为什么需要易用性？"></a>1.3 为什么需要易用性？</h3><p>这个问题没有固定的答案，但值得一提的是，最好的代码是那些从未写过的代码。因此，代码写的越少，Bug就越少。这意味着希望写更少的代码不应该被单纯的解释为开发者的懒惰，而且也不应该因为偏爱更聪明的解决方案而忽视了它的维护开销。</p><h2 id="二、MV-X-系列概要"><a href="#二、MV-X-系列概要" class="headerlink" title="二、MV(X)系列概要"></a>二、MV(X)系列概要</h2><p>当今我们已经有很架构设计模式方面的选择:</p><ul><li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a></li><li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a></li><li><a href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a></li><li><a href="https://www.objc.io/issues/13-architecture/viper/">VIPER</a></li></ul><p>前三种设计模式都把一个应用中的实体分为以下三类：</p><ul><li><strong>Models</strong> — 负责主要的数据或者操作数据的<a href="https://en.wikipedia.org/wiki/Data_access_layer">数据访问层</a>，可以想象 Perspn 和 PersonDataProvider 类。</li><li><strong>Views</strong> — 负责展示层（GUI），对于iOS环境可以联想一下以 UI 开头的所有类。</li><li><strong>Controller/Presenter/ViewModel</strong> — 负责协调 Model 和 View，通常根据用户在View上的动作在Model上作出对应的更改，并根据 Model 的更改更新 View。</li></ul><p>将实体进行划分给我们带来了以下好处：</p><ul><li>更好的理解它们之间的关系</li><li>复用（尤其是对于View和Model）</li><li>独立的测试</li></ul><p>让我们开始了解MV(X)系列，之后再返回到VIPER模式。</p><h2 id="三、MVC的过去"><a href="#三、MVC的过去" class="headerlink" title="三、MVC的过去"></a>三、MVC的过去</h2><p>在我们探讨Apple的MVC模式之前，我们来看下<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">传统的MVC模式</a>。</p><img src="/images/pattern/02.png" alt="01" style="zoom:80%;" /><p>在这种情况下，View是无状态的。一旦Model被改变，Controller就会简单地渲染View。就像网页一样，在点击了跳转到某个其他页面的连接之后就会完全的重新加载页面。</p><p>虽然可以在 iOS 应用程序中实现传统的 MVC，但由于架构问题，它没有多大意义 —— 三个实体是紧密耦合的，实体间相互都有通信。这很显然会大大降低了三者的复用性，而这正是我们不愿意看到的。鉴于此我们不再给出例子。</p><blockquote><p>传统的MVC架构不适用于当下的iOS开发</p></blockquote><h2 id="四、苹果的MVC"><a href="#四、苹果的MVC" class="headerlink" title="四、苹果的MVC"></a>四、苹果的MVC</h2><h3 id="4-1-愿景"><a href="#4-1-愿景" class="headerlink" title="4.1 愿景"></a>4.1 愿景</h3><p>Cocoa MVC：</p><img src="/images/pattern/03.png" alt="" style="zoom:80%;" /><p>由于Controller是一个介于View 和 Model之间的协调器，所以View和Model之间没有任何直接的联系。Controller是一个最小可重用单元，这对我们来说是一个好消息，因为我们总要找一个地方来写逻辑复杂度较高的代码，而这些代码又不适合放在Model中。</p><p>理论上来讲，这种模式看起来非常直观，但你有没有感到哪里有一丝诡异？你甚至听说过，有人将MVC的缩写展开成（Massive View Controller），更有甚者，<a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/">为View controller减负</a>也成为iOS开发者面临的一个重要话题。如果苹果继承并且对MVC模式有一些进展，所有这些为什么还会发生？</p><h3 id="4-2-现实"><a href="#4-2-现实" class="headerlink" title="4.2 现实"></a>4.2 现实</h3><p>Realistic Cocoa MVC：</p><img src="/images/pattern/04.png" alt="" style="zoom:80%;" /><p>Cocoa的MVC模式驱使人们写出臃肿的视图控制器，因为它们与View的生命周期息息相关，因此很难说View和ViewController是分离的。</p><p>尽管仍可以将业务逻辑和数据转换到Model，但是大多数情况下当需要为View减负的时候我们却无能为力了，很多时候，View的最大的任务就是向Controller传递用户动作事件。</p><p>ViewController最终会承担一切代理和数据源的职责，还负责一些分发和取消网络请求以及一些其他的任务，因此它的名字的由来…你懂的。</p><p>你可能会看见过很多次这样的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var userCell = tableView.dequeueReusableCellWithIdentifier(<span class="string">&quot;identifier&quot;</span>) as UserCell</span><br><span class="line">userCell.configureWithUser(user)</span><br></pre></td></tr></table></figure><p>这个cell，就是个直接使用 Model 来配置的 View，此时其实已经违背了MVC的原则，但是这种情况是一直发生的，甚至于人们不觉得这里有哪些不对。如果严格遵守MVC的话，你会把对cell的设置放在 Controller 中，而不是向这个View传递一个Model对象，但这样就会大大增加Controller的体积。</p><blockquote><p>Cocoa 的MVC被写成Massive View Controller 是不无道理的。</p></blockquote><p>直到进行<a href="http://nshipster.com/unit-testing/">单元测试</a>的时候才会发现问题越来越明显。因为你的ViewController和View是紧密耦合的，对它们进行测试就显得很艰难，你得有足够的创造性来模拟View和它们的生命周期，在以这样的方式来写View Controller的同时，业务逻辑的代码也逐渐被分散到View的布局代码中去。</p><p>我们看下一些简单的例子:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Model</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span> &#123; <span class="comment">// View + Controller</span></span><br><span class="line">    var person: Person!</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">&quot;didTapButton:&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func didTapButton(button: <span class="built_in">UIButton</span>) &#123;</span><br><span class="line">        let greeting = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.firstName + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of MVC</span></span><br><span class="line">let model = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">view.person = model;</span><br></pre></td></tr></table></figure><blockquote><p>MVC可以在一个正在显示的ViewController中实现</p></blockquote><p>这段代码看起来可测试性并不强，我们可以把和greeting相关的都放到GreetingModel中然后分开测试，但是这样我们就无法通过直接调用在GreetingViewController中的UIView相关的方法（viewDidLoad和didTapButton方法）来测试页面的展示逻辑了，因为一旦调用则会使整个页面都变化，这对单元测试来讲并不是什么好消息。</p><p>事实上，在单独一个模拟器中（比如iPhone 4S）加载并测试UIView并不能保证在其他设备中也能正常工作（例如iPad），因此我建议在单元测试的Target的设置下移除”Host Application”项，并且不要在模拟器中测试你的应用。</p><blockquote><p>View和Controller之间的交互 <a href="http://ashfurrow.com/blog/whats-worth-unit-testing-in-objective-c/">并不适合使用单元测试</a> 来测试。</p></blockquote><p>以上所述，似乎Cocoa MVC 看起来是一个相当差的架构方案。我们来重新评估一下文章开头我们提出的MVC一系列的特征:</p><ul><li><strong>任务均摊</strong> —— View和Model确实是分开的，但是View和Controller却是紧密耦合的</li><li><strong>可测试性</strong> —— 由于糟糕的分散性，只能对Model进行测试</li><li><strong>易用性</strong> —— 与其他几种模式相比最小的代码量。熟悉的人很多，因而即使对于经验不那么丰富的开发者来讲维护起来也较为容易。</li></ul><p>如果你不想在架构选择上投入更多精力，那么Cocoa MVC无疑是最好的方案，而且你会发现一些其他维护成本较高的模式对于你所开发的小的应用是一个致命的打击。</p><blockquote><p>就开发速度而言，Cocoa MVC是最好的架构选择方案。</p></blockquote><h2 id="五、MVP-Passive-View"><a href="#五、MVP-Passive-View" class="headerlink" title="五、MVP(Passive View)"></a>五、MVP(Passive View)</h2><h3 id="5-1-MVP-实现了Cocoa的MVC的愿景"><a href="#5-1-MVP-实现了Cocoa的MVC的愿景" class="headerlink" title="5.1 MVP 实现了Cocoa的MVC的愿景"></a>5.1 MVP 实现了Cocoa的MVC的愿景</h3><p>Passive View variant of MVP：</p><img src="/images/pattern/05.png" alt="" style="zoom:75%;" /><p>这看起来不正是苹果所提出的MVC方案吗？确实是的，这种模式的名字是<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a>（Passive View variant，被动视图变体），但是，这就是说苹果的MVC实际上就是<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a>了？不，并不是这样的。如果你仔细回忆一下，View是和Controller紧密耦合的，但是MVP的协调器Presenter并没有对ViewController的生命周期做任何改变，因此View可以很容易的被模拟出来。在Presenter中根本没有和布局有关的代码，但是它却负责更新View的数据和状态。</p><blockquote><p>假如告诉你UIViewController就是View呢？</p></blockquote><p>就MVP而言，UIViewController的子类实际上就是Views并不是Presenters。这点区别使得这种模式的可测试性得到了极大的提高，付出的代价是开发速度的一些降低，因为必须要做一些手动的数据和事件绑定，从下例中可以看出：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Model</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingView: <span class="keyword">class</span> &#123;</span><br><span class="line">    func setGreeting(greeting: String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewPresenter &#123;</span><br><span class="line">    init(view: GreetingView, person: Person)</span><br><span class="line">    func showGreeting()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingPresenter : GreetingViewPresenter &#123;</span><br><span class="line">    unowned let view: GreetingView</span><br><span class="line">    let person: Person</span><br><span class="line">    required init(view: GreetingView, person: Person) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view = view</span><br><span class="line">        <span class="keyword">self</span>.person = person</span><br><span class="line">    &#125;</span><br><span class="line">    func showGreeting() &#123;</span><br><span class="line">        let greeting = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.firstName + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">        <span class="keyword">self</span>.view.setGreeting(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span>, GreetingView &#123;</span><br><span class="line">    var presenter: GreetingViewPresenter!</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">&quot;didTapButton:&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func didTapButton(button: <span class="built_in">UIButton</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.presenter.showGreeting()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func setGreeting(greeting: String) &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of MVP</span></span><br><span class="line">let model = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">let presenter = GreetingPresenter(view: view, person: model)</span><br><span class="line">view.presenter = presenter</span><br></pre></td></tr></table></figure><h3 id="5-2-关于整合问题的重要说明"><a href="#5-2-关于整合问题的重要说明" class="headerlink" title="5.2 关于整合问题的重要说明"></a>5.2 关于整合问题的重要说明</h3><p>MVP是第一个如何协调整合三个实际上分离的层次的架构模式，既然我们不希望View和Model耦合，那么在显示的View Controller（其实就是View）中处理这种协调的逻辑就是不正确的，因此我们需要在其他地方来做这些事情。例如，我们可以做基于整个App范围内的路由服务，由它来负责执行协调任务，以及View到View的展示。这个出现并且必须处理的问题不仅仅是在MVP模式中，同时也存在于以下几种方案中。</p><p>我们来看下MVP模式下的三个特性的分析：</p><ul><li>任务均摊 —— 我们将最主要的任务划分到Presenter和Model，而View的功能较少（虽然上述例子中Model的任务也并不多）。</li><li>可测试性 —— 非常好，由于一个功能简单的View层，所以测试大多数业务逻辑也变得简单</li><li>易用性 —— 在我们上边不切实际的简单的例子中，代码量是MVC模式的2倍，但同时MVP的概念却非常清晰</li></ul><blockquote><p>iOS 中的MVP意味着可测试性强、代码量大。</p></blockquote><h3 id="5-3-变体-—-MVP-Supervising-Controller"><a href="#5-3-变体-—-MVP-Supervising-Controller" class="headerlink" title="5.3 变体 — MVP(Supervising Controller)"></a>5.3 变体 — MVP(Supervising Controller)</h3><p>还有一些其他形态的MVP —— Supervising Controller MVP（监听Controller的MVP）。</p><blockquote><p>核心是：Bindings(绑定)和Hooters(此处译作信号)</p></blockquote><p>这个变体包含了View和Model之间的直接绑定，但是Presenter(Supervising Controller)仍然来管理来自View的动作事件，同时也能胜任对View的更新。</p><p>Supervising Controller variant of the MVP：</p><img src="/images/pattern/07.png" alt="" style="zoom:75%;" /><p>但是我们之前就了解到，模糊的职责划分是非常糟糕的，更何况将View和Model紧密的联系起来。这和Cocoa的桌面开发的原理有些相似。</p><p>和传统的MVC一样，写这样的例子没有什么价值，故不再给出。</p><h2 id="六、MVVM"><a href="#六、MVVM" class="headerlink" title="六、MVVM"></a>六、MVVM</h2><blockquote><p>最新且是最伟大的MV(X)系列的一员</p></blockquote><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><a href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a>架构是MV(X)系列最新的一员，因此让我们希望它已经考虑到MV(X)系列中之前已经出现的问题。</p><p>从理论层面来讲MVVM看起来不错，我们已经非常熟悉View和Model，以及Meditor，在MVVM中它是View Model。</p><img src="/images/pattern/08.png" alt="" style="zoom:75%;" /><p>它和MVP模式看起来非常像:</p><ul><li>MVVM将ViewController视作View</li><li>在View和Model之间没有紧密的联系</li></ul><p>此外，它还有像监管(Supervising)版本的MVP那样的绑定功能，但这个绑定不是在View和Model之间，而是在View和ViewModel之间。</p><p>那么问题来了，在iOS中ViewModel实际上代表什么？它基本上就是UIKit下的每个控件以及控件的状态。ViewModel调用会改变Model同时会将Model的改变更新到自身，并且因为我们绑定了View和ViewModel，第一步就是相应的更新状态。</p><h3 id="6-2-绑定"><a href="#6-2-绑定" class="headerlink" title="6.2 绑定"></a>6.2 绑定</h3><p>我在MVP部分已经提到这点了，但是该部分我们仍会继续讨论。</p><p>如果我们自己不想自己实现，那么我们有两种选择:</p><ul><li>基于KVO的绑定库如 <a href="https://github.com/Raizlabs/RZDataBinding">RZDataBinding</a> 和 <a href="https://github.com/SwiftBond/Bond">SwiftBond</a></li><li>完全的<a href="https://gist.github.com/JaviLorbada/4a7bd6129275ebefd5a6">函数响应式编程</a>，比如像<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>、<a href="https://github.com/ReactiveX/RxSwift/">RxSwift</a>或者 <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a></li></ul><p>事实上，尤其是最近，你听到MVVM就会想到ReactiveCoca，反之亦然。尽管通过简单的绑定来使用MVVM是可实现的，但是ReactiveCocoa却能更好的发挥MVVM的特点。</p><p>但是关于这个框架有一个不得不说的事实：强大的能力来自于巨大的责任。当你开始使用Reactive的时候有很大的可能就会把事情搞砸。换句话来说就是，如果发现了一些错误，调试出这个bug可能会花费大量的时间，看下 Reactive Debugging 函数调用栈：</p><img src="/images/pattern/09.jpg" alt="" style="zoom:90%;" /><p>在我们简单的例子中，FRF框架和KVO被过渡禁用，取而代之地我们直接去调用showGreeting方法更新ViewModel，以及通过greetingDidChange 回调函数使用属性。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Model</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewModelProtocol: <span class="keyword">class</span> &#123;</span><br><span class="line">    var greeting: String? &#123; get &#125;</span><br><span class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? &#123; get set &#125; <span class="comment">// function to call when greeting did change</span></span><br><span class="line">    init(person: Person)</span><br><span class="line">    func showGreeting()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewModel : GreetingViewModelProtocol &#123;</span><br><span class="line">    let person: Person</span><br><span class="line">    var greeting: String? &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            <span class="keyword">self</span>.greetingDidChange?(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())?</span><br><span class="line">    required init(person: Person) &#123;</span><br><span class="line">        <span class="keyword">self</span>.person = person</span><br><span class="line">    &#125;</span><br><span class="line">    func showGreeting() &#123;</span><br><span class="line">        <span class="keyword">self</span>.greeting = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.firstName + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">    var viewModel: GreetingViewModelProtocol! &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            <span class="keyword">self</span>.viewModel.greetingDidChange = &#123; [unowned <span class="keyword">self</span>] viewModel <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.greetingLabel.text = viewModel.greeting</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>.viewModel, action: <span class="string">&quot;showGreeting&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of MVVM</span></span><br><span class="line">let model = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>)</span><br><span class="line">let viewModel = GreetingViewModel(person: model)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">view.viewModel = viewModel</span><br></pre></td></tr></table></figure><p>让我们再来看看关于三个特性的评估：</p><ul><li>任务均摊 —— 在例子中并不是很清晰，但是事实上，MVVM的View要比MVP中的View承担的责任多。因为前者通过ViewModel的设置绑定来更新状态，而后者只监听Presenter的事件但并不会对自己有什么更新。</li><li>可测试性 —— ViewModel不知道关于View的任何事情，这允许我们可以轻易的测试ViewModel。同时View也可以被测试，但是由于属于UIKit的范畴，对他们的测试通常会被忽略。</li><li>易用性 —— 在我们例子中的代码量和MVP的差不多，但是在实际开发中，我们必须把View中的事件指向Presenter并且手动的来更新View，如果使用绑定的话，MVVM代码量将会小的多。</li></ul><blockquote><p>MVVM很诱人，因为它集合了上述方法的优点，并且由于在View层的绑定，它并不需要其他附加的代码来更新View，尽管这样，可测试性依然很强。</p></blockquote><h2 id="七、VIPER"><a href="#七、VIPER" class="headerlink" title="七、VIPER"></a>七、VIPER</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><blockquote><p>VIPER —— 把LEGO建筑经验迁移到iOS app的设计</p></blockquote><p><a href="https://www.objc.io/issues/13-architecture/viper/">VIPER</a>是我们最后要介绍的，由于不是来自于MV(X)系列，它具备一定的趣味性。</p><p>迄今为止，划分责任的粒度是很好的选择。VIPER在责任划分层面进行了迭代，VIPER分为五个层次:</p><img src="/images/pattern/10.png" alt="" style="zoom:70%;" /><p>VIPER</p><ul><li><strong>交互器</strong> —— 包括关于数据和网络请求的业务逻辑，例如创建一个实体（数据），或者从服务器中获取一些数据。为了实现这些功能，需要使用服务、管理器，但是他们并不被认为是VIPER架构内的模块，而是外部依赖。</li><li><strong>展示器</strong> —— 包含UI层面的业务逻辑以及在交互器层面的方法调用。</li><li><strong>实体</strong> —— 普通的数据对象，不属于数据访问层次，因为数据访问属于交互器的职责。</li><li><strong>路由器</strong> —— 用来连接VIPER的各个模块。</li></ul><p>基本上，VIPER模块可以是一个屏幕或者用户使用应用的整个过程 —— 例如认证过程，可以由一屏完成或者需要几步才能完成，你的模块期望是多大的，这取决于你。</p><p>当我们把VIPER和MV(X)系列作比较时，我们会在任务均摊性方面发现一些不同:</p><ul><li><strong>Model</strong>（数据交互）逻辑以实体（Entities）为单位（作为最小的数据结构）拆分到交互器（Interactor）中。</li><li><strong>Controller/Presenter/ViewModel</strong>的UI展示方面的职责移到了Presenter中，但是并没有数据转换相关的操作。</li><li><strong>VIPER</strong>是第一个通过路由器（Router）实现明确的地址导航模式。</li></ul><blockquote><p>找到一个适合的方法来实现路由对于iOS应用是一个挑战，MV(X)系列避开了这个问题。</p></blockquote><p>例子中并不包含路由和模块之间的交互，所以和MV(X)系列部分架构一样不再给出例子。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Entity (usually more complex e.g. NSManagedObject)</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> GreetingData &#123; <span class="comment">// Transport data structure (not Entity)</span></span><br><span class="line">    let greeting: String</span><br><span class="line">    let subject: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingProvider &#123;</span><br><span class="line">    func provideGreetingData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingOutput: <span class="keyword">class</span> &#123;</span><br><span class="line">    func receiveGreetingData(greetingData: GreetingData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingInteractor : GreetingProvider &#123;</span><br><span class="line">    <span class="keyword">weak</span> var output: GreetingOutput!</span><br><span class="line">    </span><br><span class="line">    func provideGreetingData() &#123;</span><br><span class="line">        let person = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>) <span class="comment">// usually comes from data access layer</span></span><br><span class="line">        let subject = person.firstName + <span class="string">&quot; &quot;</span> + person.lastName</span><br><span class="line">        let greeting = GreetingData(greeting: <span class="string">&quot;Hello&quot;</span>, subject: subject)</span><br><span class="line">        <span class="keyword">self</span>.output.receiveGreetingData(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewEventHandler &#123;</span><br><span class="line">    func didTapShowGreetingButton()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingView: <span class="keyword">class</span> &#123;</span><br><span class="line">    func setGreeting(greeting: String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingPresenter : GreetingOutput, GreetingViewEventHandler &#123;</span><br><span class="line">    <span class="keyword">weak</span> var view: GreetingView!</span><br><span class="line">    var greetingProvider: GreetingProvider!</span><br><span class="line">    </span><br><span class="line">    func didTapShowGreetingButton() &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingProvider.provideGreetingData()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func receiveGreetingData(greetingData: GreetingData) &#123;</span><br><span class="line">        let greeting = greetingData.greeting + <span class="string">&quot; &quot;</span> + greetingData.subject</span><br><span class="line">        <span class="keyword">self</span>.view.setGreeting(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span>, GreetingView &#123;</span><br><span class="line">    var eventHandler: GreetingViewEventHandler!</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">&quot;didTapButton:&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func didTapButton(button: <span class="built_in">UIButton</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.eventHandler.didTapShowGreetingButton()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func setGreeting(greeting: String) &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of VIPER module, without Router</span></span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">let presenter = GreetingPresenter()</span><br><span class="line">let interactor = GreetingInteractor()</span><br><span class="line">view.eventHandler = presenter</span><br><span class="line">presenter.view = view</span><br><span class="line">presenter.greetingProvider = interactor</span><br><span class="line">interactor.output = presenter</span><br></pre></td></tr></table></figure><p>让我们再来评估一下特性:</p><ul><li>任务均摊 —— 毫无疑问，VIPER是任务划分中的佼佼者。</li><li>可测试性 —— 不出意外地，更好的分布性就有更好的可测试性。</li><li>易用性 —— 最后你可能已经猜到了维护成本方面的问题。你必须为很小功能的类写出大量的接口。</li></ul><h3 id="7-2-什么是LEGO"><a href="#7-2-什么是LEGO" class="headerlink" title="7.2 什么是LEGO"></a>7.2 什么是LEGO</h3><p>当使用VIPER时，你的感觉就像是用乐高积木来搭建一个城堡，这也是一个表明当前存在一些问题的信号。可能现在就应用VIPER架构还为时过早，考虑一些更为简单的模式可能会更好。一些人会忽略这些<a href="https://inessential.com/2014/03/16/smaller_please">问题</a>，大材小用。假定他们笃信VIPER架构会在未来给他们的应用带来一些好处，虽然现在维护起来确实是有些不合理。如果你也持这样的观点，我为你推荐 <a href="https://github.com/rambler-ios/Generamba">Generamba</a> 这个用来搭建VIPER架构的工具。虽然我个人感觉，使用起来就像加农炮的自动瞄准系统，而不是简单的像投石器那样的简单的抛掷。</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>我们了解了集中架构模式，希望你已经找到了到底是什么在困扰你。毫无疑问通过阅读本篇文章，你已经了解到其实并没有完全的银弹。所以选择架构是一个根据实际情况具体分析利弊的过程。</p><p>因此，在同一个应用中包含着多种架构。比如，你开始的时候使用MVC，然后突然意识到一个页面在MVC模式下的变得越来越难以维护，然后就切换到MVVM架构，但是仅仅针对这一个页面。并没有必要对哪些MVC模式下运转良好的页面进行重构，因为二者是可以并存的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;译自：&lt;a href=&quot;https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52&quot;&gt;iOS Architecture Patterns&lt;/a&gt;(模式</summary>
      
    
    
    
    <category term="架构与设计模式" scheme="https://tenloy.github.io/categories/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的设计模式</title>
    <link href="https://tenloy.github.io/2021/09/18/design-pattern.html"/>
    <id>https://tenloy.github.io/2021/09/18/design-pattern.html</id>
    <published>2021-09-18T19:37:12.000Z</published>
    <updated>2022-02-09T09:25:55.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、架构相关术语"><a href="#一、架构相关术语" class="headerlink" title="一、架构相关术语"></a>一、架构相关术语</h1><h2 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 架构</h2><p>软件架构就是软件的基本结构。是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。</p><p>软件架构会包括软件组件、组件之间的关系，组件特性以及组件间关系的特性，如类与类之间的关系、模块与模块之 间的关系、客户端与服务端的关系。</p><p>五种常见的软件架构，<a href="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html">软件架构入门 — 阮一峰</a></p><ul><li>分层架构<ul><li>三层：展现层、业务层、数据层</li><li>四层：展现层、业务层、网络层、本地数据层</li></ul></li><li>事件驱动架构</li><li>微核架构(又称插件架构)</li><li>微服务架构</li><li>云架构</li></ul><h2 id="1-2-架构与框架"><a href="#1-2-架构与框架" class="headerlink" title="1.2 架构与框架"></a>1.2 架构与框架</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/1438723">架构和框架的区别 原文链接</a></p></blockquote><p>人们对软件架构存在非常多的误解，其中一个最为普遍的误解就是：将架构（Architecture）和框架（Framework）混为一谈。其实很简单， 一句话：框架是软件，架构不是软件。</p><ul><li>框架落脚在“架”字上，可以理解成名词性的，是一个客观性的名词存在，如.Net Framework； </li><li>架构体现在“构”字上，理解成构造，是一个动词性的，是一系列动作发生的策略性体现。</li></ul><p><strong>框架是一种特殊的软件</strong>，它并不能提供完整无缺的解决方案，而是为构建整个解决方案提供良好的基础。</p><ul><li>框架是半成品。典型地，框架是系统或子系统的半成品；框架中的服务尅被最终应用系统直接调用，而框架中的扩展点是供应用开发人 员定制的“可变化点”。</li></ul><p><strong>架构不是软件</strong>，而是一种设计理念(思想)，是关于软件如何设计的重要策略。</p><ul><li>软件架构决策设计到如何将软件系统分解成不同的部分、各部分之间的静态结构关系和动态交互关系等。</li><li>经过完整的开发过程之后，这些架构决策将体现在最终开发出的软件系统中；当然，引入软件架构之后，整个开发过程变成了“分两步走”，而架构决策往往会体现在框架之中。或许，人们常把架构和框架混为一谈的原因就在于此吧！我们不能指着某些代码，说这就是软件架构，因为软件架构是比具体代码高一个抽象层次的概念。 </li><li><strong>架构势必被代码所体现和遵循，但任何一段具体的代码都代表不了架构</strong>。</li></ul><p>框架技术和架构技术的出现，都是为了解决软件系统日益复杂所带来的困难而采取“分而治之”思维的结果—–先大局后局部，就出现了架构；先通用后专用，就出现了框架。</p><p>简而言之，框架和架构的关系可以总结为两句话：</p><ul><li>为了尽早验证架构设计，或者处于支持产品线开发的目的，可以<strong>将关键的通用机制甚至整个架构以框架的方式进行实现</strong>；</li><li>业界（及公司内部）可能存在大量可供重用的框架，这些框架或者已经实现了软件架构所需的重要架构机制，或者为未来系统的某个子 系统提供了可扩展的半成品，所以<strong>最终的软件架构可以借助这些框架构造</strong>。</li></ul><h2 id="1-3-架构模式"><a href="#1-3-架构模式" class="headerlink" title="1.3 架构模式"></a>1.3 架构模式</h2><p>架构模式是软件架构中在给定环境下，针对常遇到的问题的、通用且可重用的解决方案。—— 维基百科</p><ul><li><p>类似于软件设计模式，但覆盖范围更广，致力于软件工程中不同问题，如计算机硬件性能限制、高可用性、业务风险极小化。一些架构模式会透过软件框架实现。</p></li><li><p>维基百科中，将MVC、MVVM等称为架构模式。(在Head First设计模式中，也将其称为复合设计模式(是作者的个人名词)，是指将两个以上的普通设计模式结合而成的新设计模式)。</p></li></ul><h2 id="1-4-设计模式"><a href="#1-4-设计模式" class="headerlink" title="1.4 设计模式"></a>1.4 设计模式</h2><p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。</p><ul><li>设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。</li><li>面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。</li><li>设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</li></ul><p>并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。</p><h2 id="1-5-内聚、耦合"><a href="#1-5-内聚、耦合" class="headerlink" title="1.5 内聚、耦合"></a>1.5 内聚、耦合</h2><h3 id="1-5-1-内聚性"><a href="#1-5-1-内聚性" class="headerlink" title="1.5.1 内聚性"></a>1.5.1 内聚性</h3><p>内聚性（Cohesion）也称为内聚力，是从功能角度来度量<strong>模块内的组成部分之间相互联系的紧密程度</strong>。</p><p>因为：</p><ul><li>当一个模块或一个类被设计成只支持一组相关的功能时，那内聚性肯定很高。</li><li>反之，当被设计成支持一组不相关的功能时，那模块内的组成部分联系紧密程度肯定不高，也就是低内聚。</li></ul><p>所以，内聚性也用来衡量一个类或模块是否达到单一目的或责任。</p><p><strong>内聚是一个比单一责任原则更普遍的概念，但两者其实关系是很密切的。遵守这个原则的类容易具有很高的凝聚力，比背负很多责任的低内聚类更容易维护</strong>。</p><p>一般会希望程序的模块有高内聚性，因为高内聚性一般和许多理想的软件特性有关，包括鲁棒性、可靠度、可复用性及易懂性等特性，而低内聚性一般也代表不易维护、不易测试、不易复用以及难以理解。</p><h3 id="1-5-2-耦合性"><a href="#1-5-2-耦合性" class="headerlink" title="1.5.2 耦合性"></a>1.5.2 耦合性</h3><p>耦合性（Coupling，Dependency）或称耦合力或耦合度，是一个和内聚性相对的概念。描述的是软件结构中，<strong>模块及模块之间联系的紧密程度，可以体现在，信息或参数依赖的程度</strong>。</p><blockquote><p>耦合度，可以简单理解为当一个类发生变更时，对其他类造成的影响程度，影响越小则耦合度越弱，影响越大耦合度越强。</p></blockquote><p>耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p><p>一般而言高内聚性代表低耦合性，反之亦然。内聚性是由赖瑞·康斯坦丁所提出，是以实务上可减少维护及修改的“好”软件的特性为基础。</p><h3 id="1-5-3-高内聚、松耦合"><a href="#1-5-3-高内聚、松耦合" class="headerlink" title="1.5.3 高内聚、松耦合"></a>1.5.3 高内聚、松耦合</h3><p>软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚；而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合。</p><h2 id="1-6-透明-对xx透明"><a href="#1-6-透明-对xx透明" class="headerlink" title="1.6 透明(对xx透明)"></a>1.6 透明(对xx透明)</h2><p>在汉语中，透明有以下两种看起来截然相反的含义：(前者是看的清清楚楚，后者是看不到)</p><ul><li>比喻公开而无遮掩。比如建立一个公开、公正、 透明的用人制度。</li><li>能透过光线的。比如透明玻璃。（<font color='red'>对xx透明，意思就是xx看不到该事物/属性</font>）<ul><li>虽然在日常使用中所指的“透明”是对可见光，但它也可以延伸到用于指代任何种类的辐射。</li><li>例如医学中：肉体对X光是透明的，但骨头却不是，使得X光成像对医疗非常有用。</li><li>例如计算机中：计算机术语“透明”是指客观存在并且运行着但是我们看不到的特性。即它客观存在，但对于大多数、特定类别的开发人员而言是不需要了解的东西，这就是计算机学中所指的透明。换种说法，透明就是一个黑盒，你只需要应用它给出的接口，而不需要了解其内在机理。<ul><li>计算机组织对电脑用户是透明的，就是说计算机组织对用户来说是看不到的，也不需要看到的。</li><li>透传，即透明传输（pass-through），指的是在通讯中不管传输的业务内容如何，只负责将传输的内容由源地址传输到目的地址，而不对业务数据内容做任何改变。<ul><li>从上层角度看，似乎就是一个透明的管道，什么都可以传。</li><li>非透明传输就是底层协议要对传输内容有限制或者修改。</li></ul></li></ul></li></ul></li></ul><p>注意：计算机中，有些场景的“透明”，也会被人错表达为第一种的意思，阅读时需要结合上下文理解，避免被误导。</p><h2 id="1-7-程序设计中的抽象与接口"><a href="#1-7-程序设计中的抽象与接口" class="headerlink" title="1.7 程序设计中的抽象与接口"></a>1.7 程序设计中的抽象与接口</h2><p><em>此处，并不是指编程语言中的抽象类、接口类。而是程序设计中的抽象、接口概念。</em></p><h3 id="抽象和抽象化的两种解读"><a href="#抽象和抽象化的两种解读" class="headerlink" title="抽象和抽象化的两种解读"></a>抽象和抽象化的两种解读</h3><p>抽象：</p><ul><li>从众多的具体事物中，抽取共同的、本质的属性，舍弃个别的、非本质的属性，从而形成概念。（所以抽象作为形容词，也意味着不具体的、笼统的；空洞的（跟「具体」相对））</li><li>将复杂物体的一个或几个特性抽出去而只注意其他特性的行动或过程(如头脑只思考树本身的形状或只考虑树叶的颜色，不受它们的大小和形状的限制)。比如：<ul><li>抽象艺术：打破了艺术原来强调主题写实再现的局限，把艺术基本要素，进行抽象的组合，创造出抽象的形式，因而突破了艺术必须具有可以辨认形象的籓篱，开创了艺术新的发展天地。</li><li>抽象画：与自然物象极少或完全没有相近之处，而又具强烈的形式构成面貌的绘画。</li></ul></li></ul><p>与上面对应，抽象化也有了两种解读：</p><ul><li>忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</li><li>在计算机科学中，抽象化（Abstraction）是将资料与程序，以它的语义来呈现出它的外观，但是<strong>隐藏起它的实现细节</strong>。抽象化是用来减少程序的复杂度，使得程序员可以专注在处理少数重要的部分。—— 维基百科<ul><li>为了使抽象的成品（算法）不会出现问题，要注意抽象时是否漏掉重要特征。</li></ul></li></ul><p>程序设计中，需要根据上下文来区分语义。(<em>尤其是桥接模式那里….乍得一看，都被定义搞晕了</em>)。编程语言中的抽象类、接口类中，抽象很明显是前种含义。</p><h3 id="程序设计接口"><a href="#程序设计接口" class="headerlink" title="程序设计接口"></a>程序设计接口</h3><p>接口或界面（interface）泛指<strong>实体把自己提供给外界的一种抽象化物</strong>（可以为另一实体），用以由内部操作分离出<strong>外部沟通方法</strong>，使其能被修改内部而不影响外界其他实体与其交互的方式，就如面向对象编程提供的多重抽象化。</p><p>接口可能也提供某种意义上的在讲不同语言的实体之间的翻译，诸如人类与电脑之间。因为接口是一种间接手段，所以相比起直接沟通，会引致些额外负担。</p><p>常见的接口：</p><ul><li>人类与电脑等信息机器或人类与程序之间的接口称为用户界面。</li><li>电脑等信息机器硬件组件间的接口叫硬件接口。</li><li>电脑等信息机器软件组件间的接口叫软件接口，其存在于分离的软件组件间，并提供一种机制使这些组件可以沟通。</li></ul><p>程序编写或设计的方法论中所关心的接口，是作为程序组件功能的抽象化，属于软件接口的一类。提供给软件组件间的接口会被访问到的事物的种类可以包括：常量、资料类型、程序的种类、例外规格、类型签名。在某些个案，定义变量作为接口的一部分可能会很有用。</p><h2 id="1-8-关注点分离"><a href="#1-8-关注点分离" class="headerlink" title="1.8 关注点分离"></a>1.8 关注点分离</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>关注点分离是解决复杂问题的一种系统思维方法。大体思路是，先将复杂问题做合理的分解，再分别仔细研究问题的不同侧面(关注点)，最后综合各方面的结果，合成整体的解决方案。</p><p>关注点分离，是对只与“特定概念、目标”（关注点）相关联的软件组成部分进行“标识、封装和操纵”的能力，即标识、封装和操纵关注点的能力。</p><p>是处理复杂性的一个原则。由于关注点混杂在一起会导致复杂性大大增加，所以能够把不同的关注点分离，分别处理就是处理复杂性的一个原则，一种方法。</p><p>关注点分离的价值在于简化计算机程序的开发和维护。当关注点分开时，各部分可以重复使用，以及独立开发和更新。具有特殊价值的是能够稍后改进或修改一段代码，而无需知道其他部分的细节必须对这些部分进行相应的更改。</p><h3 id="如何分离关注点"><a href="#如何分离关注点" class="headerlink" title="如何分离关注点"></a>如何分离关注点</h3><p>大部分业务需求，都是在做变的部分，如果不变也就没有业务需求了，<strong>变化的东西是什么？找到这个就是我们的关注点</strong>。</p><p>小到一个函数，大到一个类，再或者是一个包，甚至更大的是一个层，都可以看作是一个关注点，关注点常见划分的手段有两种：<strong>功能(职责)<strong>和</strong>业务语义</strong>。平时说的边界也是在分离各自己的关注点，划分边界也是体现了单一职责。</p><p>实现单一职责，有<strong>纵向和横向</strong>两个角度：纵向是具有依赖的；横向是水平可替换的。</p><p>常见的两种关注点分离的实现：<strong>分层、面向接口编程</strong>。分层就是纵向考虑的，每个层的职责不一样，但层与层之间有相互关联；接口实现是横向的，接口的实现是可替换的。</p><p><strong>关注点开放</strong>：将会变的部分开放出去，由各业务逻辑模块自己去做，封装不变的、共性的部分。</p><h1 id="二、设计模式中对象之间的关系"><a href="#二、设计模式中对象之间的关系" class="headerlink" title="二、设计模式中对象之间的关系"></a>二、设计模式中对象之间的关系</h1><p>在面向对象设计模式中，类与类之间主要有6种关系，他们分别是：依赖、关联、聚合、组合、泛化、实现。</p><p>它们的耦合度依次增强。</p><h2 id="2-1-依赖-dependency"><a href="#2-1-依赖-dependency" class="headerlink" title="2.1 依赖(dependency)"></a>2.1 依赖(dependency)</h2><blockquote><p>依赖关系的定义为：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。</p></blockquote><p>依赖(Dependency)关系是类与类之间的联接，表示一个类依赖于另一个类的定义。<strong>一般而言，依赖关系在Java语言中体现为局域变量、方法的形参，或者对静态方法的调用。</strong></p><p>依赖关系用一条带箭头的虚线表示（A依赖于B）。</p><img src="/images/pattern/17.jpg" alt="21" style="zoom:100%;" /><h2 id="2-2-关联-association"><a href="#2-2-关联-association" class="headerlink" title="2.2 关联(association)"></a>2.2 关联(association)</h2><blockquote><p>对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。</p></blockquote><p><strong>关联关系分为单向关联和双向关联。</strong></p><ul><li>单向关联表现为：类A当中使用了类B，其中类B是作为类A的成员变量。</li><li>双向关联表现为：类A当中使用了类B作为成员变量；同时类B中也使用了类A作为成员变量。</li></ul><p>关联(Association）关系是类与类之间的联接，它使一个类知道另一个类的属性和方法。<strong>关联关系一般使用成员变量来实现。</strong></p><p><strong>注意：</strong></p><ol><li>java双向关联关系代码样例会抛出java.lang.StackOverflowError(未实验)</li><li>在OC中双向关联时，注意不要引起循环导入(会编译报错的)</li></ol><p>关联关系用一条带箭头的实线表示（表示A关联了B，但 B没关联A）。</p><img src="/images/pattern/18.jpg" alt="21" style="zoom:100%;" /><h2 id="2-3-聚合-aggregation"><a href="#2-3-聚合-aggregation" class="headerlink" title="2.3 聚合(aggregation)"></a>2.3 聚合(aggregation)</h2><blockquote><p><strong>聚合关系是关联关系的一种</strong>，耦合度强于关联，他们的代码表现是相同的，仅仅是在语义上有所区别：关联关系的对象间是相互独立的，而聚合关系的对象之间存在着包容关系，他们之间是“整体-个体”的相互关系。</p></blockquote><p>聚合(Aggregation) 是<strong>强的关联关系。聚合是整体和个体之间的关系。</strong>与关联关系一样，<strong>聚合关系也是通过实例变量实现的。</strong>但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。</p><p><strong>例如：</strong>部门类与员工类，部门由员工组成，部门解散员工照样生活。</p><p>聚合关系用一条带空心菱形箭头的实线表示（A聚合到B上，或者说B由A组成）。</p><img src="/images/pattern/19.jpg" alt="21" style="zoom:100%;" /><h2 id="2-4-组合-composition"><a href="#2-4-组合-composition" class="headerlink" title="2.4 组合(composition)"></a>2.4 组合(composition)</h2><blockquote><p>相比于聚合，组合是一种耦合度更强的关联关系。存在组合关系的类表示“整体-部分”的关联关系。一般来说，为了表示组合关系，<strong>常常会使用构造方法来达到初始化的目的</strong>，在初始化的时候，就将”部分”传入。</p></blockquote><ul><li><strong>它要求普通的聚合关系中”整体”负责”部分”的生命周期，它们之间是共生共死的</strong>，并且”部分”单独存在时没有任何意义。”整体”负责保持”部分“存活，在一些情况下将”部分”湮灭掉</li><li><strong>组合关系是不能共享的，</strong>整体“可以将”部分”传递给另一个对象，由后者负责其的生命周期。换言之，”部分”在每一个时刻只能与一个对象发生组合关系，由后者排他地负责生命周期。部分和整体的生命周期一样。</li></ul><p><strong>举例</strong>：</p><ul><li>公司类与部门类。公司由部门组成，公司破产倒闭，部门则不复存在，没有部门存在，公司也没有了。</li><li>人class与灵魂类、肉体类。当人的生命周期开始时，必须同时有灵魂和肉体；当人的生命周期结束时，灵魂肉体随之消亡；无论是灵魂还是肉体，都不能单独存在，他们必须作为人的组成部分存在。</li></ul><p>组合关系用一条带实心菱形箭头的实线表示（A组成B，或者B由A组成）。</p><img src="/images/pattern/20.jpg" alt="21" style="zoom:100%;" /><h2 id="2-5-泛化-generalization"><a href="#2-5-泛化-generalization" class="headerlink" title="2.5 泛化(generalization)"></a>2.5 泛化(generalization)</h2><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)。</p><p>继承关系为 is-a的关系；反之，两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p><p>泛化关系表现为继承非抽象类；</p><p>类图中，泛化关系用一条带空心三角箭头的实线表示（A继承自B）。</p><img src="/images/pattern/21.jpg" alt="21" style="zoom:100%;" /><h2 id="2-6-实现-realize"><a href="#2-6-实现-realize" class="headerlink" title="2.6 实现(realize)"></a>2.6 实现(realize)</h2><p>实线，又称为细化。表现为继承抽象类；</p><p>类图中，实现关系用一条带空心三角箭头的虚线表示；</p><img src="/images/pattern/23.jpg" alt="23" style="zoom:100%;" /><p><strong>关联、聚合、组合只能配合语义，结合上下文才能够判断出来，而只给出一段代码让我们判断是关联，聚合，还是组合关系，则是无法判断的。</strong></p><h2 id="2-7-关联与继承优缺点对比"><a href="#2-7-关联与继承优缺点对比" class="headerlink" title="2.7 关联与继承优缺点对比"></a>2.7 关联与继承优缺点对比</h2><p>在设计模式中，有一个原则为优先使用组合/聚合，而不是继承。如装饰者模式、桥接模式都是这个原则的体现。</p><p>在《阿里巴巴Java开发手册》中也重申了此设计原则：谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现。不得已使用继承时，必须符合里氏替换原则。</p><p><a href="https://juejin.cn/post/6844903938106343431">为什么阿里巴巴建议开发者谨慎使用继承？</a></p><table><thead><tr><th>关联关系</th><th>继承关系</th></tr></thead><tbody><tr><td>优点：不破坏封装，<strong>更安全</strong>。</td><td>缺点：破坏封装。</td></tr><tr><td>优点：整体类与局部类之间松耦合，彼此相对独立，<strong>灵活性高</strong>。</td><td>缺点：子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性。也称继承具备强侵入性（父类代码侵入子类）</td></tr><tr><td>优点：具有较好的<strong>可扩展性</strong>。</td><td>缺点：支持扩展，但是往往以增加系统结构的复杂度为代价</td></tr><tr><td>优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象</td><td>缺点：不支持动态继承。在运行时，子类无法选择不同的父类</td></tr><tr><td>优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口</td><td>缺点：子类不能改变父类的接口（3.2节 里氏替换原则）</td></tr><tr><td>缺点：整体类不能自动获得和局部类同样的接口</td><td>优点：子类能自动继承父类的接口。（父类封装共性，子类实现特性。继承可以很好的实现代码复用（封装）的功能。）</td></tr><tr><td>缺点：创建整体类的对象时，需要创建所有局部类的对象</td><td>优点：创建子类的对象时，无须创建父类的对象</td></tr></tbody></table><h3 id="继承破坏封装？"><a href="#继承破坏封装？" class="headerlink" title="继承破坏封装？"></a>继承破坏封装？</h3><p>封装：通过公有化方法访问私有化属性，使得数据不容易被任意窜改，常用private修饰属性；</p><p>继承：通过子类继承父类从而获得父类的属性和方法，正常情况下，用protected修饰属性，专门用于给子类继承的，权限一般在本包下和子类里；</p><p>继承破坏了封装：是因为属性的访问修饰符被修改，使得属性在本包和子类里可以任意修改属性的数据，数据的安全性从而得不到保障。</p><h3 id="何时使用继承？"><a href="#何时使用继承？" class="headerlink" title="何时使用继承？"></a>何时使用继承？</h3><ul><li>继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型（<em>是否要使用多态</em>）。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。  —— 《Java编程思想》</li><li>只有当子类真正是超类的子类型时，才适合用继承（<em>从现实语义进行思考</em>）。换句话说，对于两个类A和B，只有当两者之间确实存在is-a关系的时候，类B才应该继续类A。  —— 《Effective Java》</li></ul><h2 id="2-8-补充：委托"><a href="#2-8-补充：委托" class="headerlink" title="2.8 补充：委托"></a>2.8 补充：委托</h2><p>委托：是设计模式中的一项基本技巧。</p><p>有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，它还使我们可以模拟mixin。 —— 维基百科</p><p><em>感觉这个与关联的概念很相似。虽然说委托模式，但应该不算是一种模式。</em></p><h1 id="三、面向对象的七大设计原则"><a href="#三、面向对象的七大设计原则" class="headerlink" title="三、面向对象的七大设计原则"></a>三、面向对象的七大设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><p><strong>OO原则是我们的目标，设计模式是我们的做法</strong>。不过这一切都是为了：松耦合、易复用、方便开发维护。</p><p>SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）是由罗伯特·C·马丁在21世纪早期引入的记忆术首字母缩略字，指代了面向对象编程和面向对象设计的五个基本原则。</p><h2 id="3-1-开放-封闭原则（OCP）"><a href="#3-1-开放-封闭原则（OCP）" class="headerlink" title="3.1 开放-封闭原则（OCP）"></a>3.1 开放-封闭原则（OCP）</h2><h3 id="3-1-1-定义"><a href="#3-1-1-定义" class="headerlink" title="3.1.1 定义"></a>3.1.1 定义</h3><p>开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶提出，他在 1988 年的著作《面向对象软件构造》中提出：<strong>软件实体应当对扩展开放，对修改关闭</strong>，这就是开闭原则的经典定义。</p><p>这里的软件实体包括以下几个部分：</p><ol><li>项目中划分出的模块</li><li>类与接口</li><li>方法</li></ol><p>开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><h3 id="3-1-2-作用"><a href="#3-1-2-作用" class="headerlink" title="3.1.2 作用"></a>3.1.2 作用</h3><p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。</p><ul><li>对软件测试的影响<ul><li>软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。</li></ul></li><li>可以提高代码的可复用性<ul><li>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</li></ul></li><li>可以提高软件的可维护性<ul><li>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</li></ul></li></ul><h3 id="3-1-3-封装变化原则"><a href="#3-1-3-封装变化原则" class="headerlink" title="3.1.3 封装变化原则"></a>3.1.3 封装变化原则</h3><blockquote><p><strong>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</strong>。 —— Header First设计模式</p></blockquote><p>换句话说，如果毎次新的需求一来，都会使某方面的代码发生变化，那么你就可以确定，这部分的代码需要被抽出来，和其他稳定的代码有所区分。</p><p>下面是这个原则的另一种思考方式：“把会变化的部分取出并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分“。使得代码变化的不经意后果变少，变得更有弹性。</p><p>这样的概念很简单，几乎是毎个设计模式背后的精神所在。所有的模式都提供了一套方法让“系统中的某部分改变不会影响其他部分”。</p><h3 id="3-1-4-实现"><a href="#3-1-4-实现" class="headerlink" title="3.1.4 实现"></a>3.1.4 实现</h3><h4 id="抽象约束、封装变化"><a href="#抽象约束、封装变化" class="headerlink" title="抽象约束、封装变化"></a>抽象约束、封装变化</h4><p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>举例：</p><ul><li>如装饰者模式</li><li>简单些的，如下面例子</li></ul><h3 id="3-1-5-举例"><a href="#3-1-5-举例" class="headerlink" title="3.1.5 举例"></a>3.1.5 举例</h3><p>下面以 Windows 的桌面主题为例介绍开闭原则的应用。</p><p>分析：Windows 的主题是桌面背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的桌面主题，也可以从网上下载新的主题。这些主题有共同的特点，可以为其定义一个抽象类（Abstract Subject），而每个具体的主题（Specific Subject）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的，其类图如下所示。</p><img src="/images/pattern/11.png" alt="11" style="zoom:100%;" /><h2 id="3-2-里氏替换原则（LSP）"><a href="#3-2-里氏替换原则（LSP）" class="headerlink" title="3.2 里氏替换原则（LSP）"></a>3.2 里氏替换原则（LSP）</h2><h3 id="对继承的理解"><a href="#对继承的理解" class="headerlink" title="对继承的理解"></a>对继承的理解</h3><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性。</p><p>当对继承体系中的类修改时：</p><ul><li><p>如果修改的是基类：那修改时，必须考虑到所有的子类，否则父类修改后，所有涉及到子类的功能都有可能会产生故障。</p></li><li><p>如果修改的是子类：通过重写父类的方法来完成新的功能写起来虽然简单，但是，其实继承包含这样一层含义：<strong>父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约</strong>，虽然它并不强制要求所有的子类必须遵从这些契约。</p><p>也就是说，如果子类对父类的非抽象方法任意修改：</p><ul><li>会对整个继承体系造成破坏。</li><li>整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</li></ul></li></ul><p>而里氏替换原则就是表达了上面这一层含义。</p><h3 id="3-2-1-定义"><a href="#3-2-1-定义" class="headerlink" title="3.2.1 定义"></a>3.2.1 定义</h3><p>里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》里提出来的，她提出：<strong>继承必须确保超类所拥有的性质在子类中仍然成立</strong>。即<strong>子类型必须能够替换掉它们的父类型</strong>。</p><ul><li>性质1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</li><li>性质2：所有引用基类的地方必须能透明地使用其子类的对象。</li></ul><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。</p><p>里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><h3 id="3-2-2-作用"><a href="#3-2-2-作用" class="headerlink" title="3.2.2 作用"></a>3.2.2 作用</h3><p>里氏替换原则的主要作用如下。</p><ol><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>它避免了继承中重写父类造成的可复用性变差的缺点。</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li><li>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li></ol><h3 id="3-2-3-实现"><a href="#3-2-3-实现" class="headerlink" title="3.2.3 实现"></a>3.2.3 实现</h3><p><font color='red'>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</font>也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>根据上述理解，对里氏替换原则的定义可以总结如下：</p><ul><li><strong>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</strong>（即里氏转换原则要求子类从抽象继承而不是从具体继承）</li><li>子类中可以增加自己特有的方法</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li><li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li></ul><blockquote><p><strong>疑问</strong>：如果子类继承或实现的是抽象类或者接口的话，那只能引用子类了，这还怎么体现“替换”这个原则？</p><p><strong>回答</strong>：此时还需要我们遵循依赖倒置原则，那么在代码运行中，声明的变量、方法的形参应该都是抽象类或者是接口类型的，而实际传递的是抽象类的子类或者接口的实现类。声明-&gt;实际传递，就体现了“替换”的原则。</p></blockquote><p>如果程序违背了里氏替换原则，则继承类的对象，如果在基类出现的地方，替换基类对象，就会出现运行错误。这时其修正方法是：<font color='red'>取消原来的继承关系，重新设计它们之间的关系</font>。</p><h3 id="3-2-4-举例"><a href="#3-2-4-举例" class="headerlink" title="3.2.4 举例"></a>3.2.4 举例</h3><p>下面以“几维鸟不是鸟”为例来说明里氏替换原则。</p><p>分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鸟类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> flySpeed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpeed</span><span class="params">(<span class="keyword">double</span> speed)</span> </span>&#123;</span><br><span class="line">        flySpeed = speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getFlyTime</span><span class="params">(<span class="keyword">double</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (distance / flySpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//燕子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Swallow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//几维鸟类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrownKiwi</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpeed</span><span class="params">(<span class="keyword">double</span> speed)</span> </span>&#123;</span><br><span class="line">        flySpeed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行错误的原因是：几维鸟类因为没有飞行的能力，所以重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更抽象的父类，如动物类，然后定义它们奔跑的能力。</p><p>几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。</p><h2 id="3-3-依赖倒置原则（DIP）"><a href="#3-3-依赖倒置原则（DIP）" class="headerlink" title="3.3 依赖倒置原则（DIP）"></a>3.3 依赖倒置原则（DIP）</h2><h3 id="3-3-1-定义"><a href="#3-3-1-定义" class="headerlink" title="3.3.1 定义"></a>3.3.1 定义</h3><p>依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特·马丁于 1996 年在 C++ Report 上发表的文章。</p><p>依赖倒置原则的原始定义为：<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象</strong>。</p><ul><li>高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。</li><li>在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现接口或继承抽象类的类，其特点就是可以直接被实例化。</li></ul><p>其核心思想是：<strong>要面向接口编程，不要面向实现编程</strong>。</p><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p><p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p><p>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p><h3 id="3-3-2-作用"><a href="#3-3-2-作用" class="headerlink" title="3.3.2 作用"></a>3.3.2 作用</h3><p>依赖倒置原则的主要作用如下：</p><ul><li>依赖倒置原则可以降低类间的耦合性。</li><li>依赖倒置原则可以提高系统的稳定性。</li><li>依赖倒置原则可以减少并行开发引起的风险。</li><li>依赖倒置原则可以提高代码的可读性和可维护性。</li></ul><h3 id="3-3-3-实现"><a href="#3-3-3-实现" class="headerlink" title="3.3.3 实现"></a>3.3.3 实现</h3><p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。</p><ul><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>模块间的依赖关系都通过接口或抽象类产生，即形参、变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体/实现类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ul><p>代表：工厂模式</p><h3 id="3-3-4-举例"><a href="#3-3-4-举例" class="headerlink" title="3.3.4 举例"></a>3.3.4 举例</h3><p>下面以“顾客购物程序”为例来说明依赖倒置原则的应用。</p><p>分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(ShaoguanShop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(WuyuanShop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(Shop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了</p><h3 id="3-3-5-好莱坞原则"><a href="#3-3-5-好莱坞原则" class="headerlink" title="3.3.5 好莱坞原则"></a>3.3.5 好莱坞原则</h3><p>依赖倒置原则，延伸出一个好莱坞原则。</p><blockquote><p>别调用（打电话给）我们，我们会调用（打电话给）你。</p><p>在好莱坞，演员把简历递交给演艺公司后就只有回家等待。由演艺公司（<strong>高层</strong>）对整个娱乐项的完全控制，演员（<strong>底层</strong>）只能被动式的接受公司的差使，在需要的环节中，完成自己的演出。</p></blockquote><p>好莱坞原则可以给我们一种防止“依赖腐败”的方法。当高层组件依赖低层组件，而低层组件又依赖高层组件，而高层组件又依赖边侧组件，而边侧组件又依赖低层组件时，依赖腐败就发生了。在这种情况下，没有人可以轻易地搞懂系统是如何设计的。</p><p>在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。换句话说，<strong>高层组件对待低层组件的方式是“别调用我们，我们会调用你”。尽量避免向上调用和相互调用</strong>。</p><ul><li>低层组件可以参与计算，但是高层组件控制何时以及如何让底层组件参与</li><li>低层组件绝对不可以直接调用高阶组件</li></ul><p>代表：模板方法模式</p><ul><li>由超类主控一切，当它们需要的时候，自然会去调用子类 — Header First设计模式</li><li><strong>因为要重写父类的方法，为了不违背里氏替换原则，那就是将要重写的父类中的方法声明为抽象方法。</strong></li></ul><blockquote><p>个人疑问：超类相比于子类，算是高层组件么？</p><p>Header First设计模式中：所谓“高层组件”，是由其他低层组件定义其行为的类。</p></blockquote><h2 id="3-4-单一职责原则（SRP）"><a href="#3-4-单一职责原则（SRP）" class="headerlink" title="3.4 单一职责原则（SRP）"></a>3.4 单一职责原则（SRP）</h2><h3 id="3-4-1-定义"><a href="#3-4-1-定义" class="headerlink" title="3.4.1 定义"></a>3.4.1 定义</h3><p>单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁 于《敏捷软件开发：原则、模式和实践》一书中提出的。</p><p>单一职责原则规定<strong>一个类应该只有一个引起它变化的原因</strong>，否则类应该被拆分。</p><blockquote><p>职责、改变的联系？<strong>类的每个责任都有改变的潜在区域。超过一个责任，就意味着超过一个改变的区域。</strong></p></blockquote><p>比如我们设计一个类不但要管理某种聚合，还要负责相关的操作和遍历。那么如果这个集合改变，这个类也必须改变；如果我们遍历的方式改变的话，这个类也必须跟着改变。</p><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p><ol><li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</li><li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li></ol><p>这个原则就在告诉我们，<strong>尽量让每个类保持单一责任</strong>。没错，这听起来很容易，但做起来并不简单：<strong>区分设计中的责任，是最困难的事情之一。</strong>我们的大脑很习惯看着一大群的行为，然后将它们集中化一起，尽管他们可能属于两个或多个不同的责任。想要成功的唯一方法，就是努力不懈地检查你的设计，随件系统的成长，随时观察有没有迹象显示某个类改变的原因超出一个。</p><p>注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</p><h3 id="3-4-2-作用"><a href="#3-4-2-作用" class="headerlink" title="3.4.2 作用"></a>3.4.2 作用</h3><p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。</p><ul><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li><li>提高类的可读性。复杂性降低，自然其可读性会提高。</li><li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li><li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><h3 id="3-4-3-实现"><a href="#3-4-3-实现" class="headerlink" title="3.4.3 实现"></a>3.4.3 实现</h3><p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p><p>代表：迭代器模式</p><h3 id="3-4-4-举例"><a href="#3-4-4-举例" class="headerlink" title="3.4.4 举例"></a>3.4.4 举例</h3><p>下面以大学学生工作管理程序为例介绍单一职责原则的应用。</p><p>析：大学学生工作主要包括学生生活辅导和学生学业指导两个方面的工作，其中生活辅导主要包括班委建设、出勤统计、心理辅导、费用催缴、班级管理等工作，学业指导主要包括专业引导、学习辅导、科研指导、学习总结等工作。如果将这些工作交给一位老师负责显然不合理，正确的做法是生活辅导由辅导员负责，学业指导由学业导师负责。</p><img src="/images/pattern/12.png" alt="12" style="zoom:85%;" /><h2 id="3-5-接口隔离原则（ISP）"><a href="#3-5-接口隔离原则（ISP）" class="headerlink" title="3.5 接口隔离原则（ISP）"></a>3.5 接口隔离原则（ISP）</h2><h3 id="3-5-1-定义"><a href="#3-5-1-定义" class="headerlink" title="3.5.1 定义"></a>3.5.1 定义</h3><p>接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p><p>2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：<strong>客户端不应该被迫依赖于它不使用的方法</strong>。</p><p>该原则还有另外一个定义：<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong>。</p><p>以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大(臃肿)的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><ul><li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li><li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li></ul><h3 id="3-5-2-作用"><a href="#3-5-2-作用" class="headerlink" title="3.5.2 作用"></a>3.5.2 作用</h3><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p><ol><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ol><h3 id="3-5-3-实现"><a href="#3-5-3-实现" class="headerlink" title="3.5.3 实现"></a>3.5.3 实现</h3><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><h3 id="3-5-4-举例"><a href="#3-5-4-举例" class="headerlink" title="3.5.4 举例"></a>3.5.4 举例</h3><p>下面以学生成绩管理程序为例介绍接口隔离原则的应用。</p><p>分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中。</p><img src="/images/pattern/13.png" alt="13" style="zoom:75%;" /><h2 id="3-6-迪米特法则（LoD）"><a href="#3-6-迪米特法则（LoD）" class="headerlink" title="3.6 迪米特法则（LoD）"></a>3.6 迪米特法则（LoD）</h2><h3 id="3-6-1-定义"><a href="#3-6-1-定义" class="headerlink" title="3.6.1 定义"></a>3.6.1 定义</h3><p>迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学的一个名为迪米特的研究项目，由伊恩·荷兰提出，被 UML 创始者之一的布奇普及，后来又因为在经典著作《程序员修炼之道》提及而广为人知。</p><p>迪米特法则的定义是：<strong>只与你的直接朋友交谈，不跟“陌生人”说话</strong>。</p><ul><li><p>这个原则告诉我们要<strong>减少对象之间的交互，一个对象应当对其他对象有尽可能少的了解，只留下几个“密友”</strong>。</p></li><li><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三方转发该调用。</p></li><li><p>“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p></li></ul><p>其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响到其他部分。如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，它需要话很多成本维护，也会以为太复杂而不容易被其他人了解。</p><h3 id="3-6-2-作用"><a href="#3-6-2-作用" class="headerlink" title="3.6.2 作用"></a>3.6.2 作用</h3><p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。</p><ol><li>降低了类之间的耦合度，提高了模块的相对独立性。</li><li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li></ol><p>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p><h3 id="3-6-3-实现"><a href="#3-6-3-实现" class="headerlink" title="3.6.3 实现"></a>3.6.3 实现</h3><p>从迪米特法则的定义和特点可知，它强调以下两点：</p><ol><li>从依赖者的角度来说，只依赖应该依赖的对象。</li><li>从被依赖者的角度说，只暴露应该暴露的方法。</li></ol><p>所以，在运用迪米特法则时要注意以下 6 点。</p><ol><li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li><li>在类的结构设计上，尽量降低类成员的访问权限。</li><li>在类的设计上，优先考虑将一个类设置成不变类。</li><li>在对其他类的引用上，将引用其他对象的次数降到最低。</li><li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li><li>谨慎使用序列化（Serializable）功能。</li></ol><p>代表：外观模式、中介者模式</p><h3 id="3-6-4-举例"><a href="#3-6-4-举例" class="headerlink" title="3.6.4 举例"></a>3.6.4 举例</h3><p>明星与经纪人的关系实例。</p><p>分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><img src="/images/pattern/14.png" alt="14" style="zoom:85%;" /><h2 id="3-7-合成复用原则（CRP）"><a href="#3-7-合成复用原则（CRP）" class="headerlink" title="3.7 合成复用原则（CRP）"></a>3.7 合成复用原则（CRP）</h2><h3 id="3-7-1-定义"><a href="#3-7-1-定义" class="headerlink" title="3.7.1 定义"></a>3.7.1 定义</h3><blockquote><p>“有一个”比”是一个”更好。（有些地方不将其列入设计原则，太过具体）</p></blockquote><p>合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时：</p><ul><li><p>要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p></li><li><p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p></li></ul><h3 id="3-7-2-作用"><a href="#3-7-2-作用" class="headerlink" title="3.7.2 作用"></a>3.7.2 作用</h3><p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。</p><ol><li>它维持了类的封装性。因为成员对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成员对象的唯一方法是通过成员对象的接口。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的对象。</li></ol><h3 id="3-7-3-实现"><a href="#3-7-3-实现" class="headerlink" title="3.7.3 实现"></a>3.7.3 实现</h3><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p><p>代表：策略模式。</p><h3 id="3-7-4-举例"><a href="#3-7-4-举例" class="headerlink" title="3.7.4 举例"></a>3.7.4 举例</h3><p>下面以汽车分类管理程序为例来介绍合成复用原则的应用。</p><p>分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。下图就是用继承关系实现的汽车分类的类图。</p><img src="/images/pattern/15.png" alt="15" style="zoom:80%;" /><p>可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如下所示。</p><img src="/images/pattern/16.png" alt="16" style="zoom:80%;" /><h2 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a>3.8 小结</h2><p>这 7 种设计原则是软件设计模式必须尽量遵循的原则，是设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，而是要综合考虑人力、时间、成本、质量，不刻意追求完美，要在适当的场景遵循设计原则。这体现的是一种平衡取舍，可以帮助我们设计出更加优雅的代码结构。</p><p>各种原则要求的侧重点不同，下面我们分别用一句话归纳总结软件设计模式的七大原则，如下表所示。</p><table><thead><tr><th>设计原则</th><th>一句话归纳</th><th>目的</th></tr></thead><tbody><tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>降低维护带来的新风险</td></tr><tr><td>里氏替换原则</td><td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td><td>防止继承泛滥</td></tr><tr><td>依赖倒置原则</td><td>高层不应该依赖低层，要面向接口编程</td><td>更利于代码结构的升级扩展</td></tr><tr><td>单一职责原则</td><td>一个类只干一件事，实现类要单一</td><td>便于理解，提高代码的可读性</td></tr><tr><td>接口隔离原则</td><td>一个接口只干一件事，接口要精简单一</td><td>功能解耦，高聚合、低耦合</td></tr><tr><td>迪米特法则</td><td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td><td>只和朋友交流，不和陌生人说话，减少代码臃肿</td></tr><tr><td>合成复用原则</td><td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td><td>降低代码耦合</td></tr></tbody></table><p>实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。</p><h1 id="四、设计模式分类"><a href="#四、设计模式分类" class="headerlink" title="四、设计模式分类"></a>四、设计模式分类</h1><p>根据设计模式之间的共性(功能、针对的角色等角度)，可以把设计模式分为几类，常见的有两种分类：</p><img src="/images/pattern/30.png" alt="30" style="zoom:100%;" /><p>了解分类有利于我们理解、思考、比较、选型。</p><h2 id="4-1-根据作用范围分类"><a href="#4-1-根据作用范围分类" class="headerlink" title="4.1 根据作用范围分类"></a>4.1 根据作用范围分类</h2><p>根据模式主要是作用在类上，还是对象上，或者说所处理的是类还是对象，可以分为：</p><ul><li>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。<ul><li>即在类模式类图中，一般只存在继承和实现、依赖。</li></ul></li><li>对象模式：用于处理对象之间的关系，这些关系可以通过关联、组合或聚合来实现，在运行时刻是可以变化的，更具动态性。<ul><li>即在对象模式类图中，会存在关联、聚合、组合关系。</li><li>换句话说，只要存在对象的聚合或组合关系(对象存在关联关系)，就叫做对象创建模式</li></ul></li></ul><p>根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分设计模式都属于对象型设计模式。</p><h2 id="4-2-根据功能分类"><a href="#4-2-根据功能分类" class="headerlink" title="4.2 根据功能分类"></a>4.2 根据功能分类</h2><h3 id="4-2-1-创建型模式"><a href="#4-2-1-创建型模式" class="headerlink" title="4.2.1 创建型模式"></a>4.2.1 创建型模式</h3><ul><li>类创建型模式：处理类的创建。</li><li>对象创建型模式：处理对象的创建。</li></ul><p>详细地说，对象创建型模式把对象的部分创建的工作推迟到另一个对象中，而类创建型模式将它推迟到子类中。</p><p><em>除了工厂模式是类创建模式，其它都是对象创建型模式。</em></p><blockquote><p>疑问：抽象工厂中看着没有涉及对象关联关系，为什么是对象创建型模式呢？</p><p>在<a href="https://blog.csdn.net/wan2083/article/details/1482894">某处</a>看到另一种解读(正确性不确定…)：</p><ul><li><p>类创建型模式：只需要知道创建产品的类或类层次结构，就可以创建出相应的对象。调用者只需要看到创建对象的类，而不需要知道自己将会得到什么样的一个对象。在这里体现出了，<strong>调用者要知道创建对象的类</strong>。</p></li><li><p>对象创建型模式：调用者通过一个函数来创建对象，所以调用者必须知道自己将要得到什么样的对象，只要知道将要得到对象的特征就行了，将其传给工厂方法来获得要的对象。在这里体现出了，<strong>调用者要知道对象的特征</strong>。</p></li></ul></blockquote><h3 id="4-2-2-结构型模式"><a href="#4-2-2-结构型模式" class="headerlink" title="4.2.2 结构型模式"></a>4.2.2 结构型模式</h3><ul><li>类结构型模式：关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。 </li><li>对象结构型模式：关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。 </li></ul><p><em>除了Adapter(类)模式是类结构型模式，其它包括Adapter(对象)模式等都是对象结构型模式。</em></p><h3 id="4-2-3-行为型模式"><a href="#4-2-3-行为型模式" class="headerlink" title="4.2.3 行为型模式"></a>4.2.3 行为型模式</h3><ul><li>类行为型模式：主要通过继承、多态等方式来分配父类与子类的职责。</li><li>对象行为型模式：主要是通过对象关联等方式来分配两个或多个类的职责。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。</li></ul><p><em>除了解释器、模板方法模式是类行为型模式，其它都是对象行为型模式。</em></p><h1 id="五、创建型模式-怎么创建对象"><a href="#五、创建型模式-怎么创建对象" class="headerlink" title="五、创建型模式(怎么创建对象)"></a>五、创建型模式(怎么创建对象)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象。通俗的说，就是用于<strong>描述“怎样创建对象”</strong>，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。</p><p>为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p><ul><li><p>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p></li><li><p>创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时指定。</p></li><li><p>通常应该是工厂方法开始，当设计者设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地。</p></li></ul><h2 id="5-1-简单工厂模式-生产多个类对象"><a href="#5-1-简单工厂模式-生产多个类对象" class="headerlink" title="5.1 简单工厂模式(生产多个类对象)"></a>5.1 简单工厂模式(生产多个类对象)</h2><blockquote><p><strong>简而言之：一个工厂类 负责创建 多个具体类的对象（是同一父类）。</strong>  （因为太简单了？不计入23种设计模式之列）</p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在简单工厂模式中创建实例的方法通常为静态（static）方法，所以简单工厂模式(Simple Factory Pattern)又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p><p>在简单工厂模式中，可以<strong>根据参数的不同返回不同类的实例</strong>。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>简单工厂模式包含如下角色：</p><ul><li>工厂角色(Factory)：负责实现创建所有实例的内部逻辑；工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li>抽象产品(Product)：是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；</li><li>具体产品(ConcreteProduct)：是具体类，其实例也就是我们的创建目标。</li></ul><img src="/images/pattern/24.jpg" alt="24" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Product* <span class="title">Factory::createProduct</span><span class="params">(string proname)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;A&quot;</span> == proname )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;B&quot;</span> == proname)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p><p>优点：</p><ul><li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</li><li>在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，可以减少使用者的记忆量。</li><li>在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。</li></ul><p>缺点：</p><ul><li>简单工厂模式最大的问题在于工厂类的职责相对过重，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。违背高聚合原则。</li><li>当增加新的产品时，需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><h2 id="5-2-工厂方法模式-生产单个类对象"><a href="#5-2-工厂方法模式-生产单个类对象" class="headerlink" title="5.2 工厂方法模式(生产单个类对象)"></a>5.2 工厂方法模式(生产单个类对象)</h2><blockquote><p><strong>简而言之，一个工厂子类 负责创建 一个具体类的对象。</strong></p></blockquote><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。</p><p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><p>当出现新的具体类时，只需要为其新创建一个具体的工厂类就可以获得该新类的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p>工厂方法模式包含如下角色：</p><ul><li>Product：抽象产品</li><li>ConcreteProduct：具体产品</li><li>Factory：抽象工厂</li><li>ConcreteFactory：具体工厂</li></ul><p><strong>具体工厂同具体产品之间是一对一的关系</strong>。</p><img src="/images/pattern/25.png" alt="25" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  AbstractFactory * fc = <span class="keyword">new</span> <span class="built_in">ConcreteFactory1</span>();</span><br><span class="line">  Product * prod = fc-&gt;<span class="built_in">newProduct</span>();</span><br><span class="line">  prod-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> fc;</span><br><span class="line">  <span class="keyword">delete</span> prod;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><p>优点：</p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程，甚至无须知道具体产品类的类名。</li><li>灵活性增强，对于新产品的创建，无须修改原来代码，只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li><li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li></ul><p>缺点：</p><ul><li>类的个数容易过多，增加系统的复杂度、编译开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。</li><li>抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。</li></ul><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>客户只关心产品的品牌，不关心创建产品的细节。</li><li>客户只知道创建产品的工厂名，而不知道具体的产品名。</li><li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂类只提供创建产品的接口。</li></ul><h3 id="实例-—-日志记录器"><a href="#实例-—-日志记录器" class="headerlink" title="实例 — 日志记录器"></a>实例 — 日志记录器</h3><p>某系统日志记录器要求支持多种日志记录方式，如文件记录、数据库记录等，且用户可以根据要求动态选择日志记录方式， 现使用工厂方法模式设计该系统。</p><img src="/images/pattern/26.jpg" alt="26" style="zoom:80%;" /><h2 id="5-3-抽象工厂模式-生产一个产品族"><a href="#5-3-抽象工厂模式-生产一个产品族" class="headerlink" title="5.3 抽象工厂模式(生产一个产品族)"></a>5.3 抽象工厂模式(生产一个产品族)</h2><blockquote><p><strong>简而言之，一个工厂子类 负责创建 一个产品族 (同一个工厂生产的，位于不同产品继承结构中的一组产品)</strong></p></blockquote><h3 id="概念：产品等级结构、产品族"><a href="#概念：产品等级结构、产品族" class="headerlink" title="概念：产品等级结构、产品族"></a>概念：产品等级结构、产品族</h3><p>为了更清晰地理解工厂方法模式，需要先引入两个概念：</p><ul><li><strong>产品等级结构</strong> ：产品等级结构即<strong>产品的继承结构</strong>，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构。</li><li><strong>产品族</strong> ：在抽象工厂模式中，<strong>产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品</strong>。<ul><li>商业中，产品族一般是指同一家公司以同一品牌生产的一组相关产品。一个公司可能会创建一个产品系列来利用现有客户对其原有品牌的忠诚度。</li></ul></li></ul><p>如海尔电器工厂生产的海尔电视机、海尔电冰箱，这是一个产品族。</p><p>而海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p><img src="/images/pattern/27.png" alt="27" style="zoom:80%;" /><blockquote><p>族：事物有共同属性的一大类；种族(共同起源)、民族(共同语言、文化)、宗族(共同血缘)、家族(同姓)。</p><p>簇：相当于“丛”，密集的或长在一块儿但不粘在一起的一丛</p><p>族，某些场景，又称簇(family) ？</p><p>也可指<strong>具有相同或相似的功能结构或性能，共享主要的产品特征、组件或者子结构</strong>，并通过<strong>变型配置</strong>来满足特定市场的一组产品的聚类。</p><p>类簇：类簇是Foundation框架中广泛使用的设计模式。类簇将一些私有的、具体的子类组合在一个公共的、抽象的超类下面，以这种方法来组织类可以简化一个面向对象框架的公开架构，而又不减少功能的丰富性。</p></blockquote><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构"><a href="#标准结构" class="headerlink" title="标准结构"></a>标准结构</h4><p>抽象工厂模式包含如下角色：</p><ul><li>抽象工厂(Abstract Factory)：包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂(Concrete Factory)</li><li>抽象产品(Abstract Product)：抽象工厂模式有多个抽象产品。</li><li>具体产品(ConcreteProduct)</li></ul><p><strong>具体工厂同具体产品之间是一对多的关系</strong>。</p><img src="/images/pattern/28.jpg" alt="28" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  AbstractFactory * fc  = <span class="keyword">new</span> <span class="built_in">ConcreteFactory1</span>();</span><br><span class="line">  AbstractProductA * pa = fc-&gt;<span class="built_in">createProductA</span>();</span><br><span class="line">  AbstractProductB * pb = fc-&gt;<span class="built_in">createProductB</span>();</span><br><span class="line">  pa-&gt;<span class="built_in">use</span>();</span><br><span class="line">  pb-&gt;<span class="built_in">eat</span>();</span><br><span class="line"></span><br><span class="line">  AbstractFactory * fc2  = <span class="keyword">new</span> <span class="built_in">ConcreteFactory2</span>();</span><br><span class="line">  AbstractProductA * pa2 = fc2-&gt;<span class="built_in">createProductA</span>();</span><br><span class="line">  AbstractProductB * pb2 = fc2-&gt;<span class="built_in">createProductB</span>();</span><br><span class="line">  pa2-&gt;<span class="built_in">use</span>();</span><br><span class="line">  pb2-&gt;<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="退化的工厂"><a href="#退化的工厂" class="headerlink" title="退化的工厂"></a>退化的工厂</h4><p>当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p><p>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p><h3 id="优缺点-开闭原则的倾斜性"><a href="#优缺点-开闭原则的倾斜性" class="headerlink" title="优缺点(开闭原则的倾斜性)"></a>优缺点(开闭原则的倾斜性)</h3><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p><ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li><li>抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。</li></ul><p>其缺点是：抽象工厂模式的扩展有一定的“开闭原则”倾斜性。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。而抽象工厂模式扩展时：</p><ol><li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li><li>当产品族中需要增加一个新种类的产品时，或者说增加一个新的产品等级时，所有的工厂类都需要进行修改，不满足开闭原则。</li></ol><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>使用抽象工厂模式一般要满足以下条件。</p><ul><li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li><li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。如有人只喜欢穿某一个品牌的衣服和鞋。</li></ul><h2 id="5-4-建造者-生成器模式-不同配置"><a href="#5-4-建造者-生成器模式-不同配置" class="headerlink" title="5.4 建造者/生成器模式(不同配置)"></a>5.4 建造者/生成器模式(不同配置)</h2><blockquote><p><strong>简而言之：多个建造者子类 负责创建 同一个具体类对象。每个建造者子类 负责创建 不同的该类对象的配置</strong></p><p>比如：建造者是在创建KFC套餐。抽象建造者规定要创建：主食+饮料。其中一个建造者子类创建的是汉堡+果汁；另一个建造者创建的是鸡肉卷+可乐。</p></blockquote><p>在软件开发中，存在一些复杂对象，实例化时存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>造者模式(Builder Pattern)是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><p>它将变与不变相分离，即<strong>产品的组成部分是不变的，但每一部分是可以灵活选择的</strong>。（成员变量们一样，值可以不一样）</p><p>建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</p><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-1"><a href="#标准结构-1" class="headerlink" title="标准结构"></a>标准结构</h4><p>建造者模式包含如下角色：</p><ul><li><p>指挥者(Director)：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</p></li><li><p>抽象建造者(Builder)：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</p></li><li><p>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。<strong>一个具体建造者会创建一种不同的产品对象(组成部分相同，数据不同)。</strong></p></li><li><p>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。</p></li></ul><p><strong>具体建造者同具体产品之间是多对一的关系（一个具体产品有多种建造方式）</strong>。</p><img src="/images/pattern/29.jpg" alt="29" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_a,m_b,m_c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Product</span>()&#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Product</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setA</span><span class="params">(string str)</span></span>&#123; m_a = str; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setB</span><span class="params">(string str)</span></span>&#123; m_b = str; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setC</span><span class="params">(string str)</span></span>&#123; m_c = str; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;product has&quot;</span> &lt;&lt; m_a &lt;&lt; m_b &lt;&lt; m_c &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Product * m_prod;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Builder</span>() &#123; m_prod = <span class="keyword">new</span> <span class="built_in">Product</span>(); &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Builder</span>()&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Product * <span class="title">getResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_prod; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span>:</span> <span class="keyword">public</span> Builder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ConcreteBuilder</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ConcreteBuilder</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">//不同的建造者，可以实现不同产品的建造  </span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>&#123;  m_prod-&gt;<span class="built_in">setA</span>(<span class="string">&quot;A Style &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>&#123;  m_prod-&gt;<span class="built_in">setB</span>(<span class="string">&quot;B Style &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>&#123;  m_prod-&gt;<span class="built_in">setC</span>(<span class="string">&quot;C style &quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Builder * m_pbuilder;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Director</span>()&#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Director</span>()&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setBuilder</span><span class="params">(Builder* buider)</span></span>&#123;  m_pbuilder = buider;  &#125;</span><br><span class="line">  <span class="function">Product* <span class="title">constuct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m_pbuilder-&gt;<span class="built_in">buildPartA</span>();</span><br><span class="line">    m_pbuilder-&gt;<span class="built_in">buildPartB</span>();</span><br><span class="line">    m_pbuilder-&gt;<span class="built_in">buildPartC</span>();</span><br><span class="line">    <span class="keyword">return</span> m_pbuilder-&gt;<span class="built_in">getResult</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ConcreteBuilder * builder = <span class="keyword">new</span> <span class="built_in">ConcreteBuilder</span>();</span><br><span class="line">  Director director;</span><br><span class="line">  director.<span class="built_in">setBuilder</span>(builder);</span><br><span class="line">  Product * pd =  director.<span class="built_in">construct</span>();</span><br><span class="line">  pd-&gt;<span class="built_in">show</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> builder;</span><br><span class="line">  <span class="keyword">delete</span> pd;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：</p><ol><li>隔离了客户与生产过程；</li><li>负责控制产品的生成过程。</li></ol><p>指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p><h4 id="简化结构"><a href="#简化结构" class="headerlink" title="简化结构"></a>简化结构</h4><ul><li>省略抽象建造者角色：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。</li><li>省略指挥者角色：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让Builder角色扮演指挥者与建造者双重角色。</li></ul><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>封装性好，构建和表示分离。在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得<strong>相同的创建过程</strong>可以创建不同的产品对象。</li><li>扩展性好，符合“开闭原则”：<ul><li>各个具体的建造者相互独立，有利于系统的解耦。可以很方便地替换具体建造者或增加新的具体建造者， 使用<strong>不同的具体建造者</strong>即可创建不同的产品对象。</li><li>指挥者类针对抽象建造者类编程，增加新的具体建造者无须修改原有类库的代码。</li></ul></li><li><strong>可以更加精细地控制产品的创建过程</strong> 。建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li></ul><p>缺点：</p><ul><li><strong>产品的组成部分必须相同</strong>，这限制了其使用范围。</li><li>如果产品内部复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li><li>如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li></ul><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用建造者模式：</p><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li>隔离复杂对象的创建和使用，并使得<strong>相同的创建过程可以创建不同的产品</strong>。</li></ul><p>在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。</p><h3 id="比较：与工厂模式的不同"><a href="#比较：与工厂模式的不同" class="headerlink" title="比较：与工厂模式的不同"></a>比较：与工厂模式的不同</h3><p>建造者（Builder）模式和工厂模式的关注点不同：</p><ul><li>工厂方法模式更注重零部件的创建过程(<strong>一步生成</strong>)；</li><li>建造者模式注重零部件的组装过程，它侧重于<strong>一步步构造</strong>一个复杂对象，返回一个完整的对象；</li></ul><p>但两者可以结合使用。</p><p>与抽象工厂模式的差别就更多了:</p><ul><li>与抽象工厂模式相比， <strong>建造者模式返回一个组装好的完整产品</strong> ，而 <strong>抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</strong></li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤。</li><li>如果将抽象工厂模式看成 <strong>汽车配件生产工厂</strong> ，生产一个产品族的产品，那么建造者模式就是一个 <strong>汽车组装工厂</strong> ，通过对部件的组装可以返回一辆完整的汽车。</li></ul><h2 id="5-5-单例模式"><a href="#5-5-单例模式" class="headerlink" title="5.5 单例模式"></a>5.5 单例模式</h2><p>在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。</p><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>单例模式(Singleton Pattern)是指一个类只有一个实例，且该类能自行创建这个实例并向整个系统提供使用的一种模式。</p><p>单例模式的要点有三个：</p><ol><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点。</li></ol><p>单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p>单例模式包含如下角色：</p><ul><li>Singleton：单例</li></ul><img src="/images/pattern/31.jpg" alt="Singleton" style="zoom:100%;" /><p>在单例模式的实现过程中，需要注意如下三点：</p><ul><li>单例类的构造函数为私有，确保用户无法通过new关键字直接实例化它。</li><li>提供一个自身的静态私有成员变量；</li><li>提供一个公有的静态工厂方法。</li></ul><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>单例模式可以保证内存里只有一个实例，减少了内存上的开销。</li><li>对于一些需要频繁创建和销毁、实例化过程很占用资源的对象，单例模式无疑可以提高系统的性能。</li><li>单例模式设置全局访问点，所以它可以严格控制客户怎样以及何时访问它，可以优化和共享资源的访问。</li><li>扩展：允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><p>缺点：</p><ul><li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li><li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li><li>滥用单例将带来一些负面问题，如：<ul><li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li><li>为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</li><li>现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul></li></ul><h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用单例模式：</p><ul><li>系统中要求一个类只有一个实例对象。比如：<ul><li>业务限制：一个班中的班长、每个人的身份证号、系统中唯一的序列号生成器等。</li><li>系统限制：该类的实例，会占用过多的资源，只允许创建一个对象。</li></ul></li><li>类对象，频繁实例化，又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li><li>类对象，实例化时会占用较多的资源，或耗时较长，且经常使用。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>扩展：如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</li></ul><h2 id="5-6-原型模式-clone对象"><a href="#5-6-原型模式-clone对象" class="headerlink" title="5.6 原型模式(clone对象)"></a>5.6 原型模式(clone对象)</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。</p><p>用这种方式创建对象非常高效，根本无须知道对象创建的细节。</p><h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p>原型模式包含以下主要角色。</p><ol><li>抽象原型类：规定了具体原型对象必须实现的接口。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ol><img src="/images/pattern/32.png" alt="32" style="zoom:100%;" /><p>原型模式的克隆分为浅克隆和深克隆。</p><ul><li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li><li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li></ul><p>Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。</p><p>OC 中的 NSCopying 协议也指定了 copyWithZone() 方法，具体类需要遵循此协议，实现方法。</p><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>在某些环境下，复制对象比创建一个新对象，性能上更加优良。</li></ul><p>缺点：</p><ul><li>需要为每一个类都配置一个 clone 方法</li><li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li><li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li></ul><h3 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h3><p>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</p><h1 id="六、结构型模式-怎么组成更大的结构"><a href="#六、结构型模式-怎么组成更大的结构" class="headerlink" title="六、结构型模式(怎么组成更大的结构)"></a>六、结构型模式(怎么组成更大的结构)</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>结构型模式(Structural Pattern)用于<strong>描述如何将类或对象按某种布局组成更大的结构</strong>。就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。</p><p>或者说，结构型模式是描述怎样组装现有的类，设计他们的交互方式，从而达到实现一定的功能的目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）、封装性（适配器，桥接）。</p><p>如装饰、代理、外观、适配器、组合、桥接、享元等 7 种结构型模式。</p><h2 id="6-1-装饰模式-功能扩展"><a href="#6-1-装饰模式-功能扩展" class="headerlink" title="6.1 装饰模式(功能扩展)"></a>6.1 装饰模式(功能扩展)</h2><p>一般有两种方式可以实现给一个类或对象增加行为：</p><ul><li>继承机制：子类在拥有父类方法的同时，还可以拥有自身方法。</li><li>关联机制：将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)。（或者说装饰器对象包裹原始对象）</li></ul><p><em>关联机制扩展功能相比继承的优点见下文。</em></p><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p><p>其别名也可以称为包装器(Wrapper)，根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p><h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-2"><a href="#标准结构-2" class="headerlink" title="标准结构"></a>标准结构</h4><p>装饰器模式主要包含以下角色。</p><ol><li>抽象构件类（Component）：定义一个抽象接口，以规范准备接收附加责任的对象。</li><li>具体构件类（ConcreteComponent）：实现抽象构件。将会通过装饰角色为其添加一些职责</li><li>抽象装饰类（Decorator）：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰类（ConcreteDecorator）：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ol><img src="/images/pattern/33.jpg" alt="33" style="zoom:100%;" /><ul><li>一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类对其进行扩展。 </li></ul><h4 id="简化结构-1"><a href="#简化结构-1" class="headerlink" title="简化结构"></a>简化结构</h4><p>装饰器模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如：</p><ul><li>简化1：如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。</li><li>简化2：如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span> </span>&#123; syso(<span class="string">&quot;创建具体构件角色&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span>    </span>&#123; syso(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123; <span class="keyword">this</span>.component = component; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span>               </span>&#123; component.operation(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123; <span class="keyword">super</span>(component); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        syso(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component p = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        Component d = <span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><p>装饰模式与继承关系的目的都是要扩展对象的功能。相比于继承，使用装饰器的好处：</p><ul><li>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性。</li><li>继承是一种耦合度较高的静态关系，无法在程序运行时动态扩展。即装饰模式可以提供比继承更多的<strong>灵活性</strong>。可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li><li>当扩展功能增多时，子类会很膨胀。而装饰器模式中，通过使用<strong>不同的具体装饰类</strong>、这些<strong>具体装饰类的排列组合</strong>，可以创造出很多不同行为的组合。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，<strong>符合“开闭原则”</strong>。</li></ul><p>装饰模式的缺点:</p><ul><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</li></ul><h3 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：<ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li><li>第二类是因为类定义不能继承（如final类）.</li></ul></li></ul><h2 id="6-2-代理模式-控制访问"><a href="#6-2-代理模式-控制访问" class="headerlink" title="6.2 代理模式(控制访问)"></a>6.2 代理模式(控制访问)</h2><blockquote><p><strong>核心是控制访问。</strong></p></blockquote><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>代理模式(Proxy Pattern) ：给某对象提供一个代理(也叫替身、占位符)以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><blockquote><p>疑问：从定义来看，代理模式的核心是控制对目标对象的访问，类似服务器中的反向代理(安全防护、负载均衡等)？那正向代理(扩展目标对象的功能，如VPN软件等)算不算代理模式？如果不属于，那正向代理这种对应到软件开发中，应该属于什么模式呢？</p></blockquote><h3 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h3><p>代理模式包含如下角色：</p><ul><li>Subject: 抽象主题角色。声明真实主题和代理对象实现的方法。</li><li>Proxy: 代理主题角色。提供了与真实主题相同的接口，其内部含有对真实主题的引用。控制外部对真实主题的访问。</li><li>RealSubject: 真实主题角色</li></ul><img src="/images/pattern/34.jpg" alt="34" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Proxy::<span class="built_in">Proxy</span>()&#123;</span><br><span class="line">  <span class="comment">//有人觉得 RealSubject对象的创建应该是在main中实现；我认为RealSubject应该</span></span><br><span class="line">  <span class="comment">//对用户是透明的，用户所面对的接口都是通过代理的；这样才是真正的代理； </span></span><br><span class="line">  m_pRealSubject = <span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line">&#125;</span><br><span class="line">Proxy::~<span class="built_in">Proxy</span>()&#123;</span><br><span class="line">  <span class="keyword">delete</span> m_pRealSubject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Proxy::afterRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Proxy::afterRequest&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Proxy::preRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Proxy::preRequest&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Proxy::request</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">preRequest</span>();</span><br><span class="line">  m_pRealSubject-&gt;<span class="built_in">request</span>();</span><br><span class="line">  <span class="built_in">afterRequest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。</p><p>在Java中，根据代理的创建时期，代理模式分为静态代理和动态代理。</p><ul><li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li><li>动态：利用反射机制在运行时创建代理类。</li></ul><h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性。</li></ul><p>缺点：</p><ul><li>代理模式会造成系统设计中类的数量增加，增加了系统的复杂度；</li><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢；</li></ul><h3 id="适用场景-7"><a href="#适用场景-7" class="headerlink" title="适用场景"></a>适用场景</h3><p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p><ul><li>图片代理：对大图浏览的控制。用户通过浏览器访问网页时先不加载真实的大图，而是先加载一个小图片，然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新网页中显示。</li><li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li><li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<ul><li>Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li></ul></li><li>保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li>缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li>防火墙(Firewall)代理：保护目标不让恶意用户接近。</li><li>同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。</li><li>智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li></ul><h2 id="6-3-外观模式-功能包装"><a href="#6-3-外观模式-功能包装" class="headerlink" title="6.3 外观模式(功能包装)"></a>6.3 外观模式(功能包装)</h2><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 </p><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>外观模式(Facade Pattern)：为子系统中的一组接口提供一个一致的界面。即外部与该子系统的通信必须通过一个统一的外观对象（高层接口）进行，这个高层接口使得这一子系统更加容易使用。</p><p>通俗点说：我们创建一个接口简化而统一的类，用来包装子系统中一个或多个复杂的类。</p><p>外观模式又称为门面模式，它是一种对象结构型模式。</p><p>在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度2个以上的类对象，我们经常都会自觉地创建一个新的类封装这些类功能，提供精简的接口，让高层模块可以更加容易地使用子系统的功能。尤其是现阶段各种第三方SDK、开源类库，很大概率都会使用外观模式。</p><h3 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-3"><a href="#标准结构-3" class="headerlink" title="标准结构"></a>标准结构</h4><p>外观模式包含如下角色：</p><ul><li>外观（Facade）角色：为子系统对外提供一个统一的接口。将客户的请求代理给适当的子系统中的类。</li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。注意：子系统中的类是没有Facade的任何信息的，即没有对Facade对象的引用。</li></ul><img src="/images/pattern/35.jpg" alt="35" style="zoom:100%;" /><p>注意点：</p><ul><li><p>一般将外观类设计为单例类。</p></li><li><p>一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。</p></li><li><p>不要试图通过外观类为子系统增加新行为。</p><p>不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。</p></li><li><p>外观模式与迪米特法则</p><p>外观模式创造出一个外观对象，将客户端所涉及的属于一个子系统的协作伙伴的数量减到最少，使得客户端与子系统内部的对象的相互作用被外观对象所取代。外观类充当了客户类与子系统类之间的“第三者”，降低了客户类与子系统类之间的耦合度，外观模式就是实现代码重构以便达到“迪米特法则”要求的一个强有力的武器。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Facade.h&quot;</span></span></span><br><span class="line">Facade::<span class="built_in">Facade</span>()&#123;</span><br><span class="line">  m_SystemA  = <span class="keyword">new</span> <span class="built_in">SubSystemClassA</span>();</span><br><span class="line">  m_SystemB = <span class="keyword">new</span> <span class="built_in">SubSystemClassB</span>();</span><br><span class="line">  m_SystemC = <span class="keyword">new</span> <span class="built_in">SubSystemClassC</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Facade::~<span class="built_in">Facade</span>()&#123;</span><br><span class="line">  <span class="keyword">delete</span> m_SystemA;</span><br><span class="line">  <span class="keyword">delete</span> m_SystemB;</span><br><span class="line">  <span class="keyword">delete</span> m_SystemC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Facade::wrapOpration</span><span class="params">()</span></span>&#123;</span><br><span class="line">  m_SystemA-&gt;<span class="built_in">operationA</span>();</span><br><span class="line">  m_SystemB-&gt;<span class="built_in">operationB</span>();</span><br><span class="line">  m_SystemC-&gt;<span class="built_in">opeartionC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-抽象外观类的引入"><a href="#扩展-抽象外观类的引入" class="headerlink" title="扩展: 抽象外观类的引入"></a>扩展: 抽象外观类的引入</h4><ul><li>外观模式最大的缺点在于违背了“开闭原则”，当增加、移除子系统类时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。</li><li>对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统类对象。</li><li>同时可以通过修改配置文件来达到不修改源代码并更换外观类的目的。</li></ul><img src="/images/pattern/36.jpg" alt="36" style="zoom:100%;" /><h3 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li><li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li></ul><p>缺点：</p><ul><li>不能很好地限制客户使用子系统中的类，如果对客户访问子系统中的类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，当增加或移除子系统中的类时可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li></ul><h3 id="适用场景-8"><a href="#适用场景-8" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用外观模式：</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li><li>当一个子系统中多个类与客户程序、其他子系统之间存在依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li><li>在层次化结构(分层结构)中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><h2 id="6-4-适配器模式-API转换"><a href="#6-4-适配器模式-API转换" class="headerlink" title="6.4 适配器模式(API转换)"></a>6.4 适配器模式(API转换)</h2><p>在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。</p><p>在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，这可能是因为现有类中使用到的方法名与目标类中定义的方法名不一致等原因所导致的。而如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。</p><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p><p>在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。</p><p>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。</p><p>适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><h3 id="结构-9"><a href="#结构-9" class="headerlink" title="结构"></a>结构</h3><p>适配器模式包含如下角色：</p><ul><li>Target：目标抽象类。当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>Adaptee：适配者类。被访问和适配的现存组件库中的组件接口。</li><li>Adapter：适配器类。它是一个转换器，把适配者类的接口转换成目标接口，让客户按目标接口的格式访问适配者。<ul><li>对象适配器：引用适配者类的对象。</li><li>类适配器：继承适配者类。</li></ul></li></ul><p>适配器模式有对象适配器和类适配器两种实现：</p><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><img src="/images/pattern/37.jpg" alt="37" style="zoom:100%;" /><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><img src="/images/pattern/38.jpg" alt="38" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类适配器模式测试：&quot;</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">&quot;对象适配器模式测试：&quot;</span>);</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h4><ul><li>认适配器模式(Default Adapter Pattern)或缺省适配器模式：<ul><li>当适配器不需要全部实现目标接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式。</li></ul></li><li>双向适配器模式：既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口。（<em>额，想象不出来使用场景</em>）</li></ul><h3 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li><li>增加了类的透明性，将具体的实现封装在适配者类中，对于客户端类来说是透明的。</li><li>提高了类的复用性，程序员不需要修改原有代码而重用现有的适配者类。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul><p>类适配器模式的独有优点：</p><ul><li>由于适配器类是适配者类的子类，因此可以在类适配器中修改一些适配者的方法，使得类适配器的灵活性更强。</li></ul><p>对象适配器模式的独有优点：</p><ul><li>一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个对象适配器可以把适配者类和它的子类都适配到目标接口。</li><li>而类适配器模式的缺陷在于：对于Java、C#等不支持多继承的语言，一次最多只能适配一个适配者类。</li></ul><p>缺点：</p><ul><li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li></ul><h3 id="适用场景-9"><a href="#适用场景-9" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用适配器模式：</p><ul><li><p>系统需要使用现有的类，而这些类的接口不符合系统的需要。</p><blockquote><p>修改一下使用的地方不就行了？有些场景无法修改，比如要使用该类的系统是面向多个模块的，不能单因为这个新的类就修改原系统中的代码。</p></blockquote></li><li><p>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p></li></ul><h2 id="6-5-组合模式-组合和个体使用一致性"><a href="#6-5-组合模式-组合和个体使用一致性" class="headerlink" title="6.5 组合模式(组合和个体使用一致性)"></a>6.5 组合模式(组合和个体使用一致性)</h2><blockquote><p>个人：这个组合，好像跟对象之间的组合关系并不等价。这个组合是表示”整体-部分“的关系，对应对象之间的聚合、组合关系？</p></blockquote><p>在现实生活中、软件开发中，存在很多“部分-整体”的关系，例如：</p><ul><li>大学中的部门与学院；</li><li>总公司中的部门与分公司；</li><li>卖电脑的商家，可以卖配件，也可以卖组装整机；</li><li>文件系统中，复制文件，可以一个个文件复制粘贴，也可以整个文件夹复制粘贴；</li><li>窗体程序中，可以操作一个个简单控件，也可以同样的方式操作容器控件；</li></ul><p>对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。</p><h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>将多个对象组合成树状结构，以表示“整体-部分”的层次结构。实现组合模式，可以<strong>使得用户对单个对象和组合对象的使用具有一致性</strong>。</p><p><em>即不管将要操作的是组合对象还是单个对象，我们都可以统一处理，如果是组合对象，它自己负责将操作分发到内部的所有单个对象上。</em></p><p>树状结构图一般如下：</p><img src="/images/pattern/39.png" alt="39" style="zoom:80%;" /><p>根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用；</p><p>叶子节点与树枝节点在语义上不属于用一种类型。</p><p>但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（用统一接口定义），让它们具备一致行为。即在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。</p><h3 id="结构-10"><a href="#结构-10" class="headerlink" title="结构"></a>结构</h3><p>组合模式包含以下主要角色。</p><ul><li>抽象构件（Component）角色：为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。<ul><li>在透明式的组合模式中，还声明访问和管理子节点的接口；</li><li>在安全式的组合模式中，不声明访问和管理子节点的接口，管理工作由树枝构件自己完成。</li></ul></li><li>树叶构件（Leaf）角色：没有子节点，继承或实现抽象构件。</li><li>树枝构件（Composite）角色 / 中间构件：有子节点，继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li></ul><p>组合模式分为：</p><h4 id="透明式的组合模式"><a href="#透明式的组合模式" class="headerlink" title="透明式的组合模式"></a>透明式的组合模式</h4><p>该方式中，抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。</p><img src="/images/pattern/40.jpg" alt="40" style="zoom:100%;" /><h4 id="安全式的组合模式"><a href="#安全式的组合模式" class="headerlink" title="安全式的组合模式"></a>安全式的组合模式</h4><p>该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。</p><img src="/images/pattern/41.jpg" alt="40" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 透明式的组合模式的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component c0 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component c1 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Component leaf2 = <span class="keyword">new</span> Leaf(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Component leaf3 = <span class="keyword">new</span> Leaf(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        c0.add(leaf1);</span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2);</span><br><span class="line">        c1.add(leaf3);</span><br><span class="line">        c0.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全式的组合模式的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处要将树枝构件类型更改为 Composite 类型，以便获取管理子节点的操作方法。</span></span><br><span class="line">        Composite c0 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Composite c1 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Component leaf2 = <span class="keyword">new</span> Leaf(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Component leaf3 = <span class="keyword">new</span> Leaf(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        c0.add(leaf1);</span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2);</span><br><span class="line">        c1.add(leaf3);</span><br><span class="line">        c0.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-复杂的组合模式"><a href="#扩展-复杂的组合模式" class="headerlink" title="扩展: 复杂的组合模式"></a>扩展: 复杂的组合模式</h4><p>如果对前面介绍的组合模式中的树叶节点和树枝节点进行抽象，也就是说树叶节点和树枝节点拥有不同的实现，这时组合模式就扩展成复杂的组合模式了，如 Java AWT/Swing 中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。</p><img src="/images/pattern/42.jpg" alt="42" style="zoom:100%;" /><h3 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li><li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li></ol><p>缺点：</p><ol><li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li><li>不容易限制容器中的构件；</li><li>不容易用继承的方法来增加构件的新功能；</li></ol><h3 id="适用场景-10"><a href="#适用场景-10" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>在需要表示一个对象整体与部分的层次结构的场合。</li><li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</li></ol><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>用组合模式实现当用户在商店购物后，显示其所选商品信息，并计算所选商品总价的功能。</p><p>说明：假如李先生到韶关“天街e角”生活用品店购物：</p><ul><li>用 1 个红色小袋子装了 2 包婺源特产（单价 7.9 元）、1 张婺源地图（单价 9.9 元）；</li><li>用 1 个白色小袋子装了 2 包韶关香藉（单价 68 元）和 3 包韶关红茶（单价 180 元）；</li><li>用 1 个中袋子装了前面的红色小袋子和 1 个景德镇瓷器（单价 380 元）；</li><li>用 1 个大袋子装了前面的中袋子、白色小袋子和 1 双李宁牌运动鞋（单价 198 元）。</li></ul><p>现在要求编程显示李先生放在大袋子中的所有商品信息并计算要支付的总价。</p><p>安全组合模式设计，其结构图如下图：</p><img src="/images/pattern/43.jpg" alt="43" style="zoom:90%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> composite;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> s = <span class="number">0</span>;</span><br><span class="line">        Bags BigBag, mediumBag, smallRedBag, smallWhiteBag;</span><br><span class="line">        Goods sp;</span><br><span class="line">        BigBag = <span class="keyword">new</span> Bags(<span class="string">&quot;大袋子&quot;</span>);</span><br><span class="line">        mediumBag = <span class="keyword">new</span> Bags(<span class="string">&quot;中袋子&quot;</span>);</span><br><span class="line">        smallRedBag = <span class="keyword">new</span> Bags(<span class="string">&quot;红色小袋子&quot;</span>);</span><br><span class="line">        smallWhiteBag = <span class="keyword">new</span> Bags(<span class="string">&quot;白色小袋子&quot;</span>);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;婺源特产&quot;</span>, <span class="number">2</span>, <span class="number">7.9f</span>);</span><br><span class="line">        smallRedBag.add(sp);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;婺源地图&quot;</span>, <span class="number">1</span>, <span class="number">9.9f</span>);</span><br><span class="line">        smallRedBag.add(sp);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;韶关香菇&quot;</span>, <span class="number">2</span>, <span class="number">68</span>);</span><br><span class="line">        smallWhiteBag.add(sp);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;韶关红茶&quot;</span>, <span class="number">3</span>, <span class="number">180</span>);</span><br><span class="line">        smallWhiteBag.add(sp);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;景德镇瓷器&quot;</span>, <span class="number">1</span>, <span class="number">380</span>);</span><br><span class="line">        mediumBag.add(sp);</span><br><span class="line">        mediumBag.add(smallRedBag);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;李宁牌运动鞋&quot;</span>, <span class="number">1</span>, <span class="number">198</span>);</span><br><span class="line">        BigBag.add(sp);</span><br><span class="line">        BigBag.add(smallWhiteBag);</span><br><span class="line">        BigBag.add(mediumBag);</span><br><span class="line">        System.out.println(<span class="string">&quot;您选购的商品有：&quot;</span>);</span><br><span class="line">        BigBag.show();</span><br><span class="line">        s = BigBag.calculation();</span><br><span class="line">        System.out.println(<span class="string">&quot;要支付的总价是：&quot;</span> + s + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象构件：物品</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Articles</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">calculation</span><span class="params">()</span></span>; <span class="comment">//计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件：商品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Articles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;     <span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;    <span class="comment">//数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> unitPrice; <span class="comment">//单价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">int</span> quantity, <span class="keyword">float</span> unitPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">        <span class="keyword">this</span>.unitPrice = unitPrice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">calculation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quantity * unitPrice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;(数量：&quot;</span> + quantity + <span class="string">&quot;，单价：&quot;</span> + unitPrice + <span class="string">&quot;元)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件：袋子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bags</span> <span class="keyword">implements</span> <span class="title">Articles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;     <span class="comment">//名字  </span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Articles&gt; bags = <span class="keyword">new</span> ArrayList&lt;Articles&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bags</span><span class="params">(String name)</span>        </span>&#123; <span class="keyword">this</span>.name = name;   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Articles c)</span>     </span>&#123; bags.add(c);        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Articles c)</span>  </span>&#123; bags.remove(c);     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Articles <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> bags.get(i); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">calculation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : bags) &#123;</span><br><span class="line">            s += ((Articles) obj).calculation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : bags) &#123;</span><br><span class="line">            ((Articles) obj).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-6-桥接模式-接口与实现分离"><a href="#6-6-桥接模式-接口与实现分离" class="headerlink" title="6.6 桥接模式(接口与实现分离)"></a>6.6 桥接模式(接口与实现分离)</h2><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p><ul><li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li><li>第二种设计方案是根据实际需要对形状和颜色进行组合</li></ul><p>对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p><h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p><h4 id="抽象、实现部分？-先见1-7小节"><a href="#抽象、实现部分？-先见1-7小节" class="headerlink" title="抽象、实现部分？(先见1.7小节)"></a>抽象、实现部分？(先见1.7小节)</h4><p>注意，这里提到的抽象部分、实现部分与编程语言中的接口或抽象类、实现类是不同的含义。这里的抽象部分是指接口(interface，或者界面)：</p><ul><li>抽象部分（也被称为接口）是一些实体的高阶控制层。该层自身不完成任何具体的工作，它需要将工作委派给实现部分层（也被称为平台）。——  <a href="https://refactoringguru.cn/design-patterns/bridge">《深入设计模式》</a></li><li>《Head First设计模式》一书中也有场景，将抽象部分表示为一个系统对外暴露的接口。</li></ul><p>举个例子，在实际的程序中，抽象部分可以是用户操作界面（比如GUI），而实现部分则是底层操作系统代码（API），GUI层调用API层来对用户的各种操作做出响应。</p><p>一般来说，你可以在两个独立方向上扩展这种应用：</p><ul><li>开发多个不同的GUI（例如面向普通用户和管理员进行分别配置）</li><li>支持多个不同的API（例如，能够在Windows、Linux和macOS上运行该程序）。</li></ul><h4 id="抽象与实现分离"><a href="#抽象与实现分离" class="headerlink" title="抽象与实现分离"></a>抽象与实现分离</h4><ul><li>”将抽象部分与它的实现部分分离“，就是<strong>实现系统可能有多角度/维度分类，每一种分类都有可能变化，那么就把这种多角度/维度分离出来让它们独立变化，减少它们之间的耦合</strong>。—— 《大话设计模式》</li><li>桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变。这两个类层次之间的关系就叫桥接。——《Head First设计模式》</li></ul><blockquote><p>维度（Dimension），又称维数、量纲和次元，是描述<strong>对象状态所需的独立参数（数学）或系统自由度（物理）的数量</strong>。在物理学和数学中，数学空间的维数被非正式地定义为指定其中任何点所需的最小坐标数(1维是线，只需指定长度。2维是一个平面，需指定长度和宽度。3维是一个立体，需指定长度、宽度、高度)。</p></blockquote><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>桥接模式通过将继承改为组合的方式来解决这个问题。具体来说，就是<strong>抽取其中一个维度并使之成为独立的类层次，这样就可以在初始类中引用这个新层次的对象</strong>，从而使得一个类不必拥有所有的状态和行为。</p><h3 id="结构-11"><a href="#结构-11" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-4"><a href="#标准结构-4" class="headerlink" title="标准结构"></a>标准结构</h4><p>桥接模式包含如下角色：</p><ul><li>Abstraction：抽象类</li><li>RefinedAbstraction：扩充/精炼/精确抽象类</li><li>Implementor：实现类接口</li><li>ConcreteImplementor：具体实现类</li></ul><p>桥接模式的一个常见使用场景就是替换继承。在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使得二者可以独立地变化。</p><img src="/images/pattern/44.jpg" alt="44" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  RefinedAbstraction.cpp</span></span><br><span class="line"><span class="comment">//  Implementation of the Class RefinedAbstraction</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">RefinedAbstraction::<span class="built_in">RefinedAbstraction</span>()  &#123; &#125;</span><br><span class="line">RefinedAbstraction::<span class="built_in">RefinedAbstraction</span>(Implementor* imp) :<span class="built_in">Abstraction</span>(imp) &#123; &#125;</span><br><span class="line">RefinedAbstraction::~<span class="built_in">RefinedAbstraction</span>() &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RefinedAbstraction::operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;do something else ,and then &quot;</span> &lt;&lt; endl;</span><br><span class="line">    m_pImp-&gt;<span class="built_in">operationImp</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现类1</span></span><br><span class="line">    Implementor * pImp = <span class="keyword">new</span> <span class="built_in">ConcreteImplementorA</span>();</span><br><span class="line">    Abstraction * pa = <span class="keyword">new</span> <span class="built_in">RefinedAbstraction</span>(pImp);</span><br><span class="line">    pa-&gt;<span class="built_in">operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体实现类2</span></span><br><span class="line">    Implementor * pImpb = <span class="keyword">new</span> <span class="built_in">ConcreteImplementorB</span>();</span><br><span class="line">    Abstraction * pb = <span class="keyword">new</span> <span class="built_in">RefinedAbstraction</span>(pImpb);</span><br><span class="line">    pb-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pa;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-与适配器模式联用"><a href="#扩展-与适配器模式联用" class="headerlink" title="扩展: 与适配器模式联用"></a>扩展: 与适配器模式联用</h4><p>桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</p><img src="/images/pattern/46.jpg" alt="46" style="zoom:100%;" /><h3 id="优缺点-10"><a href="#优缺点-10" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>抽象与实现分离。提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。符合开闭原则。</li><li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li><li>符合合成复用原则</li><li>实现细节对客户透明，可以对用户隐藏实现细节。</li></ul><p>缺点是：</p><ul><li>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程。</li><li>要求能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</li></ul><h3 id="适用场景-11"><a href="#适用场景-11" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展</strong>。</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li><li>对于那些<strong>不希望使用继承、或不希望因为多层次继承导致系统类的个数急剧增加</strong>的系统，桥接模式尤为适用。</li></ul><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p>案例1：</p><p>设备及其遥控器的架构设计。 <strong>设备</strong> Device类作为实现部分， 而 <strong>遥控器</strong> Remote类则作为抽象部分。</p><p>最初类层次结构被拆分为两个部分： 设备和遥控器。</p><img src="/images/pattern/48.png" alt="48" style="zoom:90%;" /><p>案例2：</p><p>女士皮包有很多种，可以按用途分、按皮质分、按品牌分、按颜色分、按大小分等，存在多个维度的变化，所以采用桥接模式来实现女士皮包的选购比较合适。</p><p>本实例按用途分可选钱包（Wallet）和挎包（HandBag），按颜色分可选黄色（Yellow）和红色（Red）。可以按两个维度定义为颜色类和包类。</p><img src="/images/pattern/45.jpg" alt="45" style="zoom:85%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Color color;</span><br><span class="line">    Bag bag;</span><br><span class="line">    color = (Color) ReadXML.getObject(<span class="string">&quot;color&quot;</span>);</span><br><span class="line">    bag = (Bag) ReadXML.getObject(<span class="string">&quot;bag&quot;</span>);</span><br><span class="line">    bag.setColor(color);</span><br><span class="line">    String name = bag.getName();</span><br><span class="line">    show(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-7-享元模式-对象复用池"><a href="#6-7-享元模式-对象复用池" class="headerlink" title="6.7 享元模式(对象复用池)"></a>6.7 享元模式(对象复用池)</h2><h3 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h3><p>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。</p><ul><li>系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。</li><li>模式要求能够共享的对象必须是细粒度对象，因此它又称为蝇量模式、轻量级模式。</li></ul><p>它是一种对象结构型模式。</p><p>通过享元模式，可以大幅度减少需要创建的对象数量，节约内存空间，提高系统的性能。</p><h3 id="结构-12"><a href="#结构-12" class="headerlink" title="结构"></a>结构</h3><p>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p><h4 id="内部状态、外部状态"><a href="#内部状态、外部状态" class="headerlink" title="内部状态、外部状态"></a>内部状态、外部状态</h4><p>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。</p><ul><li>内部状态是<strong>存储在享元对象内部</strong>并且不会随环境改变而改变的状态，因此内部状态可以共享。<ul><li>外部直接只能读取不能修改其数值。</li></ul></li><li>外部状态是随环境改变而改变的、不可以共享的状态。即外部状态可以被“从外部”改变。<ul><li><strong>享元对象的外部状态必须由客户端保存</strong>，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。</li><li>一个外部状态与另一个外部状态之间是相互独立的。</li></ul></li></ul><p>比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。</p><h4 id="标准结构-5"><a href="#标准结构-5" class="headerlink" title="标准结构"></a>标准结构</h4><p>享元模式包含如下角色：</p><ul><li>Flyweight: 抽象享元类。所有具体享元类的超类或接口，接口中定义的方法，使得Flyweight可以接收并操作传入享元对象中的外部状态。</li><li>ConcreteFlyweight: 具体享元类。继承Flyweight超类或实现Flyweight接口，并为内部状态增加存储空间。</li><li>UnsharedConcreteFlyweight: 非共享具体享元类。<ul><li>Flyweight接口只是使共享成为可能，但它并不强制共享。</li><li>尽管我们大部分情况下，都需要共享对象来降低内存的消耗。但个别情况下也有可能不需要共享的。</li></ul></li><li>FlyweightFactory: 享元工厂类。负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ul><img src="/images/pattern/49.jpg" alt="49" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 享元工厂</span></span><br><span class="line"><span class="function">Flyweight* <span class="title">FlyweightFactory::getFlyweight</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    map&lt;string,Flyweight*&gt;::iterator itr = m_mpFlyweight.<span class="built_in">find</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(itr == m_mpFlyweight.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        Flyweight * fw = <span class="keyword">new</span> <span class="built_in">ConcreteFlyweight</span>(str);</span><br><span class="line">        m_mpFlyweight.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(str,fw));</span><br><span class="line">        <span class="keyword">return</span> fw;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;aready in the pool,use the exist one:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> itr-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> :</span> <span class="keyword">public</span> Flyweight &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string intrinsicState;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFlyweight</span>(string str)&#123;</span><br><span class="line">        intrinsicState = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFlyweight</span>()&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Flyweight[&quot;</span> &lt;&lt; intrinsicState &lt;&lt; <span class="string">&quot;] do operation.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非共享具体享元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> :</span> <span class="keyword">public</span> Flyweight &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string intrinsicState;  <span class="comment">// 内部状态</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string otherState; <span class="comment">//其他的状态。会被外部改变，所以此对象不可复用</span></span><br><span class="line">    <span class="built_in">UnsharedConcreteFlyweight</span>(string str)&#123;</span><br><span class="line">        intrinsicState = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">UnsharedConcreteFlyweight</span>()&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;不要共享我 Flyweight[&quot;</span> &lt;&lt; intrinsicState &lt;&lt; <span class="string">&quot;] do operation.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FlyweightFactory factory;</span><br><span class="line">    Flyweight * fw = factory.<span class="built_in">getFlyweight</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    fw-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    </span><br><span class="line">    Flyweight * fw2 = factory.<span class="built_in">getFlyweight</span>(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    fw2-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    <span class="comment">//aready exist in pool</span></span><br><span class="line">    Flyweight * fw3 = factory.<span class="built_in">getFlyweight</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    fw3-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    </span><br><span class="line">    Flyweight * fw4 = <span class="keyword">new</span> <span class="built_in">UnsharedConcreteFlyweight</span>(<span class="string">&quot;four&quot;</span>);</span><br><span class="line">    fw4-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单纯享元模式"><a href="#单纯享元模式" class="headerlink" title="单纯享元模式"></a>单纯享元模式</h4><p>在单纯享元模式中，所有的享元对象都是可以共享的，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。</p><h4 id="复合享元模式"><a href="#复合享元模式" class="headerlink" title="复合享元模式"></a>复合享元模式</h4><p>将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p><h4 id="扩展-与其他模式的联用"><a href="#扩展-与其他模式的联用" class="headerlink" title="扩展: 与其他模式的联用"></a>扩展: 与其他模式的联用</h4><ul><li>在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。</li><li>在一个系统中，通常只有唯一一个享元工厂，因此享元工厂类可以使用单例模式进行设计。</li><li>享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态。</li></ul><h3 id="优缺点-11"><a href="#优缺点-11" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li></ul><p>缺点：</p><ul><li>享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</li></ul><h3 id="适用场景-12"><a href="#适用场景-12" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用享元模式：</p><ul><li>一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。</li></ul><p>享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。</p><h1 id="七、行为型模式-协作及职责分配"><a href="#七、行为型模式-协作及职责分配" class="headerlink" title="七、行为型模式(协作及职责分配)"></a>七、行为型模式(协作及职责分配)</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。</p><p>行为型模式(Behavioral Pattern)用于描述类或对象之间<strong>怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。</strong></p><p>只要是行为型模式，都涉及到类和对象如何交互及分配职责。</p><ol><li><strong>算法和对象间职责的分配</strong>。即通过行为型模式，可以更加清晰地划分类与对象的职责。</li><li><strong>运行时，实例对象之间的交互</strong>(<strong>或者说通信模式</strong>)。行为型模式刻画了在程序运行时难以跟踪的、复杂的控制流。</li></ol><p>如策略、模板方法、观察者、状态、备忘录、迭代器、命令、职责链、中介者、解释器、访问者等 11 种行为型模式。</p><h2 id="7-1-策略模式-拆分算法族到各策略子类"><a href="#7-1-策略模式-拆分算法族到各策略子类" class="headerlink" title="7.1 策略模式(拆分算法族到各策略子类)"></a>7.1 策略模式(拆分算法族到各策略子类)</h2><p>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。</p><p>比如想要进行数据的查找、排序，而查找、排序的实现有很多种，在指定的场景下选用正确的算法，效果更优。</p><p>选择策略的形式 ：</p><ul><li>一种常用的方法是硬编码(Hard Coding)在一个类中，即在该类中提供多个方法，每一个方法对应一个具体的查找算法；</li><li>将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。</li></ul><p>这两种的缺点：如果需要增加一种新的查找算法，需要修改封装算法类的源代码；且在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。违背开闭原则、单一职责原则。</p><ul><li>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</li><li>定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。</li></ul><h3 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h3><p>策略模式(Strategy Pattern)：定义一系列算法(也称算法族)，将每一种算法封装起来，并让它们可以相互替换。（每种算法实现对应一个抽象策略的子类。）</p><p>此模式让算法独立于使用它的客户而变化，即算法的变化不会影响到使用算法的客户。也称为政策模式(Policy)。</p><h3 id="结构-13"><a href="#结构-13" class="headerlink" title="结构"></a>结构</h3><p>策略模式包含如下角色：</p><ul><li>Context: 上下文类。持有一个策略类的引用，最终给客户端调用。</li><li>Strategy: 抽象策略类。定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，上下文类中使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li><li>ConcreteStrategy: 具体策略类。实现了抽象策略定义的接口，提供具体的算法实现。</li></ul><img src="/images/pattern/50.jpg" alt="50" style="zoom:100%;" /><p>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</p><p>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Strategy * s1 = <span class="keyword">new</span> <span class="built_in">ConcreteStrategyA</span>();</span><br><span class="line">    Context * cxt = <span class="keyword">new</span> <span class="built_in">Context</span>();</span><br><span class="line">    cxt-&gt;<span class="built_in">setStrategy</span>(s1);</span><br><span class="line">    cxt-&gt;<span class="built_in">algorithm</span>();</span><br><span class="line">    </span><br><span class="line">    Strategy *s2 = <span class="keyword">new</span> <span class="built_in">ConcreteStrategyB</span>();</span><br><span class="line">    cxt-&gt;<span class="built_in">setStrategy</span>(s2);</span><br><span class="line">    cxt-&gt;<span class="built_in">algorithm</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> s1;</span><br><span class="line">    <span class="keyword">delete</span> s2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-12"><a href="#优缺点-12" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li>使用策略模式可以避免使用多重条件转移语句，如 if…else 语句、switch…case 语句。</li><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法：该模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li><li>策略模式提供了可以替换继承关系的办法。</li></ul><p>缺点</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类。<strong>当存在的策略很多时，可以通过使用享元模式在一定程度上减少对象的数量</strong>。</li></ul><h3 id="适用场景-13"><a href="#适用场景-13" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用策略模式：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li></ul><h2 id="7-2-模板方法模式-延迟实现算法某些步"><a href="#7-2-模板方法模式-延迟实现算法某些步" class="headerlink" title="7.2 模板方法模式(延迟实现算法某些步)"></a>7.2 模板方法模式(延迟实现算法某些步)</h2><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p><p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p><p>我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它，例如，简历模板、论文模板、Word 中模板文件等。</p><h3 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h3><p>模板方法（Template Method）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><h3 id="结构-14"><a href="#结构-14" class="headerlink" title="结构"></a>结构</h3><p>模板方法模式包含以下主要角色。</p><ul><li><p>抽象类/抽象模板（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下：</p><ul><li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li><li>基本方法：是整个算法中的一个步骤，包含以下几种类型。<ul><li>抽象方法：在抽象类中声明，由具体子类实现。</li><li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li><li>钩子方法：钩子是内容为空的可选步骤。 即使不重写钩子， 模板方法也能工作。 钩子通常放置在算法重要步骤的前后， 为子类提供额外的算法扩展点。正确使用“钩子方法”可以使得子类控制父类的行为。如下图中的 <code>step2()</code> 方法。</li></ul></li></ul></li><li><p>具体子类/具体实现（Concrete Class）：可以重写所有步骤/基本方法，但不能重写模板方法自身。</p></li></ul><img src="/images/pattern/51.jpg" alt="51" style="zoom:100%;" /><p>客户端必须知道所有的具体实现类，并自行决定使用哪一个具体实现类。</p><h3 id="优缺点-13"><a href="#优缺点-13" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点:</p><ol><li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li><li>它在父类中提取了公共的部分代码，便于代码复用。</li><li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li></ol><p>缺点:</p><ol><li><strong>对每个不同的实现都需要定义一个子类</strong>，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li><li>由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。</li></ol><h3 id="适用场景-14"><a href="#适用场景-14" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li><li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li></ol><h2 id="7-3-观察者模式-一对多的依赖关系"><a href="#7-3-观察者模式-一对多的依赖关系" class="headerlink" title="7.3 观察者模式(一对多的依赖关系)"></a>7.3 观察者模式(一对多的依赖关系)</h2><p>在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众等。</p><p>在软件世界也是这样，例如，Excel 中的数据与折线图、饼状图、柱状图之间的关系；MVC 模式中的模型与视图的关系；事件模型中的事件源与事件处理者。所有这些，如果用观察者模式来实现就非常方便。</p><h3 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h3><p>观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</p><p>观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p><h3 id="结构-15"><a href="#结构-15" class="headerlink" title="结构"></a>结构</h3><h4 id="标准观察者模式"><a href="#标准观察者模式" class="headerlink" title="标准观察者模式"></a>标准观察者模式</h4><p>观察者模式包含如下角色：</p><ul><li>Subject: 抽象目标/主题类。提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li><li>ConcreteSubject: 具体目标/主题类。当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li><li>Observer: 抽象观察者。是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li><li>ConcreteObserver: 具体观察者。实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li></ul><img src="/images/pattern/52.jpg" alt="52" style="zoom:90%;" /><ul><li>一个目标可以有任意数目的与之相依赖的观察者。</li><li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象目标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Obeserver*&gt; m_vtObj;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Subject</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Obeserver * pObeserver)</span></span>&#123;</span><br><span class="line">        m_vtObj.<span class="built_in">push_back</span>(pObeserver);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(Obeserver * pObeserver)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;Obeserver*&gt;::iterator itr = m_vtObj.<span class="built_in">begin</span>(); </span><br><span class="line">            itr != m_vtObj.<span class="built_in">end</span>(); itr++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(*itr == pObeserver) &#123;</span><br><span class="line">                m_vtObj.<span class="built_in">erase</span>(itr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;Obeserver*&gt;::iterator itr = m_vtObj.<span class="built_in">begin</span>(); </span><br><span class="line">            itr != m_vtObj.<span class="built_in">end</span>(); itr++) &#123;</span><br><span class="line">            (*itr)-&gt;<span class="built_in">update</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> i)</span></span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObeserver</span> :</span> <span class="keyword">public</span> Obeserver &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_objName;</span><br><span class="line">    <span class="keyword">int</span> m_obeserverState;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteObeserver</span>(string name) &#123;</span><br><span class="line">        m_objName = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteObeserver</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject * sub)</span> </span>&#123;</span><br><span class="line">        m_obeserverState = sub-&gt;<span class="built_in">getState</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;update oberserver[&quot;</span> &lt;&lt; m_objName &lt;&lt; <span class="string">&quot;] state:&quot;</span> </span><br><span class="line">             &lt;&lt; m_obeserverState &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="狭义的发布订阅者模式"><a href="#狭义的发布订阅者模式" class="headerlink" title="狭义的发布订阅者模式"></a>狭义的发布订阅者模式</h4><p><a href="https://www.zhihu.com/question/23486749">观察者模式和发布订阅模式有什么不同？</a></p><ul><li><p>发布订阅模式属于广义上的观察者模式：发布订阅模式是最常用的一种观察者模式的实现，并且从解耦和重用角度来看，更优于典型的观察者模式</p></li><li><p>发布订阅模式多了个事件通道：</p><ul><li><p>在观察者模式中，观察者需要直接订阅目标事件；在目标发出内容改变的事件后，直接接收事件并作出响应。</p><img src="/images/pattern/53.png" alt="53" style="zoom:100%;" /></li><li><p>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面从发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件。以此避免发布者和订阅者之间产生依赖关系。（<em>一般还会有个remove观察者的方法</em>）</p><img src="/images/pattern/54.png" alt="54" style="zoom:100%;" /></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：每当数据中心DataHub中有数据准备好，就通知DownloadTask进行下载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 DownloadManager 类作为事件通道。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DownloadManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">  <span class="built_in">this</span>.uId = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DownloadManager.prototype.publish = <span class="function"><span class="keyword">function</span>(<span class="params">eventType, url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.events[eventType]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> subscribers = <span class="built_in">this</span>.events[eventType],</span><br><span class="line">    count = subscribers ? subscribers.length : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">    <span class="keyword">var</span> subscriber = subscribers[count];</span><br><span class="line">    subscriber.handler(eventType, subscriber.taskId, url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DownloadManager.prototype.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">eventType, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.events[eventType]) &#123;</span><br><span class="line">    <span class="built_in">this</span>.events[eventType] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> taskId = (++<span class="built_in">this</span>.uId).toString();</span><br><span class="line">  <span class="built_in">this</span>.events[eventType].push(&#123;</span><br><span class="line">    taskId: taskId,</span><br><span class="line">    handler: handler</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> taskId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DataHub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">DataHub.prototype.notify = <span class="function"><span class="keyword">function</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  callback(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个订阅者</span></span><br><span class="line"><span class="keyword">var</span> dataLoader = <span class="function"><span class="keyword">function</span>(<span class="params">eventType, taskId, url</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Task &#x27;</span> + taskId + <span class="string">&#x27; load data from &#x27;</span> + url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅。需要借助事件管理器</span></span><br><span class="line"><span class="keyword">var</span> downloadManager = <span class="keyword">new</span> DownloadManager();</span><br><span class="line"><span class="keyword">var</span> downloadTask1 = downloadManager.subscribe(<span class="string">&#x27;dataReady&#x27;</span>, dataLoader);</span><br><span class="line"><span class="comment">// notify</span></span><br><span class="line">dataHub.notify(<span class="string">&#x27;http://somedomain.someaddress&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  downloadManager.publish(<span class="string">&#x27;dataReady&#x27;</span>, url);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="优缺点-14"><a href="#优缺点-14" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>观察者模式符合“开闭原则”的要求。</li></ul><p>缺点：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li></ul><h3 id="适用场景-15"><a href="#适用场景-15" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用观察者模式：</p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><p>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p><p>MVC模式是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。观察者模式可以用来实现MVC模式，观察者模式中的观察目标就是MVC模式中的模型(Model)，而观察者就是MVC中的视图(View)，控制器(Controller)充当两者之间的中介者(Mediator)。当模型层的数据发生改变时，视图层将自动改变其显示内容。</p><h2 id="7-4-状态模式-对象不同状态下不同行为"><a href="#7-4-状态模式-对象不同状态下不同行为" class="headerlink" title="7.4 状态模式(对象不同状态下不同行为)"></a>7.4 状态模式(对象不同状态下不同行为)</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的<strong>对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化</strong>。</p><p>对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理。但是显然这种做法对复杂的状态判断存在天然弊端，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展。</p><p>状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，<strong>把相关“判断逻辑”提取出来：把受环境改变影响的对象行为包装在不同的状态对象中，系统处于哪种情况，直接使用相应的状态类对象进行处理</strong>。这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。</p><p>在UML中可以使用状态图来描述对象状态的变化。</p><h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><p>状态模式与<a href="https://en.wikipedia.org/wiki/Finite-state_machine">有限状态机</a>的概念紧密相关。</p><img src="/images/pattern/56.jpg" alt="56" style="zoom:100%;" /><p>其主要思想是程序在任意时刻仅可处于几种有限的状态中。 在任何一个特定状态中，程序的行为都不相同，且可瞬间从一个状态切换到另一个状态。不过，根据当前状态，程序可能会切换到另外一种状态，也可能会保持当前状态不变。这些数量有限且预先定义的状态切换规则被称为<em>转移</em>。</p><p>这类系统具有一系列离散的输入输出信息和有穷数目的内部状态(状态:概括了对过去输入信息处理的状况)。系统只需要根据当前所处的状态和当前面临的输入信息就可以决定系统的后继行为。每当系统处理了当前的输入后，系统的内部状态也将发生改变。</p><h3 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h3><p>状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)。</p><p>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</p><h3 id="结构-16"><a href="#结构-16" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-可切换状态的状态模式"><a href="#标准结构-可切换状态的状态模式" class="headerlink" title="标准结构(可切换状态的状态模式)"></a>标准结构(可切换状态的状态模式)</h4><p>状态模式包含如下角色：</p><ul><li>Context: 上下文类<ul><li>保存了对于一个具体状态对象的<strong>引用</strong>， 并会将所有与该状态相关的工作委派给它。</li><li>上下文通过抽象状态接口与状态对象交互， 且会提供一个<strong>设置器</strong>用于传递新的状态对象。</li><li>Context有时候可以充当状态管理器(State Manager)的角色，即也可以在上下文类中对状态进行切换操作。</li></ul></li><li>State: 抽象状态类<ul><li>声明特定状态所对应的行为，可以有一个或多个行为。</li><li>这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。</li></ul></li><li>ConcreteState: 具体状态类<ul><li><strong>实现不同的状态所对应的行为</strong>。为了避免多个状态中包含相似代码，你可以提供一个封装有部分通用行为的中间抽象类。</li><li><strong>状态对象可存储对于上下文对象的反向引用或者通过方法参数传入</strong>（上下文类和状态类之间存在一种双向的关联关系）。状态可以通过该引用从上下文处获取所需信息，并且能<font color='red'>触发状态转移</font>。</li></ul></li></ul><img src="/images/pattern/55.png" alt="55" style="zoom:100%;" /><p><strong>上下文和具体状态都可以设置上下文的下个状态。通过替换上下文所引用的状态对象来完成实际的状态转换。</strong></p><p>抽象状态类的产生是由于上下文类存在多个状态，同时还满足两个条件：这些状态经常需要切换，在不同的状态下对象的行为不同。</p><p>由于上下文类可以设置为任一具体状态类，因此它针对抽象状态类进行编程。</p><p>上下文类对象在其内部状态改变时可以改变它的行为，<strong>对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> :</span> <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ConcreteStateA</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> State * m_pState = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteStateA</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> State * <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == m_pState)&#123;</span><br><span class="line">            m_pState = <span class="keyword">new</span> <span class="built_in">ConcreteStateA</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_pState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Context * c)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;doing something in State A.\n done,change state to B&quot;</span> &lt;&lt; endl;</span><br><span class="line">        c-&gt;<span class="built_in">changeState</span>(ConcreteStateB::<span class="built_in">Instance</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State *m_pState;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>() &#123;</span><br><span class="line">        m_pState = ConcreteStateA::<span class="built_in">Instance</span>();  <span class="comment">//default is a</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Context</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeState</span><span class="params">(State * st)</span></span>&#123;</span><br><span class="line">        m_pState = st;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m_pState-&gt;<span class="built_in">handle</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Context * c = <span class="keyword">new</span> <span class="built_in">Context</span>();</span><br><span class="line">    c-&gt;<span class="built_in">request</span>();</span><br><span class="line">    c-&gt;<span class="built_in">request</span>();</span><br><span class="line">    c-&gt;<span class="built_in">request</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单状态模式结构"><a href="#简单状态模式结构" class="headerlink" title="简单状态模式结构"></a>简单状态模式结构</h4><p>可切换状态的状态模式：</p><ul><li>大多数的状态模式都是可以切换状态的状态模式。</li><li>在实现状态切换时，在具体状态类内部需要调用上下文类Context的setState()方法进行状态的转换操作，在具体状态类中可以调用到上下文类的方法，因此状态类与上下文类之间通常还存在关联关系或者依赖关系。通过在状态类中引用上下文类的对象来回调上下文类的setState()方法实现状态的切换。</li><li>在这种可以切换状态的状态模式中，增加新的状态类可能需要修改其他某些状态类甚至上下文类的源代码，否则系统无法切换到新增状态。</li></ul><p>简单状态模式：</p><ul><li>是指状态都相互独立，状态之间无须进行转换的状态模式，这是最简单的一种状态模式。</li><li>对于这种状态模式，每个状态类都封装与状态相关的操作，而无须关心状态的切换，可以在客户端直接实例化状态类，然后将状态对象设置到上下文类中。</li><li>遵循“开闭原则”，在客户端可以针对抽象状态类进行编程，而将具体状态类写到配置文件中，同时增加新的状态类对原有系统也不造成任何影响。</li></ul><h4 id="扩展：状态的共享"><a href="#扩展：状态的共享" class="headerlink" title="扩展：状态的共享"></a>扩展：状态的共享</h4><p>在有些情况下，会创建多个上下文对象，这些对象会共享这一组状态。为了避免具体状态类对象的重复创建，常见有以下两种解决方式：</p><ol><li>引入享元模式，将这些具体状态对象放在集合中供程序共享。</li><li>将这些状态对象定义为的具体状态类的静态成员对象(<em>如上面的demo代码</em>)。</li></ol><p>如果多个上下文对象需要共享同一个状态（<em>意思是这个状态不是对象的，而是所有本类的对象共同拥有的属性？</em>），那么需要将这些状态对象定义为上下文类的静态成员对象。</p><h4 id="模式对比"><a href="#模式对比" class="headerlink" title="模式对比"></a>模式对比</h4><p>状态模式和策略模式的 UML 类图架构很像，但两者的应用场景是不一样的。策略模式的多种算法行为择其一都能满足，彼此之间是独立的，用户可自行更换策略算法。而状态模式的各个状态间存在相互关系，彼此之间在一定条件下存在自动切换状态的效果，并且用户无法指定状态，只能设置初始状态。</p><h3 id="优缺点-15"><a href="#优缺点-15" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li><strong>结构清晰</strong>，状态模式将与特定状态相关的行为局部化到一个状态中，而不是集中在一个巨大的条件语句块中。并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>将<strong>状态转换显示化</strong>，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>状态类职责明确，<strong>有利于程序的扩展</strong>。通过定义新的子类很容易地增加新的状态和转换。</li></ul><p>缺点</p><ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态的行为也需修改对应类的源代码。</li></ul><h3 id="适用场景-16"><a href="#适用场景-16" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>某个类的对象存在多种状态，对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li></ul><h3 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h3><h4 id="案例1-TCPConnection"><a href="#案例1-TCPConnection" class="headerlink" title="案例1: TCPConnection"></a>案例1: TCPConnection</h4><p>这个示例来自《设计模式》，展示了一个简化版的TCP协议实现；TCP连接的状态有多种可能，状态之间的转换有相应的逻辑前提；这是使用状态模式的场合；</p><img src="/images/pattern/57.jpg" alt="57" style="zoom:100%;" /><h4 id="案例2-多线程的状态转换"><a href="#案例2-多线程的状态转换" class="headerlink" title="案例2: 多线程的状态转换"></a>案例2: 多线程的状态转换</h4><p>多线程存在 5 种状态，分别为新建状态、就绪状态、运行状态、阻塞状态和死亡状态，各个状态当遇到相关方法调用或事件触发时会转换到其他状态，其状态转换规律如下图所示。</p><img src="/images/pattern/58.jpg" alt="58" style="zoom:100%;" /><img src="/images/pattern/59.jpg" alt="59" style="zoom:96%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreStateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadContext context = <span class="keyword">new</span> ThreadContext();</span><br><span class="line">        context.start();</span><br><span class="line">        context.getCPU();</span><br><span class="line">        context.suspend();</span><br><span class="line">        context.resume();</span><br><span class="line">        context.getCPU();</span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上下文类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadState state;</span><br><span class="line">    ThreadContext() &#123;</span><br><span class="line">        state = <span class="keyword">new</span> New();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(ThreadState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadState <span class="title">getState</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span>           </span>&#123; ((New) state).start(<span class="keyword">this</span>);       &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCPU</span><span class="params">()</span>          </span>&#123; ((Runnable)state).getCPU(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span>         </span>&#123; ((Running) state).suspend(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span>            </span>&#123; ((Running) state).stop(<span class="keyword">this</span>);    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span>          </span>&#123; ((Blocked) state).resume(<span class="keyword">this</span>);  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象状态类：线程状态</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String stateName; <span class="comment">//状态名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态类：新建状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">New</span> <span class="keyword">extends</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">New</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateName = <span class="string">&quot;新建状态&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程处于：新建状态.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ThreadContext hj)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用start()方法--&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (stateName.equals(<span class="string">&quot;新建状态&quot;</span>)) &#123;</span><br><span class="line">            hj.setState(<span class="keyword">new</span> Runnable());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程不是新建状态，不能调用start()方法.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态类：就绪状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable</span> <span class="keyword">extends</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Runnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateName = <span class="string">&quot;就绪状态&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程处于：就绪状态.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCPU</span><span class="params">(ThreadContext hj)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;获得CPU时间--&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (stateName.equals(<span class="string">&quot;就绪状态&quot;</span>)) &#123;</span><br><span class="line">            hj.setState(<span class="keyword">new</span> Running());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程不是就绪状态，不能获取CPU.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态类：运行状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Running</span> <span class="keyword">extends</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateName = <span class="string">&quot;运行状态&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程处于：运行状态.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">(ThreadContext hj)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用suspend()方法--&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (stateName.equals(<span class="string">&quot;运行状态&quot;</span>)) &#123;</span><br><span class="line">            hj.setState(<span class="keyword">new</span> Blocked());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程不是运行状态，不能调用suspend()方法.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(ThreadContext hj)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用stop()方法--&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (stateName.equals(<span class="string">&quot;运行状态&quot;</span>)) &#123;</span><br><span class="line">            hj.setState(<span class="keyword">new</span> Dead());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程不是运行状态，不能调用stop()方法.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态类：阻塞状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">extends</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateName = <span class="string">&quot;阻塞状态&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程处于：阻塞状态.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">(ThreadContext hj)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用resume()方法--&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (stateName.equals(<span class="string">&quot;阻塞状态&quot;</span>)) &#123;</span><br><span class="line">            hj.setState(<span class="keyword">new</span> Runnable());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程不是阻塞状态，不能调用resume()方法.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态类：死亡状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dead</span> <span class="keyword">extends</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateName = <span class="string">&quot;死亡状态&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程处于：死亡状态.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-5-备忘录模式-保存临时状态以备回滚"><a href="#7-5-备忘录模式-保存临时状态以备回滚" class="headerlink" title="7.5 备忘录模式(保存临时状态以备回滚)"></a>7.5 备忘录模式(保存临时状态以备回滚)</h2><h3 id="定义-17"><a href="#定义-17" class="headerlink" title="定义"></a>定义</h3><p>备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p><blockquote><p>snapshot(快照)：在电脑系统中，快照是整个系统在某个时间点上的状态。该名词由摄影中借用而来。它储存了系统映象，让电脑系统在出现问题时，可以快速恢复到未出问题前的状况。</p><p>在版本管理中，snapshot快照版本通常是指开发过程中的不稳定版本。对比于release发布版本。</p></blockquote><h3 id="结构-17"><a href="#结构-17" class="headerlink" title="结构"></a>结构</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>到底该如何生成一个快照呢？</p><ul><li>遍历对象的所有成员变量并将其数值复制保存？但只有当对象对其内容没有严格访问权限限制的情况下，你才能使用该方式。不过很遗憾，绝大部分对象会使用私有成员变量来存储重要数据，这样别人就无法轻易查看其中的内容。</li><li>就算公开所有成员变量，你可通过上面的方式，随时生成对象的状态快照，但这种方式仍存在一些严重问题。未来你可能会添加或删除一些成员变量。这听上去很简单，但需要对负责复制受影响对象状态的类进行更改。</li></ul><p>备忘录模式将创建状态快照（Snapshot）的工作委派给实际状态的拥有者<strong>原发器/发起人</strong>（Originator）对象。 这样其他对象就不再需要从 “外部” 复制对象状态了，原发起器类拥有其状态的完全访问权，因此可以自行生成快照。</p><p>模式建议将对象状态的副本存储在一个名为<strong>备忘录</strong>（Memento）的特殊对象中。而将备忘录保存在<strong>负责人/管理者</strong>（Caretakers）类中（<em>通常会有个备忘录列表，如果不需要支持多次回滚，那仅持有一个对象引用即可</em>）。</p><ul><li>只有原发器拥有对备忘录所有成员的访问权限，从而能随时从备忘录中获取数据，来恢复其以前的状态。</li><li>其他对象必须使用受限接口与备忘录进行交互，它们可以获取快照的元数据（创建时间和操作名称等）。</li></ul><h4 id="标准结构-支持类嵌套"><a href="#标准结构-支持类嵌套" class="headerlink" title="标准结构(支持类嵌套)"></a>标准结构(支持类嵌套)</h4><p>所以，备忘录模式的主要角色如下。</p><ul><li>原发器/发起人（Originator）角色：生成自身状态的快照，创建备忘录对象并能在需要时通过备忘录对象恢复自身状态。它可以访问备忘录里的所有信息。</li><li>备忘录（Memento）角色：是原发器状态快照的值对象（value object）。通常做法是将备忘录设为不可变的，并通过构造函数一次性传递数据。</li><li>负责人/管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ul><img src="/images/pattern/60.jpg" alt="60" style="zoom:100%;" /><p>在支持嵌套类的编程语言中，可以将备忘录类嵌套在原发器中，这样原发器就可访问备忘录的成员变量和方法（即使这些方法被声明为私有），同时限制了Caretaker的访问权限。</p><h4 id="不支持类嵌套的结构"><a href="#不支持类嵌套的结构" class="headerlink" title="不支持类嵌套的结构"></a>不支持类嵌套的结构</h4><p>在不支持嵌套类的编程语言中，为了能使原发器对象能够完全访问备忘录对象，需要将将备忘录的所有成员变量声明为公有。另一方面，为了限制其对备忘录成员变量的直接访问权限，可在Caretaker与备忘录之间新增一个中间接口进行交互，该接口仅声明与备忘录元数据相关的方法。</p><img src="/images/pattern/61.jpg" alt="61" style="zoom:100%;" /><h4 id="扩展-与原型模式联用"><a href="#扩展-与原型模式联用" class="headerlink" title="扩展: 与原型模式联用"></a>扩展: 与原型模式联用</h4><p>在备忘录模式中，通过定义“备忘录”来备份“发起人”的信息，而原型模式的 clone() 方法具有自备份功能，所以，如果让发起人实现 Cloneable 接口就有备份自己的功能，这时可以删除备忘录类。</p><h3 id="优缺点-16"><a href="#优缺点-16" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li></ul><p>缺点：</p><ul><li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li></ul><h3 id="适用场景-17"><a href="#适用场景-17" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li></ul><h2 id="7-6-迭代器模式-抽取封装集合的遍历"><a href="#7-6-迭代器模式-抽取封装集合的遍历" class="headerlink" title="7.6 迭代器模式(抽取封装集合的遍历)"></a>7.6 迭代器模式(抽取封装集合的遍历)</h2><p>在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，通常的做法是将创建和遍历都放在同一个类中，缺点：</p><ol><li>不利于程序的扩展，如果要新增遍历方法(DFS、BFS、随机存取等)就必须修改程序源代码，这违背了 “开闭原则”。</li><li>不断向集合中添加遍历算法会模糊其 “高效存储数据” 的主要职责。此外，有些算法可能是根据特定应用订制的， 将其加入泛型集合类中会显得非常奇怪。</li><li>使用多种集合的客户端代码可能并不关心存储数据的方式。不过由于集合提供不同的元素访问方式，你的代码将不得不与特定的集合类进行耦合。</li></ol><p>那将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：</p><ol><li>暴露了聚合类的内部表示，使其数据不安全；</li><li>增加了客户的负担。</li></ol><p>“迭代器模式”能较好地克服以上缺点，它<strong>将集合的遍历行为抽取为单独的迭代器对象</strong>，置于客户访问类与聚合类之间，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”。</p><h3 id="定义-18"><a href="#定义-18" class="headerlink" title="定义"></a>定义</h3><p>提供一种方法来顺序访问一个聚合对象中的各个元素，而又不暴露该聚合对象的内部表示。</p><h3 id="结构-18"><a href="#结构-18" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-6"><a href="#标准结构-6" class="headerlink" title="标准结构"></a>标准结构</h4><p>迭代器模式主要包含以下角色。</p><ul><li>抽象聚合（Aggregate）角色：需要声明一个或多个方法来获取与集合兼容的迭代器。请注意， 返回方法的类型要声明为抽象迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</li><li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，在客户端请求迭代器时返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义了遍历聚合所需的接口，通常包含 hasNext()、first()、next() 等方法。</li><li>具体迭代器（Concretelterator）角色：实现遍历集合的一种特定算法。迭代器对象必须跟踪自身遍历的进度。这使得多个迭代器可以相互独立地遍历同一集合。</li></ul><img src="/images/pattern/62.jpg" alt="62" style="zoom:100%;" /><p><strong>客户端</strong> （Client） 通过集合和迭代器的接口与两者进行交互。这样一来客户端无需与具体类进行耦合，允许同一客户端代码使用各种不同的集合和迭代器。</p><p>所有迭代器必须实现相同的接口。 这样一来，只要有合适的迭代器，客户端代码就能兼容任何类型的集合或遍历算法。如果你需要采用特殊方式来遍历集合，只需创建一个新的迭代器类即可，无需对集合或客户端进行修改。</p><p>在日常开发中，我们几乎不会自行创建迭代器，而是会从集合中获取。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。</p><h4 id="扩展-与组合模式联用"><a href="#扩展-与组合模式联用" class="headerlink" title="扩展: 与组合模式联用"></a>扩展: 与组合模式联用</h4><p>迭代器模式常常与组合模式结合起来使用，在对组合模式中的容器构件进行访问时，经常将迭代器潜藏在组合模式的容器构成类中。当然，也可以构造一个外部迭代器来对容器构件进行访问。</p><h3 id="优缺点-17"><a href="#优缺点-17" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。</li><li>开闭原则。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。<ul><li>抽象迭代器为遍历不同的聚合结构提供一个统一的接口。</li><li>支持以不同方式遍历一个聚合，自定义迭代器的子类以支持新的遍历。</li></ul></li><li>你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。相似的， 你可以暂停遍历并在需要时继续。</li><li>可以将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”，以使算法可以和容器交互运作。提升了数据结构、算法的独立性、弹性、交互操作性。</li></ul><p>缺点：</p><ul><li>如果你的程序只与简单的集合进行交互，应用该模式可能会矫枉过正。</li><li>对于某些特殊集合，使用迭代器可能比直接遍历的效率低。</li></ul><h3 id="适用场景-18"><a href="#适用场景-18" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>当集合背后为复杂的数据结构，且你希望对客户端隐藏其复杂性时（出于使用便利性或安全性的考虑），可以使用迭代器模式。<ul><li>迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。</li></ul></li><li>当需要为聚合对象提供多种遍历方式时。</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时。<ul><li>该模式为集合和迭代器提供了一些通用接口。如果你在代码中使用了这些接口，那么将其他实现了这些接口的集合和迭代器传递给它时，它仍将可以正常运行。</li></ul></li></ul><p>由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。</p><h2 id="7-7-命令模式-将方法调用转化为对象"><a href="#7-7-命令模式-将方法调用转化为对象" class="headerlink" title="7.7 命令模式(将方法调用转化为对象)"></a>7.7 命令模式(将方法调用转化为对象)</h2><h3 id="概念：参数、参数化"><a href="#概念：参数、参数化" class="headerlink" title="概念：参数、参数化"></a>概念：参数、参数化</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><blockquote><ul><li>也叫参变量。在所讨论的某个数学或物理问题中，于给定条件下取固定值的变量。如在平面直角坐标系中，如果曲线l上任意一点的坐标（x，y）都可以表示为在某个区间内的变量t的函数，那么所得到的方程x=f（t），y=g（t）就叫做该曲线的参数方程，变量t叫做参数。</li><li>表明任何现象、机构、装置的某种性质的量。如导电率、导热率、膨胀系数等。</li><li>在程序设计中，又称形式引数（formal argument），是一种在调用子程序时用以向子程序传递数据的特殊变量，这些被传递数据也就是子程序引数（arguments）的值。</li></ul></blockquote><h4 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h4><blockquote><p><a href="https://en.wikipedia.org/wiki/Parametric_design">参数化设计</a>：将系统本身编写为函数与过程，使用某些可以编辑的参数或变量，来操纵或改变方程或系统的最终结果。</p></blockquote><p>参数化是一种方法，或者说一种思想。在建模、生活中很多地方都可以用到。简单来说，就是用<strong>最少的元素，控制最多的内容</strong>。从一个物体中抽取一个或几个要素，作为<strong>参数</strong>。其他的要素作为<strong>从动要素</strong>。通过<strong>公式</strong>对参数的计算，得到所有从动要素的值。从而<strong>生成符合要求的整个物体</strong>。</p><p>这个物体你可以理解为一个零件，也可以是包含多个零件的装配体。建立起从动要素和参数的关联的这个过程，称之为参数化。这个关联（公式）是静态的，但参数是动态的，它在它的取值范围内可以随意改变。</p><p><strong>所谓“参数化”就是把一个事物或者问题用参数来表示的行为。</strong>（<em>知道了参数的值就知道了整个事物的模样</em>）。</p><p>此外，有些场景，参数化就是简单的表面意思：<strong>使某个事物可以当做(泛型类、函数的)参数传递。</strong>比如C++模板中常说的<em>类型参数化</em>。</p><h3 id="定义-19"><a href="#定义-19" class="headerlink" title="定义"></a>定义</h3><h4 id="举例引入"><a href="#举例引入" class="headerlink" title="举例引入"></a>举例引入</h4><p>以编辑器为例，一般在工具栏、右键菜单栏、快捷键中 ，都会支持复制、粘贴功能，那我们需要怎么组织这段代码？</p><ul><li>将操作代码复制进许多个类中。</li><li>让菜单栏依赖于我们工具栏中的按钮。(更糟)</li></ul><p>优秀的软件设计通常会将关注点进行分离，而这往往会导致软件的分层。上面的例子中，我们可以清晰的划分出一层负责用户图像界面，一层负责业务逻辑。一个 GUI 对象传递一些参数来调用一个业务逻辑对象。 这个过程通常被描述为一个对象发送<strong>请求</strong>给另一个对象。</p><p>GUI 层可以直接访问业务逻辑层：</p><img src="/images/pattern/63.jpg" alt="63" style="zoom:100%;" /><p>命令模式建议 GUI 对象不直接提交这些请求。 你应该将请求的所有细节 （例如调用的对象、 方法名称和参数列表） 抽取出来组成<em>命令</em>类， 该类中仅包含一个用于触发请求的方法。</p><p>命令对象负责连接不同的 GUI 和业务逻辑对象。 此后， GUI 对象无需了解业务逻辑对象是否获得了请求， 也无需了解其对请求进行处理的方式。 GUI 对象触发命令即可， 命令对象会自行处理所有细节工作。</p><img src="/images/pattern/64.jpg" alt="64" style="zoom:100%;" /><p>此外，当我们订餐时，服务员记下你点的食物， 写在一张纸上。然后来到厨房，把订单贴在墙上。过了一段时间，厨师拿到了订单，他根据订单来准备食物。厨师将做好的食物和订单一起放在托盘上。服务员看到托盘后对订单进行检查，确保所有食物都是你要的，然后将食物放到了你的桌上。</p><p>那张纸就是一个命令，它在厨师开始烹饪前一直位于队列中。命令中包含与烹饪这些食物相关的所有信息，厨师能够根据它马上开始烹饪。</p><h4 id="正式定义"><a href="#正式定义" class="headerlink" title="正式定义"></a>正式定义</h4><p>命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</p><p>命令模式将请求调用者和请求接收者解耦，使得两者不直接交互。</p><h3 id="结构-19"><a href="#结构-19" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-7"><a href="#标准结构-7" class="headerlink" title="标准结构"></a>标准结构</h4><p>命令模式包含如下角色：</p><ul><li>抽象命令类(Command)：通常仅声明一个执行命令的方法 execute()。</li><li>具体命令类(Concrete Command)：<ul><li>实现各种类型的请求。</li><li>具体命令自身并不完成工作， 而是会将调用委派其所拥有的接收者对象（业务逻辑对象）。</li><li>接收对象执行方法所需的参数可以声明为具体命令的成员变量。可将命令对象设为不可变，仅允许通过构造函数对这些成员变量进行初始化。</li></ul></li><li>接收者(Receiver)：<ul><li>包含部分业务逻辑，几乎任何对象都可以作为接收者。</li><li>绝大部分命令只处理如何将请求传递到接收者的细节，接收者自己会完成实际的工作。</li></ul></li><li>发送者(Sender)/触发者(Invoker)：<ul><li>负责对请求进行初始化，其中必须包含一个成员变量来存储对于命令对象的引用。</li><li>发送者触发命令，而不向接收者直接发送请求。</li><li>注意，发送者并不负责创建命令对象，它通常会通过构造函数从客户端处获得预先生成的命令。</li></ul></li></ul><img src="/images/pattern/65.jpg" alt="65" style="zoom:100%;" /><p>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</p><ul><li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Command *m_pCommand;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Invoker</span>(Command * pCommand) &#123;</span><br><span class="line">        m_pCommand = pCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Invoker</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;invoker calling&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_pCommand-&gt;<span class="built_in">execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> :</span> <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Receiver *m_pReceiver;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand</span>(Receiver * pReceiver)&#123;</span><br><span class="line">        m_pReceiver = pReceiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteCommand</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteCommand::execute&quot;</span>  &lt;&lt; endl;</span><br><span class="line">        m_pReceiver-&gt;<span class="built_in">action</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Receiver</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Receiver</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;receiver action.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    Receiver * pReceiver = <span class="keyword">new</span> <span class="built_in">Receiver</span>();</span><br><span class="line">    ConcreteCommand * pCommand = <span class="keyword">new</span> <span class="built_in">ConcreteCommand</span>(pReceiver);</span><br><span class="line">    Invoker * pInvoker = <span class="keyword">new</span> <span class="built_in">Invoker</span>(pCommand);</span><br><span class="line">    pInvoker-&gt;<span class="built_in">call</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pReceiver;</span><br><span class="line">    <span class="keyword">delete</span> pCommand;</span><br><span class="line">    <span class="keyword">delete</span> pInvoker;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-与其他模式的联用-1"><a href="#扩展-与其他模式的联用-1" class="headerlink" title="扩展: 与其他模式的联用"></a>扩展: 与其他模式的联用</h4><p>宏命令又称为组合命令，它是命令模式和组合模式联用的产物。</p><ul><li>宏命令也是一个具体命令，不过它包含了对其他命令对象的引用，在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法，一个宏命令的成员对象可以是简单命令，还可以继续是宏命令。执行一个宏命令将执行多个具体命令，从而实现对命令的批处理。</li></ul><p>命令模式还可以同备忘录（Memento）模式组合使用，这样就变成了可撤销的命令模式</p><h3 id="优缺点-18"><a href="#优缺点-18" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的Undo和Redo。</li><li>在需要的时候，可以很容易地将命令记入日志。</li></ul><p>缺点</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li></ul><h3 id="适用场景-19"><a href="#适用场景-19" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。<ul><li>命令模式将特定的方法调用转化为独立对象。 带来了许多有趣的应用：你可以将命令作为方法的参数进行传递、将命令保存在其他对象中，或者在运行时切换已连接的命令等。</li></ul></li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作（<em>结合备忘录模式实现</em>）。</li><li>系统需要将一组操作组合在一起，即支持宏命令</li></ul><p>很多系统都提供了宏命令功能，如UNIX平台下的Shell编程，可以将多条命令封装在一个命令对象中，只需要一条简单的命令即可执行一个命令序列，这也是命令模式的应用实例之一。</p><h2 id="7-8-责任链模式-将请求处理者们连成链"><a href="#7-8-责任链模式-将请求处理者们连成链" class="headerlink" title="7.8 责任链模式(将请求处理者们连成链)"></a>7.8 责任链模式(将请求处理者们连成链)</h2><p>在现实生活中，一个事件需要经过多个对象处理是很常见的场景。例如，采购审批流程、请假流程等。公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据需要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这无疑增加了难度。</p><h3 id="定义-20"><a href="#定义-20" class="headerlink" title="定义"></a>定义</h3><p>责任链模式(Chain of Responsibility)，也叫职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。(<em>每个处理者收到请求后，均可选择处理该请求，或将其传递给链上的下个处理者。</em>)</p><p>责任链模式将请求的发送者和处理者解耦，即客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。</p><p>而系统也可以在不影响客户使用的情况下，动态地重新组织和分配责任。</p><h3 id="结构-20"><a href="#结构-20" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-8"><a href="#标准结构-8" class="headerlink" title="标准结构"></a>标准结构</h4><p>责任链模式主要包含以下角色。</p><ul><li>抽象处理者(Handler)：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者(Concrete Handler)：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。<ul><li>处理者通常是独立且不可变的，需要通过构造函数一次性地获得所有必要地数据。</li></ul></li><li>客户类(Client)：根据程序逻辑一次性或者动态地生成链。值得注意的是，请求可发送给链上的任意一个处理者，而非必须是第一个处理者。</li></ul><img src="/images/pattern/66.jpg" alt="66" style="zoom:100%;" /><p>责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。</p><h4 id="扩展-纯、不纯的责任链模式"><a href="#扩展-纯、不纯的责任链模式" class="headerlink" title="扩展: 纯、不纯的责任链模式"></a>扩展: 纯、不纯的责任链模式</h4><p>责任链模式存在以下两种情况。</p><ul><li>纯的责任链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。</li><li>不纯的责任链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。</li></ul><h4 id="对比-与状态模式的区别"><a href="#对比-与状态模式的区别" class="headerlink" title="对比: 与状态模式的区别"></a>对比: 与状态模式的区别</h4><p>状态模式和责任链模式。但在某些情况下，状态模式中的状态可以理解为责任，那么在这种情况下，两种模式都可以使用。</p><p>相似处：</p><ul><li>都会发生状态或责任的转移。(<em>状态的转移可能是有环的，而责任链不能出现环。</em>)</li><li>都能消除 if-else 分支过多的问题。</li></ul><p>不过两者还是有很明显的区别的：</p><ul><li><p>从定义来看，状态模式强调的是一个对象内在状态的改变，而责任链模式强调的是外部节点对象间的改变。</p></li><li><p>从代码实现上来看，两者最大的区别就是状态模式的各个状态对象知道自己要进入的下一个状态对象，而责任链模式并不清楚其下一个节点处理对象，因为链式组装由客户端负责。</p></li></ul><h3 id="优缺点-19"><a href="#优缺点-19" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>将请求的发送者和接受者解耦。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li><li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li><li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li><li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li><li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li></ul><p>缺点：</p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><h3 id="适用场景-20"><a href="#适用场景-20" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。</li><li>可动态指定一组对象处理请求，或添加新的处理者。</li></ul><h2 id="7-9-中介者模式-将依赖从网状变星型"><a href="#7-9-中介者模式-将依赖从网状变星型" class="headerlink" title="7.9 中介者模式(将依赖从网状变星型)"></a>7.9 中介者模式(将依赖从网状变星型)</h2><p>在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。</p><p><em>例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须让其他所有的朋友一起修改，牵一发而动全身，非常复杂。</em></p><p>如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。</p><p><em>如前面所说的“每个人必须记住所有朋友电话”的问题，只要在网上建立一个每个朋友都可以访问的“通信录”就解决了。</em></p><p>这样的例子还有很多，例如：</p><ul><li>你刚刚参加工作想租房，可以找“房屋中介”；</li><li>刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。</li><li>MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；</li><li>常用的 QQ 聊天程序的“中介者”是 QQ 服务器。</li></ul><p>所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。</p><h3 id="定义-21"><a href="#定义-21" class="headerlink" title="定义"></a>定义</h3><p>中介者模式(Mediator Pattern)定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>中介者模式又称为调停者模式。</p><h3 id="结构-21"><a href="#结构-21" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-9"><a href="#标准结构-9" class="headerlink" title="标准结构"></a>标准结构</h4><p>中介者模式包含以下主要角色。</p><ul><li>抽象中介者(Mediator)：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li><li>具体中介者(Concrete Mediator)：实现中介者接口。<ul><li>定义一个 List 或 map (<em>可根据具体同事类对象的个数等因素来决定</em>)来管理所有的同事对象。</li><li>协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li></ul></li><li>抽象同事类(Colleague)：定义同事类的接口。<ul><li>每个同事类都有一个指向中介者对象的引用。该引用被声明为中介者接口类型，可通过将其连接到不同的中介者以使其能在其他程序中复用。</li><li>提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li></ul></li><li>具体同事类(Concrete Colleague)：是抽象同事类的实现者。<ul><li>是各种包含业务逻辑的类。</li><li>当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li></ul></li></ul><img src="/images/pattern/67.jpg" alt="67" style="zoom:100%;" /><p>中介者模式可以使对象之间的关系数量急剧减少。中介者承担两方面的职责：</p><ul><li>中转作用（结构性）：<ul><li>通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</li><li>对于同事对象来说，中介者看上去完全就是一个黑箱。发送者不知道最终会由谁来处理自己的请求，接收者也不知道最初是谁发出了请求。</li></ul></li><li>协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> :</span> <span class="keyword">public</span> Mediator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>,Colleague*&gt; m_mpColleague;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteMediator</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteMediator</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> nWho,string str)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,Colleague*&gt;::const_iterator itr = m_mpColleague.<span class="built_in">find</span>(nWho);</span><br><span class="line">        <span class="keyword">if</span>(itr == m_mpColleague.<span class="built_in">end</span>())&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not found this colleague!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Colleague* pc = itr-&gt;second;</span><br><span class="line">        pc-&gt;<span class="built_in">receivemsg</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">registered</span><span class="params">(<span class="keyword">int</span> nWho, Colleague * aColleague)</span></span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,Colleague*&gt;::const_iterator itr = m_mpColleague.<span class="built_in">find</span>(nWho);</span><br><span class="line">        <span class="keyword">if</span>(itr == m_mpColleague.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_mpColleague.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(nWho,aColleague));</span><br><span class="line">            <span class="comment">//同时将中介类暴露给colleague </span></span><br><span class="line">            aColleague-&gt;<span class="built_in">setMediator</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleagueA</span> :</span> <span class="keyword">public</span> Colleague</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleagueA</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteColleagueA</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> toWho,string str)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;send msg from colleagueA,to:&quot;</span> &lt;&lt; toWho &lt;&lt; endl;</span><br><span class="line">        m_pMediator-&gt;<span class="built_in">operation</span>(toWho,str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">receivemsg</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteColleagueA reveivemsg:&quot;</span> &lt;&lt; str &lt;&lt;endl;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    ConcreteColleagueA * pa = <span class="keyword">new</span> <span class="built_in">ConcreteColleagueA</span>();</span><br><span class="line">    ConcreteColleagueB * pb = <span class="keyword">new</span> <span class="built_in">ConcreteColleagueB</span>();</span><br><span class="line">    ConcreteMediator * pm = <span class="keyword">new</span> <span class="built_in">ConcreteMediator</span>();</span><br><span class="line">    pm-&gt;<span class="built_in">registered</span>(<span class="number">1</span>,pa);</span><br><span class="line">    pm-&gt;<span class="built_in">registered</span>(<span class="number">2</span>,pb);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sendmsg from a to b</span></span><br><span class="line">    pa-&gt;<span class="built_in">sendmsg</span>(<span class="number">2</span>,<span class="string">&quot;hello,i am a&quot;</span>);</span><br><span class="line">    <span class="comment">// sendmsg from b to a</span></span><br><span class="line">    pb-&gt;<span class="built_in">sendmsg</span>(<span class="number">1</span>,<span class="string">&quot;hello,i am b&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pa,pb,pm;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构-不存在抽象中介者"><a href="#结构-不存在抽象中介者" class="headerlink" title="结构: 不存在抽象中介者"></a>结构: 不存在抽象中介者</h4><ol><li>不定义中介者接口，把具体中介者对象实现成为单例。</li><li>同事对象不持有中介者，而是在需要的时候直接获取中介者对象并调用。</li></ol><img src="/images/pattern/69.jpg" alt="69" style="zoom:100%;" /><h4 id="结构-不存在抽象组件类"><a href="#结构-不存在抽象组件类" class="headerlink" title="结构: 不存在抽象组件类"></a>结构: 不存在抽象组件类</h4><p>抽象组件类并不是一定要存在的，尤其是对于已有代码的重构，更不能保证所有组件都会继承同一个抽象组件类。</p><img src="/images/pattern/68.jpg" alt="68" style="zoom:100%;" /><h3 id="优缺点-20"><a href="#优缺点-20" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li><li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li><li>类之间各司其职，符合迪米特法则。<ul><li>通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，中介者模式就是迪米特法则的一个典型应用。</li></ul></li></ul><p>缺点</p><ul><li>在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li></ul><h3 id="适用场景-21"><a href="#适用场景-21" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li><li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li></ul><p>中介者模式可以方便地应用于图形界面(GUI)开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系。对于这些复杂的交互关系，有时候我们可以引入一个中介者类，将这些交互的组件作为具体的同事类，将它们之间的引用和控制关系交由中介者负责，在一定程度上简化系统的交互，这也是中介者模式的常见应用之一。(<em>比如：iOS开发中的路由模块</em>)</p><h2 id="7-10-解释器模式-自定义嵌入式DSL"><a href="#7-10-解释器模式-自定义嵌入式DSL" class="headerlink" title="7.10 解释器模式(自定义嵌入式DSL)"></a>7.10 解释器模式(自定义嵌入式DSL)</h2><p>解释器（Interpreter）模式能引起一些高级开发者的兴趣。这是因为解释器模式的思想是让非初级用户和领域专家使用一门简单的语言（没编程语言那么复杂的语言）来表达思想。</p><p>解释器模式，常用于创建一种专注于某个特定领域的计算机语言。这种语言称为领域特定语言（Domain Specific Language, DSL）。</p><p>DSL 分为内部/嵌入式 DSL 和外部 DSL(前者的实现依赖于某种宿主语言)，而解释器模式仅与内部 DSL 相关。我们的目标是使用宿主语言提供的特性构建一种简单但有用的语言。</p><h3 id="概念：文法、句子、语法树"><a href="#概念：文法、句子、语法树" class="headerlink" title="概念：文法、句子、语法树"></a>概念：文法、句子、语法树</h3><blockquote><p>语法：语言的结构规则，包括词的构成和变化、词组和句子的组织（概括起来就是两部分：词法和句法）。又称文法。</p></blockquote><p>无论是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的“句子”的文法如下。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 符号“::=”表示“定义为”</span><br><span class="line">// 用〈 和 〉括住的是非终结符：是用来表示语法成分的符号，有时也称为“语法变量”</span><br><span class="line">// 没有括住的是终结符：是文法所定义的语言的基本符号，有时也称为token</span><br><span class="line"></span><br><span class="line">〈句子〉::=〈主语〉〈谓语〉〈宾语〉</span><br><span class="line">〈主语〉::=〈代词〉|〈名词〉</span><br><span class="line">〈谓语〉::=〈动词〉</span><br><span class="line">〈宾语〉::=〈代词〉|〈名词〉</span><br><span class="line">〈代词〉你|我|他</span><br><span class="line">〈名词〉大学生|筱霞|英语</span><br><span class="line">〈动词〉::=是|学习</span><br></pre></td></tr></table></figure><p>句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子。</p><p>语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。如下图所示是“我是大学生”的语法树。</p><img src="/images/pattern/70.jpg" alt="70" style="zoom:100%;" /><h3 id="定义-22"><a href="#定义-22" class="headerlink" title="定义"></a>定义</h3><p>解释器模式(Interpreter)的定义：定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。是一种类行为型模式。</p><p>解释器模式需要解决的是，<strong>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子</strong>。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p><p><em>比方说，我们常常会使用正则表达式，在字符串中搜索匹配的字符或判断一个字符串是否符合我们规定的格式。正则表达式就是解释器模式的一种应用，解释器为正则表达式定义了一套文法（如何表示一个特定的正则表达式），以及如何解释这个正则表达式。</em></p><p>这种模式用编译语言的方式来分析应用中的实例。实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p><h3 id="结构-22"><a href="#结构-22" class="headerlink" title="结构"></a>结构</h3><p>解释器模式包含以下主要角色。</p><ul><li>抽象表达式(Abstract Expression)：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li><li>终结符表达式(Terminal Expression)：抽象表达式的子类。<ul><li>实现与文法中终结符相关联的解释操作。</li><li>文法中的每一个终结符都有一个具体终结表达式与之相对应。</li></ul></li><li>非终结符表达式(Nonterminal Expression)：抽象表达式的子类。<ul><li>实现与文法中非终结符相关联的解释操作。</li><li>文法中的每条规则都对应于一个非终结符表达式类。</li></ul></li><li>环境(Context)：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。<ul><li>环境类传递数据给表达式类/解释器类有两种方式：1. 将Context对象作为 interpret() 方法的参数传入。 2. 事先在Context类中，完成表达式类对象的配置(<em>如下图</em>)。</li></ul></li><li>客户端(Client)：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li></ul><img src="/images/pattern/71.jpg" alt="71" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">解释器模式设计一个“韶粵通”公交车卡的读卡器程序。</span></span><br><span class="line"><span class="comment">说明：假如“韶粵通”公交车读卡器可以判断乘客的身份，如果是“韶关”或者“广州”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> net.biancheng.c.interpreter;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*文法规则</span></span><br><span class="line"><span class="comment">  &lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;</span></span><br><span class="line"><span class="comment">  &lt;city&gt; ::= 韶关|广州</span></span><br><span class="line"><span class="comment">  &lt;person&gt; ::= 老人|妇女|儿童</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context bus = <span class="keyword">new</span> Context();</span><br><span class="line">        bus.freeRide(<span class="string">&quot;韶关的老人&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;韶关的年轻人&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;广州的妇女&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;广州的儿童&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;山东的儿童&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) set.add(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(info)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Expression city = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Expression person = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression city, Expression person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        String s[] = info.split(<span class="string">&quot;的&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> city.interpret(s[<span class="number">0</span>]) &amp;&amp; person.interpret(s[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] citys = &#123;<span class="string">&quot;韶关&quot;</span>, <span class="string">&quot;广州&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String[] persons = &#123;<span class="string">&quot;老人&quot;</span>, <span class="string">&quot;妇女&quot;</span>, <span class="string">&quot;儿童&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Expression cityPerson;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Expression city = <span class="keyword">new</span> TerminalExpression(citys);</span><br><span class="line">        Expression person = <span class="keyword">new</span> TerminalExpression(persons);</span><br><span class="line">        cityPerson = <span class="keyword">new</span> AndExpression(city, person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeRide</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ok = cityPerson.interpret(info);</span><br><span class="line">        <span class="keyword">if</span> (ok) System.out.println(<span class="string">&quot;您是&quot;</span> + info + <span class="string">&quot;，您本次乘车免费！&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(info + <span class="string">&quot;，您不是免费人员，本次乘车扣费2元！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-21"><a href="#优缺点-21" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li></ul><p>缺点：</p><ul><li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li><li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li><li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li></ul><h3 id="适用场景-22"><a href="#适用场景-22" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>当语言的文法较为简单，且执行效率不是关键问题时。</li><li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li><li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。</li></ul><p>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题</p><h2 id="7-11-访问者模式-“访问者”一词很贴切"><a href="#7-11-访问者模式-“访问者”一词很贴切" class="headerlink" title="7.11 访问者模式(“访问者”一词很贴切)"></a>7.11 访问者模式(“访问者”一词很贴切)</h2><blockquote><p><strong>每个访问者对集合中每个元素的处理不同。</strong>将操作从数据结构中抽出，封成访问者类。</p></blockquote><p>在现实生活中，有些集合对象存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如：</p><ul><li>公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；</li><li>电影或电视剧中的人物角色，不同的观众对他们的评价也不同；</li><li>顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。</li></ul><img src="/images/pattern/73.jpg" alt="73" style="zoom:90%;" /><p>对于这些数据元素相对稳定而访问方式多种多样的数据结构，访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。</p><h3 id="定义-23"><a href="#定义-23" class="headerlink" title="定义"></a>定义</h3><p>访问者模式(Visitor)的定义：将作用于某种数据结构中的各元素的<strong>操作，从数据结构中分离出来</strong>封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。</p><h3 id="结构-23"><a href="#结构-23" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-10"><a href="#标准结构-10" class="headerlink" title="标准结构"></a>标准结构</h4><p>访问者模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类。</p><p>访问者模式包含以下主要角色。</p><ul><li>抽象访问者(Visitor)：定义一个访问具体元素的接口。<ul><li>为每个具体元素类声明一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li><li>如果编程语言支持重载，这些方法的名称可以是相同的，但是其参数一定是不同的。</li></ul></li><li>具体访问者(ConcreteVisitor)：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li><li>抽象元素(Element)：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</li><li>具体元素(ConcreteElement)：实现抽象元素角色提供的 accept() 操作。<ul><li>该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法：方法体通常都是 visitor.visit(this) </li><li>另外具体元素中可能还包含本身业务逻辑的相关操作。</li></ul></li><li>对象结构(Object Structure)：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li></ul><img src="/images/pattern/72.png" alt="72" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.visitor;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectStructure os = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor); </span><br><span class="line">        <span class="comment">// 具体访问者A访问--&gt;具体元素A的操作。</span></span><br><span class="line">        <span class="comment">// 具体访问者A访问--&gt;具体元素B的操作。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        visitor = <span class="keyword">new</span> ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        <span class="comment">// 具体访问者B访问--&gt;具体元素A的操作。</span></span><br><span class="line">        <span class="comment">// 具体访问者B访问--&gt;具体元素B的操作。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象访问者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorB</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象元素类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素A的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素B的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象结构角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; list = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Element&gt; i = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-与其他模式联用"><a href="#扩展-与其他模式联用" class="headerlink" title="扩展: 与其他模式联用"></a>扩展: 与其他模式联用</h4><p>访问者（Visitor）模式是使用频率较高的一种设计模式，它常常同以下两种设计模式联用。</p><ul><li><p>与“迭代器模式”联用。因为访问者模式中的“对象结构”是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。上面类图中的对象结构是用 List 实现的，它通过 List 对象的 Iterator() 方法获取迭代器。如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。</p></li><li><p>与“组合模式”联用。因为访问者模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到组合模式。部分类图如下：</p><img src="/images/pattern/74.png" alt="74" style="zoom:100%;" /></li></ul><h3 id="优缺点-22"><a href="#优缺点-22" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li><li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li><li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li><li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li></ul><p>缺点：</p><ul><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li><li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li><li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li></ul><h3 id="适用场景-23"><a href="#适用场景-23" class="headerlink" title="适用场景"></a>适用场景</h3><p>当系统中存在类型数量稳定（固定）的一类数据结构时，可以使用访问者模式方便地实现对该类型所有数据结构的不同操作，而又不会对数据产生任何副作用（脏数据）。</p><p>简而言之，就是<strong>当对集合中的不同类型数据（类型数量稳定）进行多种操作时，使用访问者模式</strong>。</p><ul><li>对象结构相对稳定，但其操作算法经常变化的程序。</li><li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li><li>对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html">《Graphic Design Patterns》(很不错的，很详细…不过，有些地方详细到有点点的啰嗦)</a></li><li><a href="http://c.biancheng.net/design_pattern/">Java设计模式：23种设计模式全面解析(内容挺精简的)</a></li><li><a href="https://refactoringguru.cn/design-patterns/bridge">《深入设计模式》</a></li><li>《Header First设计模式》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、架构相关术语&quot;&gt;&lt;a href=&quot;#一、架构相关术语&quot; class=&quot;headerlink&quot; title=&quot;一、架构相关术语&quot;&gt;&lt;/a&gt;一、架构相关术语&lt;/h1&gt;&lt;h2 id=&quot;1-1-架构&quot;&gt;&lt;a href=&quot;#1-1-架构&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="架构与设计模式" scheme="https://tenloy.github.io/categories/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>图形处理(三) - 图形处理实践案例</title>
    <link href="https://tenloy.github.io/2021/09/15/graphics-processing-case.html"/>
    <id>https://tenloy.github.io/2021/09/15/graphics-processing-case.html</id>
    <published>2021-09-15T15:54:07.000Z</published>
    <updated>2022-02-09T09:25:55.030Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中因为性能原因，最好不要叠加太多UIView，CALayer层级的显示；但是很多情况又必须使用到图片的合成或是像素、滤镜处理。这里针这些常用的图片处理使用不同图形处理框架进行相关编码实践。<a href="https://juejin.cn/post/6846687599591948301">原文链接 — iOS图片处理实践</a>、<a href="https://link.juejin.cn/?target=https://github.com/EricStone1900/ImageOperate-OC">项目代码</a>。</p><h2 id="一、图片手动解码"><a href="#一、图片手动解码" class="headerlink" title="一、图片手动解码"></a>一、图片手动解码</h2><p>写在前面：图片编码解码理论见上上篇</p><p>场景：适用于需要快速显示图片的地方，例如tableCell，先把图片进行bitmap解码操作加入缓存。同时如果是超大图可以和下面第三节的图片压缩方法搭配使用。</p><p>解决方案：通过CGBitmapContextCreate 重绘图片，这种压缩的图片等于手动进行了一次解码，可以加快图片的展示</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片处理-强制解压缩操作-把元数据绘制到当前的上下文-压缩图片</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithBitmap:(<span class="built_in">CGFloat</span>)scale &#123;</span><br><span class="line">   <span class="comment">//获取当前图片数据源</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">   <span class="comment">//设置大小改变压缩图片</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef)*scale;</span><br><span class="line">   <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef)*scale;</span><br><span class="line">   <span class="comment">//创建颜色空间</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGImageGetColorSpace</span>(imageRef);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建绘制当前图片的上下文</span></span><br><span class="line"><span class="comment">    CGBitmapContextCreate(void * __nullable data,</span></span><br><span class="line"><span class="comment">     size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span></span><br><span class="line"><span class="comment">     CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo)</span></span><br><span class="line"><span class="comment">     data：所需要的内存空间 传nil会自动分配</span></span><br><span class="line"><span class="comment">     width/height：当前画布的大小</span></span><br><span class="line"><span class="comment">     bitsPerComponent：每个颜色分量的大小 RGBA 每一个分量占1个字节</span></span><br><span class="line"><span class="comment">     bytesPerRow：每一行使用的字节数 4*width</span></span><br><span class="line"><span class="comment">     bitmapInfo：RGBA绘制的顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="built_in">CGContextRef</span> contextRef =</span><br><span class="line">   <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>,</span><br><span class="line">                         width,</span><br><span class="line">                         height,</span><br><span class="line">                         <span class="number">8</span>,</span><br><span class="line">                         <span class="number">4</span>*width,</span><br><span class="line">                         colorSpace,</span><br><span class="line">                         kCGImageAlphaNoneSkipLast);</span><br><span class="line">   <span class="comment">//根据数据源在上下文（画板）绘制图片</span></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">   </span><br><span class="line">   imageRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">   <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:imageRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、大图在本地的高效显示"><a href="#二、大图在本地的高效显示" class="headerlink" title="二、大图在本地的高效显示"></a>二、大图在本地的高效显示</h2><p>项目场景：1、下载大图后需要显示在屏幕上；2、本地读取大图显示在屏幕上。特别是对性能和图片要求较高的时候。</p><p>最佳解决方案：WWDC2018 苹果给的方案，见上上篇最后一节。</p><h2 id="三、图片压缩"><a href="#三、图片压缩" class="headerlink" title="三、图片压缩"></a>三、图片压缩</h2><p>写在前面：首先介绍两种最简单最常见的压缩方式，下面复杂的压缩方式也是在此之上的扩展，可以根据实际情况进行调整；</p><p>关于质量的压缩，苹果提供了一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageJPEGRepresentation</span>(image, compression);</span><br></pre></td></tr></table></figure><p>关于这个方法，理论上值越小表示图片质量越低，图片文件自然越小。但是并不是 compression 取 0，就是0b大小，取 1 就是原图。而且如果你是一张很大的图，即使compression = 0.0001等或更小，图片压缩到一定大小后，都无法再被压缩下去。</p><h3 id="3-1-按照指定压缩比例压缩图片"><a href="#3-1-按照指定压缩比例压缩图片" class="headerlink" title="3.1 按照指定压缩比例压缩图片"></a>3.1 按照指定压缩比例压缩图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照质量压缩</span></span><br><span class="line"><span class="comment">//主要弊端：如果有大图按这个方法，尺寸有可能依然很大</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithQuality:(<span class="built_in">CGFloat</span>)rate &#123;</span><br><span class="line">   <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, rate);</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-按照指定尺寸压缩图片"><a href="#3-2-按照指定尺寸压缩图片" class="headerlink" title="3.2 按照指定尺寸压缩图片"></a>3.2 按照指定尺寸压缩图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照尺寸压缩</span></span><br><span class="line"><span class="comment">// 主要弊端：图片可能会变形，质量也无法保证</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithSize:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">   <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">   [<span class="keyword">self</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">   <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-具体的应用场景分析"><a href="#3-3-具体的应用场景分析" class="headerlink" title="3.3 具体的应用场景分析"></a>3.3 具体的应用场景分析</h3><h4 id="1-上传或存储有大小要求的图片"><a href="#1-上传或存储有大小要求的图片" class="headerlink" title="1. 上传或存储有大小要求的图片"></a>1. 上传或存储有大小要求的图片</h4><p>循环逐渐减小图片尺寸，直到图片稍小于指定大小，这样做的好处是可以在我们限定图片大小后，图片尺寸也是此时最大的。问题是循环次数多，效率低，耗时长。可以用二分法来提高效率：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环逐渐减小图片尺寸，直到图片稍小于指定大小</span></span><br><span class="line"><span class="comment">// 同样的问题是循环次数多，效率低，耗时长。可以用二分法来提高效率，具体代码省略。这里介绍另外一种方法，比二分法更好，压缩次数少，而且可以使图片压缩后刚好小于指定大小(不只是 &lt; maxLength， &gt; maxLength * 0.9)。</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithCycleSize:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = <span class="keyword">self</span>;</span><br><span class="line">   <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">NSUInteger</span> lastDataLength = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (data.length &gt; maxLength &amp;&amp; data.length != lastDataLength) &#123;</span><br><span class="line">       lastDataLength = data.length;</span><br><span class="line">       <span class="built_in">CGFloat</span> ratio = (<span class="built_in">CGFloat</span>)maxLength / data.length;</span><br><span class="line">       <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>((<span class="built_in">NSUInteger</span>)(resultImage.size.width * sqrtf(ratio)),</span><br><span class="line">                                (<span class="built_in">NSUInteger</span>)(resultImage.size.height * sqrtf(ratio))); <span class="comment">// Use NSUInteger to prevent white blank</span></span><br><span class="line">       <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">       <span class="comment">// Use image to draw (drawInRect:), image is larger but more compression time</span></span><br><span class="line">       <span class="comment">// Use result image to draw, image is smaller but less compression time</span></span><br><span class="line">       [resultImage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">       resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">       <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">       data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-上传或存储有质量要求的图片"><a href="#2-上传或存储有质量要求的图片" class="headerlink" title="2. 上传或存储有质量要求的图片"></a>2. 上传或存储有质量要求的图片</h4><p>循环压缩图片质量直到图片稍小于指定大小，默认循环6次，循环太多次后面也再也压不下去，当然这个次数可以自行配置。好处就是最大限度的保证了图片质量。同样用二分法来提高效率。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环压缩图片质量直到图片稍小于指定大小。</span></span><br><span class="line"><span class="comment">// ⚠️：注意：当图片质量低于一定程度时，继续压缩没有效果。默认压缩最多6次,通过二分法来优化循环次数多</span></span><br><span class="line"><span class="comment">// 压缩图片质量的优点在于，尽可能保留图片清晰度，图片不会明显模糊；缺点在于，不能保证图片压缩后小于指定大小。</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithCycleQulity:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> compression = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        compression = (max + min) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">        <span class="keyword">if</span> (data.length &lt; maxLength * <span class="number">0.9</span>) &#123;</span><br><span class="line">            min = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length &gt; maxLength) &#123;</span><br><span class="line">            max = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-在大小有上限的情况下尽量保证质量"><a href="#3-在大小有上限的情况下尽量保证质量" class="headerlink" title="3. 在大小有上限的情况下尽量保证质量"></a>3. 在大小有上限的情况下尽量保证质量</h4><p>两种图片压缩方法结合 尽量兼顾质量和大小。以确保大小合适为标准。好处就是在大小限定的情况下最大保证了质量和尺寸。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)compressWithQulitySize:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">    <span class="comment">// Compress by quality</span></span><br><span class="line">    <span class="built_in">CGFloat</span> compression = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        compression = (max + min) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">        <span class="keyword">if</span> (data.length &lt; maxLength * <span class="number">0.9</span>) &#123;</span><br><span class="line">            min = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length &gt; maxLength) &#123;</span><br><span class="line">            max = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> resultImage;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Compress by size</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> lastDataLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (data.length &gt; maxLength &amp;&amp; data.length != lastDataLength) &#123;</span><br><span class="line">        lastDataLength = data.length;</span><br><span class="line">        <span class="built_in">CGFloat</span> ratio = (<span class="built_in">CGFloat</span>)maxLength / data.length;</span><br><span class="line">        <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>((<span class="built_in">NSUInteger</span>)(resultImage.size.width * sqrtf(ratio)),</span><br><span class="line">                                 (<span class="built_in">NSUInteger</span>)(resultImage.size.height * sqrtf(ratio))); <span class="comment">// Use NSUInteger to prevent white blank</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">        [resultImage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">        resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, compression);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、图片像素修改操作"><a href="#四、图片像素修改操作" class="headerlink" title="四、图片像素修改操作"></a>四、图片像素修改操作</h2><p>写在前面：这部分的理论都是通过图片重绘来修改修该图片位图中的像素值，从而达到图片的修改。</p><h3 id="4-1-图片灰度图-黑白图"><a href="#4-1-图片灰度图-黑白图" class="headerlink" title="4.1 图片灰度图(黑白图)"></a>4.1 图片灰度图(黑白图)</h3><p>灰度图的三种颜色转换算法：</p><ol><li><p>浮点算法：R = G = B = 0.3<em>R + 0.59</em>G + 0.11*B</p></li><li><p>平均值法：R = G = B = (R+G+B)/3</p></li><li><p>任取一个分量色：R = G = B = R或G或B</p></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageToGray:(<span class="built_in">NSInteger</span>)type &#123;</span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">    <span class="comment">//1、获取图片宽高</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">    <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">    <span class="comment">//2、创建颜色空间</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">    <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), <span class="keyword">self</span>.CGImage);</span><br><span class="line">    <span class="comment">//5、将彩色图片像素点重新设置颜色</span></span><br><span class="line">    <span class="comment">//取平均值 R=G=B=(R+G+B)/3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;width; x++) &#123;</span><br><span class="line">            <span class="comment">//计算平均值重新存储像素点-直接操作像素点</span></span><br><span class="line">            uint8_t *rgbPiexl = (uint8_t *)&amp;imagePiexl[y*width+x];</span><br><span class="line">            <span class="comment">//rgbPiexl[0],rgbPiexl[1],rgbPiexl[2];</span></span><br><span class="line">            <span class="comment">//(rgbPiexl[0]+rgbPiexl[1]+rgbPiexl[2])/3;</span></span><br><span class="line">            uint32_t gray = rgbPiexl[<span class="number">0</span>]*<span class="number">0.3</span>+rgbPiexl[<span class="number">1</span>]*<span class="number">0.59</span>+rgbPiexl[<span class="number">2</span>]*<span class="number">0.11</span>;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">                gray = rgbPiexl[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">1</span>) &#123;</span><br><span class="line">                gray = (rgbPiexl[<span class="number">0</span>]+rgbPiexl[<span class="number">1</span>]+rgbPiexl[<span class="number">2</span>])/<span class="number">3</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">                gray = rgbPiexl[<span class="number">0</span>]*<span class="number">0.3</span>+rgbPiexl[<span class="number">1</span>]*<span class="number">0.59</span>+rgbPiexl[<span class="number">2</span>]*<span class="number">0.11</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rgbPiexl[<span class="number">0</span>] = gray;</span><br><span class="line">            rgbPiexl[<span class="number">1</span>] = gray;</span><br><span class="line">            rgbPiexl[<span class="number">2</span>] = gray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据上下文绘制</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">    <span class="comment">//释放用过的内存</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">    free(imagePiexl);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-修改图片的RGB值"><a href="#4-2-修改图片的RGB值" class="headerlink" title="4.2 修改图片的RGB值"></a>4.2 修改图片的RGB值</h3><p>通过修改图片的RGB值来控制图片的颜色显示。或者替换某种颜色。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageToRGB:(<span class="built_in">CGFloat</span>)rk g:(<span class="built_in">CGFloat</span>)gk b:(<span class="built_in">CGFloat</span>)bk &#123;</span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">   <span class="comment">//1、获取图片宽高</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">   <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">   <span class="comment">//2、创建颜色空间</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">   <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">   <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">   <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">   <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">   <span class="comment">//5、将彩色图片像素点重新设置颜色</span></span><br><span class="line">   <span class="comment">//取平均值 R=G=B=(R+G+B)/3</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;height; y++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;width; x++) &#123;</span><br><span class="line">           <span class="comment">//操作像素点</span></span><br><span class="line">           uint8_t *rgbPiexl = (uint8_t *)&amp;imagePiexl[y*width+x];</span><br><span class="line">           <span class="comment">//该色值下不做处理</span></span><br><span class="line">           <span class="keyword">if</span> (rgbPiexl[<span class="number">0</span>]&gt;<span class="number">245</span>&amp;&amp;rgbPiexl[<span class="number">1</span>]&gt;<span class="number">245</span>&amp;&amp;rgbPiexl[<span class="number">2</span>]&gt;<span class="number">245</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;该色值下不做处理&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               rgbPiexl[<span class="number">0</span>] = rgbPiexl[<span class="number">0</span>]*rk;</span><br><span class="line">               rgbPiexl[<span class="number">1</span>] = rgbPiexl[<span class="number">1</span>]*gk;</span><br><span class="line">               rgbPiexl[<span class="number">2</span>] = rgbPiexl[<span class="number">2</span>]*bk;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//根据上下文绘制</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">   <span class="comment">//释放用过的内存</span></span><br><span class="line">   <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">   <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">   free(imagePiexl);</span><br><span class="line">   <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-图片打码"><a href="#4-3-图片打码" class="headerlink" title="4.3 图片打码"></a>4.3 图片打码</h3><p>马赛克就是让图片看上去模糊不清。将特定区域的像素点设置为同一种颜色，整体就会变得模糊，区域块越大越模糊，越小越接近于原始像素。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置马赛克</span></span><br><span class="line"><span class="comment">//马赛克就是让图片看上去模糊不清。将特定区域的像素点设置为同一种颜色，整体就会变得模糊，区域块越大越模糊，越小越接近于原始像素。</span></span><br><span class="line"><span class="comment">//同样使用强制解压缩操作，操作像素点，马赛克部分实际操作</span></span><br><span class="line"><span class="comment">//1、设置区域大小；</span></span><br><span class="line"><span class="comment">//2、在该区域获取一个像素点（第一个）作为整个区域的取色；</span></span><br><span class="line"><span class="comment">//3、将取色设置到区域中；</span></span><br><span class="line"><span class="comment">//4、取下一个区域同上去色设置区域</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)imageToMosaic:(<span class="built_in">NSInteger</span>)size; &#123;</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">    <span class="comment">//1、获取图片宽高</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">    <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">    <span class="comment">//2、创建颜色空间</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">    <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">    <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">    <span class="comment">//5、获取像素数组</span></span><br><span class="line">    <span class="built_in">UInt8</span> *bitmapPixels = <span class="built_in">CGBitmapContextGetData</span>(contextRef);</span><br><span class="line">    <span class="built_in">UInt8</span> *pixels[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">NSUInteger</span> currentPixels = <span class="number">0</span>;<span class="comment">//当前的像素点</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> preCurrentPiexls = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> mosaicSize = size;<span class="comment">//马赛克尺寸</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>;  i &lt; height - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span> ; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            currentPixels = i * width + j;</span><br><span class="line">            <span class="keyword">if</span> (i % mosaicSize == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j % mosaicSize == <span class="number">0</span>) &#123;</span><br><span class="line">                    memcpy(pixels, bitmapPixels + <span class="number">4</span> * currentPixels, <span class="number">4</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    memcpy(bitmapPixels + <span class="number">4</span> * currentPixels, pixels, <span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preCurrentPiexls = (i - <span class="number">1</span>) * width + j;</span><br><span class="line">                memcpy(bitmapPixels + <span class="number">4</span> * currentPixels, bitmapPixels + <span class="number">4</span> * preCurrentPiexls, <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据上下文创建图片数据源</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">    <span class="comment">//释放用过的内存</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">    free(imagePiexl);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、图形框架合成图片"><a href="#五、图形框架合成图片" class="headerlink" title="五、图形框架合成图片"></a>五、图形框架合成图片</h2><p>使用不同图形框架合成图片，添加滤镜水印等。</p><p>写在前面：理论和上面像素修改一样，通过操作像素达到修改图片的目的，但是这里使用了系统提供的不同框架和第三方GPUImage。不同框架效率也有所不一样。这里每段代码都加入了对应像素（黑白处理），只是为了学习，后面可以根据需求在对应代码块添加或替换对应对像素的操作，亦可后面加入参数进行封装。</p><h3 id="5-1-直接绘图合成"><a href="#5-1-直接绘图合成" class="headerlink" title="5.1 直接绘图合成"></a>5.1 直接绘图合成</h3><p>此方案原理上就是通过绘图，将多张图片的像素按照自己的设计绘制在一张图片上。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingPixels:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage; &#123;</span><br><span class="line">   <span class="comment">// 1. Get the raw pixels of the image</span></span><br><span class="line">   <span class="built_in">UInt32</span> * backPixels;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGImageRef</span> backCGImage = [backImage <span class="built_in">CGImage</span>];</span><br><span class="line">   <span class="built_in">NSUInteger</span> backWidth = <span class="built_in">CGImageGetWidth</span>(backCGImage);</span><br><span class="line">   <span class="built_in">NSUInteger</span> backHeight = <span class="built_in">CGImageGetHeight</span>(backCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">   <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSUInteger</span> backBytesPerRow = bytesPerPixel * backWidth;</span><br><span class="line"></span><br><span class="line">   backPixels = (<span class="built_in">UInt32</span> *)calloc(backHeight * backWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(backPixels, backWidth, backHeight,</span><br><span class="line">                                                bitsPerComponent, backBytesPerRow, colorSpace,</span><br><span class="line">                                                kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, backWidth, backHeight), backCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. Blend the pattern onto the image</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> frontCGImage = [frontImage <span class="built_in">CGImage</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.1 Calculate the size &amp; position of the pattern</span></span><br><span class="line">   <span class="built_in">CGFloat</span> frontImageAspectRatio = frontImage.size.width / frontImage.size.height;</span><br><span class="line">   <span class="built_in">NSInteger</span> targetFrontWidth = backWidth * <span class="number">0.25</span>;</span><br><span class="line">   <span class="built_in">CGSize</span> frontSize = <span class="built_in">CGSizeMake</span>(targetFrontWidth, targetFrontWidth / frontImageAspectRatio);</span><br><span class="line"> <span class="comment">//    CGPoint frontOrigin = CGPointMake(backWidth * 0.5, backHeight * 0.2);</span></span><br><span class="line">       <span class="built_in">CGPoint</span> frontOrigin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.2 Scale &amp; Get pixels of the pattern</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> frontBytesPerRow = bytesPerPixel * frontSize.width;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">UInt32</span> *frontPixels = (<span class="built_in">UInt32</span> *)calloc(frontSize.width * frontSize.height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextRef</span> frontContext = <span class="built_in">CGBitmapContextCreate</span>(frontPixels, frontSize.width, frontSize.height,</span><br><span class="line">                                                     bitsPerComponent, frontBytesPerRow, colorSpace,</span><br><span class="line">                                                     kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(frontContext, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, frontSize.width, frontSize.height),frontCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.3 Blend each pixel</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> offsetPixelCountForInput = frontOrigin.y * backWidth + frontOrigin.x;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; frontSize.height; j++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; frontSize.width; i++) &#123;</span><br><span class="line">           <span class="built_in">UInt32</span> *backPixel = backPixels + j * backWidth + i + offsetPixelCountForInput;</span><br><span class="line">           <span class="built_in">UInt32</span> backColor = *backPixel;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">UInt32</span> * frontPixel = frontPixels + j * (<span class="keyword">int</span>)frontSize.width + i;</span><br><span class="line">           <span class="built_in">UInt32</span> frontColor = *frontPixel;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Blend the pattern with 50% alpha</span></span><br><span class="line"><span class="comment">//            CGFloat frontAlpha = 0.5f * (A(frontColor) / 255.0);</span></span><br><span class="line">           <span class="built_in">CGFloat</span> frontAlpha = <span class="number">1.0</span>f * (A(frontColor) / <span class="number">255.0</span>);</span><br><span class="line">           <span class="built_in">UInt32</span> newR = R(backColor) * (<span class="number">1</span> - frontAlpha) + R(frontColor) * frontAlpha;</span><br><span class="line">           <span class="built_in">UInt32</span> newG = G(backColor) * (<span class="number">1</span> - frontAlpha) + G(frontColor) * frontAlpha;</span><br><span class="line">           <span class="built_in">UInt32</span> newB = B(backColor) * (<span class="number">1</span> - frontAlpha) + B(frontColor) * frontAlpha;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//Clamp, not really useful here :p</span></span><br><span class="line">           newR = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newR));</span><br><span class="line">           newG = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newG));</span><br><span class="line">           newB = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newB));</span><br><span class="line"></span><br><span class="line">           *backPixel = RGBAMake(newR, newG, newB, A(backColor));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. Convert the image to Black &amp; White</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; backHeight; j++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; backWidth; i++) &#123;</span><br><span class="line">           <span class="built_in">UInt32</span> * currentPixel = backPixels + (j * backWidth) + i;</span><br><span class="line">           <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Average of RGB = greyscale</span></span><br><span class="line">           <span class="built_in">UInt32</span> averageColor = (R(color) + G(color) + B(color)) / <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">           *currentPixel = RGBAMake(averageColor, averageColor, averageColor, A(color));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. Create a new UIImage</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> newCGImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">   <span class="built_in">UIImage</span> * processedImage = [<span class="built_in">UIImage</span> imageWithCGImage:newCGImage];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5. Cleanup!</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(frontContext);</span><br><span class="line">   free(backPixels);</span><br><span class="line">   free(frontPixels);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> processedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-CoreGraphics-框架合成图片"><a href="#5-2-CoreGraphics-框架合成图片" class="headerlink" title="5.2 CoreGraphics 框架合成图片"></a>5.2 CoreGraphics 框架合成图片</h3><p>使用CoreGraphics框架合成图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingCoreGraphics:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage; &#123;</span><br><span class="line"> <span class="built_in">CGRect</span> imageRect = &#123;<span class="built_in">CGPointZero</span>,backImage.size&#125;;</span><br><span class="line"> <span class="built_in">NSInteger</span> backWidth = <span class="built_in">CGRectGetWidth</span>(imageRect);</span><br><span class="line"> <span class="built_in">NSInteger</span> backHeight = <span class="built_in">CGRectGetHeight</span>(imageRect);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1. Blend the pattern onto our image</span></span><br><span class="line"> <span class="built_in">CGFloat</span> frontImageAspectRatio = frontImage.size.width / frontImage.size.height;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">NSInteger</span> targetFrontWidth = backWidth * <span class="number">0.25</span>;</span><br><span class="line"> <span class="built_in">CGSize</span> frontSize = <span class="built_in">CGSizeMake</span>(targetFrontWidth, targetFrontWidth / frontImageAspectRatio);</span><br><span class="line"><span class="comment">//  CGPoint frontOrigin = CGPointMake(backWidth * 0.5, backHeight * 0.2);</span></span><br><span class="line"> <span class="built_in">CGPoint</span> frontOrigin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">CGRect</span> frontRect = &#123;frontOrigin, frontSize&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">UIGraphicsBeginImageContext</span>(backImage.size);</span><br><span class="line"> <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// flip drawing context</span></span><br><span class="line"> <span class="built_in">CGAffineTransform</span> flip = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line"> <span class="built_in">CGAffineTransform</span> flipThenShift = <span class="built_in">CGAffineTransformTranslate</span>(flip,<span class="number">0</span>,-backHeight);</span><br><span class="line"> <span class="built_in">CGContextConcatCTM</span>(context, flipThenShift);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1.1 Draw our image into a new CGContext</span></span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, imageRect, [backImage <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1.2 Set Alpha to 0.5 and draw our pattern on</span></span><br><span class="line"> <span class="built_in">CGContextSetBlendMode</span>(context, kCGBlendModeSourceAtop);</span><br><span class="line"> <span class="built_in">CGContextSetAlpha</span>(context,<span class="number">0.5</span>);</span><br><span class="line"> <span class="built_in">CGRect</span> transformedpatternRect = <span class="built_in">CGRectApplyAffineTransform</span>(frontRect, flipThenShift);</span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, transformedpatternRect, [frontImage <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">UIImage</span> * imageWithFront = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"> <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 2. Convert our image to Black and White</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2.1 Create a new context with a gray color space</span></span><br><span class="line"> <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line"> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, backWidth, backHeight,</span><br><span class="line">                          <span class="number">8</span>, <span class="number">0</span>, colorSpace, (<span class="built_in">CGBitmapInfo</span>)kCGImageAlphaNone);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.2 Draw our image into the new context</span></span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, imageRect, [imageWithFront <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2.3 Get our new B&amp;W Image</span></span><br><span class="line"> <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line"> <span class="built_in">UIImage</span> * finalImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Cleanup</span></span><br><span class="line"> <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"> <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"> <span class="built_in">CFRelease</span>(imageRef);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> finalImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-CoreImage-框架合成图片"><a href="#5-3-CoreImage-框架合成图片" class="headerlink" title="5.3 CoreImage 框架合成图片"></a>5.3 CoreImage 框架合成图片</h3><p>使用CoreImage 框架以添加滤镜形式合成图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)processUsingCoreImage:(UIImage *)backImage frontImage:(UIImage *)frontImage &#123;</span><br><span class="line">  CIImage * backCIImage &#x3D; [[CIImage alloc] initWithImage:backImage];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 1. Create a grayscale filter</span><br><span class="line">  CIFilter * grayFilter &#x3D; [CIFilter filterWithName:@&quot;CIColorControls&quot;];</span><br><span class="line">  [grayFilter setValue:@(0) forKeyPath:@&quot;inputSaturation&quot;];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 2. Create our pattern filter</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; Cheat: create a larger pattern image</span><br><span class="line">  UIImage * patternFrontImage &#x3D; [self createPaddedPatternImageWithSize:backImage.size pattern:frontImage];</span><br><span class="line">  CIImage * frontCIImage &#x3D; [[CIImage alloc] initWithImage:patternFrontImage];</span><br><span class="line"></span><br><span class="line">  CIFilter * alphaFilter &#x3D; [CIFilter filterWithName:@&quot;CIColorMatrix&quot;];</span><br><span class="line">&#x2F;&#x2F;  CIVector * alphaVector &#x3D; [CIVector vectorWithX:0 Y:0 Z:0.5 W:0];</span><br><span class="line">     CIVector * alphaVector &#x3D; [CIVector vectorWithX:0 Y:0 Z:1.0 W:0];</span><br><span class="line">  [alphaFilter setValue:alphaVector forKeyPath:@&quot;inputAVector&quot;];</span><br><span class="line">  </span><br><span class="line">  CIFilter * blendFilter &#x3D; [CIFilter filterWithName:@&quot;CISourceAtopCompositing&quot;];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 3. Apply our filters</span><br><span class="line">  [alphaFilter setValue:frontCIImage forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  frontCIImage &#x3D; [alphaFilter outputImage];</span><br><span class="line"></span><br><span class="line">  [blendFilter setValue:frontCIImage forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  [blendFilter setValue:backCIImage forKeyPath:@&quot;inputBackgroundImage&quot;];</span><br><span class="line">  CIImage * blendOutput &#x3D; [blendFilter outputImage];</span><br><span class="line">  </span><br><span class="line">  [grayFilter setValue:blendOutput forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  CIImage * outputCIImage &#x3D; [grayFilter outputImage];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 4. Render our output image</span><br><span class="line">  CIContext * context &#x3D; [CIContext contextWithOptions:nil];</span><br><span class="line">  CGImageRef outputCGImage &#x3D; [context createCGImage:outputCIImage fromRect:[outputCIImage extent]];</span><br><span class="line">  UIImage * outputImage &#x3D; [UIImage imageWithCGImage:outputCGImage];</span><br><span class="line">  CGImageRelease(outputCGImage);</span><br><span class="line">  </span><br><span class="line">  return outputImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createPaddedPatternImageWithSize 这是个生成滤镜图案的代码块具体请看<a href="https://link.juejin.cn/?target=https://github.com/EricStone1900/ImageOperate-OC">DEMO</a></p><h3 id="5-4-GPUImage-框架合成图片"><a href="#5-4-GPUImage-框架合成图片" class="headerlink" title="5.4 GPUImage 框架合成图片"></a>5.4 GPUImage 框架合成图片</h3><p>使用GPUImage 框架以添加滤镜形式合成图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingGPUImage:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 1. Create our GPUImagePictures</span></span><br><span class="line">   GPUImagePicture * backGPUImage = [[GPUImagePicture alloc] initWithImage:backImage];</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">UIImage</span> *fliterImage = [<span class="keyword">self</span> createPaddedPatternImageWithSize:backImage.size pattern:frontImage];</span><br><span class="line">   GPUImagePicture * frontGPUImage = [[GPUImagePicture alloc] initWithImage:fliterImage];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 2. Setup our filter chain</span></span><br><span class="line">   GPUImageAlphaBlendFilter * alphaBlendFilter = [[GPUImageAlphaBlendFilter alloc] init];</span><br><span class="line">   alphaBlendFilter.mix = <span class="number">0.5</span>;</span><br><span class="line">   </span><br><span class="line">   [backGPUImage addTarget:alphaBlendFilter atTextureLocation:<span class="number">0</span>];</span><br><span class="line">   [frontGPUImage addTarget:alphaBlendFilter atTextureLocation:<span class="number">1</span>];</span><br><span class="line">   </span><br><span class="line">   GPUImageGrayscaleFilter * grayscaleFilter = [[GPUImageGrayscaleFilter alloc] init];</span><br><span class="line">   </span><br><span class="line">   [alphaBlendFilter addTarget:grayscaleFilter];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 3. Process &amp; grab output image</span></span><br><span class="line">   [backGPUImage processImage];</span><br><span class="line">   [frontGPUImage processImage];</span><br><span class="line">   [grayscaleFilter useNextFrameForImageCapture];</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">UIImage</span> * output = [grayscaleFilter imageFromCurrentFramebuffer];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-对比总结"><a href="#5-5-对比总结" class="headerlink" title="5.5 对比总结"></a>5.5 对比总结</h3><ul><li>从代码量来看：明显1直接绘图合成的代码量明显高出许多。CoreImage，和GPUImage的方案要自己加入pattern图，其实代码量也不算少。因此仅从合成图这个功能来看。代码量上 CoreGraphic方案最优。</li><li>从性能来看：本地测试，CoreGraphic，直接绘图合成，速度最快。GPUImage也差不多，CoreImage添加滤镜方案最慢。</li><li>从可控多样性需求来说：GPUImage本来就提供很多滤镜，同时开源。无疑当前最佳，但是其他的都可以自己进行对应功能封装。</li></ul><p>总的来说还是要看项目需求，个人觉得一般性添加水印，合成图片什么如果要直接用CoreGraphic是个不错的选择，以后有时间可以基于CoreGraphic封装功能。</p><h2 id="六、参考文档"><a href="#六、参考文档" class="headerlink" title="六、参考文档"></a>六、参考文档</h2><ul><li><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/822841145b52">iOS图片压缩</a></li><li><a href="https://link.juejin.cn/?target=https://www.raywenderlich.com/sessions/new?return_path=/2335-image-processing-in-ios-part-1-raw-bitmap-modification">Image-Processing</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在项目中因为性能原因，最好不要叠加太多UIView，CALayer层级的显示；但是很多情况又必须使用到图片的合成或是像素、滤镜处理。这里针这些常用的图片处理使用不同图形处理框架进行相关编码实践。&lt;a href=&quot;https://juejin.cn/post/68466875</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>图形处理(二) - 图形与视频处理相关的框架</title>
    <link href="https://tenloy.github.io/2021/09/15/graphics-processing.html"/>
    <id>https://tenloy.github.io/2021/09/15/graphics-processing.html</id>
    <published>2021-09-15T15:54:01.000Z</published>
    <updated>2022-02-09T09:25:55.030Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 - <a href="https://juejin.cn/post/6844903645272604679">iOS图形处理概论：OpenGL ES，Metal，Core Graphics，Core Image，GPUImage，OpenCV等</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于刚接触iOS图形相关框架的小白，有一些图形框架在字面上和功能上非常容易混淆。这里旨在总结一下各种框架，区分它们的概念和功能，以作日后进一步细分学习的指引。因而，<strong>本文并不会针对具体框架作详解，只作区分引导</strong>，读者可自行选择方向继续深造。为此，笔者总结了一张各种框架关系图，如下所示：</p><img src="/images/graphics/GraphicsFrames.png" alt="GraphicsFrames" style="zoom:59%;" /><img src="/images/iosrender/01.png" alt="01" style="zoom:90%;" /><p>总的来说，iOS与图形图像处理相关的框架都在这里了：</p><ul><li>界面图形框架 – UIKit</li><li>核心动画框架 – Core Animation</li><li>苹果封装的图形框架 – Core Graphics &amp; Quartz 2D</li><li>传统跨平台图形框架 – OpenGL ES</li><li>苹果最新力推的图形框架 – Metal</li><li>适合图片的苹果滤镜框架 – Core Image</li><li>适合视频的第三方滤镜方案 – GPUImage</li><li>游戏引擎 – Scene Kit (3D) 和 Sprite Kit (2D)</li><li>计算机视觉在iOS的应用 – OpenCV for iOS</li></ul><h2 id="一、界面图形-—-UIKit"><a href="#一、界面图形-—-UIKit" class="headerlink" title="一、界面图形 — UIKit"></a>一、界面图形 — UIKit</h2><h3 id="1-1-UIKit"><a href="#1-1-UIKit" class="headerlink" title="1.1 UIKit"></a>1.1 UIKit</h3><p>UIKit是一组Objective-C API，为线条图形、Quartz图像和颜色操作提供Objective-C 封装，并提供2D绘制、图像处理及用户接口级别的动画。</p><p>UIKit包括UIBezierPath（绘制线、角度、椭圆及其它图形）、UIImage（显示图像）、UIColor（颜色操作）、UIFont和UIScreen（提供字体和屏幕信息）等类以及在位图图形环境、PDF图形环境上进行绘制和 操作的功能等, 也提供对标准视图的支持，也提供对打印功能的支持。</p><h3 id="1-2-UIKit与Core-Graphics的关系"><a href="#1-2-UIKit与Core-Graphics的关系" class="headerlink" title="1.2 UIKit与Core Graphics的关系"></a>1.2 UIKit与Core Graphics的关系</h3><p>在UIKit中，UIView类本身在绘制时<strong>自动创建一个图形环境，即Core Graphics层的CGContext类型，作为当前的图形绘制环境</strong>。在绘制时可以调用 <code>UIGraphicsGetCurrentContext</code> 函数获得当前的图形环境，例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    <span class="comment">// Drawing code</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    <span class="comment">//1.获取上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">//2.描述路径</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> * path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    <span class="comment">//起点</span></span><br><span class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">10</span>)];</span><br><span class="line">    <span class="comment">//终点</span></span><br><span class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    <span class="comment">//设置颜色</span></span><br><span class="line">    [[<span class="built_in">UIColor</span> whiteColor]setStroke];</span><br><span class="line">    <span class="comment">//3.添加路径</span></span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(contextRef, path.CGPath);</span><br><span class="line">    <span class="comment">//显示路径</span></span><br><span class="line">    <span class="built_in">CGContextStrokePath</span>(contextRef);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就是在UIView的子类中调用 <code>UIGraphicsGetCurrentContext</code> 函数获得当前的图形环境，然后向该图形环境添加路径，最后绘制。</p><h2 id="二、核心动画-—-Core-Animation"><a href="#二、核心动画-—-Core-Animation" class="headerlink" title="二、核心动画 — Core Animation"></a>二、核心动画 — Core Animation</h2><h3 id="2-1-Core-Animation"><a href="#2-1-Core-Animation" class="headerlink" title="2.1 Core Animation"></a>2.1 Core Animation</h3><p>Core Animation 是一套Objective-C API，实现了一个高性能的复合引擎，并提供一个简单易用的编程接口，给用户UI添加平滑运动和动态反馈能力。</p><p>Core Animation 是 UIKit 实现动画和变换的基础，也负责视图的复合功能。使用Core Animation可以实现定制动画和细粒度的动画控制，创建复杂的、支持动画和变换的layered 2D视图。</p><p>Core Animation 不属于绘制系统，但它是以硬件复合和操作显示内容的基础设施。这个基础设施的核心是layer对象，用来管理和操作显示内容。在 iOS 中 <strong>每一个视图都对应Core Animation的一个层对象</strong>，与视图一样，层之间也组织为层关系树。一个层捕获视图内容为一个被图像硬件容易操作的位图。在多数应用中层作为管理视图的方式使用，但也可以创建独立的层到一个层关系树中来显示视图不够支持的显示内容。</p><p>OpenGL ES的内容也可以与Core Animation内容进行集成。</p><p>为了使用Core Animation实现动画，可以修改 <strong>层的属性值</strong> 来触发一个action对象的执行，不同的action对象实现不同的动画。</p><h3 id="2-2-Core-Animatio相关基类及子类"><a href="#2-2-Core-Animatio相关基类及子类" class="headerlink" title="2.2 Core Animatio相关基类及子类"></a>2.2 Core Animatio相关基类及子类</h3><p>Core Animation 提供了一下一组应用可以采用的类来提供对不同动画类型的支持：</p><ul><li><strong>CAAnimation</strong> 是一个抽象公共基类，CAAnimation采用CAMediaTiming 和CAAction协议为动画提供时间（如周期、速度、重复次数等）和action行为（启动、停止等）。</li><li><strong>CAPropertyAnimation</strong> 是  CAAnimation的抽象子类，为动画提供一个由一个key路径规定的层属性的支持；</li><li><strong>CABasicAnimation</strong> 是CAPropertyAnimation的具体子类，为一个层属性提供简单插入能力。</li><li><strong>CAKeyframeAnimation</strong> 也是CAPropertyAnimation的具体子类，提供key帧动画支持。</li></ul><h2 id="三、苹果封装的绘图框架-—-Core-Graphics"><a href="#三、苹果封装的绘图框架-—-Core-Graphics" class="headerlink" title="三、苹果封装的绘图框架 — Core Graphics"></a>三、苹果封装的绘图框架 — Core Graphics</h2><blockquote><p><a href="https://developer.apple.com/documentation/coregraphics?language=objc">Core Graphics</a> 框架基于 Quartz 高级绘图引擎。 它提供具有无与伦比的输出保真度的低级、轻量级 2D 渲染。 您可以使用此框架来处理基于路径的绘图、转换、离屏渲染、抗锯齿渲染、颜色管理、渐变和阴影、图案、图像数据管理、图像创建和图像遮罩，以及 PDF 文档的创建、显示和解析。 <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html?language=objc#//apple_ref/doc/uid/TP30001066">Quartz 2D Programming Guide</a></p><p>在 macOS 中，Core Graphics 还包括用于处理显示硬件、低级用户输入事件和窗口系统的服务。</p></blockquote><h3 id="3-1-Core-Graphics"><a href="#3-1-Core-Graphics" class="headerlink" title="3.1 Core Graphics"></a>3.1 Core Graphics</h3><p>Core Graphics是一套C-based API， 支持：</p><ul><li>绘制图形：向量图形、线、三角形、矩形、圆、弧等</li><li>绘制文字</li><li>绘制/生成图案</li><li>截图/裁剪图片</li><li>读取/生成PDF</li><li>自定义UI控件</li></ul><h3 id="3-2-Quartz-2D"><a href="#3-2-Quartz-2D" class="headerlink" title="3.2 Quartz 2D"></a>3.2 Quartz 2D</h3><p>Quartz 2D是Core Graphics中的2D 绘制呈现引擎。Quartz是资源和设备无关的，提供路径绘制，anti-aliased呈现，剃度填充图案，图像，透明绘制和透明层、遮蔽和阴影、颜色管理，坐标转换，字体、offscreen呈现、pdf文档创建、显示和分析等功能。</p><p>Quartz 2D能够与所有的图形和动画技术（如Core Animation, OpenGL ES, 和 UIKit 等）一起使用。</p><p>Quartz 2D采用paint模式进行绘制。</p><h3 id="3-3-图形环境Context"><a href="#3-3-图形环境Context" class="headerlink" title="3.3 图形环境Context"></a>3.3 图形环境Context</h3><p>Quartz 2D中使用的<strong>图形环境</strong>也由一个类CGContext表示。</p><p>在Quartz 2D中可以把一个图形环境作为一个绘制目标。当使用Quartz 2D进行绘制时，所有设备特定的特性被包含在你使用的特定类型的图形环境中，因此通过给相同的图像操作函数提供不同的图像环境你就能够画相同的图像到不同的设备上，因此做到了图像绘制的设备无关性。</p><p>图形环境Context是个比较抽象的东西，它不仅仅是一个可以绘制的图层，还包含为当前图层设置的参数，如阴影，线条粗细，绘制模式等。可以类比成一个新建的Photoshop图层以及当前笔触，颜色等配置。</p><p>对于移动平台，有三种常见的图形环境Context：</p><ul><li>位图上下文（Bitmap graphics context）：一般用于绘制图片或者自定义控件。<ul><li>View Graphics Context: 由UIView自动创建，你重写UIView drawRect方法时，你的内容会画在这个上下文上。</li><li>Bitmap Graphics Context: 绘制在该上下文的内容会以点阵形式存储在一块内存中。简单说，就是为图片开辟一块内存，然后在里面画东西，上下文帮你把图片内存抽象成一个Context(图层)了。</li></ul></li><li>PDF上下文（PDF graphics context）：用于生成pdf文件。</li><li>图层上下文（Layer graphics context）：用于离屏绘制（ offscreen drawing）。</li><li>其他如Window Graphics Context、Printer Graphics Context……。</li></ul><p>在什么上下文里，操作，生成的就是什么格式的文件（就比如office软件，我们打开word就生成Word文件，打开Excel就生成excel表，打开PPT，就生成PPT）。</p><h3 id="3-4-Quartz-2D提供的主要类包括"><a href="#3-4-Quartz-2D提供的主要类包括" class="headerlink" title="3.4 Quartz 2D提供的主要类包括"></a>3.4 Quartz 2D提供的主要类包括</h3><ul><li>CGContext：表示一个图形环境；</li><li>CGPath：使用向量图形来创建路径，并能够填充和stroke；</li><li>CGImage：用来表示位图；</li><li>CGLayer：用来表示一个能够用于重复绘制和offscreen绘制的绘制层；</li><li>CGPattern：用来表示Pattern，用于重复绘制；</li><li>CGShading和 CGGradient：用于绘制剃度；</li><li>CGColor 和 CGColorSpace；用来进行颜色和颜色空间管理；</li><li>CGFont, 用于绘制文本；</li><li>CGPDFContentStream、CGPDFScanner、CGPDFPage、CGPDFObject,CGPDFStream, CGPDFString等用来进行pdf文件的创建、解析和显示。</li></ul><h2 id="四、传统跨平台图形框架-—-OpenGL-ES"><a href="#四、传统跨平台图形框架-—-OpenGL-ES" class="headerlink" title="四、传统跨平台图形框架 — OpenGL ES"></a>四、传统跨平台图形框架 — OpenGL ES</h2><h3 id="4-1-OpenGL-ES"><a href="#4-1-OpenGL-ES" class="headerlink" title="4.1 OpenGL ES"></a>4.1 OpenGL ES</h3><p>OpenGL ES是一套多功能开放标准的用于嵌入系统的C-based的图形库，用于2D和3D数据的可视化。OpenGL被设计用来转换一组图形调用功能到底层图形硬件（GPU），由GPU执行图形命令，用来实现复杂的图形操作和运算，从而能够高性能、高帧率利用GPU提供的2D和3D绘制能力。</p><p>OpenGL ES规范本身不定义绘制表面和绘制窗口，因此ios为了使用它必须提供和创建一个OpenGL ES 的呈现环境，创建和配置存储绘制命令结果的framebuffer 及创建和配置一个或多个呈现目标。</p><h3 id="4-2-EAGL"><a href="#4-2-EAGL" class="headerlink" title="4.2 EAGL"></a>4.2 EAGL</h3><p>在 iOS中使用EAGL提供的EAGLContext类 来实现和提供一个呈现环境，用来保持OpenGL ES使用到的硬件状态。EAGL是一个Objective-C API，提供使OpenGL ES与Core Animation和UIKIT集成的接口。</p><p>在调用任何OpenGL ES 功能之前必须首先初始化一个EAGLContext 对象。每一个IOS应用的每一个线程都有一个当前context，在调用OpenGL ES函数时，使用或改变此context中的状态。</p><p>EAGLContext 的类方法setCurrentContext: 用来设置当前线程的当前context。EAGLContext 的类方法currentContext 返回当前线程的当前context。在切换相同线程的两个上下文之前，必须调用glFlush函数来确保先前已提交的命令被提交到图形硬件中。</p><h3 id="4-3-GLKit"><a href="#4-3-GLKit" class="headerlink" title="4.3 GLKit"></a>4.3 GLKit</h3><p>可以采用不同的方式使用OpenGL ES以便呈现OpenGL ES内容到不同的目标：GLKit和CAEAGLLayer。</p><p>为了创建全屏幕的视图或使OpenGL ES内容与UIKit视图集成，可以使用GLKit。在使用GLKit时，GLKit提供的类GLKView类本身实现呈现目标及创建和维护一个framebuffer。</p><p>GLKit是一组Objective-C 类，为使用OpenGL ES 提供一个面向对象接口，用来简化OpenGL ES应用的开发。</p><h3 id="4-4-CAEAGLLayer"><a href="#4-4-CAEAGLLayer" class="headerlink" title="4.4 CAEAGLLayer"></a>4.4 CAEAGLLayer</h3><p>为了使OpenGL ES内容作为一个Core Animation层的部分内容时，可以使用CAEAGLLayer 作为呈现目标，并需要另外创建framebuffer以及自己实现和控制整个绘制流程。</p><h3 id="4-5-GLKit支持四个3D应用开发的关键领域"><a href="#4-5-GLKit支持四个3D应用开发的关键领域" class="headerlink" title="4.5 GLKit支持四个3D应用开发的关键领域"></a>4.5 GLKit支持四个3D应用开发的关键领域</h3><ol><li><p>GLKView 和 GLKViewController 类提供一个标准的OpenGL ES视图和相关联的呈现循环。GLKView可以作为OpenGL ES内容的呈现目标，GLKViewController提供内容呈现的控制和动画。视图管理和维护一个framebuffer，应用只需在framebuffer进行绘画即可。</p></li><li><p>GLKTextureLoader 为应用提供从IOS支持的各种图像格式的源自动加载纹理图像到OpenGL ES 图像环境的方式，并能够进行适当的转换，并支持同步和异步加载方式。</p></li><li><p>数学运算库，提供向量、矩阵、四元数的实现和矩阵堆栈操作等OpenGL ES 1.1功能。</p></li><li><p>Effect效果类提供标准的公共着色效果的实现。能够配置效果和相关的顶点数据，然后创建和加载适当的着色器。GLKit 包括三个可配置着色效果类：GLKBaseEffect实现OpenGL ES 1.1规范中的关键的灯光和材料模式, GLKSkyboxEffect提供一个skybox效果的实现, GLKReflectionMapEffect 在GLKBaseEffect基础上包括反射映射支持。</p></li></ol><h2 id="五、苹果最新力推的图形框架-—-Metal"><a href="#五、苹果最新力推的图形框架-—-Metal" class="headerlink" title="五、苹果最新力推的图形框架 — Metal"></a>五、苹果最新力推的图形框架 — Metal</h2><p>Metal框架支持GPU硬件加速、高级3D图形渲染以及大数据并行运算。且提供了先进而精简的API来确保框架的细粒度(fine-grain)，并且在组织架构、程序处理、图形呈现、运算指令以及指令相关数据资源的管理上都支持底层控制。其核心目的是尽可能的减少CPU开销，而将运行时产生的大部分负载交由GPU承担。</p><p>编写基于底层图形 API 的渲染引擎时，除了 Metal 以外的其他选择还有 OpenGL 和 OpenGL ES。</p><p>OpenGL 不仅支持包括 OSX，Windows，Linux 和 Android 在内的几乎所有平台，还有大量的教程，书籍和最佳实践指南等资料。目前，Metal 的资源非常有限，并且仅限于搭载了 64 位处理器的 iPhone 和 iPad。但另外一方面，因为 OpenGL 的限制，其性能与 Metal 相比并不占优势，毕竟后者是专门用来解决这些问题的。</p><p>如果想要一个 iOS 上高性能的并行计算库，答案非常简单。Metal 是唯一的选择。OpenGL 在 iOS 上是私有框架，而 Core Image (使用了 OpenGL) 对这样的任务来说既不够强大又不够灵活。</p><h2 id="六、适合图片的苹果滤镜框架-—-Core-Image"><a href="#六、适合图片的苹果滤镜框架-—-Core-Image" class="headerlink" title="六、适合图片的苹果滤镜框架 — Core Image"></a>六、适合图片的苹果滤镜框架 — Core Image</h2><h3 id="6-1-滤镜术语"><a href="#6-1-滤镜术语" class="headerlink" title="6.1 滤镜术语"></a>6.1 滤镜术语</h3><p>摄影滤光镜，简称滤光镜、滤色镜或滤镜（Filter），是摄影时放在照相机镜头前端的一种玻璃或塑料镜片，能够对光的不同波段进行选择性吸收，从而对摄影作品产生特殊的效果。种类很多。一些图像处理软件也可以向图片中加入滤镜的模拟效果。</p><p>常用滤镜：</p><ul><li>UV镜 可降低紫外线射入镜头，另外常被做为保护镜：以保护镜头前方镜片</li><li>偏振镜 又称PL镜：可消除反光、增加色彩鲜艳</li><li>中性灰度滤镜 又称中灰镜、ND镜或减光镜：可以延长曝光时间，或在强光下可以使用大光圈正确曝光</li><li>渐变中灰滤镜 又称中灰渐变镜：可以应付大光比场景</li><li>暖色滤镜：可以暖化肤色</li></ul><p>一些图像处理软件针对性地提供了一些对传统滤镜效果的模拟功能，使图像达到一种特殊效果。滤镜通常需要同通道、图层、色阶等联合使用，才能使图像取得最佳艺术效果。</p><p>滤镜在软件界面中也直接以“滤镜”（Filter）称呼；日久便约定俗成，软件中将一些特定效果（effect）或预设（preset）以‘滤镜’统一称呼，特别于一些简单化傻瓜化软件中较为常见，如美图秀秀以及智能手机appInstagram等。如今智能手机自带的相机系统中也常见诸多滤镜。</p><h3 id="6-2-Core-Image"><a href="#6-2-Core-Image" class="headerlink" title="6.2 Core Image"></a>6.2 Core Image</h3><blockquote><p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185-CH1-TPXREF101">Core Image</a> 是一种图像处理和分析技术，旨在为静态和视频图像提供近乎实时的处理。它使用 GPU 或 CPU 渲染路径对来自 Core Graphics、Core Video 和 Image I/O 框架的图像数据类型进行操作。 </p><p>Core Image 通过提供易于使用的应用程序编程接口 (API) 来隐藏底层图形处理的细节。您无需了解 OpenGL、OpenGL ES 或 Metal 的详细信息即可利用 GPU 的强大功能，也无需了解 Grand Central Dispatch (GCD) 的任何相关信息即可获得多核处理的优势。 Core Image 为您处理细节。</p><p>Image I/O 编程接口框架允许应用程序读取和写入大多数图像文件格式。 该框架提供了高效率的色彩管理和对图像元数据的访问。</p></blockquote><img src="/images/graphics/architecture_2x.png" alt="" style="zoom:65%;" /><p>Core Image 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了180种)， 这些Filter 提供了各种各样的效果， 并且还可以通过 <code>滤镜链</code> 将各种效果的 <code>Filter叠加</code> 起来形成强大的自定义效果。</p><p>一个 <strong>滤镜</strong> 是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。</p><p>一个 <strong>滤镜链</strong> 是一个链接在一起的滤镜网络，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。</p><p>iOS8 之后更是支持自定义 CIFilter，可以定制满足业务需求的复杂效果。</p><p>Core Image 的 API 主要就是三类：</p><ul><li>CIImage 保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。</li><li>CIFilter 表示应用的滤镜，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。</li><li>CIContext 表示上下文，如 Core Graphics 以及 Core Data 中的上下文用于处理绘制渲染以及处理托管对象一样，Core Image 的上下文也是实现对图像处理的具体对象。可以从其中取得图片的信息。</li></ul><p>Core Image 的另外一个优势，就是可以根据需求选择 CPU 或者 GPU 来处理。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建基于 CPU 的 CIContext 对象 (默认是基于 GPU，CPU 需要额外设置参数)</span></span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithOptions: [<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:kCIContextUseSoftwareRenderer]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithOptions: <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class="line">EAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithEAGLContext:eaglctx];</span><br></pre></td></tr></table></figure><h2 id="七、适合视频的第三方滤镜方案-—-GPUImage"><a href="#七、适合视频的第三方滤镜方案-—-GPUImage" class="headerlink" title="七、适合视频的第三方滤镜方案 — GPUImage"></a>七、适合视频的第三方滤镜方案 — GPUImage</h2><p>GPUImage 优势： 最低支持 iOS 4.0，iOS 5.0 之后就支持自定义滤镜。 在低端机型上，GPUImage 有更好的表现。（这个我没用真正的设备对比过，GPUImage 的主页上是这么说的） GPUImage 在视频处理上有更好的表现。 GPUImage 的代码完成公开，实现透明。 可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高。</p><h2 id="八、游戏引擎-—-Scene-Kit-3D-和-Sprite-Kit-2D"><a href="#八、游戏引擎-—-Scene-Kit-3D-和-Sprite-Kit-2D" class="headerlink" title="八、游戏引擎 — Scene Kit (3D) 和 Sprite Kit (2D)"></a>八、游戏引擎 — <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/">Scene Kit</a> (3D) 和 <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html">Sprite Kit</a> (2D)</h2><p>对于寻找游戏引擎的开发者来说，Metal 不是最佳选择。苹果官方的的 <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/">Scene Kit</a> (3D) 和 <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html">Sprite Kit</a> (2D) 是更好的选择。这些 API 提供了包括物理模拟在内的更高级别的游戏引擎。</p><p>另外还有功能更全面的 3D 引擎，例如 Epic 的 <a href="https://link.juejin.cn/?target=https://www.unrealengine.com/">Unreal Engine</a> 或 <a href="https://link.juejin.cn/?target=http://unity3d.com/">Unity</a>，二者都是跨平台的。使用这些引擎，你无需直接使用 Metal 的 API，就可以从 Metal 中获益。</p><h3 id="8-1-2D渲染-–-SpriteKit"><a href="#8-1-2D渲染-–-SpriteKit" class="headerlink" title="8.1 2D渲染 – SpriteKit"></a>8.1 2D渲染 – SpriteKit</h3><p>SpriteKit 让开发者可以开发高性能、省电节能的 2D 游戏。在 iOS 8 中，我们新添了多项增强功能，这将使 2D 游戏体验更加精彩。这些新技术有助于使游戏角色的动作更加自然，并让开发者可以更轻松地在游戏中加入力场、检测碰撞和生成新的灯光效果。</p><h3 id="8-2-3D渲染-–-SceneKit"><a href="#8-2-3D渲染-–-SceneKit" class="headerlink" title="8.2 3D渲染 – SceneKit"></a>8.2 3D渲染 – SceneKit</h3><p>SceneKit 专为休闲 3D 游戏而设计，可让开发者渲染 3D 游戏场景。SceneKit 内置了物理引擎、粒子发生器和各种易用工具，可以轻松快捷地为 3D 物体编写动作。不仅如此，它还与 SpriteKit 完全集成，所以开发者可以直接在 3D 游戏中加入 SpriteKit 的素材。</p><h2 id="九、计算机视觉在iOS的应用-—-OpenCV-for-iOS"><a href="#九、计算机视觉在iOS的应用-—-OpenCV-for-iOS" class="headerlink" title="九、计算机视觉在iOS的应用 — OpenCV for iOS"></a>九、计算机视觉在iOS的应用 — OpenCV for iOS</h2><blockquote><p>OpenCV的全称是：Open Source Computer Vision Library。OpenCV是一个基于（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。</p></blockquote><p>OpenCV 的 API 是 C++ 的。它由不同的模块组成，这些模块中包含范围极为广泛的各种方法，从底层的图像颜色空间转换到高层的机器学习工具。这里提供一个入门PDF文档 <a href="https://link.juejin.cn/?target=http://www.opencv.org.cn/forum.php?mod=viewthread&tid=33549">下载入口</a>。</p><p>使用 C++ API 并不是绝大多数 iOS 开发者每天都做的事，你需要使用 Objective-C++ 文件来调用 OpenCV 的函数。 也就是说，你不能在 Swift 或者 Objective-C 语言内调用 OpenCV 的函数。 这篇 OpenCV 的 <a href="https://link.juejin.cn/?target=http://docs.opencv.org/doc/tutorials/ios/video_processing/video_processing.html%23opencviosvideoprocessing">iOS 教程</a>告诉你只要把所有用到 OpenCV 的类的文件后缀名改为 <code>.mm</code> 就行了，包括视图控制器类也是如此。这么干或许能行得通，却不是什么好主意。正确的方式是给所有你要在 app 中使用到的 OpenCV 功能写一层 Objective-C++ 封装。这些 Objective-C++ 封装把 OpenCV 的 C++ API 转化为安全的 Objective-C API，以方便地在所有 Objective-C 类中使用。</p><p>走封装的路子，你的工程中就可以只在这些封装中调用 C++ 代码，从而避免掉很多让人头痛的问题，比如直接改文件后缀名会因为在错误的文件中引用了一个 C++ 头文件而产生难以追踪的编译错误。</p><p>OpenCV 声明了命名空间 <code>cv</code>，因此 OpenCV 的类的前面会有个 <code>cv::</code> 前缀，就像 <code>cv::Mat</code>、 <code>cv::Algorithm</code> 等等。你也可以在 <code>.mm</code> 文件中使用 <code>using namespace cv</code> 来避免在一堆类名前使用 <code>cv::</code>前缀。但是，在某些类名前你必须使用命名空间前缀，比如 <code>cv::Rect</code> 和 <code>cv::Point</code>，因为它们会跟定义在 <code>MacTypes.h</code> 中的 <code>Rect</code> 和 <code>Point</code> 相冲突。尽管这只是个人偏好问题，我还是偏向在任何地方都使用 <code>cv::</code>以保持一致性。</p><p>一般讲的OpenCV是基于CPU的，相关资料和支持也是最完善的。当然，也有基于GPU模块，但提供的接口非常坑爹，相当一部分不支持浮点类型（像histogram、integral这类常用的都不支持）；又如，遇到阈值判断的地方，就必须传回cpu处理，因为gpu函数都是并行处理的，每改写完一个算法模块，就测试一下运行效率，有的时候是振奋人心，有的时候则是当头棒喝——比CPU还慢。详情可参阅 <a href="https://link.juejin.cn/?target=https://blog.csdn.net/kelvin_yan/article/details/41804357">这里</a>。</p><h2 id="十、参考文献"><a href="#十、参考文献" class="headerlink" title="十、参考文献"></a>十、参考文献</h2><ul><li><p>Core Animations</p><ul><li><a href="https://www.sohu.com/a/203987045_468740">https://www.sohu.com/a/203987045_468740</a> </li><li><a href="https://blog.csdn.net/huangznian/article/details/42919221">https://blog.csdn.net/huangznian/article/details/42919221</a> </li><li><a href="https://www.jianshu.com/p/446a6b72f981">https://www.jianshu.com/p/446a6b72f981</a> </li><li><a href="https://www.jianshu.com/p/439e158b44de">https://www.jianshu.com/p/439e158b44de</a></li></ul></li><li><p>Metal</p><ul><li><a href="https://juejin.cn/post/6844903494072139789">https://juejin.cn/post/6844903494072139789</a> </li><li><a href="https://www.jianshu.com/p/ce53d0178f20">https://www.jianshu.com/p/ce53d0178f20</a> </li><li><a href="https://blog.csdn.net/pizi0475/article/details/50232029">https://blog.csdn.net/pizi0475/article/details/50232029</a> </li><li><a href="https://baike.baidu.com/item/Metal/10917053?fr=aladdin">https://baike.baidu.com/item/Metal/10917053?fr=aladdin</a> </li><li><a href="https://zhuanlan.zhihu.com/p/24623380?utm_source=tuicool&amp;utm_medium=referral">https://zhuanlan.zhihu.com/p/24623380?utm_source=tuicool&amp;utm_medium=referral</a></li></ul></li><li><p>Core Image</p><ul><li><a href="https://objccn.io/issue-21-6/">https://objccn.io/issue-21-6/</a> </li><li><a href="http://colin1994.github.io/2016/10/21/Core-Image-OverView/?utm_source=tuicool&amp;utm_medium=referral">http://colin1994.github.io/2016/10/21/Core-Image-OverView/?utm_source=tuicool&amp;utm_medium=referral</a> </li><li><a href="https://blog.csdn.net/jingcheng345413/article/details/54967640">https://blog.csdn.net/jingcheng345413/article/details/54967640</a> </li><li><a href="https://www.cnblogs.com/try2do-neo/p/3601546.html">https://www.cnblogs.com/try2do-neo/p/3601546.html</a></li></ul></li><li><p>Core Graphics</p><ul><li><a href="https://www.jianshu.com/p/e7a50dcbe7c8">https://www.jianshu.com/p/e7a50dcbe7c8</a> </li><li><a href="https://www.jianshu.com/p/55cc1587e618">https://www.jianshu.com/p/55cc1587e618</a> </li><li><a href="https://www.jianshu.com/p/494c57f49479">https://www.jianshu.com/p/494c57f49479</a> </li><li><a href="https://my.oschina.net/flyfishbay/blog/1504698">https://my.oschina.net/flyfishbay/blog/1504698</a></li></ul></li><li><p>OpenCV</p><ul><li><a href="https://blog.csdn.net/zhonggaorong/article/details/78191514">https://blog.csdn.net/zhonggaorong/article/details/78191514</a> </li><li><a href="http://www.opencv.org.cn/forum.php?mod=viewthread&amp;tid=33549">http://www.opencv.org.cn/forum.php?mod=viewthread&amp;tid=33549</a> </li><li><a href="https://blog.csdn.net/kelvin_yan/article/details/41804357">https://blog.csdn.net/kelvin_yan/article/details/41804357</a> </li><li><a href="https://blog.csdn.net/sinat_31135199/article/details/53053188">https://blog.csdn.net/sinat_31135199/article/details/53053188</a> </li><li><a href="https://blog.csdn.net/liyuefeilong/article/details/46292339">https://blog.csdn.net/liyuefeilong/article/details/46292339</a></li></ul></li><li><p>GPUImage</p><ul><li><a href="https://blog.csdn.net/fanbird2008/article/details/51707430">https://blog.csdn.net/fanbird2008/article/details/51707430</a></li></ul></li><li><p>其它</p><ul><li><a href="https://blog.csdn.net/goohong/article/details/40743883">https://blog.csdn.net/goohong/article/details/40743883</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接 - &lt;a href=&quot;https://juejin.cn/post/6844903645272604679&quot;&gt;iOS图形处理概论：OpenGL ES，Metal，Core Graphics，Core Image，GPUImage，Open</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
</feed>
