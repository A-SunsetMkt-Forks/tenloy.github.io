<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tenloy&#39;s Blog</title>
  
  <subtitle>学习 记录</subtitle>
  <link href="https://tenloy.github.io/atom.xml" rel="self"/>
  
  <link href="https://tenloy.github.io/"/>
  <updated>2021-06-23T06:05:15.225Z</updated>
  <id>https://tenloy.github.io/</id>
  
  <author>
    <name>Tenloy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[转]谈谈DSL以及DSL的应用（以CocoaPods 为例）</title>
    <link href="https://tenloy.github.io/2021/06/23/12-DSL/"/>
    <id>https://tenloy.github.io/2021/06/23/12-DSL/</id>
    <published>2021-06-23T13:43:30.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://draveness.me/dsl/">谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例）</a></p></blockquote><blockquote><p>因为 DSL 以及 DSL 的界定本身就是一个比较模糊的概念，所以难免有与他人观点意见相左的地方，如果有不同的意见，我们可以具体讨论。</p></blockquote><p>这次文章的题目虽然是谈谈 DSL 以及 DSL 的应用，不过文章中主要侧重点仍然是 DSL，会简单介绍 DSL 在 iOS 开发中（CocoaPods）是如何应用的。</p><h2 id="没有银弹？"><a href="#没有银弹？" class="headerlink" title="没有银弹？"></a>没有银弹？</h2><p>1987 年，IBM 大型电脑之父 Fred Brooks 发表了一篇关于软件工程中的论文 [No Silver Bullet—Essence and Accidents of Software Engineering](No Silver Bullet—Essence and Accidents of Software Engineering) 文中主要围绕这么一个观点：没有任何一种技术或者方法能使软件工程的生产力在十年之内提高十倍。</p><blockquote><p>There is no single development, in either technology or management technique, which by itself promises even one order-of-magnitude improvement within a decade in productivity, in reliability, in simplicity.</p></blockquote><p>时至今日，我们暂且不谈银弹在软件工程中是否存在（<del>这句话在老板或者项目经理要求加快项目进度时，还是十分好用的</del>），作为一个开发者也不是很关心这种抽象的理论，我们更关心的是开发效率能否有实质的提升。</p><img src="/images/DSL/2016-10-03-silver-bullet.jpg" style="zoom:70%"><p>而今天要介绍的 DSL 就可以真正的提升生产力，减少不必要的工作，在一些领域帮助我们更快的实现需求。</p><h2 id="DSL-是什么？"><a href="#DSL-是什么？" class="headerlink" title="DSL 是什么？"></a>DSL 是什么？</h2><blockquote><p>笔者是在两年以前，在大一的一次分享上听到 DSL 这个词的，但是当时并没有对这个名词有多深的理解与认识，听过也就忘记了，但是最近做的一些开源项目让我重新想起了 DSL，也是这次分享题目的由来。</p></blockquote><p>DSL 其实是 Domain Specific Language 的缩写，中文翻译为<em>领域特定语言</em>（下简称 DSL）；而与 DSL 相对的就是 GPL，这里的 GPL 并不是我们知道的开源许可证，而是 General Purpose Language 的简称，即<em>通用编程语言</em>，也就是我们非常熟悉的 Objective-C、Java、Python 以及 C 语言等等。</p><p><a href="https://en.wikipedia.org/wiki/Domain-specific_language">Wikipedia</a> 对于 DSL 的定义还是比较简单的：</p><blockquote><p>A specialized computer language designed for a specific task.</p><p>为了解决某一类任务而专门设计的计算机语言。</p></blockquote><p>与 GPL 相对，DSL 与传统意义上的通用编程语言 C、Python 以及 Haskell 完全不同。通用的计算机编程语言是可以用来编写任意计算机程序的，并且能表达任何的<strong>可被计算</strong>的逻辑，同时也是 <a href="https://en.wikipedia.org/wiki/Turing_completeness">图灵完备</a> 的。</p><blockquote><p>这一小节中的 DSL 指外部 DSL，下一节中会介绍 <a href="https://draveness.me/dsl/#embedded-dsl%E5%B5%8C%E5%85%A5%E5%BC%8F-dsl">内部 DSL/嵌入式 DSL</a></p></blockquote><p>但是在里所说的 DSL 并不是图灵完备的，它们的<strong>表达能力有限</strong>，只是在特定领域解决特定任务的。</p><blockquote><p>A computer programming language of limited expressiveness focused on a particular domain.</p></blockquote><p>另一个世界级软件开发大师 Martin Fowler 对于领域特定语言的定义在笔者看来就更加具体了，<strong>DSL 通过在表达能力上做的妥协换取在某一领域内的高效</strong>。</p><p>而有限的表达能力就成为了 GPL 和 DSL 之间的一条界限。</p><h3 id="几个栗子"><a href="#几个栗子" class="headerlink" title="几个栗子"></a>几个栗子</h3><p>最常见的 DSL 包括 Regex 以及 HTML &amp; CSS，在这里会对这几个例子进行简单介绍</p><ul><li><p>Regex</p><ul><li><p>正则表达式仅仅指定了字符串的 pattern，其引擎就会根据 pattern 判断当前字符串跟正则表达式是否匹配。</p><img src="/images/DSL/2016-10-03-regex.jpg" style="zoom:70%"></li></ul></li><li><p>SQL</p><ul><li>SQL 语句在使用时也并没有真正的执行，我们输入的 SQL 语句最终还要交给数据库来进行处理，数据库会从 SQL 语句中<strong>读取</strong>有用的信息，然后从数据库中返回使用者期望的结果。</li></ul></li><li><p>HTML &amp; CSS</p><ul><li>HTML 和 CSS 只是对 Web 界面的结构语义和样式进行描述，虽然它们在构建网站时非常重要，但是它们并非是一种编程语言，正相反，我们可以认为 HTML 和 CSS 是在 Web 中的领域特定语言。</li></ul></li></ul><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><p>上面的几个🌰明显的缩小了通用编程语言的概念，但是它们确实在自己领域表现地非常出色，因为这些 DSL 就是根据某一个特定领域的特点塑造的；而通用编程语言相比领域特定语言，在设计时是为了解决更加抽象的问题，而关注点并不只是在某一个领域。</p><p>上面的几个例子有着一些共同的特点：</p><ul><li>没有计算和执行的概念；</li><li>其本身并不需要直接表示计算；</li><li>使用时只需要声明规则、事实以及某些元素之间的层级和关系；</li></ul><p>虽然了解了 DSL 以及 DSL 的一些特性，但是，到目前为止，我们对于如何构建一个 DSL 仍然不是很清楚。</p><h3 id="构建-DSL"><a href="#构建-DSL" class="headerlink" title="构建 DSL"></a>构建 DSL</h3><p>DSL 的构建与编程语言其实比较类似，想想我们在重新实现编程语言时，需要做那些事情；实现编程语言的过程可以简化为定义语法与语义，然后实现编译器或者解释器的过程，而 DSL 的实现与它也非常类似，我们也需要对 DSL 进行语法与语义上的设计。</p><img src="/images/DSL/2016-10-03-compiler.png" style="zoom:70%"><p>总结下来，实现 DSL 总共有这么两个需要完成的工作：</p><ol><li>设计语法和语义，定义 DSL 中的元素是什么样的，元素代表什么意思</li><li>实现 parser，对 DSL 解析，最终通过解释器来执行</li></ol><p>以 HTML 为例，HTML 中所有的元素都是包含在尖括号 <code>&lt;&gt;</code> 中的，尖括号中不同的元素代表了不同的标签，而这些标签会被浏览器<strong>解析</strong>成 DOM 树，再经过一系列的过程调用 Native 的图形 API 进行绘制。</p><img src="/images/DSL/2016-10-03-dom-tree.png" style="zoom:70%"><p>再比如，我们使用下面这种方式对一个模型进行定义，实现一个 ORM 领域的 DSL：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define <span class="symbol">:article</span> <span class="keyword">do</span></span><br><span class="line">  attr <span class="symbol">:name</span></span><br><span class="line">  attr <span class="symbol">:content</span></span><br><span class="line">  attr <span class="symbol">:upvotes</span>, <span class="symbol">:int</span></span><br><span class="line"></span><br><span class="line">  has_many <span class="symbol">:comments</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在上面的 DSL 中，使用 <code>define</code> 来定义一个新的模型，使用 <code>attr</code> 来为模型添加属性，使用 <code>has_many</code> 建立数据模型中的一对多关系；我们可以使用 DSL 对这段“字符串”进行解析，然后交给代码生成器来生成代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> createdAt: <span class="type">Date</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">init</span>(<span class="params">title</span>: <span class="type">String</span>, <span class="params">content</span>: <span class="type">String</span>, <span class="params">createdAt</span>: <span class="type">Date</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">new</span>(<span class="params">title</span>: <span class="type">String</span>, <span class="params">content</span>: <span class="type">String</span>, <span class="params">createdAt</span>: <span class="type">Date</span>)</span> -&gt; <span class="type">Article</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span>(<span class="params">title</span>: <span class="type">String</span>, <span class="params">content</span>: <span class="type">String</span>, <span class="params">createdAt</span>: <span class="type">Date</span>)</span> -&gt; <span class="type">Article</span>?</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建的 DSL 中的元素数量非常少，只有 <code>define</code> <code>attr</code> 以及 <code>has_many</code> 等几个关键字，但是通过这几个关键字就可以完成在模型层需要表达的绝大部分语义。</p><h3 id="设计原则和妥协"><a href="#设计原则和妥协" class="headerlink" title="设计原则和妥协"></a>设计原则和妥协</h3><p>DSL 最大的设计原则就是<strong>简单</strong>，通过简化语言中的元素，降低使用者的负担；无论是 Regex、SQL 还是 HTML 以及 CSS，其说明文档往往只有几页，非常易于学习和掌握。但是，由此带来的问题就是，DSL 中缺乏抽象的概念，比如：模块化、变量以及方法等。</p><blockquote><p>抽象的概念并不是某个领域所关注的问题，就像 Regex 并不需要有模块、变量以及方法等概念。</p></blockquote><p>由于抽象能力的缺乏，在我们的项目规模变得越来越大时，DSL 往往满足不了开发者的需求；我们仍然需要编程语言中的模块化等概念对 DSL 进行补充，以此解决 DSL 并不是真正编程语言的问题。</p><img src="/images/DSL/2016-10-03-css-sass.jpg" style="zoom:70%"><p>在当今的 Web 前端项目中，我们在开发大规模项目时往往不会直接手写 CSS 文件，而是会使用 Sass 或者 Less 为 CSS 带来更强大的抽象能力，比如嵌套规则，变量，混合以及继承等特性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">li</span> &#123; <span class="attribute">display</span>: inline-block; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在使用 DSL 的项目规模逐渐变大时，开发者会通过增加抽象能力的方式，对已有的 DSL 进行拓展；但是这种扩展往往需要重新实现通用编程语言中的特性，所以一般情况下都是比较复杂的。</p><h2 id="Embedded-DSL（嵌入式-DSL）"><a href="#Embedded-DSL（嵌入式-DSL）" class="headerlink" title="Embedded DSL（嵌入式 DSL）"></a>Embedded DSL（嵌入式 DSL）</h2><p>那么，是否有一种其它的方法为 DSL 快速添加抽象能力呢？而这也就是这一小节的主题，嵌入式 DSL。</p><p>在上一节讲到的 DSL 其实可以被称为外部 DSL；而这里即将谈到的嵌入式 DSL 也有一个别名，内部 DSL。</p><p>这两者最大的区别就是，内部 DSL 的实现往往是嵌入一些编程语言的，比如 iOS 的依赖管理组件 CocoaPods 和 Android 的主流编译工具 Gradle，前者的实现是基于 Ruby 语言的一些特性，而后者基于 Groovy。</p><img src="/images/DSL/2016-10-03-cocoapods.png" style="zoom:70%"><p>CocoaPods 以及其它的嵌入式 DSL 使用了宿主语言（host language）的抽象能力，并且省去了实现复杂语法分析器（Parser）的过程，并不需要重新实现模块、变量等特性。</p><p>嵌入式 DSL 的产生其实模糊了框架和 DSL 的边界，不过这两者看起来也没有什么比较明显的区别；不过，DSL 一般会使用宿主语言的特性进行创造，在设计 DSL 时，也不会考虑宿主语言中有哪些 API 以及方法，而框架一般都是对语言中的 API 进行组合和再包装。</p><blockquote><p>我们没有必要争论哪些是框架，哪些是 DSL，因为这些争论并没有什么意义。</p></blockquote><h3 id="Rails-和-Embedded-DSL"><a href="#Rails-和-Embedded-DSL" class="headerlink" title="Rails 和 Embedded DSL"></a>Rails 和 Embedded DSL</h3><p>最出名也最成功的嵌入式 DSL 应该就是 Ruby on Rails 了，虽然对于 Rails 是否是 DSL 有争议，不过 Rails 为 Web 应用的创建提供大量的内置的支撑，使我们在开发 Web 应用时变得非常容易。</p><img src="/images/DSL/2016-10-03-rails.jpg" style="zoom:70%"><h2 id="Ruby、-DSL-和-iOS"><a href="#Ruby、-DSL-和-iOS" class="headerlink" title="Ruby、 DSL 和 iOS"></a>Ruby、 DSL 和 iOS</h2><p>笔者同时作为 iOS 和 Rails 开发者接触了非常多的 DSL，而在 iOS 开发中最常见的 DSL 就是 CocoaPods 了，而这里我们以 CocoaPods 为例，介绍如何使用 Ruby 创造一个嵌入式 DSL。</p><h3 id="Why-Ruby？"><a href="#Why-Ruby？" class="headerlink" title="Why Ruby？"></a>Why Ruby？</h3><p>看到这里有人可能会问了，为什么使用 Ruby 创造嵌入式 DSL，而不是使用 C、Java、Python 等等语言呢，这里大概有四个原因：</p><ul><li>一切皆对象的特性减少了语言中的元素，不存在基本类型、操作符；</li><li>向 Ruby 方法中传入代码块非常方便；</li><li>作为解释执行的语言，eval 模糊了数据和代码的边界；</li><li>不对代码的格式进行约束，同时一些约定减少了代码中的噪音。</li></ul><h4 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h4><p>在许多语言，比如 Java 中，数字与其他的基本类型都不是对象，而在 Ruby 中所有的元素，包括基本类型都是对象，同时也不存在运算符的概念，所谓的 <code>1 + 1</code>，其实只是 <code>1.+(1)</code> 的语法糖而已。</p><p>得益于一切皆对象的概念，在 Ruby 中，你可以向任意的对象发送 <code>methods</code> 消息，在运行时自省，所以笔者在每次忘记方法时，都会直接用 <code>methods</code> 来“查阅文档”：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2.3.1 :003 &gt;</span> <span class="number">1</span>.methods</span><br><span class="line"> =&gt; [<span class="symbol">:%</span>, <span class="symbol">:&amp;</span>, <span class="symbol">:*</span>, <span class="symbol">:+</span>, <span class="symbol">:-</span>, <span class="symbol">:/</span>, <span class="symbol">:&lt;</span>, <span class="symbol">:&gt;</span>, <span class="symbol">:^</span>, <span class="symbol">:|</span>, <span class="symbol">:~</span>, <span class="symbol">:-@</span>, <span class="symbol">:**</span>, <span class="symbol">:&lt;=&gt;</span>, <span class="symbol">:&lt;&lt;</span>, <span class="symbol">:&gt;&gt;</span>, <span class="symbol">:&lt;=</span>, <span class="symbol">:&gt;=</span>, <span class="symbol">:==</span>, <span class="symbol">:===</span>, <span class="symbol">:[]</span>, <span class="symbol">:inspect</span>, <span class="symbol">:size</span>, <span class="symbol">:succ</span>, <span class="symbol">:to_s</span>, <span class="symbol">:to_f</span>, <span class="symbol">:div</span>, <span class="symbol">:divmod</span>, <span class="symbol">:fdiv</span>, <span class="symbol">:modulo</span>, ...]</span><br></pre></td></tr></table></figure><p>比如在这里向对象 <code>1</code> 调用 <code>methods</code> 就会返回它能响应的所有方法。</p><p>一切皆对象不仅减少了语言中类型的数量，消灭了基本数据类型与对象之间的边界；这一概念同时也简化了组成语言的元素，这样 Ruby 中只有对象和方法，这两个概念，极大降低了这门语言的复杂度：</p><ul><li>使用对象存储状态</li><li>对象之间通过方法通信</li></ul><h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>Ruby 对函数式编程范式的支持是通过 block，这里的 block 和 Objective-C 中的 block 有些不同。</p><p>首先 Ruby 中的 block 也是一种对象，即 <code>Proc</code> 类的实例，也就是所有的 block 都是 first-class 的，可以作为参数传递，返回。</p><p>下面的代码演示了两种向 Ruby 方法中传入代码块的方式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twice</span><span class="params">(&amp;<span class="built_in">proc</span>)</span></span></span><br><span class="line"><span class="number">2</span>.times &#123; <span class="built_in">proc</span>.call() &#125; <span class="keyword">if</span> <span class="built_in">proc</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twice</span></span></span><br><span class="line"><span class="number">2</span>.times &#123; <span class="keyword">yield</span> &#125; <span class="keyword">if</span> block_given?</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>yield</code> 会调用外部传入的 block，<code>block_given?</code> 用于判断当前方法是否传入了 <code>block</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">twice <span class="keyword">do</span></span><br><span class="line">puts <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">twice &#123; puts <span class="string">&quot;hello&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>向 <code>twice</code> 方法传入 block 也非常简单，使用 <code>do</code>、<code>end</code> 或者 <code>&#123;</code>、<code>&#125;</code> 就可以向任何的 Ruby 方法中传入代码块。</p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>早在几十年前的 Lisp 语言就有了 <code>eval</code> 这个方法，这个方法会将字符串当做代码来执行，也就是说 <code>eval</code> 模糊了代码与数据之间的边界。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval <span class="string">&quot;1 + 2 * 3&quot;</span></span><br><span class="line"> =&gt; <span class="number">7</span></span><br></pre></td></tr></table></figure><p>有了 <code>eval</code> 方法，我们就获得了更加强大的动态能力，在运行时，使用字符串来改变控制流程，执行代码并可以直接利用当前语言的解释器；而不需要去手动解析字符串然后执行代码。</p><h4 id="格式和约定"><a href="#格式和约定" class="headerlink" title="格式和约定"></a>格式和约定</h4><p>编写 Ruby 脚本时并不需要像 Python 一样对代码的格式有着严格的规定，没有对空行、Tab 的要求，完全可以想怎么写就怎么写，这样极大的增加了 DSL 设计的可能性。</p><p>同时，在一般情况下，Ruby 在方法调用时并不需要添加括号：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">&quot;Wello World!&quot;</span></span><br><span class="line">puts(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样减少了 DSL 中的噪音，能够帮助我们更加关心语法以及语义上的设计，降低了使用者出错的可能性。</p><p>最后，Ruby 中存在一种特殊的数据格式 <code>Symbol</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="symbol">:symbol</span>.to_s</span><br><span class="line"> =&gt; <span class="string">&quot;symbol&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;symbol&quot;</span>.to_sym</span><br><span class="line"> =&gt; <span class="symbol">:symbol</span></span><br></pre></td></tr></table></figure><p>Symbol 可以通过 Ruby 中内置的方法与字符串之间无缝转换。那么作为一种字符串的替代品，它的使用也能够降低使用者出错的成本并提升使用体验，我们并不需要去写两边加上引号的字符串，只需要以 <code>:</code> 开头就能创建一个 Symbol 对象。</p><h3 id="Podfile-是什么"><a href="#Podfile-是什么" class="headerlink" title="Podfile 是什么"></a>Podfile 是什么</h3><p>对 Ruby 有了一些了解之后，我们就可以再看一下使用 CocoaPods 的工程中的 Podfile 到底是什么了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;Demo&#x27;</span> <span class="keyword">do</span></span><br><span class="line">pod <span class="string">&#x27;Mantle&#x27;</span>, <span class="string">&#x27;~&gt; 1.5.1&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>如果不了解 iOS 开发后者没有使用过 CocoaPods，笔者在这里简单介绍一下这个文件中的一些信息。</p><p><code>source</code> 可以看作是存储依赖元信息（包括依赖的对应的 GitHub 地址）的源地址；</p><p><code>target</code> 表示需要添加依赖的工程的名字；</p><p><code>pod</code> 表示依赖，<code>Mantle</code> 为依赖的框架，后面是版本号。</p></blockquote><p>上面是一个使用 Podfile 定义依赖的一个例子，不过 Podfile 对约束的描述其实是这样的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source(<span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&#x27;Demo&#x27;</span>) <span class="keyword">do</span></span><br><span class="line">pod(<span class="string">&#x27;Mantle&#x27;</span>, <span class="string">&#x27;~&gt; 1.5.1&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Podfile 中对于约束的描述，其实都可以看作是代码的简写，在解析时会当做 Ruby 代码来执行。</p><h3 id="简单搞个-Embedded-DSL"><a href="#简单搞个-Embedded-DSL" class="headerlink" title="简单搞个 Embedded DSL"></a>简单搞个 Embedded DSL</h3><p>使用 Ruby 实现嵌入式 DSL 一般需要三个步骤，这里以 CocoaPods 为例进行简单介绍：</p><ul><li>创建一个 Podfile 中“代码”执行的上下文，也就是一些方法；</li><li>读取 Podfile 中的内容到脚本中；</li><li>使用 <code>eval</code> 在上下文中执行 Podfile 中的“代码”；</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CocoaPods 对于 DSL 的实现基本上就是我们创建一个 DSL 的过程，定义一系列必要的方法，比如 <code>source</code>、<code>pod</code> 等等，创造一个执行的上下文；然后去读存储 DSL 的文件，并且使用 <code>eval</code> 执行。</p><p><strong>信息的传递一般都是通过参数</strong>来进行的，比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br></pre></td></tr></table></figure><p><code>source</code> 方法的参数就是依赖元信息 <code>Specs</code> 的 Git 地址，在 <code>eval</code> 执行时就会被读取到 CocoaPods 中，然后进行分析。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>下面是一个非常常见的 Podfile 内容：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;http://source.git&#x27;</span></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;Demo&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;SDWebImage&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;Masonry&#x27;</span></span><br><span class="line">    pod <span class="string">&quot;Typeset&quot;</span></span><br><span class="line">    pod <span class="string">&#x27;BlocksKit&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;Mantle&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;IQKeyboardManager&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;IQDropDownTextField&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因为这里的 <code>source</code>、<code>platform</code>、<code>target</code> 以及 <code>pod</code> 都是方法，所以在这里我们需要构建一个包含上述方法的上下文：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eval_pod.rb</span></span><br><span class="line"><span class="variable">$hash_value</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">source</span><span class="params">(url)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(target)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">platform</span><span class="params">(platform, version)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pod</span><span class="params">(pod)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用一个全局变量 <code>hash_value</code> 存储 Podfile 中指定的依赖，并且构建了一个 Podfile 解析脚本的骨架；我们先不去完善这些方法的实现细节，先尝试一下读取 Podfile 中的内容并执行 <code>eval</code> 看看会不会有问题。</p><p>在 <code>eval_pod.rb</code> 文件的最下面加入这几行代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content = File.read <span class="string">&#x27;./Podfile&#x27;</span></span><br><span class="line">eval content</span><br><span class="line">p <span class="variable">$hash</span>_value</span><br></pre></td></tr></table></figure><p>这里读取了 Podfile 文件中的内容，并把其中的内容当做字符串执行，最后打印 <code>hash_value</code> 的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby eval_pod.rb</span><br></pre></td></tr></table></figure><p>运行这段 Ruby 代码虽然并没有什么输出，但是并没有报出任何的错误，接下来我们就可以完善这些方法了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">source</span><span class="params">(url)</span></span></span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;source&#x27;</span>] = url</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(target)</span></span></span><br><span class="line">    targets = <span class="variable">$hash_value</span>[<span class="string">&#x27;targets&#x27;</span>]</span><br><span class="line">    targets = [] <span class="keyword">if</span> targets == <span class="literal">nil</span></span><br><span class="line">    targets &lt;&lt; target</span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;targets&#x27;</span>] = targets</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">if</span> block_given?</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">platform</span><span class="params">(platform, version)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pod</span><span class="params">(pod)</span></span></span><br><span class="line">    pods = <span class="variable">$hash_value</span>[<span class="string">&#x27;pods&#x27;</span>]</span><br><span class="line">    pods = [] <span class="keyword">if</span> pods == <span class="literal">nil</span></span><br><span class="line">    pods &lt;&lt; pod</span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;pods&#x27;</span>] = pods</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在添加了这些方法的实现之后，再次运行脚本就会得到 Podfile 中的依赖信息了，不过这里的实现非常简单的，很多情况都没有处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby eval_pod.rb</span><br><span class="line">&#123;<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;http://source.git&quot;</span>, <span class="string">&quot;targets&quot;</span>=&gt;[<span class="string">&quot;Demo&quot;</span>], <span class="string">&quot;pods&quot;</span>=&gt;[<span class="string">&quot;AFNetworking&quot;</span>, <span class="string">&quot;SDWebImage&quot;</span>, <span class="string">&quot;Masonry&quot;</span>, <span class="string">&quot;Typeset&quot;</span>, <span class="string">&quot;BlocksKit&quot;</span>, <span class="string">&quot;Mantle&quot;</span>, <span class="string">&quot;IQKeyboardManager&quot;</span>, <span class="string">&quot;IQDropDownTextField&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><p>不过使用 Ruby 构建一个嵌入式 DSL 的过程大概就是这样，使用语言内建的特性来进行创作，创造出一个在使用时看起来并不像代码的 DSL。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>在最后，笔者想说的是，当我们在某一个领域经常需要解决重复性问题时，可以考虑实现一个 DSL 专门用来解决这些类似的问题。</p><p>而使用嵌入式 DSL 来解决这些问题是一个非常好的办法，我们并不需要重新实现解释器，也可以利用宿主语言的抽象能力。</p><p>同时，在嵌入式 DSL 扩展了 DSL 的范畴之后，不要纠结于某些东西到底是框架还是领域特定语言，这些都不重要，重要的是，在遇到了某些问题时，我们能否跳出来，使用文中介绍的方法减轻我们的工作量。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>[No Silver Bullet—Essence and Accidents of Software Engineering](No Silver Bullet—Essence and Accidents of Software Engineering)</li><li><a href="https://en.wikipedia.org/wiki/Domain-specific_language">Domain-specific language</a></li><li><a href="http://martinfowler.com/bliki/DomainSpecificLanguage.html">DomainSpecificLanguage</a></li><li><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm">How browsers work</a></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><blockquote><p>GitHub Repo：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p></blockquote><blockquote><p>Source: <a href="https://draveness.me/dsl">https://draveness.me/dsl</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://draveness.me/dsl/&quot;&gt;谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 DSL 以及 D</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>(二) 动态规划算法</title>
    <link href="https://tenloy.github.io/2021/06/22/11_dynamic-programming/"/>
    <id>https://tenloy.github.io/2021/06/22/11_dynamic-programming/</id>
    <published>2021-06-22T14:40:13.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、术语介绍"><a href="#一、术语介绍" class="headerlink" title="一、术语介绍"></a>一、术语介绍</h2><p>先来说几个动态规划问题中的术语。</p><p>动态规划<code>(dynamic programming)</code>是运筹学的一个分支，是求解决策过程<code>(decision process)</code>最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程<code>(multistep decision process)</code>的优化问题时，提出了著名的最优化原理<code>(principle of optimality)</code>，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。</p><p><img src="/images/algorithm/dp-1.jpg" alt="多阶段决策问题的图示"></p><h3 id="1-1-阶段"><a href="#1-1-阶段" class="headerlink" title="1.1 阶段"></a>1.1 阶段</h3><ul><li>把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同。</li><li>描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用 <code>k</code> 表示。</li><li>此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。</li></ul><p><strong>在前面的图中，第一个阶段就是点A到点B，第二个阶段是点B到点C，而第三个阶段是点C到点D。</strong></p><h3 id="1-2-状态"><a href="#1-2-状态" class="headerlink" title="1.2 状态"></a>1.2 状态</h3><p>状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它<strong>既是该阶段某路的起点，同时又是前一阶段某支路的终点。</strong></p><p><strong>前面的例子(图)中，初始状态即A，而第一个阶段有两个状态B1和B2，第二个阶段是三个状态C1，C2和C3，而第三个阶段是状态D1和D2。</strong></p><p>过程的状态通常可以用一个或一组数来描述，称为<code>状态变量</code>，用<code>x(k)</code>表示。一般，状态是离散的，但有时为了方便也将状态取成连续的。</p><p>而且在每个阶段的状态维数可以不同。状态变量当过程按所有可能不同的方式发展时，过程各段的状态变量将在某一确定的范围内取值。状态变量取值的集合称为<code>状态集合</code>。</p><h3 id="1-3-无后效性"><a href="#1-3-无后效性" class="headerlink" title="1.3 无后效性"></a>1.3 无后效性</h3><p>我们要求状态具有下面的性质：如果某阶段的状态一旦确定，则在这一阶段以后过程的发展变化仅与此阶段的状态有关，不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。</p><p>换句话说，过程的每一次实现可以用一个状态序列表示。<strong>在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。</strong></p><p>也就是说，<code>未来与过去无关</code>，当前的状态是此前历史（以往决策）的一个完整总结，过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性。（简单点说：过去只能通过影响现在，进而影响未来）</p><h3 id="1-4-决策"><a href="#1-4-决策" class="headerlink" title="1.4 决策"></a>1.4 决策</h3><ul><li>一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为<code>决策</code>。在最优控制中，也称为控制。</li><li><strong>每一个阶段都有若干个决策可供选择。</strong></li><li>在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。</li><li>描述决策的变量称<code>决策变量</code>，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史。</li></ul><p>决策变量的范围称为<code>允许决策集合</code>。</p><img src="/images/algorithm/dp-3.png" style="zoom:70%"><h3 id="1-5-多阶段决策问题与策略"><a href="#1-5-多阶段决策问题与策略" class="headerlink" title="1.5 多阶段决策问题与策略"></a>1.5 多阶段决策问题与策略</h3><p>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策(采取措施)，一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为<code>多阶段决策问题</code>。</p><ul><li><strong>策略</strong>：由每个阶段的决策组成的一个决策序列称为<strong>策略</strong>。<ul><li>每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取。</li></ul></li><li><strong>允许策略集合</strong>：对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为<strong>允许策略集合</strong>。</li><li><strong>最优策略</strong>：允许策略集合中达到最优效果的策略称为<strong>最优策略</strong>。<ul><li>对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。</li></ul></li></ul><h3 id="1-6-状态转移方程"><a href="#1-6-状态转移方程" class="headerlink" title="1.6 状态转移方程"></a>1.6 状态转移方程</h3><p>给定k阶段状态变量 <code>x(k)</code> 的值后，如果这一阶段的决策变量一经确定，第 <code>k+1</code> 阶段的状态变量 <code>x(k+1)</code> 也就完全确定，即 <code>x(k+1)</code> 的值随 <code>x(k)</code> 和第 <code>k</code> 阶段的决策 <code>u(k)</code> 的值变化而变化。</p><p>那么可以把这一关系看成 <code>(x(k),u(k))</code> 与 <code>x(k+1)</code> 确定的对应关系，用 <code>x(k+1) = Tk(x(k),u(k))</code> 表示。这是从 <code>k</code> 阶段到 <code>k+1</code> 阶段状态转移方程的状态转移规律，称为状态转移方程。</p><h3 id="1-7-最优化原理-最优子结构性质"><a href="#1-7-最优化原理-最优子结构性质" class="headerlink" title="1.7 最优化原理/最优子结构性质"></a>1.7 最优化原理/最优子结构性质</h3><ul><li>最优性原理：要求问题的<code>最优策略的子策略也是最优</code>。可以通俗地理解为子问题的局部最优将导致整个问题的全局最优，即<code>一个问题的最优解只取决于其子问题的最优解</code>，子问题的非最优解对问题的求解没有影响。</li><li>最优子结构性质：当一个问题的最优解包含着它的子问题的最优解时，就称此问题具有最优子结构性质。</li></ul><p>一个问题 <code>满足最优化原理</code>也称其 <code>拥有最优子结构性质</code>。</p><p>动态规划引出：</p><p><strong>多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决<code>多阶段决策最优化问题</code>的方法为动态规划方法。</strong></p><h2 id="二、基本思想"><a href="#二、基本思想" class="headerlink" title="二、基本思想"></a>二、基本思想</h2><blockquote><p>动态规划算法通常用于<code>求解最优性问题</code>：在这类问题中，可能会有许多可行解，每一个解都对应于一个值，我们希望找到具有最优值的解。  </p></blockquote><p><strong>动态规划</strong>(DP：Dynamic Programming)是一种重要的程序设计手段，其基本思想是在对一个<strong>多阶段决策</strong>的问题，按照某一顺序，根据每一步所选决策的不同会引起状态的转移，最后会在变化的状态中获取到一个决策序列。</p><p><strong>动态规划</strong>是一种把多阶段过程转化为一系列单阶段问题，逐个求解的方法泛应用于生产调度、工程技术和最优控制等领域。</p><p>动态规划与分治法的异同：</p><ul><li>相同点：都是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li><li>不同点：分治法是将问题划分成相互独立的子问题，因此部分子问题会被重复计算；动态规划方法分解得到的<code>子问题往往不互相独立</code>，而是相互重叠的，从而避免了大量重复计算。</li></ul><p>动态规划的实质是分治思想和解决冗余的结合：</p><ul><li><p>将问题实例分解为更小的、相似的子问题</p></li><li><p>存储子问题的解，在需要时再找出已求得的答案，来避免计算重复的子问题，从而得到多项式时间算法。</p><p>用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的<code>填表格式</code>。</p></li></ul><p>一般来说，只要该问题可以划分成规模更小的子问题，并且原问题的最优解中包含了子问题的最优解(即满足最优化原理)，则可以考虑用动态规划解决。</p><p>动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。当重复子问题的数目比较小时，动态规划的效果也会很差。</p><h2 id="三、适用情况"><a href="#三、适用情况" class="headerlink" title="三、适用情况"></a>三、适用情况</h2><p>一般具有以下3个特征：</p><ul><li><p>满足最优化原理(或称：问题具有最优子结构的性质。<code>是动态规划的基础</code>)</p><p>怎么分析问题是否满足？反证法</p><p><strong>先假设由问题的最优解导出的子问题的解不是最优的 → 然后证明在这个假设下可构造出比原问题最优解更好的解 → 从而导致矛盾，证明最优化原理</strong></p></li><li><p>无后效性</p></li><li><p>有重叠子问题：递归地分解问题时，产生的子问题并不总是独立的（很多子问题重复），一个子问题在下一阶段中可能被多次使用到。<strong>该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势</strong></p><p>动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。<code>其中的关键在于解决冗余</code>，这是动态规划算法的根本目的。动态规划实质上是一种 <code>以空间换时间</code>的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p></li></ul><h2 id="四、基本步骤"><a href="#四、基本步骤" class="headerlink" title="四、基本步骤"></a>四、基本步骤</h2><h3 id="4-1-书面版"><a href="#4-1-书面版" class="headerlink" title="4.1 书面版"></a>4.1 书面版</h3><p>1、分析最优解的性质，并刻画其结构特征。(确定满足最优化原理、划分阶段、确定状态)</p><p>2、递归地定义最优解。(确定状态转移方程(递推方程))</p><p>3、以自底向上或自顶向下(备忘录)的方式计算出最优值</p><p>4、根据计算最优值时得到的信息，从子问题的最优解逐步构造出整个问题的最优解</p><p>步骤1-3是动态规划算法的基本步骤。在只需求出最优值的情形下，步骤4可以省略，步骤3中记录的信息也较少； 若需要求出问题的一个最优解，则必须执行步骤4，步骤3中记录的信息必须足够多，以便构造最优解。</p><p>【问题描述】：给定两个字符串A[m]、B[n]，求它们的最长公共子序列C。</p><p>1、刻画最优解的结构特征</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果temp=A[m]=B[n]，C=temp+max_common_len(A[<span class="number">1</span>,...,m<span class="number">-1</span>],B[<span class="number">1</span>,...,n<span class="number">-1</span>])；</span><br><span class="line">如果A[m]!=B[n]，则C=maxLen(max_common_len(A[<span class="number">1</span>,...,m],B[<span class="number">1</span>,...,n<span class="number">-1</span>])，max_common_len(A[<span class="number">1</span>,...,m<span class="number">-1</span>],B[<span class="number">1</span>,...n]))。</span><br></pre></td></tr></table></figure><p>2、递归的定义最优解的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设C[i,j]表示两个串A[i]与B[j]的最长公共子序列的长度，则</span><br><span class="line"><span class="keyword">if</span> i=j=<span class="number">0</span>, C[i,j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> i,j&gt;<span class="number">0</span> <span class="keyword">and</span> A[i]==B[j], C[i,j]=<span class="number">1</span>+C[i<span class="number">-1</span>,j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span> i,j&gt;<span class="number">0</span> <span class="keyword">and</span> A[i]!=B[j], C[i,j]=max(C[i<span class="number">-1</span>,j],C[i,j<span class="number">-1</span>]).</span><br></pre></td></tr></table></figure><p>3、计算最优解</p><h3 id="4-2-个人理解版本"><a href="#4-2-个人理解版本" class="headerlink" title="4.2 个人理解版本"></a>4.2 个人理解版本</h3><p><strong>第一步：将原问题分解为子问题 — 划分阶段</strong></p><ul><li>把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决。</li><li>子问题的解一旦求出就会被保存，所以每个子问题只需求解一次。</li><li>按照问题的时间或空间特征，把问题分为若干个子问题。划分时，需要注意<strong>划分后的子问题一定要是有序的或者是可排序的</strong>，否则问题就无法求解。(多阶段决策问题)</li></ul><p><strong>第二步：确定状态 — 确定状态、状态空间</strong></p><ul><li>在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题，所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。当然，状态的选择要<code>满足无后效性</code>。</li><li>所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。</li><li><em>比如：求课件中的最大子段和。有n个状态，即状态空间大小为n，每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。因此，用动态规划算法通常只需要多项式时间。</em></li></ul><p><strong>第三步：确定一些初始状态的值</strong></p><ul><li>初始状态，也会被称为边界状态、叶节点状态(对应一个子问题)</li></ul><p><strong>第四步：确定状态转移方程</strong></p><ul><li>定义出什么是状态、在该状态下的值后，就要找出不同的状态之间如何迁移 —— <strong>怎么从本阶段状态(“值”已知)递推到下一阶段的未解状态，直到最终状态</strong>。(递推型)</li><li>状态的迁移可以用递推公式表示，此递推公式也可被称作<strong>状态转移方程</strong>。</li></ul><p><strong>第五步：开始计算</strong></p><ul><li>以 <code>自底向上</code> 或 <code>自顶向下的记忆化方式（备忘录法</code> 计算出最优值，根据计算最优值时得到的信息，构造问题的最优解。</li></ul><img src="/images/algorithm/dp-2.png" style="zoom:70%"><h3 id="4-3-个人总结"><a href="#4-3-个人总结" class="headerlink" title="4.3 个人总结"></a>4.3 个人总结</h3><ul><li>相比动态规划，分治法与贪心法就简单许多。(首先后两者都不用记录前面状态(子问题)的值)</li><li>分治法：先一分为二…然后合二为一… </li><li>贪心法：也算是多阶段决策问题。找出子问题分解思路、确定状态空间、初始状态值。确定状态转移方程这一步有差异，贪心法是自顶向下一层一层分解，遵守贪心选择原则，得出一系列子问题的局部最优解，直到最小子问题，即可组合出原问题的解。</li></ul><h3 id="4-4-备忘录算法"><a href="#4-4-备忘录算法" class="headerlink" title="4.4 备忘录算法"></a>4.4 备忘录算法</h3><p>备忘录方法是动态规划算法的变形，它通过分治思想对原问题进行分解，以<code>存储子问题的解</code>的方式解决冗余计算，并采用自顶向下的递归方式获取问题的最终解。</p><p><strong>备忘录算法与动态规划算法</strong></p><ul><li><p>相同之处：都会对子问题的计算结果进行存储，解决冗余计算</p></li><li><p>不同之处：动态规划算法是<code>自底向上递推</code>求解，而备忘录方法是<code>自顶向下递归</code>求解。</p></li><li><p>当子问题空间中的大量子问题无需求解时，使用备忘录方法较省时。</p></li><li><p>但当无需计算的子问题只有少部分或全部都要计算时，使用动态规划算法，节省递归带来的额外消耗。</p></li></ul><p>比如：求LCS(最长公共子序列)问题中：</p><ul><li>动态规划算法求算，就是自底向上，将所有会出现的子问题都计算并记录下来，而其实有一些子问题在后续的计算中，并不会被用到。</li><li>而备忘录算法求解，就是自顶向下递归，只计算使用到的子问题并记录，</li></ul><p><strong>备忘录算法与直接递归（备忘录方法 = 递归 + 记录表）</strong></p><ul><li>备忘录方法的控制结构与直接递归方法的控制相同(<strong>递归也是分解子问题，自顶向下求解</strong>)，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同的子问题的重复求解</li><li>备忘录：初始化为每个子问题的记录存入一个特殊的值，表示并未求解。在求解过程中，查看相应记录如果是特殊值，表示未求解，否则只要取出该子问题的解答即可。</li></ul><h2 id="五、程序设计-可只看这部分"><a href="#五、程序设计-可只看这部分" class="headerlink" title="五、程序设计(可只看这部分)"></a>五、程序设计(可只看这部分)</h2><h3 id="5-1-三要素"><a href="#5-1-三要素" class="headerlink" title="5.1 三要素"></a>5.1 三要素</h3><p>动态规划的主要难点在于理论上的设计，也就是上面几个步骤的确定，一旦设计完成，实现部分就会非常简单。</p><p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><ul><li>问题的阶段(子问题划分)</li><li>每个阶段的状态</li><li>从前一个阶段转化到后一个阶段之间的递推关系</li></ul><p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为<code>递推可以充分利用前面保存的子问题的解来减少重复计算</code>，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><h3 id="5-2-确定状态转移方程"><a href="#5-2-确定状态转移方程" class="headerlink" title="5.2 确定状态转移方程"></a>5.2 确定状态转移方程</h3><p><img src="/images/algorithm/dp-1.jpg" alt="仍以该图为例"></p><ul><li><strong>阶段</strong>：描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。<ul><li>第一个阶段就是点A到点B，第二个阶段是点B到点C，而第三个阶段是点C到点D。 </li></ul></li><li><strong>状态</strong>：状态通常可以用一个或一组数来描述，称为状态变量，记为x(k)。 <ul><li>初始状态为A，而第一个阶段有两个状态B1和B2，第二个阶段是三个状态C1，C2和C3，而第三个阶段是状态D1和D2。 </li></ul></li><li><strong>决策</strong>：每一个阶段都有若干个决策可供选择，描述决策的变量称决策变量。记为u(k)。</li><li><strong>每个阶段状态的值：</strong>为演变到该状态的前一阶段的状态值F(k) + 决策对应的值。如果发现更优解，覆盖之前的(最优常指耗费最小/路径最短，或是收益最大)。</li></ul><p>所以，状态转移方程为：</p><ul><li><p>如果是收益最大问题：直接就是如上所说：<code>F(k+1) = max&#123; F(k) + u(k) &#125; </code>(有的也用dp表示，更表示动规)</p></li><li><p>如果是耗费最小/路径最短问题：需要多一道程序，因为此时的状态是耗费xx/经历xx路径所达到的效果，而不是题目要求的最小多少耗费/最短多少路径。所以需要一个函数来进行转换，表示达到当前状态所耗费的多少，或所经历的路径长度：<code>dp(F(k+1)) = min&#123; dp(F(k)) + 1/权值 &#125;</code></p><p>如凑零钱问题中，需要的函数可以是dp(n)：定义：输入一个目标金额 n(当前状态的值F(k))，返回凑出目标金额 n 的最少硬币数量：<code>dp(n) = min&#123; dp(n-coin) + 1 | coin ∈ coins &#125;</code></p></li></ul><h3 id="5-3-最优决策表"><a href="#5-3-最优决策表" class="headerlink" title="5.3 最优决策表"></a>5.3 最优决策表</h3><p>确定了动态规划的这三要素，整个求解过程就可以用一个<code>最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态</code>，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的<code>最优值</code>（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="operator">=</span><span class="variable">max</span><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">-</span><span class="number">1</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">-</span><span class="number">1</span><span class="operator">,</span><span class="variable">m</span><span class="operator">-</span><span class="variable">w</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="operator">+</span><span class="variable">P</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-一般的算法设计模式如下"><a href="#5-4-一般的算法设计模式如下" class="headerlink" title="5.4 一般的算法设计模式如下"></a>5.4 一般的算法设计模式如下</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=max（或min）&#123;g(xi<span class="number">-1</span>[j1:j2]), ......, g(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"></span><br><span class="line">t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"></span><br><span class="line">print(x1[j1]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、经典运用"><a href="#六、经典运用" class="headerlink" title="六、经典运用"></a>六、经典运用</h2><ul><li>矩阵连乘</li><li>走金字塔</li><li>最长公共子序列(LCS)</li><li>最长递增子序列(LIS)</li><li>凸多边形最优三角剖分</li><li>背包问题</li><li>双调欧几里得旅行商问题</li><li>“求全路径最短路径的Floyd算法”<br>…<h3 id="6-1-0-1背包问题"><a href="#6-1-0-1背包问题" class="headerlink" title="6.1 0-1背包问题"></a>6.1 0-1背包问题</h3></li></ul><p>【问题描述】<br>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p>对于一种物品，要么装入背包，要么不装。所以对于一种物品的装入状态可以取0和1.我们设物品i的装入状态为xi,xi∈ (0,1)，此问题称为0-11背包问题。</p><p>【数据】<br>物品个数n=5，物品重量$w[n] = {0,2,2,6,5,4}$，物品价值$V[n] = {0,6,3,5,4,6}$（第0位，置为0，不参与计算，只是便于与后面的下标进行统一，无特别用处，也可不这么处理）。总重量$c=10$。背包的最大容量为10，那么在设置数组m大小时，可以设行列值为6和11，那么，对于$m(i,j)$就表示可选物品为$i…n$背包容量为j(总重量)时背包中所放物品的最大价值。</p><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ol><li><p>看了好多，<a href="https://blog.csdn.net/baidu_28312631/article/details/47418773">这一篇博客</a>尤为通俗易懂</p></li><li><p>如果要看备忘录算法、动态规划算法之间的差异，可以看<a href="https://blog.csdn.net/u013309870/article/details/75193592">这篇博客</a>，并做一下<a href="https://leetcode-cn.com/problems/longest-common-subsequence/">求LCS</a>这道题，搜一下它的两种解法</p></li><li><p><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin">动态规划 — 百度百科</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、术语介绍&quot;&gt;&lt;a href=&quot;#一、术语介绍&quot; class=&quot;headerlink&quot; title=&quot;一、术语介绍&quot;&gt;&lt;/a&gt;一、术语介绍&lt;/h2&gt;&lt;p&gt;先来说几个动态规划问题中的术语。&lt;/p&gt;
&lt;p&gt;动态规划&lt;code&gt;(dynamic programming</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://tenloy.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>前端各种模块化方案总结</title>
    <link href="https://tenloy.github.io/2021/06/18/10_Web-Module/"/>
    <id>https://tenloy.github.io/2021/06/18/10_Web-Module/</id>
    <published>2021-06-18T11:09:27.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、模块化"><a href="#一、模块化" class="headerlink" title="一、模块化"></a>一、模块化</h2><h3 id="1-1-什么是模块化"><a href="#1-1-什么是模块化" class="headerlink" title="1.1 什么是模块化"></a>1.1 什么是模块化</h3><p>那么，到底什么是模块化开发呢？</p><blockquote><p>模块：1、在通信、计算机、数据处理控制系统的电路中，可以组合和更换的硬件单元。2、大型软件系统中的一个具有独立功能的部分。</p></blockquote><ul><li>现实生活中模块化的例子：模块化计算机(cpu、内存、显卡、风扇、硬盘、光驱等等模块)、谷歌模块化手机、模块化房屋</li><li>代码模块化例子：日期模块、数学计算模块、日志模块等，所有这些模块共同组成了程序软件系统</li></ul><p><strong>模块化：</strong></p><ul><li>模块化开发就是<strong>将程序划分成一个个(互相依赖的)小文件/模块来开发，然后将小模块组合起来</strong>；</li><li>这个模块中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；</li><li>这个模块可以将自己希望暴露的变量、函数、对象等导出给其结构使用；</li><li>也可以通过某种方式，导入另外模块中的变量、函数、对象等；</li></ul><p><strong>模块化的好处：</strong></p><ol><li>防止命名冲突</li><li>代码复用（非模块化开发时，代码重用时，引入 js 文件的数目可能少了或者引入的顺序不对，会导致一些问题）</li><li>高维护性（模块之间有高耦合低内聚的特点）</li></ol><h3 id="1-2-JavaScript设计缺陷"><a href="#1-2-JavaScript设计缺陷" class="headerlink" title="1.2 JavaScript设计缺陷"></a>1.2 JavaScript设计缺陷</h3><p>无论你多么喜欢JavaScript，以及它现在发展的有多好，我们都需要承认在<em>Brendan Eich</em>用了10天写出JavaScript的时候，它都有很多的缺陷：</p><ul><li>比如var定义的变量作用域问题；</li><li>比如JavaScript的面向对象并不能像常规面向对象语言一样使用class；</li><li>比如JavaScript没有模块化的问题；</li></ul><p><em>Brendan Eich</em>本人也多次承认过JavaScript设计之初的缺陷，但是随着JavaScript的发展以及标准化，存在的缺陷问题基本都得到了完善。</p><ul><li>JavaScript目前已经得到了快速的发展，无论是web、移动端、小程序端、服务器端、桌面应用都被广泛的使用；</li></ul><p>在网页开发的早期，<em>Brendan Eich</em>开发JavaScript仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的：</p><ul><li>这个时候我们只需要讲JavaScript代码写到<code>&lt;script&gt;</code>标签中即可；</li><li>并没有必要放到多个文件中来编写；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;按钮被点击了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>但是随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂了：</p><ul><li>ajax的出现，前后端开发分离，意味着后端返回数据后，我们需要通过JavaScript进行前端页面的渲染；</li><li>SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现；</li><li>包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤；</li></ul><p>所以，模块化已经是JavaScript一个非常迫切的需求。</p><h3 id="1-3-没有模块化的JavaScript"><a href="#1-3-没有模块化的JavaScript" class="headerlink" title="1.3 没有模块化的JavaScript"></a>1.3 没有模块化的JavaScript</h3><h4 id="1-3-1-技术方案"><a href="#1-3-1-技术方案" class="headerlink" title="1.3.1 技术方案"></a>1.3.1 技术方案</h4><p>演变过程：</p><ul><li><p>全局函数</p><ul><li>”污染”了全局变量，无法保证不与其它模块发生变量名冲突</li><li>没有模块的划分，只能人为的认为它们属于一个模块，但是程序并不能区分哪些函数是同一个模块</li></ul></li><li><p>将函数封装到对象命名空间下</p><ul><li>从代码级别可以明显的区分出哪些函数属于同一个模块</li><li>从某种程度上解决了变量命名冲突的问题，但是并不能从根本上解决命名冲突</li><li>会暴露所有的模块成员，内部状态可以被外部改写，不安全</li><li>命名空间越来越长</li></ul></li><li><p>立即函数调用表达式(<strong>IIFE</strong>，Immediately Invoked Function Expression)</p><ul><li><p>将模块封装为立即执行函数形式，将公有方法，通过在函数内部返回值的形式向外暴露</p></li><li><p>会有人强调<strong>职责单一性</strong>，不要与程序的其它部分直接交互。比如当使用到第三方依赖时，通过向匿名函数注入依赖项的形式，来保证模块的独立性，还使模块之间的依赖关系变得明显</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> add=<span class="function"><span class="keyword">function</span>(<span class="params">v1,v2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1+v2;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123; <span class="attr">add</span>:add &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> calculator=(<span class="function"><span class="keyword">function</span>(<span class="params">cal,$</span>)</span>&#123;</span><br><span class="line">  cal.add2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> v1=$(<span class="string">&#x27;#v1&#x27;</span>).val();</span><br><span class="line">      <span class="keyword">var</span> v2= $(<span class="string">&#x27;#v2&#x27;</span>).val();</span><br><span class="line">     <span class="keyword">return</span> (v1-<span class="number">0</span>)+(v2-<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cal;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.calculator||&#123;&#125;,<span class="built_in">window</span>.$)</span><br><span class="line"><span class="comment">//在这告诉我要jquery</span></span><br><span class="line"><span class="comment">//依赖注入</span></span><br><span class="line"><span class="comment">//很牵强的解决文件依赖问题的方法</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>IIFE也是有很大缺陷的，见下方代码举例</p></li></ul><h4 id="1-3-2-问题举例"><a href="#1-3-2-问题举例" class="headerlink" title="1.3.2 问题举例"></a>1.3.2 问题举例</h4><p>我们先来简单体会一下没有模块化代码的问题。</p><p>我们知道，对于一个大型的前端项目，通常是多人开发的（即使一个人开发，也会将代码划分到多个文件夹中）：</p><ul><li>我们假设有两个人：小明和小丽同时在开发一个项目，并且会将自己的JavaScript代码放在一个单独的js文件中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小明开发了aaa.js文件，代码如下（当然真实代码会复杂的多）：</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;aaa的flag为true&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小丽开发了bbb.js文件，代码如下：</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;bbb使用了flag为false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显出现了一个问题：</p><ul><li>大家都喜欢使用flag来存储一个boolean类型的值；</li><li>但是一个人赋值了true，一个人赋值了false；</li><li>如果之后都不再使用，那么也没有关系；</li></ul><p>但是，小明又开发了ccc.js文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;使用了aaa的flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了：小明发现ccc中的flag值不对</p><ul><li>对于聪明的你，当然一眼就看出来，是小丽将flag赋值为了false；</li><li>但是如果每个文件都有上千甚至更多的代码，而且有上百个文件，你可以一眼看出来flag在哪个地方被修改了吗？</li></ul><p>备注：引用路径如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./aaa.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bbb.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./ccc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以，没有模块化对于一个大型项目来说是灾难性的。</p><h4 id="1-3-3-IIFE的缺陷"><a href="#1-3-3-IIFE的缺陷" class="headerlink" title="1.3.3 IIFE的缺陷"></a>1.3.3 IIFE的缺陷</h4><p>使用IIFE解决上面的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;aaa的flag为true&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">flag</span>: flag &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="keyword">const</span> moduleB = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;bbb使用了flag为false&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ccc.js</span></span><br><span class="line"><span class="keyword">const</span> moduleC = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> flag = moduleA.flag;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;使用了aaa的flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>命名冲突的问题，有没有解决呢？解决了。</p><p>但是，我们其实带来了新的问题：</p><ul><li>第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用；</li><li>第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；</li><li>第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况；</li></ul><p><strong>所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。</strong></p><ul><li>我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码；</li><li>这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性；</li></ul><h3 id="1-4-JavaScript中模块化方案"><a href="#1-4-JavaScript中模块化方案" class="headerlink" title="1.4 JavaScript中模块化方案"></a>1.4 JavaScript中模块化方案</h3><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>。直到ES6（2015）才推出了自己的模块化方案，在此之前，社区制定了一些模块加载方案，最主要的有：</p><p>先有规范，后有实现：</p><ul><li>服务器端规范 <a href="http://www.commonjs.org/">CommonJS</a> =&gt; <a href="https://nodejs.org/">NodeJS</a>、 Browserify</li><li>浏览器端规范 <a href="https://github.com/amdjs/amdjs-api">AMD</a> =&gt; <a href="http://requirejs.org/">RequireJS</a></li><li>浏览器端规范 <a href="https://github.com/amdjs/amdjs-api">CMD</a> =&gt; <a href="http://seajs.org/">SeaJS</a></li></ul><h2 id="二、CommonJS规范"><a href="#二、CommonJS规范" class="headerlink" title="二、CommonJS规范"></a>二、CommonJS规范</h2><h3 id="2-1-CommonJS和Node"><a href="#2-1-CommonJS和Node" class="headerlink" title="2.1 CommonJS和Node"></a>2.1 CommonJS和Node</h3><p>我们需要知道CommonJS是一个规范，最初提出来是在浏览器意外的地方使用，并且当时被命名为<strong>ServerJS</strong>，后来为了体现它的广泛性，修改为<strong>CommonJS</strong>，平时我们也会简称为CJS。</p><ul><li>Node是CommonJS在服务器端一个具有代表性的实现；</li><li>Browserify是CommonJS在浏览器中的一种实现；</li><li>webpack打包工具具备对CommonJS的支持和转换（后面会讲到）；</li></ul><p>所以，Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：</p><h3 id="2-2-Node模块化语法"><a href="#2-2-Node模块化语法" class="headerlink" title="2.2 Node模块化语法"></a>2.2 Node模块化语法</h3><h4 id="2-2-1-模块"><a href="#2-2-1-模块" class="headerlink" title="2.2.1 模块"></a>2.2.1 模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(name, age);</span><br><span class="line">sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面的代码会报错：</span></span><br><span class="line"><span class="comment"> - 那么，就意味着别的模块main中不能随便访问另外一个模块bar中的内容；</span></span><br><span class="line"><span class="comment"> - bar需要 导出 自己想要暴露的变量、函数、对象等；main从bar中 导入 自己想要使用的变量、函数、对象等数据之后，才能使用；</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>在node中每一个文件都是一个独立的模块，有自己的作用域</strong>。在一个模块内变量、函数、对象都属于这个模块，对外是封闭的。</p><p>为了实现模块的导出，Node中使用的是Module的类(提供了一个Module构造函数)，每一个模块都是Module的一个实例，也就是module；</p><p>每个模块(文件)中都包括CommonJS规范的核心变量：exports、module、require；</p><ul><li><p>module：是一个全局对象，代表当前模块。里面保存了模块的信息路径、父子结构信息、曝露出的对象信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.id           <span class="comment">//带有绝对路径的模块文件名</span></span><br><span class="line"><span class="built_in">module</span>.filename      <span class="comment">//模块的文件名，带有绝对路径</span></span><br><span class="line"><span class="built_in">module</span>.loaded       <span class="comment">//表示模块是否已经完成加载</span></span><br><span class="line"><span class="built_in">module</span>.parent     <span class="comment">//返回一个对象，表示调用该模块的模块。</span></span><br><span class="line"><span class="built_in">module</span>.children      <span class="comment">//返回一个数组，表示该模块要用到的其他模块。</span></span><br><span class="line"><span class="built_in">module</span>.exports     <span class="comment">//模块对外输出的值。需要打破模块封装性曝露的方法和属性，都要挂载到module.exports上。其它文件加载该模块,实际上就是读取module.exports属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 /Users/computer/Desktop/ccc/lib.js 文件中 console.log(module);</span></span><br><span class="line">Module &#123;</span><br><span class="line">  id: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">  path: <span class="string">&#x27;/Users/computer/Desktop/ccc&#x27;</span>,</span><br><span class="line">  <span class="built_in">exports</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span> &#125;,</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">&#x27;/Users/computer/Desktop/ccc/main.js&#x27;</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children: [</span><br><span class="line">    Module &#123;...&#125;</span><br><span class="line">  ],</span><br><span class="line">  paths: [ <span class="comment">//查找路径</span></span><br><span class="line">    <span class="string">&#x27;/Users/computer/Desktop/ccc/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/computer/Desktop/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/computer/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/node_modules&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>exports是module.exports的引用。一起负责对模块中的内容进行导出；</p></li><li><p>require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；</p></li></ul><p>在Node.js中，模块分为两类：</p><ul><li><p>第一类，系统核心模块(原生模块)，node自带。用名称直接可以加载。</p><ul><li>fs(file system)：与文件系统交互</li><li>http：提供http服务器功能</li><li>os：提供了与操作系统相关的实用方法和属性</li><li>path：处理文件路径</li><li>querystring：解析url查询字符串</li><li>url：解析url</li><li>util：提供一系列实用小工具</li><li>Buffer </li><li>等等很多，见<a href="http://api.nodejs.cn/">官方文档</a></li><li><strong>核心模块的源码都在Node的lib子目录中。为了提高运行速度，它们安装的时候都会被编译成二进制文件</strong></li></ul></li><li><p>第二类，文件模块，也称自定义模块。用路径加载。</p><p>有一种特殊的文件模块 — 包，被管理在<code>node_modules</code>文件夹中的包，也可以直接用名字加载。</p></li></ul><h4 id="2-2-2-exports导出"><a href="#2-2-2-exports导出" class="headerlink" title="2.2.2 exports导出"></a>2.2.2 exports导出</h4><p><strong>强调：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js 导出内容</span></span><br><span class="line"><span class="built_in">exports</span>.name = name;</span><br><span class="line"><span class="built_in">exports</span>.age = age;</span><br><span class="line"><span class="built_in">exports</span>.sayHello = sayHello;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 导入内容</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面这行代码意味着什么呢？</p><ul><li>意味着main中的bar变量等于exports对象；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main中的bar = bar中的<span class="built_in">exports</span></span><br></pre></td></tr></table></figure><p>所以，我可以编写下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = bar.name;</span><br><span class="line"><span class="keyword">const</span> age = bar.age;</span><br><span class="line"><span class="keyword">const</span> sayHello = bar.sayHello;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"></span><br><span class="line">sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br></pre></td></tr></table></figure><p>模块之间的引用关系：</p><img src="/images/webmodule/moduleref.jpg" alt="图片" style="zoom:70%;" /><p>为了进一步论证，bar和exports是同一个对象：</p><ul><li>所以，bar对象是exports对象的浅拷贝；</li><li>浅拷贝的本质就是一种引用的赋值而已；</li></ul><p>定时器修改对象：</p><img src="/images/webmodule/settimeoutmod.jpg" alt="图片" style="zoom:80%;" /><h4 id="2-2-3-module-exports"><a href="#2-2-3-module-exports" class="headerlink" title="2.2.3 module.exports"></a>2.2.3 module.exports</h4><p>但是Node中我们经常导出东西的时候，又是通过module.exports导出的：</p><ul><li>module.exports和exports有什么关系或者区别呢？</li></ul><p>我们追根溯源，通过维基百科中对CommonJS规范的解析：</p><ul><li>CommonJS中是没有module.exports的概念的；</li><li>但是为了实现模块的导出，Node中使用的是Module的类(提供了一个Module构造函数)，每一个模块都是Module的一个实例，也就是module；</li><li><strong>module才是导出的真正实现者；</strong></li><li>所以在Node中<strong>真正用于导出的其实根本不是exports，而是module.exports</strong>。只是为了实现CommonJS的规范，也为了使用方便，Node为每个模块提供了一个exports对象，让其对module.exports有一个引用而已。</li><li>相当于在每个模块头部，有这样一行命令：<code>var exports = module.exports;</code></li></ul><img src="/images/webmodule/export1.jpg" alt="图片" style="zoom:67%;" /><p><strong>不能直接给exports、module.exports赋值，这样等于切断了exports和module.exports的联系。最终输出的结果只会是module.exports的值</strong>。比如代码这样修改了：</p><img src="/images/webmodule/export2.jpg" alt="图片" style="zoom:67%;" /><img src="/images/webmodule/moduleexports.jpg" alt="moduleexports" style="zoom:68%;" /><h4 id="2-2-4-require"><a href="#2-2-4-require" class="headerlink" title="2.2.4 require"></a>2.2.4 require</h4><h5 id="1-require的加载原理"><a href="#1-require的加载原理" class="headerlink" title="1. require的加载原理"></a>1. require的加载原理</h5><p>前面已经说过，CommonJS 的一个模块，就是一个脚本文件。</p><ul><li><p>CommonJS是同步加载。模块加载的顺序，按照其在代码中出现的顺序</p></li><li><p><code>require</code>命令第一次加载模块时，会执行整个模块(脚本文件)中的js代码，返回该模块的module.exports接口数据。会在内存生成一个该模块对应的module对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> aaa = <span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>); <span class="comment">// aaa.js中的代码在引入时会被运行一次</span></span><br></pre></td></tr></table></figure><p>生成的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">&#x27;...&#x27;</span>,  <span class="comment">// 模块名</span></span><br><span class="line">  <span class="built_in">exports</span>: &#123; ... &#125;,  <span class="comment">// 模块输出的各个接口</span></span><br><span class="line">  loaded: <span class="literal">true</span>,   <span class="comment">// 是一个布尔值，为false表示还没有加载，为true表示已经加载完毕。这是保证每个模块只加载、运行一次的关键。</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。</p></li><li><p>模块被多次引入时（多次执行<code>require</code>命令），CommonJS 模块<strong>只会在第一次加载时运行一次</strong>，以后再加载，会去缓存中取出第一次加载时生成的module对象并返回module.exports。除非手动清除系统缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> aaa = <span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bbb = <span class="built_in">require</span>(<span class="string">&#x27;./bbb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> ccc = <span class="built_in">require</span>(<span class="string">&quot;./ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="keyword">const</span> ccc = <span class="built_in">require</span>(<span class="string">&quot;./ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ccc.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ccc被加载&#x27;</span>);  <span class="comment">// ccc中的代码只会运行一次。</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-require的查找规则"><a href="#2-require的查找规则" class="headerlink" title="2. require的查找规则"></a>2. require的查找规则</h5><p>我们现在已经知道，require是一个函数，可以帮助我们引入一个文件（模块）中导出的对象。</p><p>那么，require的查找规则是怎么样的呢？<a href="https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together">官方文档</a></p><p><strong>这里我总结比较常见的查找规则：</strong>导入格式如下：require(X)</p><ul><li><p>情况一：X是一个核心模块，比如path、http。直接返回核心模块，并且停止查找</p><ul><li>加载核心模块。传入名字，不需要传入路径。因为Node.js已经将核心模块的文件代码编译到了二进制的可执行文件中了。在加载的过程中，原生的核心模块的优先级是是最高的。</li></ul></li><li><p>情况二：X是以 <code>./</code> 或 <code>../</code> 或 <code>/</code>（根目录）开头的</p><ul><li>在Linux或者MAc的操作系统中，/表示系统的根路径。在Windows中，/表示当前文件模块所属的根磁盘路径</li><li>第一步：将X当做一个文件在对应的目录下查找；<ul><li>如果有后缀名，按照后缀名的格式查找对应的文件</li><li>如果没有后缀名，会按照如下顺序：<ol><li>直接查找文件X</li><li>查找X.js文件：当做JavaScript脚本文件解析</li><li>查找X.json文件：以JSON格式解析。<ul><li>如果是加载json文件模块，最好加上后缀.json，能稍微的提高一点加载的速度。</li><li>json文件Node.js也是通过fs读文件的形式读取出来的，然后通过JSON.parse()转换成一个对象</li></ul></li><li>查找X.node文件：以编译后的二进制文件解析。.node文件通常是c/c++写的一些扩展模块</li></ol></li></ul></li><li>第二步：没有找到对应的文件，将X作为一个目录。查找目录下面的index文件<ol><li>查找X/index.js文件</li><li>查找X/index.json文件</li><li>查找X/index.node文件</li></ol></li><li>如果没有找到，那么报错：<code>not found</code></li></ul></li><li><p>情况三：直接是一个X（没有路径），并且X不是一个核心模块</p><ul><li> 比如在<code>/Users/coderwhy/Desktop/Node/TestCode/04_learn_node/05_javascript-module/02_commonjs/main.js</code>中</li></ul><p>  编写 <code>require(&#39;why&#39;)</code></p><ul><li><p>查找顺序：从当前 package 的 node_modules 里面找，找不到就到当前 package 目录上层 node_modules 里面取… 一直找到全局 node_modules 目录。</p><img src="/images/webmodule/require1.jpg" alt="图片" style="zoom:70%;" /></li><li><p>这样找到的往往是文件夹，所以接下来就是处理一个文件目录作为 Node 模块的情况。如果文件目录下有 package.json，就根据它的 main 字段找到 js 文件。如果没有 package.json，那就<strong>默认取文件夹下的 index.js</strong>。</p><p>由于 webpack browsersify 等模块打包工具是兼容 node 的模块系统的，自然也会进行同样的处理流程。不同的是，它们支持更灵活的配置。比如在 webpack 里面，可以通过 alias 和 external 字段配置，实现对默认 import 逻辑的自定义。</p></li><li><p>如果上面的路径中都没有找到，那么报错：<code>not found</code></p></li></ul></li></ul><p>流程图：</p><img src="/images/webmodule/image1.jpg" alt="Alt text" style="zoom:80%;" /><ul><li><p>Node.js会通过同步阻塞的方式看这个路径是否存在。依次尝试，直到找到为止，如果找不到，报错</p></li><li><p>优先从缓存加载：common.js规范：载后，再次加载时，去缓存中取module.exports <a href="http://www.infoq.com/cn/articles/nodejs-module-mechanism/">参考文献</a></p></li></ul><h5 id="3-require的加载顺序"><a href="#3-require的加载顺序" class="headerlink" title="3. require的加载顺序"></a>3. require的加载顺序</h5><p><strong>如果有多个模块的引入，那么加载顺序是什么？</strong></p><p>如果出现下面模块的引用关系，那么加载顺序是什么呢？</p><ul><li>这个其实是一种数据结构：图结构；</li><li>图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）；</li><li>Node采用的是深度优先算法：main -&gt; aaa -&gt; ccc -&gt; ddd -&gt; eee -&gt;bbb</li></ul><p>多个模块的引入关系：</p><img src="/images/webmodule/multiMoudlesinclude.jpg" alt="multiMoudlesinclude" style="zoom:80%;" /><h3 id="2-3-Node的源码解析"><a href="#2-3-Node的源码解析" class="headerlink" title="2.3 Node的源码解析"></a>2.3 Node的源码解析</h3><p>Module类</p><img src="/images/webmodule/moduleclssource.jpg" alt="图片" style="zoom:80%;" /><p>Module.prototype.require函数</p><img src="/images/webmodule/requiremethodsource.jpg" alt="图片" style="zoom:80%;" /><p>Module._load函数</p><img src="/images/webmodule/loadmethodsource.jpg" alt="图片" style="zoom:80%;" /><h2 id="三、ES6-Module"><a href="#三、ES6-Module" class="headerlink" title="三、ES6 Module"></a>三、ES6 Module</h2><h3 id="4-1-认识ES6-Module"><a href="#4-1-认识ES6-Module" class="headerlink" title="4.1 认识ES6 Module"></a>4.1 认识ES6 Module</h3><h4 id="4-1-1-ES6-Module的优势"><a href="#4-1-1-ES6-Module的优势" class="headerlink" title="4.1.1 ES6 Module的优势"></a>4.1.1 ES6 Module的优势</h4><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西，导致完全没办法在编译时做“静态优化”。</p><p>由于 ES6 模块是编译时加载：</p><ul><li><p>可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高</p></li><li><p>使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p></li></ul><p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p><ul><li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li><li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li><li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li></ul><h4 id="4-1-2-自动启动严格模式"><a href="#4-1-2-自动启动严格模式" class="headerlink" title="4.1.2 自动启动严格模式"></a>4.1.2 自动启动严格模式</h4><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><ul><li>其中，尤其需要注意<code>this</code>的限制。<font color=red>ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code></font>。</li><li>参考链接：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式—MDN</a></li><li><a href="https://tenloy.github.io/pnote/web_note/05-JS%E9%AB%98%E7%BA%A7/Sources/3.6_ES5%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html">严格模式—阮一峰</a></li></ul></li></ul><h4 id="4-1-3-浏览器中加载ES6-Module"><a href="#4-1-3-浏览器中加载ES6-Module" class="headerlink" title="4.1.3 浏览器中加载ES6 Module"></a>4.1.3 浏览器中加载ES6 Module</h4><h5 id="1-加载普通js文件"><a href="#1-加载普通js文件" class="headerlink" title="1. 加载普通js文件"></a>1. 加载普通js文件</h5><p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面内嵌的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="javascript"> <span class="comment">// code </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span><span class="javascript"> <span class="comment">//code... </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p></li><li><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载。</p></li></ul><p>下面就是两种异步加载的语法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p><p><code>defer</code>与<code>async</code>的区别是：</p><ul><li><code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；</li><li><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li><li>一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。</li><li>另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</li></ul><h5 id="2-加载ES6-Module"><a href="#2-加载ES6-Module" class="headerlink" title="2. 加载ES6 Module"></a>2. 加载ES6 Module</h5><p>浏览器内嵌、外链 ES6 模块代码，也使用<code>&lt;script&gt;</code>标签，但是都要加入<code>type=&quot;module&quot;</code>属性。</p><p><code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 等同于下面代码。如果网页有多个 &lt;script type=&quot;module&quot;&gt;，它们会按照在页面出现的顺序依次执行。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">&lt;script&gt;标签的async属性也可以打开：</span></span><br><span class="line"><span class="comment">这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。 </span></span><br><span class="line"><span class="comment">同样的：一旦使用了此属性，&lt;script type=&quot;module&quot;&gt;就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&quot;./utils.js&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li><li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul><p>下面是一个示例模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;https://example.com/js/utils.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="built_in">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-4-本地浏览的报错"><a href="#4-1-4-本地浏览的报错" class="headerlink" title="4.1.4 本地浏览的报错"></a>4.1.4 本地浏览的报错</h4><p>代码结构如下（个人习惯）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">└── modules</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><p>index.html中引入两个js文件作为模块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./modules/foo.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果直接在浏览器中运行代码，会报如下错误：</p><img src="/images/webmodule/modulerunerror.jpg" alt="图片" style="zoom:80%;" /><p>这个在MDN上面有给出解释：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules</a></li><li>你需要注意本地测试 — 如果你通过本地加载Html 文件 (比如一个 <code>file://</code> 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。</li><li>你需要通过一个服务器来测试。</li></ul><p>我这里使用的VSCode，VSCode中有一个插件：Live Server</p><ul><li>通过插件运行，可以将我们的代码运行在一个本地服务中；</li></ul><img src="/images/webmodule/liveserver.jpg" alt="图片" style="zoom:80%;" /><h3 id="4-2-ES6-Module的语法"><a href="#4-2-ES6-Module的语法" class="headerlink" title="4.2 ES6 Module的语法"></a>4.2 ES6 Module的语法</h3><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>：</p><ul><li><code>export</code>命令用于规定模块的对外接口</li><li><code>import</code>命令用于输入其他模块提供的功能。</li></ul><h4 id="4-2-1-模块与CommonJS模块的区别"><a href="#4-2-1-模块与CommonJS模块的区别" class="headerlink" title="4.2.1 模块与CommonJS模块的区别"></a>4.2.1 模块与CommonJS模块的区别</h4><h5 id="1-相同点"><a href="#1-相同点" class="headerlink" title="1. 相同点"></a>1. 相同点</h5><p>与CommonJS的相同点：一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。</p><h5 id="2-导出的不同"><a href="#2-导出的不同" class="headerlink" title="2. 导出的不同"></a>2. 导出的不同</h5><p><strong>CommonJS通过module.exports导出的是一个对象，是<code>module.exports</code>属性浅拷贝后导出：</strong></p><ul><li><p>该对象只有在脚本运行完才会生成。</p></li><li><p>导出的是一个对象意味着可以将这个对象的引用在导入模块中赋值给其他变量；但是最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改；</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">count</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    obj.count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">  obj: obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter, mod.obj.count); <span class="comment">// 3  3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter, mod.obj.count); <span class="comment">// 3  4</span></span><br></pre></td></tr></table></figure><p><strong>ES Module通过export导出的不是对象，是一个个导出变量/函数/类本身的引用：</strong></p><p>说法1：</p><ul><li>它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li><li>换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。(由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错)</li><li>所以，<code>import</code>命令叫做“连接” binding 其实更合适。</li></ul><p>说法2：</p><ul><li><p>export在导出一个变量时，js引擎会解析这个语法，并且创建<strong>模块环境记录</strong>（module environment record）；</p></li><li><p><strong>模块环境记录</strong>会和变量进行 <code>绑定</code>（binding），并且这个绑定是实时的；</p></li><li><p>而在导入的地方，我们是可以实时的获取到绑定的最新值的；</p></li></ul><p><strong>export和import绑定的过程：</strong></p><img src="/images/webmodule/bindingProcedure.jpg" alt="图片" style="zoom:70%;" /><p>还是举上面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p><h5 id="3-导入的不同"><a href="#3-导入的不同" class="headerlink" title="3. 导入的不同"></a>3. 导入的不同</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码实质会整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码实质只是从<code>fs</code>模块加载 3 个方法，其他方法不加载。</p><h4 id="4-2-2-export"><a href="#4-2-2-export" class="headerlink" title="4.2.2 export"></a>4.2.2 export</h4><p>export关键字将一个模块中的变量、函数、类等导出；</p><h5 id="1-export-lt-decl-gt"><a href="#1-export-lt-decl-gt" class="headerlink" title="1. export &lt;decl&gt;"></a>1. <code>export &lt;decl&gt;</code></h5><p>方式一：分别导出。在<strong>语句声明</strong>的前面直接加上export关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> message = <span class="string">&quot;my name is why&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export需要指定对外暴露的接口，所以不能直接输出一个值</span></span><br><span class="line"><span class="comment">// export 40; //error</span></span><br></pre></td></tr></table></figure><h5 id="2-export"><a href="#2-export" class="headerlink" title="2. export {}"></a>2. <code>export &#123;&#125;</code></h5><p>方式二：统一导出。将所有需要导出的标识符，放到export后面的 <code>&#123;&#125;</code>中。它与上一种写法是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些数据。</p><ul><li>注意：这里的 <code>&#123;&#125;</code>里面不是ES6的对象字面量的增强写法，<code>&#123;&#125;</code>也不是表示一个对象的；</li><li>所以：<code>export &#123;name: name&#125;</code>，是错误的写法；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-export-lt-gt-as-lt-gt"><a href="#3-export-lt-gt-as-lt-gt" class="headerlink" title="3. export {&lt;&gt; as &lt;&gt;}"></a>3. <code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code></h5><p>方式三：通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字在导出时给<code>标识符</code>起一个别名：<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name <span class="keyword">as</span> fName,</span><br><span class="line">  age <span class="keyword">as</span> fAge,</span><br><span class="line">  sayHello <span class="keyword">as</span> fSayHello1,</span><br><span class="line">  sayHello <span class="keyword">as</span> fSayHello2, <span class="comment">// 重命名后，sayHello可以用不同的名字输出两次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-export导出的是标识符的地址"><a href="#4-export导出的是标识符的地址" class="headerlink" title="4. export导出的是标识符的地址"></a>4. export导出的是标识符的地址</h5><p><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> foo = <span class="string">&#x27;baz&#x27;</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p><p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。</p><h5 id="5-export导出同一个实例"><a href="#5-export导出同一个实例" class="headerlink" title="5. export导出同一个实例"></a>5. export导出同一个实例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br></pre></td></tr></table></figure><p>不同的模块中，加载这个模块，得到的都是同一个实例。对c修改，其他模块导入的数据也会改变</p><h5 id="6-export书写位置"><a href="#6-export书写位置" class="headerlink" title="6. export书写位置"></a>6. export书写位置</h5><p><code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&#x27;bar&#x27;</span> <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><h5 id="7-export书写次数"><a href="#7-export书写次数" class="headerlink" title="7. export书写次数"></a>7. export书写次数</h5><p>一个模块中：<code>export &lt;decl&gt;</code>、<code>export &#123;&#125;</code>、<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code>都是可以出现<code>0-n</code>次的</p><h4 id="4-2-3-import"><a href="#4-2-3-import" class="headerlink" title="4.2.3 import"></a>4.2.3 import</h4><p>import关键字负责从另外一个模块中导入内容。</p><p><strong><code>import</code>语句会执行所加载的模块。如果同一个模块被加载多次，那么模块里的代码只执行一次。</strong></p><p><strong>导入内容的方式也有多种：</strong></p><h5 id="1-import-from-39-39"><a href="#1-import-from-39-39" class="headerlink" title="1. import {} from &#39;&#39;"></a>1. <code>import &#123;&#125; from &#39;&#39;</code></h5><p>方式一：选择导入。<code>import &#123;标识符列表&#125; from &#39;模块&#39;</code>；</p><p>注意：</p><ul><li>大括号里面的变量名，必须与被导入模块对外接口的名称相同。</li><li>这里的<code>&#123;&#125;</code>也不是一个对象，里面只是存放导入的标识符列表内容；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line">sayHello(<span class="string">&quot;Kobe&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; age &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>name</code>和<code>age</code>在两个语句中加载，但是它们对应的是同一个<code>foo.js</code>模块。也就是说，<code>import</code>语句是 Singleton 模式。</p><h5 id="1-import-39-39-的含义"><a href="#1-import-39-39-的含义" class="headerlink" title="1. import &#39;&#39;的含义"></a>1. <code>import &#39;&#39;</code>的含义</h5><p><code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>; </span><br></pre></td></tr></table></figure><p>上面代码仅仅执行<code>lodash</code>模块，但是不导入任何值。</p><p>同样的，如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>; <span class="comment">// 代码加载了两次`lodash`，但是只会执行一次。</span></span><br></pre></td></tr></table></figure><h5 id="2-import-lt-gt-as-lt-gt-from-39-39"><a href="#2-import-lt-gt-as-lt-gt-from-39-39" class="headerlink" title="2.  import {&lt;&gt; as &lt;&gt;} from &#39;&#39;"></a>2.  <code>import &#123;&lt;&gt; as &lt;&gt;&#125; from &#39;&#39;</code></h5><p>方式二：导入时给标识符起别名： <code>import &#123;&lt;&gt; as &lt;&gt;&#125; from &#39;&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> wName, age <span class="keyword">as</span> wAge, sayHello <span class="keyword">as</span> wSayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="3-import-as-lt-gt-from-39-39"><a href="#3-import-as-lt-gt-from-39-39" class="headerlink" title="3.  import * as &lt;&gt; from &#39;&#39;"></a>3.  <code>import * as &lt;&gt; from &#39;&#39;</code></h5><p>方式三：整体导入。将模块功能放到一个模块功能对象(a module object)上，用<code>*</code>指定： <code>import * as &lt;&gt; from &#39;&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.name);</span><br><span class="line"><span class="built_in">console</span>.log(foo.age);</span><br><span class="line">foo.sayHello(<span class="string">&quot;Kobe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.n = &quot;add&quot;; // Type Error: object is not extensible</span></span><br><span class="line"><span class="comment">// foo.f = function () &#123;&#125;; </span></span><br></pre></td></tr></table></figure><p>注意，模块整体加载所在的那个对象，应该是可以静态分析的，所以不允许运行时改变。上面的写法是不允许的。</p><h5 id="4-import导入为只读"><a href="#4-import导入为只读" class="headerlink" title="4. import导入为只读"></a>4. import导入为只读</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line">name = <span class="string">&quot;mod&quot;</span>; <span class="comment">// Syntax Error : &#x27;name&#x27; is read-only;</span></span><br></pre></td></tr></table></figure><p><code>name</code>是只读的。但是，如果<code>name</code>是一个对象，改写其属性是允许的，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</p><h5 id="5-import-from后的路径"><a href="#5-import-from后的路径" class="headerlink" title="5. import from后的路径"></a>5. import from后的路径</h5><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径，<font color=red>后缀名不能省略</font>。</p><p>如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p><h5 id="6-import命令的提升"><a href="#6-import命令的提升" class="headerlink" title="6. import命令的提升"></a>6. import命令的提升</h5><p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p><p>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.symbol&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.promise&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;React&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="7-import中不能使用表达式和变量"><a href="#7-import中不能使用表达式和变量" class="headerlink" title="7. import中不能使用表达式和变量"></a>7. import中不能使用表达式和变量</h5><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">&#x27;f&#x27;</span> + <span class="string">&#x27;oo&#x27;</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module1&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module2&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p><h4 id="4-2-4-export-default"><a href="#4-2-4-export-default" class="headerlink" title="4.2.4 export default"></a>4.2.4 export default</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>前面我们学习的导出功能都是有名字的导出（named exports）：</p><ul><li>在导出export时指定了名字；</li><li>在导入import时需要知道具体的名字；</li></ul><p>还有一种导出叫做默认导出（default export）</p><ul><li>默认导出export时可以不需要指定名字；</li><li>在导入时不需要使用 <code>&#123;&#125;</code>，并且可以自己来指定名字；</li><li>它也方便我们和现有的CommonJS等规范相互操作；</li></ul><h5 id="2-导出与导入格式"><a href="#2-导出与导入格式" class="headerlink" title="2. 导出与导入格式"></a>2. 导出与导入格式</h5><p>也是可以导出变量、函数、类的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出格式1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出格式2：用在非匿名函数前</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出格式3：用在函数变量前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;sub&#x27;</span>); &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sub;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数名`sub`，在模块外部是无效的。加载的时候，视同匿名函数加载。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式1：常用及推荐</span></span><br><span class="line"><span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式2</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.default.sub(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式3</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.sub(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><h5 id="3-export-default的本质"><a href="#3-export-default的本质" class="headerlink" title="3. export default的本质"></a>3. export default的本质</h5><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;  <span class="comment">// 等同于 export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;modules&#x27;</span>; <span class="comment">// 等同于 import foo from &#x27;modules&#x27;;</span></span><br></pre></td></tr></table></figure><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 含义是将变量`a`的值赋给变量`default`。所以，最后一种写法会报错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="comment">// export default var a = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样地，因为`export default`命令的本质是将后面的值，赋给`default`变量，所以可以直接将一个值写在`export default`之后。</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// export 42; // export后面得跟声明，或者&#123;标识符&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-export-default与export"><a href="#4-export-default与export" class="headerlink" title="4. export default与export"></a>4. export default与export</h5><p>注意：在一个模块中，export default是可以与export同时使用的：</p><ul><li>export default用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。</li><li>export是没有限制的。<code>export &lt;decl&gt;</code>、<code>export &#123;&#125;</code>、<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code>都是可以出现<code>0-n</code>次的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">&quot;module1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 在一条`import`语句中，同时输入默认接口和其他接口</span></span><br><span class="line"><span class="keyword">import</span> m, &#123;name&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">//m.sub、name</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">// m.default.sub、m.name</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m, name&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">// m.sub、name</span></span><br></pre></td></tr></table></figure><h4 id="4-2-5-export和import结合"><a href="#4-2-5-export和import结合" class="headerlink" title="4.2.5 export和import结合"></a>4.2.5 export和import结合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js 导出一个sum函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.js做一个中转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js直接从foo中导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><p>如果从一个模块中导入的内容，我们希望再直接导出出去，这个时候可以使用export和import的结合，写成一行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js 导入，但是只是做一个中转</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口改名</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> barSum &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>; <span class="comment">// 甚至在foo.js中导出时，我们可以变化它的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入和导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 相当于实现了模块之间的继承。注意，`export *`命令会忽略后面模块的`default`接口。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名接口改为默认接口的写法如下：</span></span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口也可以改名为具名接口：</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> es6 &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2020 之前，有一种`import`语句，没有对应的复合写法。[ES2020](https://github.com/tc39/proposal-export-ns-from)补上了这个写法。</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;ns&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是，写成一行以后，`sum`实际上并没有被导入当前模块，只是相当于对外转发了这个接口，导致当前模块不能直接使用`sum`。</span></span><br></pre></td></tr></table></figure><p>为什么要这样做呢？</p><ul><li>在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中；</li><li>这样方便指定统一的接口规范，也方便阅读；</li><li>这个时候，我们就可以使用export和import结合使用；</li></ul><h4 id="4-2-6-import"><a href="#4-2-6-import" class="headerlink" title="4.2.6 import()"></a>4.2.6 import()</h4><h5 id="1-import-的背景"><a href="#1-import-的背景" class="headerlink" title="1. import()的背景"></a>1. import()的背景</h5><p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行。所以，<code>import</code>和<code>export</code>命令只能在模块的顶层，是不可以在其放到逻辑代码中（比如在<code>if</code>代码块之中，或在函数之中）的。下面的代码会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。</p><p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;./&#x27;</span> + fileName;</span><br><span class="line"><span class="keyword">const</span> myModual = <span class="built_in">require</span>(path); </span><br><span class="line"><span class="comment">// 上面的语句就是动态加载，`require`到底加载哪一个模块，只有运行时才知道。`import`命令做不到这一点。</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/tc39/proposal-dynamic-import">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(specifier)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p><h5 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h5><p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;<span class="comment">// 加载模块成功以后，这个模块会作为一个对象，当作`then`方法的参数.</span></span><br><span class="line"><span class="comment">//.then(&#123;export1, export2&#125; =&gt; &#123;     // 可以使用对象解构赋值的语法，获取输出接口。</span></span><br><span class="line"><span class="comment">//.then(&#123;default: theDefault&#125; =&gt; &#123;  // 如果是default，那么需要解构重命名</span></span><br><span class="line">    </span><br><span class="line">  <span class="built_in">module</span>.loadPageInto(main); <span class="comment">// module.default来使用默认导出</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    main.textContent = err.message;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想同时加载多个模块，可以采用下面的写法。</span></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module1.js&#x27;</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module2.js&#x27;</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module3.js&#x27;</span>),</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</span><br><span class="line">   ···</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是Promise对象，所以也可以用在async函数中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [module1, module2, module3] =</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module1.js&#x27;</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module2.js&#x27;</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module3.js&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p><h5 id="3-适用场合"><a href="#3-适用场合" class="headerlink" title="3. 适用场合"></a>3. 适用场合</h5><ul><li><p>按需加载。</p><p><code>import()</code>可以在需要的时候，再加载某个模块。比如放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p></li><li><p>条件加载</p><p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p></li><li><p>动态的模块路径</p><p><code>import()</code>允许模块路径动态生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(f()).then(...);  <span class="comment">// 根据函数`f`的返回结果，加载不同的模块。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-7-应用-公共头文件"><a href="#4-2-7-应用-公共头文件" class="headerlink" title="4.2.7 应用: 公共头文件"></a>4.2.7 应用: 公共头文件</h4><p>介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">  url: <span class="string">&#x27;http://my.couchdbserver.local:5984&#x27;</span>,</span><br><span class="line">  admin_username: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">  admin_password: <span class="string">&#x27;admin password&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constants/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> users = [<span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;staff&#x27;</span>, <span class="string">&#x27;ceo&#x27;</span>, <span class="string">&#x27;chief&#x27;</span>, <span class="string">&#x27;moderator&#x27;</span>];</span><br></pre></td></tr></table></figure><p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/index.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">&#x27;./db&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;users&#125; <span class="keyword">from</span> <span class="string">&#x27;./users&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用的时候，直接加载<code>index.js</code>就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;db, users&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants/index.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-2-8-与CommonJS模块化的差异"><a href="#4-2-8-与CommonJS模块化的差异" class="headerlink" title="4.2.8 与CommonJS模块化的差异"></a>4.2.8 与CommonJS模块化的差异</h4><ul><li><p>CommonJS 模块输出的是一个值的拷贝(module.exports的浅拷贝)，ES6 模块输出的是值的引用。</p></li><li><p>CommonJS 模块是运行时加载，ES6 模块是编译(解析)时加载。</p><ul><li><p>运行时加载意味着是js引擎在 执行js代码的过程中 加载模块；所以require可以与变量、表达式等运行时代码结合使用</p></li><li><p>编译时（解析）时加载，意味着import不能和运行时相关的内容放在一起使用：</p><ul><li>比如from后面的路径需要动态获取；</li><li>比如不能将import放到if等语句的代码块中；</li><li>所以我们有时候也称ES Module是静态解析的，而不是动态或者运行时解析的；</li></ul></li></ul></li><li><p>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</p><ul><li>同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行；</li><li>异步的意味着：不会阻塞主线程继续执行；<ul><li>JS引擎在遇到<code>import</code>时会去获取这个js文件的过程是异步的</li><li>设置了 <code>type=module</code> 的script标签，相当于加上了 <code>async</code> 属性；</li><li>如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行；</li></ul></li></ul></li></ul><p>CommonJS代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;main代码执行&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="comment">// 同步加载foo文件，并且执行一次内部的代码</span></span><br><span class="line">  <span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;if语句继续执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES Module代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个js文件的代码不会被阻塞执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、CommonJS模块与ES6模块的混编"><a href="#四、CommonJS模块与ES6模块的混编" class="headerlink" title="四、CommonJS模块与ES6模块的混编"></a>四、CommonJS模块与ES6模块的混编</h2><h3 id="4-3-CommonJS模块加载ES6模块"><a href="#4-3-CommonJS模块加载ES6模块" class="headerlink" title="4.3 CommonJS模块加载ES6模块"></a>4.3 CommonJS模块加载ES6模块</h3><p>通常情况下，CommonJS不能加载ES Module</p><ul><li>因为CommonJS是同步加载的，但是ES Module必须经过静态分析等，无法在这个时候执行JavaScript代码；</li><li>但是这个并非绝对的，某些平台在实现的时候可以对代码进行针对性的解析，也可能会支持；</li></ul><p>可以使用<code>import()</code>这个方法加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-app.mjs&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>上面代码可以在 CommonJS 模块中运行。</p><p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p><h3 id="4-2-ES6模块加载CommonJS模块"><a href="#4-2-ES6模块加载CommonJS模块" class="headerlink" title="4.2 ES6模块加载CommonJS模块"></a>4.2 ES6模块加载CommonJS模块</h3><p>多数情况下，ES Module可以加载CommonJS，但是只能整体加载，不能只加载单一的输出项。</p><ul><li>ES Module在加载CommonJS时，会将其module.exports导出的内容作为default导出方式来使用；</li><li>这个依然需要看具体的实现，比如webpack中是支持的、Node最新的Current（v14.13.1）版本也是支持的；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">const</span> address = <span class="string">&#x27;foo的address&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.address);</span><br></pre></td></tr></table></figure><p>还有一种变通的加载方法，就是使用 Node.js 内置的<code>module.createRequire()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cjs.cjs</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">&#x27;cjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// esm.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = createRequire(<span class="keyword">import</span>.meta.url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cjs = <span class="built_in">require</span>(<span class="string">&#x27;./cjs.cjs&#x27;</span>);</span><br><span class="line">cjs === <span class="string">&#x27;cjs&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。</p><h3 id="4-3-使模块同时支持两种模块化导入"><a href="#4-3-使模块同时支持两种模块化导入" class="headerlink" title="4.3 使模块同时支持两种模块化导入"></a>4.3 使模块同时支持两种模块化导入</h3><p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p><p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p><p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">&#x27;../index.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = cjsModule.foo;</span><br></pre></td></tr></table></figure><p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p><p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>&#123; type: &quot;module&quot; &#125;</code>。</p><p>如果是Node.js中，还有一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;exports&quot;</span>：&#123;</span><br><span class="line">  <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./index.js&quot;</span>，</span><br><span class="line">  <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./esm/wrapper.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p><h2 id="五、Node-js开发中的模块化"><a href="#五、Node-js开发中的模块化" class="headerlink" title="五、Node.js开发中的模块化"></a>五、Node.js开发中的模块化</h2><h3 id="5-1-Node中支持-ES6-Module"><a href="#5-1-Node中支持-ES6-Module" class="headerlink" title="5.1 Node中支持 ES6 Module"></a>5.1 Node中支持 ES6 Module</h3><p>JavaScript 现在常用的有两种模块。</p><ul><li>ES6 模块，简称 ESM；</li><li>CommonJS 模块，简称 CJS。</li></ul><p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p><p>从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持，需要进行以下操作：</p><ul><li>方式一：文件以 <code>.mjs</code> 结尾，表示使用的是ES Module；</li><li>方式二：在package.json中配置字段 <code>type: module</code>，一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。<ul><li>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。</li></ul></li><li>如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</li></ul><p>在之前的版本（比如v12.19.0）中，也是可以正常运行的，但是会报一个警告：</p><img src="/images/webmodule/lstwarning.jpg" alt="图片" style="zoom:80%;" /><p>Node.js 遇到 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p><p>总结为一句话：</p><ul><li><code>.mjs</code>文件总是以 ES6 模块加载</li><li><code>.cjs</code>文件总是以 CommonJS 模块加载</li><li><code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。</li></ul><p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p><h3 id="5-2-Node-js包模块的入口文件设置"><a href="#5-2-Node-js包模块的入口文件设置" class="headerlink" title="5.2 Node.js包模块的入口文件设置"></a>5.2 Node.js包模块的入口文件设置</h3><h4 id="5-2-1-package-json-的-main-字段"><a href="#5-2-1-package-json-的-main-字段" class="headerlink" title="5.2.1 package.json 的 main 字段"></a>5.2.1 package.json 的 main 字段</h4><p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，可以只使用<code>main</code>字段，指定模块加载的入口文件。</p><h5 id="举例：指定入口文件，格式为ESM"><a href="#举例：指定入口文件，格式为ESM" class="headerlink" title="举例：指定入口文件，格式为ESM"></a>举例：指定入口文件，格式为ESM</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有<code>type</code>字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p><p>然后，<code>import</code>命令就可以加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./my-app.mjs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;es-module-package&#x27;</span>;</span><br><span class="line"><span class="comment">// 实际加载的是 ./node_modules/es-module-package/src/index.js</span></span><br></pre></td></tr></table></figure><p>上面代码中，运行该脚本以后，Node.js 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p><p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p><h4 id="5-2-2-package-json-的-exports-字段"><a href="#5-2-2-package-json-的-exports-字段" class="headerlink" title="5.2.2 package.json 的 exports 字段"></a>5.2.2 package.json 的 exports 字段</h4><p><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</p><h5 id="1-给脚本或子目录起别名"><a href="#1-给脚本或子目录起别名" class="headerlink" title="1. 给脚本或子目录起别名"></a>1. 给脚本或子目录起别名</h5><p><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./submodule&quot;</span>: <span class="string">&quot;./src/submodule.js&quot;</span>,  <span class="comment">//给脚本文件 src/submodule.js 起别名</span></span><br><span class="line">    <span class="string">&quot;./features/&quot;</span>: <span class="string">&quot;./src/features/&quot;</span>，<span class="comment">// 给子目录 ./src/features/ 起别名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过别名加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/submodule&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/submodule.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feature <span class="keyword">from</span> <span class="string">&#x27;es-module-package/features/x.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/features/x.js</span></span><br></pre></td></tr></table></figure><p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/private-module.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;./node_modules/es-module-package/private-module.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="2-main-的别名"><a href="#2-main-的别名" class="headerlink" title="2. main 的别名."></a>2. main 的别名<code>.</code></h5><p><code>exports</code>字段的别名如果是<code>.</code> 就代表了是模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./main-legacy.cjs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main-modern.cjs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p><h5 id="3-条件加载"><a href="#3-条件加载" class="headerlink" title="3. 条件加载"></a>3. 条件加载</h5><p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开<code>--experimental-conditional-exports</code>标志。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>, <span class="comment">// 别名`.`的`require`条件指定`require()`命令的入口文件（即 CommonJS 的入口）</span></span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span> <span class="comment">// 别名`.`的`default`条件指定其他情况的入口（即 ES6 的入口）。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法可以简写如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果同时还有其他别名，就不能采用简写，否则或报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./feature&quot;</span>: <span class="string">&quot;./lib/feature.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-Node-js原生模块完全支持ES6-Module"><a href="#5-3-Node-js原生模块完全支持ES6-Module" class="headerlink" title="5.3 Node.js原生模块完全支持ES6 Module"></a>5.3 Node.js原生模块完全支持ES6 Module</h3><p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体加载</span></span><br><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">&#x27;events&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定的输出项</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line">readFile(<span class="string">&#x27;./foo.txt&#x27;</span>, <span class="function">(<span class="params">err, source</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-4-加载路径"><a href="#5-4-加载路径" class="headerlink" title="5.4 加载路径"></a>5.4 加载路径</h3><p>ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 模块中将报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span>;</span><br></pre></td></tr></table></figure><p>为了与浏览器的<code>import</code>加载规则相同，Node.js 的<code>.mjs</code>文件支持 URL 路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo.mjs?query=1&#x27;</span>; <span class="comment">// 加载 ./foo 传入参数 ?query=1</span></span><br></pre></td></tr></table></figure><p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p><p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议）和<code>data:</code>协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以<code>/</code>或<code>//</code>开头的路径）。</p><h3 id="5-5-内部变量"><a href="#5-5-内部变量" class="headerlink" title="5.5 内部变量"></a>5.5 内部变量</h3><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p><p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p><p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p><ul><li><code>arguments</code></li><li><code>require</code></li><li><code>module</code></li><li><code>exports</code></li><li><code>__filename</code></li><li><code>__dirname</code></li></ul><h2 id="六、循环加载"><a href="#六、循环加载" class="headerlink" title="六、循环加载"></a>六、循环加载</h2><p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p><p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p><p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p><h3 id="6-1-CommonJS-模块的循环加载"><a href="#6-1-CommonJS-模块的循环加载" class="headerlink" title="6.1 CommonJS 模块的循环加载"></a>6.1 CommonJS 模块的循环加载</h3><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p><p>让我们来看，Node <a href="https://nodejs.org/api/modules.html#modules_cycles">官方文档</a>里面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;   <span class="comment">// 先输出一个`done`变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>); <span class="comment">// 然后加载另一个脚本文件b.js。注意，此时代码就停在这里，等待`b.js`执行完毕，再往下执行。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.done); <span class="comment">// b.js执行完毕，返回来a.js接着往下执行，直到执行完毕。</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.js 执行完毕&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 执行到这一行，会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。</span></span><br><span class="line"><span class="comment"> 此时：a.js已经执行的部分，只有一行：exports.done = false; 即对于b.js来说，它从a.js只输入一个变量done=false 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.done);</span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.js 执行完毕&#x27;</span>);</span><br><span class="line"><span class="comment">// b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。</span></span><br></pre></td></tr></table></figure><p>我们写一个脚本main.js，验证这个过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.done, b.done);</span><br></pre></td></tr></table></figure><p>执行<code>main.js</code>，运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line">在 b.js 之中，a.done = <span class="literal">false</span></span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 之中，b.done = <span class="literal">true</span></span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done=<span class="literal">true</span>, b.done=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面的代码证明了两件事：</p><ol><li>在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。</li><li><code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行<code>exports.done = true;</code></li></ol><p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</p><p>另外，<strong>由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 安全的写法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>).foo; <span class="comment">// 危险的写法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.good = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.foo(<span class="string">&#x27;good&#x27;</span>, arg); <span class="comment">// 使用的是 a.foo 的最新值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.bad = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(<span class="string">&#x27;bad&#x27;</span>, arg); <span class="comment">// 使用的是一个部分加载时的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p><h3 id="6-2-ES6-模块的循环加载"><a href="#6-2-ES6-模块的循环加载" class="headerlink" title="6.2 ES6 模块的循环加载"></a>6.2 ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p><p>请看下面这个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p><p>让我们一行行来看，ES6 循环加载是怎么处理的：</p><ul><li>首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。</li><li>接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。</li><li>执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</li></ul><p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span> &#125;   <span class="comment">// const foo = () =&gt; &#x27;foo&#x27;; 仍然会执行报错。函数表达式，就不具有提升作用</span></span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;bar&#125;;</span><br></pre></td></tr></table></figure><p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">foo</span><br><span class="line">a.mjs</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>这是因为<strong>函数具有提升作用</strong>，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。</p><p>这也意味着，<strong>如果把函数<code>foo</code>改写成函数表达式，也会报错。</strong></p><h3 id="6-3-代码示例"><a href="#6-3-代码示例" class="headerlink" title="6.3 代码示例"></a>6.3 代码示例</h3><p>我们再来看 ES6 模块加载器<a href="https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md">SystemJS</a>给出的一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">&#x27;./odd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">&#x27;./even&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p><p>运行上面这段代码，结果如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node</span><br><span class="line">&gt; <span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./even.js&#x27;</span>;</span><br><span class="line">&gt; m.even(<span class="number">10</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; m.even(<span class="number">20</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。</p><p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">&#x27;./odd&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.counter = counter;</span><br><span class="line"><span class="built_in">exports</span>.even = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">&#x27;./even&#x27;</span>).even;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var m = require(<span class="string">&#x27;./even&#x27;</span>);</span><br><span class="line">&gt; m.even(10)</span><br><span class="line">TypeError: even is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><h2 id="七、了解：AMD和CMD规范"><a href="#七、了解：AMD和CMD规范" class="headerlink" title="七、了解：AMD和CMD规范"></a>七、了解：AMD和CMD规范</h2><h3 id="7-1-CommonJS规范缺点"><a href="#7-1-CommonJS规范缺点" class="headerlink" title="7.1. CommonJS规范缺点"></a>7.1. CommonJS规范缺点</h3><p>CommonJS加载模块是同步的：</p><ul><li>同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行；</li><li>这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快；</li></ul><p>如果将它应用于浏览器呢？</p><ul><li>浏览器加载js文件需要先从服务器将文件下载下来，之后在加载运行；</li><li>那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作；</li></ul><p>所以在浏览器中，我们通常不使用CommonJS规范：</p><ul><li>当然在webpack中使用CommonJS是另外一回事；</li><li>因为它会将我们的代码转成浏览器可以直接执行的代码；</li></ul><p>在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD：</p><ul><li>但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换；</li><li>AMD和CMD已经使用非常少了，所以这里我们进行简单的演练；</li></ul><h3 id="7-2-AMD规范"><a href="#7-2-AMD规范" class="headerlink" title="7.2. AMD规范"></a>7.2. AMD规范</h3><h4 id="7-2-1-AMD与Require-js"><a href="#7-2-1-AMD与Require-js" class="headerlink" title="7.2.1 AMD与Require.js"></a>7.2.1 AMD与Require.js</h4><p>AMD主要是应用于浏览器的一种模块化规范：</p><ul><li>AMD是Asynchronous Module Definition（异步模块定义）的缩写；</li><li>它采用的是异步加载模块；</li><li>事实上AMD的规范还要早于CommonJS，但是CommonJS目前依然在被使用，而AMD使用的较少了；</li></ul><p>我们提到过，规范只是定义代码的应该如何去编写，只有有了具体的实现才能被应用：</p><ul><li>AMD实现的比较常用的库是require.js和curl.js；</li></ul><h4 id="7-2-2-Require-js的使用"><a href="#7-2-2-Require-js的使用" class="headerlink" title="7.2.2 Require.js的使用"></a>7.2.2 Require.js的使用</h4><p>第一步：下载require.js</p><ul><li>下载地址：<a href="https://github.com/requirejs/requirejs">https://github.com/requirejs/requirejs</a></li><li>找到其中的require.js文件； </li></ul><p>第二步：定义HTML的script标签引入require.js和定义入口文件：</p><ul><li>data-main属性的作用是在加载完src的文件后会加载执行该文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/require.js&quot;</span> <span class="attr">data-main</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三步：编写如下目录和代码(<strong>个人习惯</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">├── lib</span><br><span class="line">│   └── require.js</span><br><span class="line">└── modules</span><br><span class="line">    ├── bar.js</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">      foo: <span class="string">&#x27;./modules/foo&#x27;</span>,</span><br><span class="line">      bar: <span class="string">&#x27;./modules/bar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 开始加载执行foo模块的代码</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;foo&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>modules/bar.js</p><ul><li>如果一个模块不依赖其他，那么直接使用define(function)即可</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;coderwhy&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age, </span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>modules/foo.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">&#x27;bar&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar.name);</span><br><span class="line">  <span class="built_in">console</span>.log(bar.age);</span><br><span class="line">  bar.sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-3-CMD规范"><a href="#7-3-CMD规范" class="headerlink" title="7.3 CMD规范"></a>7.3 CMD规范</h3><h4 id="7-3-1-CMD与SeaJS"><a href="#7-3-1-CMD与SeaJS" class="headerlink" title="7.3.1 CMD与SeaJS"></a>7.3.1 CMD与SeaJS</h4><p>CMD规范也是应用于浏览器的一种模块化规范：</p><ul><li>CMD 是Common Module Definition（通用模块定义）的缩写；</li><li>它也采用了异步加载模块，但是它将CommonJS的优点吸收了过来；</li><li>但是目前CMD使用也非常少了；</li></ul><p>CMD也有自己比较优秀的实现方案：</p><ul><li>SeaJS</li></ul><h4 id="7-3-2-SeaJS的使用"><a href="#7-3-2-SeaJS的使用" class="headerlink" title="7.3.2 SeaJS的使用"></a>7.3.2 SeaJS的使用</h4><h5 id="1-下载SeaJS"><a href="#1-下载SeaJS" class="headerlink" title="1. 下载SeaJS"></a>1. 下载SeaJS</h5><ul><li>下载地址：<a href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li><li>找到dist文件夹下的sea.js</li></ul><h5 id="2-引入sea-js和启动模块"><a href="#2-引入sea-js和启动模块" class="headerlink" title="2. 引入sea.js和启动模块"></a>2. 引入sea.js和启动模块</h5><ul><li><code>seajs</code>是指定主入口文件的，也称为启动模块</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!--在调用 seajs 之前，必须先引入 sea.js 文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  seajs.use(<span class="string">&#x27;./index.js&#x27;</span>);  </span></span><br><span class="line">  /*</span><br><span class="line">   通过 seajs.use() 函数可以启动模块</span><br><span class="line"><span class="javascript">- (<span class="string">&#x27;模块id&#x27;</span> [,callback])加载一个模块，并执行回调函数</span></span><br><span class="line"><span class="javascript">- ([<span class="string">&#x27;模块1&#x27;</span>, <span class="string">&#x27;模块2&#x27;</span>] [,callback])加载多个模块，并执行回调函数</span></span><br><span class="line"><span class="javascript">- callback 参数是可选的。格式为：<span class="function"><span class="keyword">function</span>(<span class="params"> 模块对象 </span>)</span>&#123; 业务代码 &#125;;</span></span><br><span class="line"></span><br><span class="line"> - seajs.use 理论上只用于加载启动，不应该出现在 define 中的模块代码里</span><br><span class="line"><span class="javascript"> - seajs.use 和 DOM ready 事件没有任何关系。要想保证 文档结构加载完毕再执行你的 js 代码，一定要在seajs.use内部通过 <span class="built_in">window</span>.onload 或者 $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span></span><br><span class="line">   */</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-编写如下目录和代码-个人习惯"><a href="#3-编写如下目录和代码-个人习惯" class="headerlink" title="3. 编写如下目录和代码(个人习惯)"></a>3. 编写如下目录和代码(<strong>个人习惯</strong>)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">├── lib</span><br><span class="line">│   └── sea.js</span><br><span class="line">└── modules</span><br><span class="line">    ├── bar.js</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><h5 id="4-定义模块define"><a href="#4-定义模块define" class="headerlink" title="4. 定义模块define"></a>4. 定义模块define</h5><ul><li>在CMD规范中，一个模块就是一个js文件</li></ul><p>module是一个对象，存储了模块的元信息，具体如下：</p><ul><li><p>module.id——模块的ID。</p></li><li><p>module.dependencies——一个数组，存储了此模块依赖的所有模块的ID列表。</p></li><li><p>module.exports——与exports指向同一个对象。</p></li><li><p>module.uri</p></li></ul><p>define 是一个全局函数，用来定义模块：<code>define( factory )</code></p><ul><li>对象<code>&#123;&#125;</code>：这种方式，外部会直接获取到该对象</li><li>字符串<code>&quot;&quot;</code>： 同上</li><li>函数：<code>define(function(require, exports, module)&#123; 模块代码 &#125;);</code>  为了减少出错，定义函数的时候直接把这三个参数写上</li></ul><h5 id="5-导出接口exports和module-exports"><a href="#5-导出接口exports和module-exports" class="headerlink" title="5. 导出接口exports和module.exports"></a>5. 导出接口exports和module.exports</h5><ul><li><p>功能：通过给 exports或module.exports动态的挂载变量、函数或对象，外部会获取到该接口</p></li><li><p>exports 等价于 module.exports。exports能做什么，module.exports就能做什么</p></li><li><p>可以通过多次给exports 挂载属性向外暴露</p></li><li><p>不能直接给 exports 赋值</p></li><li><p>如果想暴露单个变量、函数或对象可以通过直接给 module.exports 赋值 即可</p></li></ul><h5 id="6-依赖模块require"><a href="#6-依赖模块require" class="headerlink" title="6. 依赖模块require"></a>6. 依赖模块require</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 模块标识/模块id</span></span><br><span class="line"><span class="comment">    - 模块标识就是一个`字符串`，用来`标识模块`</span></span><br><span class="line"><span class="comment">    - 模块标识 可以不包含后缀名.js</span></span><br><span class="line"><span class="comment">    - 以 ./或 ../ 开头的相对路径模块，相对于 require 所在模块的路径</span></span><br><span class="line"><span class="comment">    - 不以 ./ 或 ../ 开头的顶级标识，会相对于模块的基础路径解析（配置项中的base）</span></span><br><span class="line"><span class="comment">    - 绝对路径如http://127.0.0.1:8080/js/a.js、/js/a.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">requeire(<span class="string">&#x27;模块id&#x27;</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1.用于根据一个模块id加载/依赖该模块</span></span><br><span class="line"><span class="comment"> 2.参数必须是一个字符串</span></span><br><span class="line"><span class="comment"> 3.该方法会得到 要加载的模块中的 module.exports 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>只能在模块环境define中使用，define(factory)的构造方法第一个参数<strong>必须命名为 require</strong></li><li>不要重命名require函数或者在任何作用域中给 require 重新赋值</li><li>在一个模块系统中，<code>require</code> 加载过的模块会被缓存</li><li>默认 <code>require</code> 是同步加载模块的</li></ul><p><strong>require.async</strong></p><p>SeaJS会在html页面打开时通过静态分析一次性记载所有需要的js文件，如果想要某个js文件在用到时才下载，可以使用require.async：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.async(<span class="string">&#x27;/path/to/module/file&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code of callback...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样只有在用到这个模块时，对应的js文件才会被下载，也就实现了JavaScript代码的按需加载。</p><h5 id="SeaJS高级配置"><a href="#SeaJS高级配置" class="headerlink" title="SeaJS高级配置"></a>SeaJS高级配置</h5><ul><li><strong>alias：别名配置</strong></li><li><strong>paths：路径配置</strong></li><li>vars：变量配置</li><li>map：映射配置</li><li>preload：预加载项</li><li>debug：调试模式</li><li><strong>base：基础路径</strong></li><li>charset：文件编码</li></ul><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./modules/foo&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>bar.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;lilei&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;你好 &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>foo.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(bar.name);</span><br><span class="line">  <span class="built_in">console</span>.log(bar.age);</span><br><span class="line">  bar.sayHello(<span class="string">&quot;韩梅梅&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul><li><p><a href="https://es6.ruanyifeng.com/#docs/module">Module的语法和加载实现 — 阮一峰</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDAzNzkwNA==&mid=2247484285&idx=1&sn=bc37c00b5c58ff42355b1b01ad9b9c0d&chksm=cfe3f082f8947994b5475d365c4460ac0d4b36d6eec68b5dd7c15fc3a0ef1b88f33b776f3f05&scene=178&cur_album_id=1567316742547226629#rd">彻底掌握前端模块化 — codewhy</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、模块化&quot;&gt;&lt;a href=&quot;#一、模块化&quot; class=&quot;headerlink&quot; title=&quot;一、模块化&quot;&gt;&lt;/a&gt;一、模块化&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是模块化&quot;&gt;&lt;a href=&quot;#1-1-什么是模块化&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Web" scheme="https://tenloy.github.io/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>[转]最通俗的 React Fiber(时间分片)</title>
    <link href="https://tenloy.github.io/2021/05/27/09_Fiber/"/>
    <id>https://tenloy.github.io/2021/05/27/09_Fiber/</id>
    <published>2021-05-27T16:51:02.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903975112671239#heading-13">原文链接</a> Fiber 不是一个新的东西，来看一下单处理进程调度</p><h2 id="一、单处理器进程调度"><a href="#一、单处理器进程调度" class="headerlink" title="一、单处理器进程调度"></a>一、单处理器进程调度</h2><img width = "60%" alt="" align=center src="/images/Fiber/16deecc2160c5d19.jpg"/><p>微软 <a href="https://zh.wikipedia.org/zh-cn/DOS"><code>DOS</code></a> 是一个<code>单任务操作系统</code>， 也称为’单工操作系统‘。这种操作系统同一个时间只允许运行一个程序。 <a href="https://www.zhihu.com/people/s.invalid">invalid s</a>在<a href="https://www.zhihu.com/question/319595914/answer/683541635">《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》</a> 的回答中将其称为： ‘<strong>一种压根没有任务调度的“残疾”操作系统</strong>‘.</p><p>在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。</p><p>直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。</p><blockquote><p>注意并发和并行不是同一个概念。</p></blockquote><h3 id="1-1-并发与并行"><a href="#1-1-并发与并行" class="headerlink" title="1.1 并发与并行"></a>1.1 并发与并行</h3><p>现代操作系统都是<strong>多任务操作系统</strong>。进程的调度策略如果按照CPU核心数来划分，可以分为<strong>单处理器调度</strong>和<strong>多处理器调度</strong>。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。</p><p><strong>说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行</strong>。</p><ul><li><p>“龙珠”中的分身术，实质上是一个人，只不过是他运动速度太快，看起来就像分身了。这就是所谓的<strong>并发(Concurrent)</strong>(单处理器)。</p></li><li><p>相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是<strong>并行</strong>(严格地讲这是<code>Master-Slave</code>架构，分身虽然物理存在，但应该没有独立的意志)。</p></li></ul><p>所以说<strong>并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持</strong>。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲<a href="https://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not parallelism</a></p><h3 id="1-2-进程调度策略"><a href="#1-2-进程调度策略" class="headerlink" title="1.2 进程调度策略"></a>1.2 进程调度策略</h3><h4 id="1-2-1-先到先得-First-Come-First-Served-FCFS"><a href="#1-2-1-先到先得-First-Come-First-Served-FCFS" class="headerlink" title="1.2.1 先到先得(First-Come-First-Served, FCFS)"></a>1.2.1 先到先得(First-Come-First-Served, FCFS)</h4><p>这是最简单的调度策略, 简单说就是<strong>没有调度</strong>。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队)。</p><p><code>FCFS</code> 上面 <code>DOS</code> 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。</p><ul><li><p><strong>FCFS 对<code>短进程</code>不利</strong>。 短进程即执行时间非常短的进程。</p><p>举例：可以用饭堂排队来比喻: 在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像<code>长进程</code>一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久…</p></li><li><p><strong>FCFS 对<code>I/O密集</code>不利</strong>。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被选择。 </p><p>举例：ZF部门办业务: 假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平…</p></li></ul><p>所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。</p><h4 id="1-2-2-轮转"><a href="#1-2-2-轮转" class="headerlink" title="1.2.2 轮转"></a>1.2.2 轮转</h4><p>这是一种基于时钟的<strong>抢占策略</strong>，这也是抢占策略中最简单的一种: <strong>公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来</strong>。</p><blockquote><p><strong>决策模式</strong>: <code>抢占策略</code>相对应的有<code>非抢占策略</code>，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。</p></blockquote><p>这种调度策略的要点是<strong>确定合适的时间片长度</strong>: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 <code>FCFS</code> 没什么区别了;  太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。</p><p>因此<strong>时间片的长度最好符合大部分进程完成一次典型交互所需的时间</strong>。</p><p>轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和<code>FCFS</code>一样，轮转策略对I/O进程还是不公平。</p><h4 id="1-2-3-最短进程优先-Shortest-Process-Next-SPN"><a href="#1-2-3-最短进程优先-Shortest-Process-Next-SPN" class="headerlink" title="1.2.3 最短进程优先(Shortest Process Next, SPN)"></a>1.2.3 最短进程优先(Shortest Process Next, SPN)</h4><p>上面说了<code>先到先得</code>策略对<code>短进程</code>不公平，<code>最短进程优先</code>索性就让’最短’的进程优先执行，也就是说: <strong>按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略</strong>。</p><p>这样可以让短进程能得到较快的响应。但是怎么获取或者<strong>评估进程执行时间</strong>呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。</p><p><code>SPN</code> 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。</p><p>另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 <code>FCFS</code> 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。</p><h4 id="1-2-4-最短剩余时间-Shortest-Remaining-Time-SRT"><a href="#1-2-4-最短剩余时间-Shortest-Remaining-Time-SRT" class="headerlink" title="1.2.4 最短剩余时间(Shortest Remaining Time, SRT)"></a>1.2.4 最短剩余时间(Shortest Remaining Time, SRT)</h4><p><strong>SRT 进一步优化了SPN，增加了抢占机制</strong>。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较<em>刚添加的新进程</em>和<em>当前正在执行的老进程</em>的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。</p><p>相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。<strong>另外长进程饥饿问题还是没有解决</strong>。</p><h4 id="1-2-5-最高响应比优先-HRRN"><a href="#1-2-5-最高响应比优先-HRRN" class="headerlink" title="1.2.5 最高响应比优先(HRRN)"></a>1.2.5 最高响应比优先(HRRN)</h4><p><strong>为了解决长进程饥饿问题，同时提高进程的响应速率</strong>。还有一种<code>最高响应比优先的</code>策略，首先了解什么是响应比:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应比 &#x3D; （等待执行时间 + 进程执行时间） &#x2F; 进程执行时间</span><br></pre></td></tr></table></figure><p><strong>这种策略会选择响应比最高的进程优先执行</strong>：</p><ul><li>对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行</li><li>对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行</li></ul><h4 id="1-2-6-反馈法"><a href="#1-2-6-反馈法" class="headerlink" title="1.2.6 反馈法"></a>1.2.6 反馈法</h4><p>SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是<strong>事后反馈</strong>的方式。这种策略下: <strong>每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列</strong>。</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">队列1</span><br><span class="line">队列2</span><br><span class="line">...</span><br><span class="line">队列N</span><br></pre></td></tr></table></figure><p>新增的任务会推入<code>队列1</code>，<code>队列1</code>会按照<code>轮转策略</code>以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入<code>队列2</code>。</p><p><code>队列2</code>会在<code>队列1</code>任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以<code>队列2</code>的轮转时间片长度是2。</p><p>反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。</p><img width = "80%" alt="" align=center src="/images/Fiber/16deecc24dfd080c.png"/><p>没有一种调度策略是万能的, 它需要考虑很多因素:</p><ul><li>响应速率。进程等待被执行的时间</li><li>公平性。兼顾短进程、长进程、I/O进程</li></ul><p>这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。</p><p>上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 <code>Linux</code> 相关的进程调度算法，这方面的资料也非常多, 例如<a href="https://blog.csdn.net/gatieme/article/details/51456569">《Linux进程调度策略的发展和演变》</a>。</p><h2 id="二、浏览器JavaScript执行环境"><a href="#二、浏览器JavaScript执行环境" class="headerlink" title="二、浏览器JavaScript执行环境"></a>二、浏览器JavaScript执行环境</h2><p>JavaScript 是<a href="https://juejin.im/post/6844903553795014663">单线程运行</a>的(就像单行道)，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。</p><blockquote><p>这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个<code>渲染线程</code>，GUI 渲染和 Javascript执行 两者是互斥的。 另外异步 I/O 操作底层实际上可能是多线程的在驱动。</p></blockquote><img width = "65%" alt="" align=center src="/images/Fiber/16deecc35b99001e.jpg"/><p><em>图片来源: <a href="https://developers.google.com/web/fundamentals/performance/rendering">Rendering Performance</a></em></p><p><strong>它只是一个’JavaScript’，同时只能做一件事情，这个和 <code>DOS</code> 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差</strong>。</p><p><strong>对于’前端框架‘来说，解决这种问题有三个方向</strong>:</p><ol><li>优化每个任务，让它有多快就多快。挤压CPU运算量</li><li>快速响应用户，让用户觉得够快，不能阻塞用户的交互</li><li>尝试 Worker 多线程</li></ol><p>Vue 选择的是第1种, 因为对于Vue来说，使用<code>模板</code>让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下<a href="https://www.yuque.com/vueconf/2019/gwn1z0">今年Vue Conf 尤雨溪的演讲</a>，非常棒!；而 React 选择了2种。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。</p><p>React 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, **在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 <code>Reconcilation</code>(中文可以译为<code>协调</code>)**。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc366f124be.png"/><p>在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。</p><p>这样说，你可能没办法体会到，通过下面两个图片来体会一下(<em>图片来源于：<a href="https://twitter.com/dan_abramov">Dan Abramov</a> 的 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 1</a> 演讲, 推荐看一下👍. 另外非常感谢<a href="https://www.zhihu.com/people/BlackGanglion/activities">淡苍</a> 将一个<a href="https://codesandbox.io/s/koyz664q35">类似的DEMO 分享在了 CodeSandbox</a>上🎉，大家自行体验</em>):</p><p>同步模式下的 React:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc3acaf5689.gif" /><p>优化后的 <code>Concurrent</code> 模式下的 React:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc385cc0286.gif" /><p>React 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。</p><p>所以React 是怎么优化的？ 划重点， <strong>为了给用户制造一种应用很快的’假象’，我们不能让一个程序长期霸占着资源。 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的’进程’，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率</strong>。</p><p><strong>所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处</strong>:</p><ul><li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在<a href="https://juejin.im/post/6844903938894872589#heading-1">《「前端进阶」高性能渲染十万条数据(时间分片)》</a> 以及司徒正美的<a href="https://zhuanlan.zhihu.com/p/37095662">《React Fiber架构》</a> 都做了相关实验</li><li>司徒正美在<a href="https://zhuanlan.zhihu.com/p/37095662">《React Fiber架构》</a> 也提到：<strong>给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</strong>。</li></ul><p>这就是为什么React 需要 Fiber 。</p><h2 id="三、何为-Fiber"><a href="#三、何为-Fiber" class="headerlink" title="三、何为 Fiber"></a>三、何为 Fiber</h2><p>对于 React 来说，Fiber 可以从两个角度理解:</p><h3 id="1-一种流程控制原语"><a href="#1-一种流程控制原语" class="headerlink" title="1. 一种流程控制原语"></a>1. 一种流程控制原语</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Fiber 也称<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程</a>、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的<code>Coroutine</code>, 还有前端开发者比较熟悉的 <code>ES6</code> 新增的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator"><code>Generator</code></a>。</p><p><strong>其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制</strong>。要理解协程，你得和普通函数一起来看, 以Generator为例:</p><p>普通函数执行的过程中无法<strong>被中断和恢复</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>Generator</code> 可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    <span class="comment">// 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权</span></span><br><span class="line">    <span class="keyword">if</span> (hasHighPriorityEvent()) &#123;</span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完高优先级事件后，恢复函数调用栈，继续执行...</span></span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React Fiber 的思想和协程的概念是契合的: <strong>React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>浏览器没有抢占的条件, 所以React只能用让出机制?</p><p><strong>答: 没错, 主动让出机制</strong></p><p>一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。</p><p>所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：<a href="https://juejin.im/post/6844903874692661255#heading-7"><strong>合作式调度(Cooperative Scheduling)</strong></a>, 相对应的有<strong>抢占式调度(Preemptive Scheduling)</strong></p><p><strong>这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任</strong>。比如可以由浏览器给我们分配执行时间片(通过<code>requestIdleCallback</code>实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p><img width = "80%" alt="" align=center src="/images/Fiber/16deecc37fdd60d7.png"/><p>这种调度方式很有趣，你会发现<strong>这是一种身份的对调</strong>，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。</p><p>当然你超时不还浏览器也拿你没办法 … 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。</p><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>怎么确定有高优先任务要处理，即什么时候让出？</p><p><strong>答: requestIdleCallback API</strong></p><p>上面代码示例中的 <code>hasHighPriorityEvent()</code> 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。</p><p>只能换一种思路，通过<strong>超时检查的机制来让出控制权</strong>。解决办法是: <em>确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器</em>。</p><p>举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。</p><p>其实浏览器提供了相关的接口 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback"><code>requestIdleCallback</code></a> API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.requestIdleCallback(</span><br><span class="line">  callback: (dealine: IdleDeadline) &#x3D;&gt; void,</span><br><span class="line">  option?: &#123;timeout: number&#125;</span><br><span class="line">  )</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>IdleDeadline</code>的接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IdleDealine &#123;</span><br><span class="line">  didTimeout: boolean &#x2F;&#x2F; 表示任务执行是否超过约定时间</span><br><span class="line">  timeRemaining(): DOMHighResTimeStamp &#x2F;&#x2F; 任务可供执行的剩余时间</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>单从名字上理解的话, <code>requestIdleCallback</code>的意思是<strong>让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕</strong>。</p><p><strong>那浏览器什么时候有空？</strong></p><p>我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecd81f16c6f2.png"/><p><em>你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。</em></p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc428fb4c0b.png"/><p><em>图片来源: <a href="https://juejin.im/post/6844903592831238157">你应该知道的requestIdleCallback</a></em></p><p>浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:</p><ul><li>处理用户输入事件</li><li>Javascript执行</li><li>requestAnimation 调用</li><li>布局 Layout</li><li>绘制 Paint</li></ul><p>上面说理想的一帧时间是 <code>16ms</code> (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 <code>requestIdleCallback</code> 的回调。例如</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc43c710e16.png"/><p><strong>但是在浏览器繁忙的时候，可能不会有盈余时间，这时候<code>requestIdleCallback</code>回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间</strong>。</p><blockquote><p>另外不建议在<code>requestIdleCallback</code>中进行<code>DOM</code>操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 <code>getBoundingClientRect</code>)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。</p></blockquote><p>目前 <code>requestIdleCallback</code> 目前只有Chrome支持。所以目前 React <a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js">自己实现了一个</a>。它利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel"><code>MessageChannel</code></a> 模拟将回调延迟到’绘制操作’之后执行:</p><img width = "100%" alt="" align=center src="/images/Fiber/16deecc5839a3974.png"/><p>简单看一下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ch = <span class="keyword">new</span> MessageChannel()</span><br><span class="line"><span class="keyword">let</span> pendingCallback</span><br><span class="line"><span class="keyword">let</span> startTime</span><br><span class="line"><span class="keyword">let</span> timeout</span><br><span class="line"></span><br><span class="line">ch.port2.onmessage = <span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="comment">// 在绘制之后被执行</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCallback) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = performance.now()</span><br><span class="line">    <span class="comment">// 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间</span></span><br><span class="line">    <span class="comment">// 通过这些数据来计算剩余时间</span></span><br><span class="line">    <span class="comment">// 另外还要处理超时(timeout)，避免任务被饿死</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasRemain &amp;&amp; noTimeout) &#123;</span><br><span class="line">      pendingCallback(deadline)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleRequestIdleCallback</span>(<span class="params">callback, timeout</span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在绘制之前被执行</span></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    startTime = performance.now()</span><br><span class="line">    timeout = timeout</span><br><span class="line">    dosomething()</span><br><span class="line">    <span class="comment">// 调度回调到绘制结束后执行</span></span><br><span class="line">    pendingCallback = callback</span><br><span class="line">    ch.port1.postMessage(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务优先级</strong></p><p>上面说了，为了避免任务被饿死，可以设置一个超时时间. <strong>这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行</strong>. 目前 React 预定义了 5 个优先级, 这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过:</p><ul><li><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li><li><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</li><li><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</li><li><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li><li><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</li></ul><h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><p>React 那为什么不使用 Generator？</p><p><strong>答: 太麻烦</strong></p><p>官方在<a href="https://github.com/facebook/react/issues/7942">《Fiber Principles: Contributing To Fiber》</a> 也作出了解答。主要有两个原因：</p><ol><li>Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。</li><li>Generator 是有状态的, 很难在中间恢复这些状态。</li></ol><blockquote><p>上面理解可能有出入，建议看一下原文</p></blockquote><p>可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。</p><h3 id="2-一个执行单元"><a href="#2-一个执行单元" class="headerlink" title="2. 一个执行单元"></a>2. 一个执行单元</h3><p>Fiber的另外一种解读是’纤维‘：<strong>这是一种数据结构或者说执行单元</strong>。我们暂且不管这个数据结构长什么样，<strong>将它视作一个执行单元，每次执行完一个’执行单元’,  React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</strong>.</p><p>上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：</p><p>假设用户调用 <code>setState</code> 更新组件, 这个待更新的任务会先放入队列中, 然后通过 <code>requestIdleCallback</code> 请求浏览器调度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">updateQueue.push(updateTask);</span><br><span class="line">requestIdleCallback(performWork, &#123;timeout&#125;);</span><br></pre></td></tr></table></figure><p>现在浏览器有空闲或者超时了就会调用<code>performWork</code>来执行任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. performWork 会拿到一个Deadline，表示剩余时间function performWork(deadline) &#123;  // 2. 循环取出updateQueue中的任务  while (updateQueue.length &gt; 0 &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;    workLoop(deadline);  &#125;  // 3. 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度  if (updateQueue.length &gt; 0) &#123;    requestIdleCallback(performWork);  &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>workLoop</code> 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘<code>执行单元</code>‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个<code>执行单元</code>，反之则停止执行，保存现场，等下一次有执行权时恢复</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前的处理现场</span></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork: Fiber | <span class="literal">undefined</span> <span class="comment">// 保存下一个需要处理的工作单元</span></span><br><span class="line"><span class="keyword">let</span> topWork: Fiber | <span class="literal">undefined</span>        <span class="comment">// 保存第一个工作单元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline: IdleDeadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span></span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork == <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = topWork = getNextUnitOfWork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 每执行完一个执行单元，检查一次剩余时间</span></span><br><span class="line">  <span class="comment">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    <span class="comment">// 下文我们再看performUnitOfWork</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交工作，下文会介绍</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCommit) &#123;</span><br><span class="line">    commitAllWork(pendingCommit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>画个流程图吧！</p><img width = "65%" alt="" align=center src="/images/Fiber/16deed1711f281b3.png"/><h2 id="四、React-的Fiber改造"><a href="#四、React-的Fiber改造" class="headerlink" title="四、React 的Fiber改造"></a>四、React 的Fiber改造</h2><p>Fiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。</p><h3 id="1-数据结构的调整"><a href="#1-数据结构的调整" class="headerlink" title="1. 数据结构的调整"></a>1. 数据结构的调整</h3><img width = "65%" alt="" align=center src="/images/Fiber/16deecc72bc9a14c.png"/><p><em>左侧是Virtual DOM，右侧可以看作diff的递归调用栈</em></p><p>上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为<code>Stack Reconcilation</code>. 你可以通过这篇文章<a href="https://juejin.im/post/6844903861434449933">《从Preact中了解React组件和hooks基本原理》</a> 来回顾一下历史。</p><p>栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解…, 递归非常适合树这种嵌套数据结构的处理。</p><p>只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理。 这种调用栈，不是程序所能控制的， 如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。</p><p>因此<strong>首先我们需要对React现有的数据结构进行调整，<a href="https://zhuanlan.zhihu.com/p/36425839"><code>模拟函数调用栈</code></a>, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代</strong>.</p><p>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 <code>Fiber</code>表示, 它的结构大概如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;</span><br><span class="line">  <span class="comment">// Fiber 类型信息</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链表结构</span></span><br><span class="line">  <span class="comment">// 指向父节点，或者render该节点的组件</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向下一个兄弟节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用图片来展示这种关系会更直观一些：</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc6db5530be.png"/><p><strong>使用链表结构只是一个结果，而不是目的，React 开发者一开始的目的是冲着模拟调用栈去的</strong>。这个很多关于Fiber 的文章都有提及, 关于调用栈的详细定义参见<a href="https://en.wikipedia.org/wiki/Call_stack">Wiki</a>：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc9a904099b.png"/><blockquote><p>调用栈最经常被用于存放子程序的<strong>返回地址</strong>。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存<code>本地变量</code>、<code>函数参数</code>、<code>环境传递</code>(Scope?)</p></blockquote><p>React Fiber 也被称为虚拟栈帧(Virtual Stack Frame), 你可以拿它和函数调用栈类比一下, 两者结构非常像:</p><table><thead><tr><th></th><th>函数调用栈</th><th>Fiber</th></tr></thead><tbody><tr><td>基本单位</td><td>函数</td><td>Virtual DOM 节点</td></tr><tr><td>输入</td><td>函数参数</td><td>Props</td></tr><tr><td>本地状态</td><td>本地变量</td><td>State</td></tr><tr><td>输出</td><td>函数返回值</td><td>React Element</td></tr><tr><td>下级</td><td>嵌套函数调用</td><td>子节点(child)</td></tr><tr><td>上级引用</td><td>返回地址</td><td>父节点(return)</td></tr></tbody></table><p>Fiber 和调用栈帧一样, 保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。</p><p>有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 <code>performUnitOfWork</code> 的实现, 它其实就是一个深度优先的遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>fiber 当前需要处理的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>topWork 本次更新的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber: Fiber, topWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对该节点进行处理</span></span><br><span class="line">  beginWork(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在子节点，那么下一个待处理的就是子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有子节点了，上溯查找兄弟节点</span></span><br><span class="line">  <span class="keyword">let</span> temp = fiber;</span><br><span class="line">  <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">    completeWork(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到顶层节点了, 退出</span></span><br><span class="line">    <span class="keyword">if</span> (temp === topWork) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到，下一个要处理的就是兄弟节点</span></span><br><span class="line">    <span class="keyword">if</span> (temp.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> temp.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有, 继续上溯</span></span><br><span class="line">    temp = temp.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以配合上文的 <code>workLoop</code> 一起看，<strong>Fiber 就是我们所说的工作单元，<code>performUnitOfWork</code> 负责对 <code>Fiber</code> 进行操作，并按照深度遍历的顺序返回下一个 Fiber</strong>。</p><p><strong>因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的<code>Fiber</code>继续遍历下去</strong>。</p><p>整个迭代顺序和之前递归的一样, 下图假设在 <code>div.app</code> 进行了更新：</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecca7850a24d.png"/><p><em>比如你在<code>text(hello)</code>中断了，那么下一次就会从 <code>p</code> 节点开始处理</em></p><p>这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的<code>return</code>回溯即可。</p><h3 id="2-两个阶段的拆分"><a href="#2-两个阶段的拆分" class="headerlink" title="2. 两个阶段的拆分"></a>2. 两个阶段的拆分</h3><img width = "85%" alt="" align=center src="/images/Fiber/16deecd830671a70.png"/><p>如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：<code>Reconciliation</code>(协调阶段) 和 <code>Commit</code>(提交阶段).</p><blockquote><p>我在之前的多篇文章中都有提及: <a href="https://juejin.im/post/6844903946016784392">《自己写个React渲染器: 以 Remax 为例(用React写小程序)》</a></p></blockquote><p>除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:</p><ul><li><strong>协调阶段</strong>: 可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为’<code>副作用</code>(Effect)’ . 以下生命周期钩子会在协调阶段被调用：<ul><li><code>constructor</code></li><li><code>componentWillMount</code> 废弃</li><li><code>componentWillReceiveProps</code> 废弃</li><li><code>static getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code> 废弃</li><li><code>render</code></li></ul></li><li><strong>提交阶段</strong>: 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)<strong>一次性执行了。</strong>这个阶段必须同步执行，不能被打断</strong>. 这些生命周期钩子在提交阶段被执行:<ul><li><code>getSnapshotBeforeUpdate()</code> 严格来说，这个是在进入 commit 阶段前调用</li><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul></li></ul><p>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。</p><p>需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，<strong>⚠️React 协调阶段的生命周期钩子可能会被调用多次!</strong>, 例如 <code>componentWillMount</code> 可能会被调用两次。</p><p>因此建议 <strong>协调阶段的生命周期钩子不要包含副作用</strong>. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如<code>componentWillMount</code>、<code>componentWillUpdate</code>. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.</p><p>现在你应该知道为什么’提交阶段’必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在<code>componentDidMount</code>中发起的异步请求、useEffect 中定义的副作用… 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。</p><p>关于为什么要拆分两个阶段，<a href="https://github.com/facebook/react/issues/13186#issuecomment-403959161">这里</a>有更详细的解释。</p><h3 id="3-Reconcilation"><a href="#3-Reconcilation" class="headerlink" title="3. Reconcilation"></a>3. Reconcilation</h3><p>接下来就是就是我们熟知的<code>Reconcilation</code>(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. <strong>思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更</strong>。</p><p>首先再进一步看一下<code>Fiber</code>的结构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">interface Fiber &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的类型信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  <span class="comment">// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)</span></span><br><span class="line">  type: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 结构信息</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子节点的唯一键, 即我们渲染列表传入的key属性</span></span><br><span class="line">  key: <span class="literal">null</span> | string,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 节点实例(状态)：</span></span><br><span class="line">  <span class="comment">//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。</span></span><br><span class="line">  <span class="comment">//        对于类组件来说，这里保存类组件的实例</span></span><br><span class="line">  <span class="comment">//        对于函数组件说，这里为空，因为函数组件没有实例</span></span><br><span class="line">  stateNode: any,</span><br><span class="line">  <span class="comment">// 新的、待处理的props</span></span><br><span class="line">  pendingProps: any,</span><br><span class="line">  <span class="comment">// 上一次渲染的props</span></span><br><span class="line">  memoizedProps: any, <span class="comment">// The props used to create the output.</span></span><br><span class="line">  <span class="comment">// 上一次渲染的组件状态</span></span><br><span class="line">  memoizedState: any,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 副作用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 当前节点的副作用类型，例如节点更新、删除、移动</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line">  <span class="comment">// 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 替身</span></span><br><span class="line"><span class="comment">   * 指向旧树中的节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Fiber 包含的属性可以划分为 5 个部分:</p><ul><li><strong>结构信息</strong> - 这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位</li><li><strong>节点类型信息</strong> - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp</li><li><strong>节点的状态</strong> - 节点的组件实例、props、state等，它们将影响组件的输出</li><li><strong>副作用</strong> - 这个也是新东西. 在 Reconciliation 过程中发现的’副作用’(变更需求)就保存在节点的<code>effectTag</code> 中(想象为打上一个标记). 那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过<code>nextEffect</code>连接起来</li><li><strong>替身</strong> - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，<strong>WIP树</strong>)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的<strong>旧树</strong>，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。</li></ul><p>现在可以放大看看<code>beginWork</code>  是如何对 Fiber 进行比对的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">fiber: Fiber</span>): <span class="title">Fiber</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.tag === WorkTag.HostComponent) &#123;</span><br><span class="line">    <span class="comment">// 宿主节点diff</span></span><br><span class="line">    diffHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.ClassComponent) &#123;</span><br><span class="line">    <span class="comment">// 类组件节点diff</span></span><br><span class="line">    diffClassComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.FunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 函数组件节点diff</span></span><br><span class="line">    diffFunctionalComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他类型节点，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宿主节点比对:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffHostComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新增节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.pendingProps.children;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类组件节点比对也差不多:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffClassComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createInstance(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.hasMounted) &#123;</span><br><span class="line">    <span class="comment">// 调用更新前生命周期钩子</span></span><br><span class="line">    applybeforeUpdateHooks(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用挂载前生命周期钩子</span></span><br><span class="line">    applybeforeMountHooks(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染新节点</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.stateNode.render();</span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line"></span><br><span class="line">  fiber.memoizedState = fiber.stateNode.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子节点比对:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">fiber: Fiber, newChildren: React.ReactNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = fiber.alternate ? fiber.alternate.child : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 全新节点，直接挂载</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber == <span class="literal">null</span>) &#123;</span><br><span class="line">    mountChildFibers(fiber, newChildren)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 新子节点</span></span><br><span class="line">  <span class="keyword">const</span> elements = extraElements(newChildren)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子元素</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevFiber = newFiber;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">    <span class="keyword">const</span> sameType = isSameType(element, oldFiber)</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = cloneFiber(oldFiber, element)</span><br><span class="line">      <span class="comment">// 更新关系</span></span><br><span class="line">      newFiber.alternate = oldFiber</span><br><span class="line">      <span class="comment">// 打上Tag</span></span><br><span class="line">      newFiber.effectTag = UPDATE</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新节点</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = createFiber(element)</span><br><span class="line">      newFiber.effectTag = PLACEMENT</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = DELETION;</span><br><span class="line">      oldFiber.nextEffect = fiber.nextEffect</span><br><span class="line">      fiber.nextEffect = oldFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevFiber &amp;&amp; element) &#123;</span><br><span class="line">      prevFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.</p><p>这里引用一下<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Youtube: Lin Clark presentation in ReactConf 2017</a> 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下:</p><blockquote><p>这篇文章<a href="https://juejin.im/post/6844903582622285831">《React Fiber》</a> 用文字版解释了Link Clark Slide.</p></blockquote><img width = "65%" alt="" align=center src="/images/Fiber/16deecce3162b355.png"/><p>上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了’标签’。 在提交阶段，React 就会将这些打上标签的节点应用变更。</p><h3 id="4-双缓冲"><a href="#4-双缓冲" class="headerlink" title="4. 双缓冲"></a>4. 双缓冲</h3><p><code>WIP 树</code>构建这种技术类似于图形化领域的’<strong>双缓存(Double Buffering)</strong>‘技术，图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。</p><p>放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。</p><p>双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。</p><p>Dan 在 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 16</a> 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，<strong>你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？</strong>:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deeccf3468b00b.png"/><h3 id="5-副作用的收集和提交"><a href="#5-副作用的收集和提交" class="headerlink" title="5. 副作用的收集和提交"></a>5. 副作用的收集和提交</h3><p>接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在<code>completeWork</code>中做, 例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parent = fiber.return</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到达顶端</span></span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="literal">null</span> || fiber === topWork) &#123;</span><br><span class="line">    pendingCommit = fiber</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.nextEffect) &#123;</span><br><span class="line">      parent.nextEffect.nextEffect = fiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.nextEffect = fiber</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.nextEffect) &#123;</span><br><span class="line">    parent.nextEffect = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后了，将所有副作用提交了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllWork</span>(<span class="params">fiber</span>) </span>&#123;  <span class="keyword">let</span> next = fiber  <span class="keyword">while</span>(next) &#123;    <span class="keyword">if</span> (fiber.effectTag) &#123;      <span class="comment">// 提交，偷一下懒，这里就不展开了      commitWork(fiber)    &#125;    next = fiber.nextEffect  &#125;  // 清理现场  pendingCommit = nextUnitOfWork = topWork = null&#125;</span></span><br></pre></td></tr></table></figure><h2 id="五、中断和恢复"><a href="#五、中断和恢复" class="headerlink" title="五、中断和恢复"></a>五、中断和恢复</h2><p>上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。 也就是说，到目前为止：<strong>⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞</strong>。我个人觉得这才是 React Fiber 中最难处理的一部分。</p><p><strong>实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务</strong>。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。</p><p><strong>但是如果不按顺序执行任务，可能会导致前后的状态不一致</strong>。 比如低优先级任务将 <code>a</code> 设置为0，而高优先级任务将 <code>a</code> 递增1, 两个任务的执行顺序会影响最终的渲染结果。因此<strong>要让高优先级任务插队, 首先要保证状态更新的时序</strong>。</p><p>解决办法是: <strong>所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行</strong>, 例如：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deeccf96dac168.png"/><p>红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态, 从而保证<strong>状态的最终一致性</strong>：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd05f86b375.png"/><p>最终红色的高优先级任务 <code>C</code> 执行时的状态值是<code>a=5,b=3</code>. 在恢复控制权时，会按照优先级先执行 <code>C</code>, 前面的<code>A</code>、 <code>B</code>暂时跳过</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd121a8657a.png"/><p>上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子 <code>a</code>、<code>b</code> 可能会影响 <code>Foo</code> 组件树，而 <code>c</code> 会影响 <code>Bar</code> 组件树。所以为了保证<strong>视图的最终一致性</strong>, 所有更新任务都要被执行。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd19b1362c0.png"/><p>首先 <code>C</code> 先被执行，它更新了 <code>Foo</code> 组件</p><p>接着执行 <code>A</code> 任务，它更新了<code>Foo</code> 和 <code>Bar</code> 组件，由于 <code>C</code> 已经以最终状态<code>a=5, b=3</code>更新了<code>Foo</code>组件，这里可以做一下性能优化，直接复用C的更新结果， 不必触发重新渲染。因此 <code>A</code> 仅需更新 <code>Bar</code> 组件即可。</p><p>接着执行 <code>B</code>，同理可以复用 Foo 更新结果。</p><p>道理讲起来都很简单，React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证<strong>状态的一致性</strong>和<strong>视图的一致性</strong>，这给了 React 团队很大的考验，以致于现在都没有正式release出来。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img width = "35%" alt="" align=center src="/images/Fiber/16deecd21336ca41.jpg"/><p><em>同样来自Link Clark 的 Slider</em></p><p>前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作, 地老天荒… 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。</p><p>React 开启 <code>Concurrent Mode</code> 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd2d4124b05.png"/><p><em>来源：<a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s">Flarnie Marchan - Ready for Concurrent Mode?</a></em></p><p>开启 <code>Concurrent Mode</code> 后，我们可以得到以下好处(详见<a href="https://www.youtube.com/watch?v=ByBPyMBTzM0">Concurrent Rendering in React</a>):</p><ul><li>快速响应用户操作和输入，提升用户交互体验</li><li>让动画更加流畅，通过调度，可以让应用保持高帧率</li><li>利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。 比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。</li><li>用<code>Suspense</code> 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。</li></ul><p>但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。</p><p>为了共同创造美好的世界，我们要严律于己，该做的优化还需要做: 纯组件、虚表、简化组件、缓存…</p><p>尤雨溪在今年的<a href="https://www.yuque.com/vueconf/2019">Vue Conf</a>一个观点让我印象深刻：<strong>如果我们可以把更新做得足够快的话，理论上就不需要时间分片了</strong>。</p><p><strong>时间分片并没有降低整体的工作量，该做的还是要做</strong>, 因此React 也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：React Fiber 本质上是为了解决 React 更新低效率的问题，<strong>不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背</strong>.</p><h2 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h2><p>本文之所以能成文，离不开社区上优质的开源项目和资料。</p><p><strong>迷你 Fiber 实现：</strong></p><p>React 现在的代码库太复杂了! 而且一直在变动和推翻自己，<a href="https://www.zhihu.com/people/he-shi-jun">Hax</a> 在 <a href="https://www.zhihu.com/question/270428598/answer/354017709">《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》 </a> 就开玩笑说: Fiber 性价比略低… 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……</p><p>这种工程量不是一般团队能Hold住的， 如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解:</p><ul><li><a href="https://github.com/RubyLouvre/anu">anu</a> <a href="https://github.com/RubyLouvre">司徒正美</a> 开发的类React框架</li><li><a href="https://github.com/132yse/fre">Fre</a> <a href="https://www.zhihu.com/people/132yse">伊撒尔</a> 开发的类React框架，代码很精简⁉️</li><li><a href="https://github.com/Foveluy/Luy">Luy</a></li><li><a href="https://github.com/pomber/didact">didact</a></li></ul><p><strong>优秀的文章 &amp; 演讲：</strong></p><p>本文只是对React Fiber进行了简单的科普，实际上React 的实现比本文复杂的多。如果你想深入理解React Fiber的，下面这些文章不容错过:</p><ul><li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 👍🎦</a> React Fiber 启蒙，YouTube</li><li><a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 16 - Dan Abramov 👍🎦</a></li><li><a href="https://www.youtube.com/watch?v=ByBPyMBTzM0&t=151s">Concurrent Rendering in React - Andrew Clark and Brian Vaughn 👍🎦</a></li><li><a href="https://zhuanlan.zhihu.com/p/37095662">司徒正美: React Fiber架构 👍</a> 看不如写</li><li><a href="https://www.zhihu.com/people/NE_SmallTown/posts">展望 React 17，回顾 React 往事 👍</a> 看完 <a href="https://www.zhihu.com/people/NE_SmallTown">Heaven</a> 的相关文章，会觉得你了解的React 知识真的只是<a href="https://zhuanlan.zhihu.com/jheaven">冰山一角</a>，我们都没资格说我们懂 React。</li><li><a href="https://zhuanlan.zhihu.com/p/36425839">浅入 React16/fiber 系列 👍</a> 同样来自 Heaven</li><li><a href="https://www.zhihu.com/search?type=content&q=requestIdleCallback">淡苍：深入剖析 React Concurrent 👍</a></li><li><a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec">Didact Fiber: Incremental reconciliation  👍</a> 实现了简单的 React Fiber</li><li><a href="https://zhuanlan.zhihu.com/p/26027085">程墨: React Fiber是什么</a></li><li><a href="https://zhuanlan.zhihu.com/p/57346388">译 深入React fiber架构及源码</a></li><li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/">黯羽轻扬: 完全理解React Fiber</a></li><li><a href="https://github.com/facebook/react/issues/7942">Fiber Principles: Contributing To Fiber</a></li><li><a href="https://philippspiess.com/scheduling-in-react/">Scheduling in React</a></li><li><a href="https://juejin.im/post/6844903874692661255">桃翁: Deep In React 之浅谈 React Fiber 架构（一）</a></li><li><a href="https://juejin.im/post/6844903608488558599#heading-12">为 Luy 实现 React Fiber 架构</a></li><li><a href="https://juejin.im/post/6844903582622285831">妖僧风月: React Fiber</a></li><li><a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s">Flarnie Marchan - Ready for Concurrent Mode? 🎦</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/rendering">Web Fundamentals &gt; Performance</a></li><li><a href="https://juejin.im/post/6844903592831238157">你应该知道的requestIdleCallback</a></li><li><a href="https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/">深入探究 eventloop 与浏览器渲染的时序问题</a></li><li><a href="https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/">Accurately measuring layout on the web</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903975112671239#heading-13&quot;&gt;原文链接&lt;/a&gt; Fiber 不是一个新的东西，来看一下单处理进程调度&lt;/p&gt;
&lt;h2 id=&quot;一、单处理器进程调度&quot;&gt;&lt;a href=&quot;#一、单</summary>
      
    
    
    
    <category term="React" scheme="https://tenloy.github.io/categories/React/"/>
    
    
    <category term="Fiber" scheme="https://tenloy.github.io/tags/Fiber/"/>
    
  </entry>
  
  <entry>
    <title>[转]什么是协程</title>
    <link href="https://tenloy.github.io/2021/05/27/08_Coroutine/"/>
    <id>https://tenloy.github.io/2021/05/27/08_Coroutine/</id>
    <published>2021-05-27T10:42:19.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<p>协程，又称微线程，纤程。英文名Coroutine。</p><p>协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。</p><p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p><p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p><p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p><p><strong>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</strong></p><p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;x&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;y&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;z&#x27;</span></span><br></pre></td></tr></table></figure><p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">3</span><br><span class="line">z</span><br></pre></td></tr></table></figure><p>但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。</p><p>看起来A、B的执行有点像多线程，但<strong>协程的特点在于是一个线程执行</strong>，那和多线程比，协程有何优势？</p><ul><li><p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p></li><li><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p></li></ul><p><strong>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</strong></p><p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p><p>来看例子：</p><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p><p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span>(<span class="params">c</span>):</span></span><br><span class="line">    c.<span class="built_in">next</span>()</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br></pre></td></tr></table></figure><p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：</p><ol><li>首先调用c.next()启动生成器；</li><li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</li><li>consumer通过yield拿到消息，处理，又通过yield把结果传回；</li><li>produce拿到consumer处理的结果，继续生产下一条消息；</li><li>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</li></ol><p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p><p>最后套用Donald Knuth的一句话总结协程的特点：</p><p>“子程序就是协程的一种特例。”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;协程，又称微线程，纤程。英文名Coroutine。&lt;/p&gt;
&lt;p&gt;协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。&lt;/p&gt;
&lt;p&gt;子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完</summary>
      
    
    
    
    <category term="OS" scheme="https://tenloy.github.io/categories/OS/"/>
    
    
    <category term="协程" scheme="https://tenloy.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>常见的编程范式知识点汇总</title>
    <link href="https://tenloy.github.io/2021/04/30/07_Common-Programming-Paradigm/"/>
    <id>https://tenloy.github.io/2021/04/30/07_Common-Programming-Paradigm/</id>
    <published>2021-04-30T18:10:23.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、结构化编程"><a href="#一、结构化编程" class="headerlink" title="一、结构化编程"></a>一、结构化编程</h3><blockquote><p>一种编程典范(编程范式)。它采用子程序、块结构、for循环以及while循环等结构，来取代传统的 goto。希望借此来改善计算机程序的明晰性、质量以及开发时间，并且避免写出面条式代码。</p></blockquote><ul><li>“面向结构”的程序设计方法即结构化程序设计方法，是“面向过程”方法的改进，结构上将软件系统划分为若干功能模块，各模块按要求单独编程，再由各模块连接，组合构成相应的软件系统。</li><li>结构化程序设计采用自顶向下、逐步求精的设计方法，各个模块通过“顺序、选择、循环”的控制结构进行连接，并且只有一个入口、一个出口。</li></ul><p>数据结构化：所谓结构化，是指将逐渐积累起来的知识加以归纳和整理，使之条理化、纲领化，做到纲举目张</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、结构化编程&quot;&gt;&lt;a href=&quot;#一、结构化编程&quot; class=&quot;headerlink&quot; title=&quot;一、结构化编程&quot;&gt;&lt;/a&gt;一、结构化编程&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一种编程典范(编程范式)。它采用子程序、块结构、for循环以及while循</summary>
      
    
    
    
    <category term="编程范式" scheme="https://tenloy.github.io/categories/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS中的工程化</title>
    <link href="https://tenloy.github.io/2021/04/29/06_Engineering/"/>
    <id>https://tenloy.github.io/2021/04/29/06_Engineering/</id>
    <published>2021-04-29T19:43:56.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、工程化"><a href="#一、工程化" class="headerlink" title="一、工程化"></a>一、工程化</h2><h3 id="2-1-几个概念"><a href="#2-1-几个概念" class="headerlink" title="2.1 几个概念"></a>2.1 几个概念</h3><p>工程</p><blockquote><p>泛指某项需要投入巨大人力和物力的工作。</p></blockquote><blockquote><p>工程是科学和数学的某种应用，通过这一应用，使自然界的物质和能源的特性能够通过各种结构、机器、产品、系统和过程，是以 <code>最短的时间</code> 和 <code>最少的人力、物力</code> 做出 <code>高效、可靠</code> 且对人类有用的东西。</p></blockquote><p>软件工程</p><blockquote><p>应用计算机科学、数学及管理科学等原理，以工程化方法制作软件的工程。它借鉴传统工程的原则、方法，创建软件以达到提高质量，降低成本的目的。</p></blockquote><p>软件工程是一门指导计算机软件开发和维护的工程学科。是一门交叉性学科(需要用到多种学科的方法支持和指导)，如：</p><ul><li>计算机科学、数学用于构造模型与算法</li><li>工程科学用于制定规范、设计范型、评估成本及确定权衡</li><li>管理科学用于计划、资源、质量、成本等管理</li></ul><h3 id="2-2-平时所提到的工程化"><a href="#2-2-平时所提到的工程化" class="headerlink" title="2.2 平时所提到的工程化"></a>2.2 平时所提到的工程化</h3><h2 id="三、容器化与动态化"><a href="#三、容器化与动态化" class="headerlink" title="三、容器化与动态化"></a>三、容器化与动态化</h2><p>移动动态化：移动指的是移动端，包括安卓、iOS。动态化则是动态部署和逻辑下发到客户端的能力。移动动态最好的状态就是让移动应用和 Web 一样，想发就发！</p><p>动态化的收益</p><p>动态化是整个外卖业务的发展方向。提单页的动态化建立在容器化的基础之上，在完成容器化之后，就具备了动态化的基础。当前提单页的动态化，所指的主要是模块层级的动态化，提单页的各模块展示顺序、展示与否，都可以完全由根据服务端下发的数据决定，各模块可以自由地进行组合、拼装，实现提单页的动态配置。</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>组件：通俗点就是组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件。<br>      组件的出现是为了解决全局工程中有很多重复代码的问题，是为了复用，而且划分力度是相对较小的模块。<br>      组件化的另一个目的是为了解耦，把系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</p><p>插件：可以理解为是封装了一层对外调用的接口的组件。<br>      插件的概念比较形象，一般存在一个“插拔”过程，所以要求可插拔的插件有一个相同的接口(这里所说的接口只是概念上的接口，即调用方法及参数等)。而组件是不存在这个相同接口的。</p><p>插件和组件的实质区别就在于通过统一接口隔绝业务代码对于组件的直接依赖，</p><p>模块：模块化的目的在于将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。<br>      将一个大的系统模块化之后，每个模块都可以被高度复用。<br>      但是值得注意的是模块不等于功能，二者的关系大概为：功能 &gt; 模块一个功能可能包含多个模块。</p><p>组件和模块的实质区别在于：组件化开发是纵向分层，模块化开发是横向分块。模块化并没有要求一定组件化，就是说进行模块化拆分时你可以完全不考虑代码重用，只是把同一业务的代码做内聚整合成不同的模块。只不过这样得到的成果相对简单，我们一般不会这样而已。</p><p>总结<br>组件：代码重用，功能相对单一或者独立，无统一接口。组件化开发的成果是基础库和公共组件。<br>插件：近乎组件，有统一接口，可以说是封装了一层对外调用的接口的组件。<br>模块：高内聚，松耦合，功能相对复杂，有多个统一接口。模块化开发的基础是框架。<br>首先，可以肯定的是，组件化和模块化的中心思想都是分而治之。目的都是将一个庞大的系统拆分成多个组件或者说是模块。</p><p>而且如果大的组件也可以称为模块，小的模块也可以称为组件，所以，在我看来组件和模块的划分并没有那么的泾渭分明。随意两者的粒度的大小改变，两者是可以转换的。</p><p>最后说一下，这三个概念是经常同时出现在一个项目中的，我们往往对复杂大项目进行模块化划分的时候，也会进行组件化，而且插件化的本质是面向接口编程，对于组件化和模块化都是适用的，可实现随意插拔的灵活和高扩展性，属于项目架构的高端设计。</p><p><a href="https://cloud.tencent.com/developer/article/1336167">https://cloud.tencent.com/developer/article/1336167</a><br><a href="http://tutuge.me/2016/03/29/modular-and-component-summary/">http://tutuge.me/2016/03/29/modular-and-component-summary/</a></p><h2 id="一、容器化"><a href="#一、容器化" class="headerlink" title="一、容器化"></a>一、容器化</h2><p>容器化、跨平台到底是不是一回事？</p><p>不是，跨平台是实现效果，容器化是一种软件开发方法，其可以实现跨平台，但不仅仅是跨平台</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、工程化&quot;&gt;&lt;a href=&quot;#一、工程化&quot; class=&quot;headerlink&quot; title=&quot;一、工程化&quot;&gt;&lt;/a&gt;一、工程化&lt;/h2&gt;&lt;h3 id=&quot;2-1-几个概念&quot;&gt;&lt;a href=&quot;#2-1-几个概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="工程化" scheme="https://tenloy.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>[转]Docker入门教程</title>
    <link href="https://tenloy.github.io/2021/04/29/05_Dock-Reprinted-from-RuanYIFeng/"/>
    <id>https://tenloy.github.io/2021/04/29/05_Dock-Reprinted-from-RuanYIFeng/</id>
    <published>2021-04-29T14:42:44.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">原文链接 — 《Docker 入门教程》</a></p><p>2013年发布至今， <a href="https://www.docker.com/">Docker</a> 一直广受瞩目，被认为可能会改变软件行业。</p><p>但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。</p><img src='/images/Docker/docker_logo.png' width = '60%'><h2 id="一、环境配置的难题"><a href="#一、环境配置的难题" class="headerlink" title="一、环境配置的难题"></a>一、环境配置的难题</h2><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p><h2 id="二、虚拟机"><a href="#二、虚拟机" class="headerlink" title="二、虚拟机"></a>二、虚拟机</h2><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p><p><strong>（1）资源占用多</strong></p><p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p><p><strong>（2）冗余步骤多</strong></p><p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p><p><strong>（3）启动慢</strong></p><p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><h2 id="三、Linux-容器"><a href="#三、Linux-容器" class="headerlink" title="三、Linux 容器"></a>三、Linux 容器</h2><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>由于容器是进程级别的，相比虚拟机有很多优势。</p><p><strong>（1）启动快</strong></p><p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p><p><strong>（2）资源占用少</strong></p><p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p><p><strong>（3）体积小</strong></p><p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p><p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h2 id="四、Docker-是什么？"><a href="#四、Docker-是什么？" class="headerlink" title="四、Docker 是什么？"></a>四、Docker 是什么？</h2><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h2 id="五、Docker-的用途"><a href="#五、Docker-的用途" class="headerlink" title="五、Docker 的用途"></a>五、Docker 的用途</h2><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h2 id="六、Docker-的安装"><a href="#六、Docker-的安装" class="headerlink" title="六、Docker 的安装"></a>六、Docker 的安装</h2><p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p><p>Docker CE 的安装请参考官方文档。</p><blockquote><ul><li><a href="https://docs.docker.com/docker-for-mac/install/">Mac</a></li><li><a href="https://docs.docker.com/docker-for-windows/install/">Windows</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/debian/">Debian</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/centos/">CentOS</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/fedora/">Fedora</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/binaries/">其他 Linux 发行版</a></li></ul></blockquote><p>安装完成后，运行下面的命令，验证是否安装成功。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker info</span><br></pre></td></tr></table></figure></blockquote><p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组（<a href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user">官方文档</a>）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></blockquote><p>Docker 是服务器—-客户端架构。命令行运行<code>docker</code>命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（<a href="https://docs.docker.com/config/daemon/systemd/">官方文档</a>）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service 命令的用法</span></span><br><span class="line">$ sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># systemctl 命令的用法</span></span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></blockquote><h2 id="六、image-文件"><a href="#六、image-文件" class="headerlink" title="六、image 文件"></a>六、image 文件</h2><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure></blockquote><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><h2 id="七、实例：hello-world"><a href="#七、实例：hello-world" class="headerlink" title="七、实例：hello world"></a>七、实例：hello world</h2><p>下面，我们通过最简单的 image 文件”<a href="https://hub.docker.com/r/library/hello-world/">hello world”</a>，感受一下 Docker。</p><p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在<a href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">下一篇文章</a>的第一节。有需要的朋友，可以先看一下。</p><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull library/hello-world</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull hello-world</span><br></pre></td></tr></table></figure></blockquote><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure></blockquote><p>现在，运行这个 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br></pre></td></tr></table></figure></blockquote><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure></blockquote><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -it ubuntu bash</span><br></pre></td></tr></table></figure></blockquote><p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br></pre></td></tr></table></figure></blockquote><h2 id="八、容器文件"><a href="#八、容器文件" class="headerlink" title="八、容器文件"></a>八、容器文件</h2><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container ls --all</span><br></pre></td></tr></table></figure></blockquote><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href="https://docs.docker.com/engine/reference/commandline/container_rm/"><code>docker container rm</code></a>命令删除。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h2 id="九、Dockerfile-文件"><a href="#九、Dockerfile-文件" class="headerlink" title="九、Dockerfile 文件"></a>九、Dockerfile 文件</h2><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p><h2 id="十、实例：制作自己的-Docker-容器"><a href="#十、实例：制作自己的-Docker-容器" class="headerlink" title="十、实例：制作自己的 Docker 容器"></a>十、实例：制作自己的 Docker 容器</h2><p>下面我以 <a href="https://www.ruanyifeng.com/blog/2017/08/koa.html">koa-demos</a> 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p><p>作为准备工作，请先<a href="https://github.com/ruanyf/koa-demos/archive/master.zip">下载源码</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ruanyf/koa-demos.git</span><br><span class="line">$ <span class="built_in">cd</span> koa-demos</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-1-编写-Dockerfile-文件"><a href="#10-1-编写-Dockerfile-文件" class="headerlink" title="10.1 编写 Dockerfile 文件"></a>10.1 编写 Dockerfile 文件</h3><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore">内容</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></blockquote><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile">内容</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure></blockquote><p>上面代码一共五行，含义如下。</p><blockquote><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul></blockquote><h3 id="10-2-创建-image-文件"><a href="#10-2-创建-image-文件" class="headerlink" title="10.2 创建 image 文件"></a>10.2 创建 image 文件</h3><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-3-生成容器"><a href="#10-3-生成容器" class="headerlink" title="10.3 生成容器"></a>10.3 生成容器</h3><p><code>docker container run</code>命令会从 image 文件生成容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p>上面命令的各个参数含义如下：</p><blockquote><ul><li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul></blockquote><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment">#</span></span><br></pre></td></tr></table></figure></blockquote><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment"># node demos/01.js</span></span><br></pre></td></tr></table></figure></blockquote><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 <a href="https://github.com/ruanyf/koa-demos/blob/master/demos/01.js">demo</a> 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本机的另一个终端窗口，查出容器的 ID</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查出容器的 ID</span></span><br><span class="line">$ docker container ls --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-4-CMD-命令"><a href="#10-4-CMD-命令" class="headerlink" title="10.4 CMD 命令"></a>10.4 CMD 命令</h3><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure></blockquote><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-5-发布-image-文件"><a href="#10-5-发布-image-文件" class="headerlink" title="10.5 发布 image 文件"></a>10.5 发布 image 文件</h3><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去 <a href="https://hub.docker.com/">hub.docker.com</a> 或 <a href="https://cloud.docker.com/">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure></blockquote><p>接着，为本地的 image 标注用户名和版本。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure></blockquote><p>也可以不标注用户名，重新构建一下 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure></blockquote><p>最后，发布 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure></blockquote><p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p><h2 id="十一、其他有用的命令"><a href="#十一、其他有用的命令" class="headerlink" title="十一、其他有用的命令"></a>十一、其他有用的命令</h2><p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p><p><strong>（1）docker container start</strong></p><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>（2）docker container stop</strong></p><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash container stop [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><p><strong>（3）docker container logs</strong></p><p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>（4）docker container exec</strong></p><p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p><strong>（5）docker container cp</strong></p><p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot;&gt;原文链接 — 《Docker 入门教程》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2013年发布至今， &lt;a href=&quot;https://www.do</summary>
      
    
    
    
    <category term="容器化" scheme="https://tenloy.github.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
    <category term="Docker" scheme="https://tenloy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>常见的容器概念：Linux容器、Docker容器、服务器容器</title>
    <link href="https://tenloy.github.io/2021/04/28/04_Containers/"/>
    <id>https://tenloy.github.io/2021/04/28/04_Containers/</id>
    <published>2021-04-28T15:10:28.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、容器"><a href="#一、容器" class="headerlink" title="一、容器"></a>一、容器</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>汉语释义：</p><blockquote><p>容器(Container)是一种基础工具。泛指任何可以用于容纳其它物品的工具。</p></blockquote><p>容器的特性：</p><ul><li><p>可以部分或完全封闭。— 隔离性</p></li><li><p>被用于容纳、储存、运输物品。 — 便携性、换到程序的概念就是可移植性</p></li><li><p>物体可以被放置在容器中，而容器则可以保护内容物。— 安全</p></li></ul><h2 id="二、Linux容器与Docker容器"><a href="#二、Linux容器与Docker容器" class="headerlink" title="二、Linux容器与Docker容器"></a>二、Linux容器与Docker容器</h2><h3 id="2-1-诞生背景—环境配置的难题"><a href="#2-1-诞生背景—环境配置的难题" class="headerlink" title="2.1 诞生背景—环境配置的难题"></a>2.1 诞生背景—环境配置的难题</h3><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p><h3 id="2-2-虚拟机"><a href="#2-2-虚拟机" class="headerlink" title="2.2 虚拟机"></a>2.2 虚拟机</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p><p><strong>（1）资源占用多</strong></p><p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p><p><strong>（2）冗余步骤多</strong></p><p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p><p><strong>（3）启动慢</strong></p><p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><h3 id="2-3-Linux容器"><a href="#2-3-Linux容器" class="headerlink" title="2.3 Linux容器"></a>2.3 Linux容器</h3><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><h4 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h4><ul><li><p>Linux 容器技术能够让您对应用及其整个运行时环境（包括全部所需文件）一起进行打包或隔离。从而让您可以在不同环境（如开发、测试和生产等环境）之间轻松迁移应用，同时还可保留应用的全部功能。 —  <a href="https://www.redhat.com/zh/topics/containers">Red Hat官网</a></p></li><li><p>容器是包含在任何环境中运行所需的所有元素的软件包。是轻量级应用代码包，还包含了依赖项，例如编程语言运行时的特定版本和运行软件服务所需的库。 —  <a href="https://cloud.google.com/learn/what-are-containers?hl=zh-cn#section-1"> Google Cloud官网</a></p></li><li><p>Linux 容器，又称Linux软件容器，是一种操作系统层虚拟化技术，为Linux内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器(Container)，内含应用软件本身的代码，以及所需要的操作系统核心和库。</p><p>Linux 容器透过统一的名字空间和共享API来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得Linux用户可以容易的创建和管理系统或应用容器。— <a href="https://zh.wikipedia.org/wiki/LXC">维基百科</a></p></li></ul><p>总之：容器就是代码/应用程序+运行时环境</p><p>LXC通常被认为介于“加强版”的chroot和完全成熟的虚拟机之间的技术。LXC的目标是创建一个尽可能与标准安装的Linux相同但又不需要分离内核的环境。</p><p>容器虚拟化操作系统，可以在任何地方运行，不管目标环境是私有数据中心、公有云，还是开发者的个人笔记本电脑。</p><p>容器也是保障 IT 安全的一个重要组成部分。将安全性内置于容器管道，可以为基础架构增添防护，从而保障容器的可靠性、可扩展性和信赖度。</p><h4 id="2-3-2-优势"><a href="#2-3-2-优势" class="headerlink" title="2.3.2 优势"></a>2.3.2 优势</h4><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>由于容器是进程级别的，相比虚拟机有很多优势。</p><p><strong>（1）启动快</strong></p><p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p><p><strong>（2）资源占用少</strong></p><p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p><p><strong>（3）体积小</strong></p><p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p><p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h4 id="2-3-3-使用"><a href="#2-3-3-使用" class="headerlink" title="2.3.3 使用"></a>2.3.3 使用</h4><p>LXC的使用：</p><ul><li><p>Proxmox VE: 它直到4.0版才使用LXC技术，在此之前的版本都是使用OpenVZ技术。</p></li><li><p>Docker：它在0.9版之前都是使用LXC技术，但在0.9版之后，已不再是唯一且默认的运行环境。</p><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p></li></ul><h3 id="2-4-Docker容器"><a href="#2-4-Docker容器" class="headerlink" title="2.4 Docker容器"></a>2.4 Docker容器</h3><p><a href="https://yeasy.gitbook.io/docker_practice/">Docker — 从入门到实践</a></p><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><ul><li>最初实现是基于 LXC</li><li>从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer</li><li>从 1.11 版本开始，则进一步演进为使用 runC 和 containerd。</li></ul><p><strong>Docker</strong> 自开源后受到广泛的关注和讨论，至今其 <a href="https://github.com/moby/moby">GitHub 项目</a> 已经超过 6 万 多个星标和一万多个 <code>fork</code>。甚至由于 <code>Docker</code> 项目的火爆，在 <code>2013</code> 年底，dotCloud 公司决定改名为 Docker。<code>Docker</code> 最初是在 <code>Ubuntu 12.04</code> 上开发实现的；<code>Red Hat</code> 则从 <code>RHEL 6.5</code> 开始对 <code>Docker</code> 进行支持；<code>Google</code> 也在其 <code>PaaS</code> 产品中广泛应用 <code>Docker</code>。</p><h4 id="2-4-2-用途"><a href="#2-4-2-用途" class="headerlink" title="2.4.2 用途"></a>2.4.2 用途</h4><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h4 id="2-4-3-镜像Image"><a href="#2-4-3-镜像Image" class="headerlink" title="2.4.3 镜像Image"></a>2.4.3 镜像Image</h4><p>镜像Image于Docker容器（本质上还是程序与进程的区别？）</p><h5 id="1-引自Docker网站"><a href="#1-引自Docker网站" class="headerlink" title="1) 引自Docker网站"></a>1) 引自Docker网站</h5><p>镜像/映像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p><strong>容器映像</strong>：包含创建容器所需的所有依赖项和信息的包。 映像包括所有依赖项（例如框架），以及容器运行时使用的部署和执行配置。 通常情况下，映像派生自多个基础映像，这些基础映像是堆叠在一起形成容器文件系统的层。 创建后，映像不可变。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><h5 id="2-引自阮一峰"><a href="#2-引自阮一峰" class="headerlink" title="2) 引自阮一峰"></a>2) 引自阮一峰</h5><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><h3 id="2-5-容器与虚拟机的区别"><a href="#2-5-容器与虚拟机的区别" class="headerlink" title="2.5 容器与虚拟机的区别"></a>2.5 容器与虚拟机的区别</h3><p>虚拟机：一种运行在主机操作系统之上，可以访问底层硬件的客机操作系统，例如Linux 或 Windows。</p><p>容器常常被拿来和虚拟机 (VM) 比较。与虚拟机相似，容器也可以让您将应用与库和其他依赖项打包，提供独立环境来运行您的软件服务。</p><p>但是两者的相似性仅此而已，因为容器为开发者和 IT 运营团队提供了更加轻型、具有众多优势的运营单元。</p><ul><li>容器比虚拟机更加轻量化</li><li>容器在操作系统级别进行虚拟化，而虚拟机在硬件级别进行虚拟化</li><li>容器共享操作系统内核，其占用的内存与虚拟机相比微乎其微</li></ul><h3 id="2-6-容器化的优势"><a href="#2-6-容器化的优势" class="headerlink" title="2.6 容器化的优势"></a>2.6 容器化的优势</h3><p>容器化是软件开发的一种方法，通过该方法可将应用程序或服务、其依赖项及其配置（抽象化为部署清单文件）一起打包为容器映像。容器化应用程序可以作为一个单元进行测试，并可以作为容器映像实例部署到主机操作系统 (OS)。 <a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/container-docker-introduction/">参考链接</a></p><p>容器在整个应用程序生命周期工作流中提供以下优点：</p><ul><li><p><strong>责任分离</strong>：容器化使开发者和 IT 运营团队的责任泾渭分明，开发者专注于应用逻辑和依赖项，而 IT 运营团队可以专注于部署和管理，不必为应用细节分心，例如具体的软件版本和配置。</p></li><li><p><strong>工作负载可移植性</strong>：</p><ul><li>软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。 按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境。</li><li>容器几乎能在任何地方运行，极大减轻了开发和部署工作量：在 Linux、Windows 和 Mac 操作系统中；在虚拟机或物理服务器上；在开发者的机器或本地数据中心的机器上；当然还有在公有云上。</li><li>就像船只、火车或卡车运输集装箱而不管其内部是什么货物一样。</li></ul></li><li><p><strong>应用隔离/隔离性</strong>：容器会在操作系统级别虚拟化 CPU、内存、存储和网络资源，为开发者提供在逻辑上与其他应用相隔离的操作系统接口，即在共享 OS 上将应用程序彼此隔离开。</p></li><li><p><strong>灵活性</strong>：轻量级。容器化应用程序在容器主机上运行，而容器主机在 OS（Linux 或 Windows）上运行。 因此，容器的占用比虚拟机 (VM) 映像小得多。</p><p>每个容器可以运行整个 Web 应用或服务，如下图所示，在一个容器主机上运行多个容器。 在此示例中，Docker 主机是容器主机，而 App1、App2、Svc 1 和 Svc 2 是容器化应用程序或服务。</p></li></ul><img src = '/images/Docker/multiple-containers-single-host.png' width = '50%'><ul><li><p><strong>可伸缩性</strong>：通过为短期任务创建新容器，可以快速扩大。 从应用程序的角度来看，实例化映像（创建容器）类似于实例化 服务或 Web 应用等进程。 </p><p>但出于可靠性考虑，在多个主机服务器上运行同一映像的多个实例时，通常要使每个容器（映像实例）在不同容错域中的不同主机服务器或 VM 中运行。</p></li></ul><h2 id="三、服务器与容器"><a href="#三、服务器与容器" class="headerlink" title="三、服务器与容器"></a>三、服务器与容器</h2><h3 id="3-1-服务器-server"><a href="#3-1-服务器-server" class="headerlink" title="3.1 服务器(server)"></a>3.1 服务器(server)</h3><p>服务器(server)指：<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a></p><ul><li><p>一个管理资源并为用户提供服务的计算机软件，通常分为文件服务器（能使用户在其它计算机访问文件），数据库服务器和应用程序服务器。</p></li><li><p>运行以上软件的计算机，或称为网络主机（host）。通常是指那些具有较高计算能力，能够提供给多个用户使用的计算机。</p></li></ul><p>有时，这两种定义会引起混淆。如网页服务器：</p><ul><li>它可能是指用于网站的计算机。</li><li>也可能是指像Apache这样的软件，运行在这样的计算机上以管理网页组件和回应网页浏览器的请求。</li></ul><p>根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，Web服务器等。</p><h4 id="3-1-1-作为硬件"><a href="#3-1-1-作为硬件" class="headerlink" title="3.1.1 作为硬件"></a>3.1.1 作为硬件</h4><p>服务器与PC机的不同点很多：</p><ul><li>服务器的最大特点就是其强大的运算能力或是具备大量磁盘存储空间，使其能在短时间内完成大量工作及负载大量的文件资料存储，并为大量用户提供服务。</li><li>服务器通常以网络作为介质，既可以通过内部网对内提供服务，也可以通过互联网对外提供服务。所以PC机在一个时刻通常只为一个用户服务。而服务器能够通过网络同时提供给多个用户使用</li><li>和普通的个人电脑相比， 服务器需要连续的工作在7×24小时环境。这就意味着服务器需要更多的稳定性技术RAS，比如支持使用ECC存储器。</li></ul><h4 id="3-1-2-作为软件"><a href="#3-1-2-作为软件" class="headerlink" title="3.1.2 作为软件"></a>3.1.2 作为软件</h4><p>服务器软件工作在客户端-服务器或浏览器-服务器的方式，有很多形式的服务器，常用的包括：</p><ul><li><p>文件服务器(file server)或网络存储设备(network attached storage)</p></li><li><p>数据库服务器(database server) —— 如Oracle数据库服务器，MySQL，MariaDB，PostgreSQL，Microsoft SQL Server，MongoDB，Redis等；</p></li><li><p>应用程序服务器(application server/AP server)</p><ul><li><strong>运行应用程序，提供应用程序所实现服务</strong>。通常来说，<strong>服务器端的应用程序实现各种业务逻辑，应用服务器通过各种协议把这些业务逻辑曝露给客户端的程序</strong>。它提供了访问业务逻辑的途径，以供客户端应用程序使用。应用服务器使用此业务逻辑就像调用对象的一个方法一样。</li><li>如Bea公司的WebLogic、JBoss、Sun的GlassFish，及Tomcat、Jetty、Websphere、JBoss等都是Java EE WEB应用服务器/<strong>Java EE服务器</strong><ul><li>Java EE服务器是实现Java EE技术规范，并提供标准Java EE服务的应用程序服务器。</li><li>Java EE服务器有时称为应用服务器，因为它们允许您向客户端提供应用数据，就像Web服务器向Web浏览器提供Web页面一样。</li></ul></li></ul></li><li><p>网页服务器(Web server) </p><ul><li>WEB：现广泛译作网络、互联网等技术领域。表现为三种形式，即<strong>超文本（hypertext）、超媒体（hypermedia）、超文本传输协议（HTTP）</strong>等。</li><li>Web server可以向浏览器等WEB客户端提供文档浏览、数据文件下载等WEB服务。</li><li>如Apache、lighttpd、nginx、微软的IIS等；</li></ul></li><li><p>FTP服务器（FTP server）—— Pureftpd、Proftpd、WU-ftpd、Serv-U、vs-ftpd等；</p></li><li><p>邮件服务器(mail server)</p></li><li><p>域名服务器（DNS server）—— 如BIND等</p></li><li><p>代理服务器（proxy server）—— 如Squid cache</p></li><li><p>其他，如Active Directory服务器、Minecraft游戏服务器等</p></li><li><p>补充：WEB应用服务器</p><ul><li><p>上面我们把应用服务器和WEB服务器严格区分：应用服务器通过应用程序接口(通常是网络请求API）把业务逻辑暴露给客户端应用程序。而WEB服务器通过HTTP提供静态内容给浏览器等客户端。</p><p>如果不严格区分，应用服务器包含WEB服务器，因为WEB服务器是WEB服务应用程序实现的。</p></li><li><p>WEB应用服务器：结合应用服务器和WEB服务器，可以说，它是带应用服务器的Web服务器，接收HTTP请求后，既能返回页面等静态内容，又能处理业务逻辑返回数据。</p></li></ul></li></ul><img src = '/images/Docker/servers.jpg' width = '70%' align:left style='margin-left:10%'><h3 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h3><p>如果说Linux、Docker容器是装满物体的容器：应用/服务程序 + 运行时环境</p><p>那么服务器中说的容器就是纯指未装物体的容器：运行时环境 — <strong>可以部署应用程序，使其在上面运行的环境</strong>。</p><img src = '/images/Docker/container_server.jpg' width = '50%' align:left style='margin-left:10%'><p>容器是服务器中位于应用程序/组件和平台之间的<code>接口集合</code>。它处理屏蔽了服务器平台的复杂性(如线程安全、事务、网络、资源等细节)，使得应用程序在它的基础上可以方便快捷的部署。<a href="https://zh.wikipedia.org/zh-hans/Web%E5%AE%B9%E5%99%A8">Web容器</a></p><ul><li><p>容器管理组件的生命周期，向应用程序组件分派请求，并提供与上下文数据（如关于当前请求的信息）的接口。</p></li><li><p>容器一般位于服务器之内，由服务器负责加载和维护。一个容器只能存在于一个服务器之内，一个服务器可以创建和维护多个容器。</p></li><li><p>容器一般遵守可配置的原则，即容器的用户可以通过对容器参数的配置，来达到自己的使用需求，而不需要修改容器的代码。</p></li></ul><p>根据接口实现的规范、用途不同，常见的分类有：</p><img src = '/images/Docker/containers.jpg' width = '70%' align:left style='margin-left:10%'><h4 id="3-2-1-Servlet容器"><a href="#3-2-1-Servlet容器" class="headerlink" title="3.2.1 Servlet容器"></a>3.2.1 Servlet容器</h4><p>Servlet：属于Java EE重要技术规范，构建了”接收请求–调用servlet程序处理–返回响应”基本模型。</p><p>Servlet程序：Java提供了开发Servlet程序的API，该API可以说Servlet容器的一部分，它对接应用程序与Servlet容器；</p><p>Servlet容器：就是<strong>实现了Servlet</strong>技术规范的部署环境，它可以部署运行Servlet程序。</p><h4 id="3-2-2-Java-WEB容器"><a href="#3-2-2-Java-WEB容器" class="headerlink" title="3.2.2 Java WEB容器"></a>3.2.2 Java WEB容器</h4><p>WEB容器：可以部署多个WEB应用程序的环境。</p><p>Java WEB容器：<strong>实现了Java EE</strong>规定的WEB应用技术规范的的部署环境。</p><p>Java EE WEB应用技术规范：Servlet、JSP（JavaServer Pages）、Java WebSocket等。</p><p>所以，完整的<strong>Java WEB</strong>容器包含Servlet容器。</p><h4 id="3-2-3-Java-EE容器"><a href="#3-2-3-Java-EE容器" class="headerlink" title="3.2.3 Java EE容器"></a>3.2.3 Java EE容器</h4><p>Java EE容器：实现了Java EE技术规范的部署环境。</p><p>Java EE技术规范：除了上面说的Servlet、JSP等Java EE WEB应用技术规范，还包括EJB（Enterprise JavaBeans）等许多技术规范。</p><p>所以，<strong>完整的Java EE</strong>容器包含Java WEB容器（Servlet容器）、EJB容器等。</p><h3 id="3-3-举例说明容器与服务器的联系"><a href="#3-3-举例说明容器与服务器的联系" class="headerlink" title="3.3 举例说明容器与服务器的联系"></a>3.3 举例说明容器与服务器的联系</h3><blockquote><p>服务器是指管理资源并为用户提供服务的计算机软件，或运行该软件的硬件设备。</p></blockquote><blockquote><p>容器是对服务器平台上接口的一层上层封装，屏蔽一些复杂性，提供简化版的接口。使得程序可以在其上快捷的开发和部署运行。</p></blockquote><h4 id="3-3-1-Apache、Nginx、IIS"><a href="#3-3-1-Apache、Nginx、IIS" class="headerlink" title="3.3.1 Apache、Nginx、IIS"></a>3.3.1 Apache、Nginx、IIS</h4><p>Apache、Nginx、IIS是目前主流的三个Web服务器。</p><p>但是可以用它们来构建WEB应用服务器，通常它们发现一个请求是动态请求，就通过CGI、ISAPI、特殊管道等协议接口调用后面的应用服务器来协同处理请求。如Nginx通过fastCGI模块来调用ZendEngine执行PHP应用来处理PHP请求。</p><h4 id="3-3-2-Tomcat及常见的JavaEE应用服务器"><a href="#3-3-2-Tomcat及常见的JavaEE应用服务器" class="headerlink" title="3.3.2 Tomcat及常见的JavaEE应用服务器"></a>3.3.2 Tomcat及常见的JavaEE应用服务器</h4><p>Tomcat、Jetty、WebLogic、Websphere、JBoss都是Java（EE） WEB应用服务器。</p><p>Tomcat</p><ul><li>按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）、Java Expression Language 和 Java WebSocket（Java EE）技术的支持。并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。</li><li>因为实现了Servlet规范，所以可以称为是一个Servlet容器，可以运行Servlet程序</li><li>由于Tomcat本身也内含了HTTP服务器，可以通过HTTP提供HTML页面等静态内容的请求访问，因此也可以视作是一个Web服务器。</li><li>因为可以通过Servlet容器，调用Servlet处理动态请求，所以也是一个应用服务器；</li></ul><p>所以，可以说Tomcat是Java（EE） WEB应用服务器。</p><p>注意，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是用C语言实现的HTTPWeb服务器；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</p><p>Tomcat提供了一个Jasper编译器用以将JSP编译成对应的Servlet。</p><p>Tomcat的Servlet引擎通常与Apache或者其他Web服务器一起工作。除了用于开发过程中的调试以及那些对速度和事务处理只有很小要求的用户，很少会将Tomcat单独作为Web服务器。但随着版本的更新，正有越来越多的用户将其单独作为Web服务器用以那些对速度和可靠性有较高要求的环境中。</p><h4 id="3-3-3-Nginx-Tomcat的WEB应用服务器-集群"><a href="#3-3-3-Nginx-Tomcat的WEB应用服务器-集群" class="headerlink" title="3.3.3 Nginx + Tomcat的WEB应用服务器(集群)"></a>3.3.3 Nginx + Tomcat的WEB应用服务器(集群)</h4><img src = '/images/Docker/nginx_tomcat.jpg' width = '50%' align:left style='margin-left:10%'><p>一般在实际应用中：</p><ul><li>先是通过Nginx反向代理服务器(reverse proxy server)接收请求，匹配分离动态/静态请求（动静分离）</li><li>如果是静态请求，则转发到另外的Nginx WEB服务器上，返回静态内容；</li><li>如果是动态请求，则转发到后面的Tomcat应用服务器，处理动态请求的业务逻辑。</li></ul><p><a href="https://blog.csdn.net/tjiyu/article/details/53148174">参考链接 — 各种容器与服务器的区别与联系</a></p><h2 id="五、iOS的容器化"><a href="#五、iOS的容器化" class="headerlink" title="五、iOS的容器化"></a>五、iOS的容器化</h2><h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>容器在不同场景下的含义</p><ol><li>字面意思，容器就是指容纳小物品的事物，比如：<ol><li>UIStackview</li><li>自定义的Container视图组件</li><li>前端组件化开发中的页面充当的角色(将一个页面分成很多个组件，此处页面就相当于是个纯粹的容器)</li></ol></li><li>数据的解析/渲染环境。比如：<ol><li>美团，后端返回协商好的结构化的数据，移动端对数据进行解析，还原成界面的layout。进行视图创建、渲染</li></ol></li><li>应用程序的运行环境。比如：<ol><li>上面的Docker容器</li><li>服务器容器</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、容器&quot;&gt;&lt;a href=&quot;#一、容器&quot; class=&quot;headerlink&quot; title=&quot;一、容器&quot;&gt;&lt;/a&gt;一、容器&lt;/h2&gt;&lt;h3 id=&quot;1-1-定义&quot;&gt;&lt;a href=&quot;#1-1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 定</summary>
      
    
    
    
    <category term="容器化" scheme="https://tenloy.github.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>同步和异步解读及编程中的使用场景</title>
    <link href="https://tenloy.github.io/2021/04/20/03_Sync-Async/"/>
    <id>https://tenloy.github.io/2021/04/20/03_Sync-Async/</id>
    <published>2021-04-20T20:05:13.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、同步"><a href="#一、同步" class="headerlink" title="一、同步"></a>一、同步</h2><blockquote><p>协调，实现步调一致。两个或几个随时间变化的量，在变化过程中(在时域序列上相对位置)保持一定的相对/约束关系(这个关系分很多种：可以是两者 <code>同时</code>做指定的事、也可以是两者 <code>先后</code>做指定的事等)。</p></blockquote><p>比如：</p><ul><li>音画同步、动作同步等。指某人/事 <code>同时</code>产生，同时进行。</li><li>云同步等。在时间上保持一致性与统一化的现象。</li><li>同步。两部分任务之间按照 <code>先后</code>顺序进行。<ul><li>线程同步：一者暂停(在时域中是一个横线)，等另一者执行完成，再继续</li></ul></li></ul><p>注意：</p><blockquote><p>简单来说：同步就是一段时间内，规定<code>同一时间标准的每一刻</code>（注解1），每个模块(设备/部件/线程)分别应该完成什么(变化)，且各模块的<code>变化之间有一定的相对/约束关系</code>(注解2)</p></blockquote><ol><li><code>当两个设备需要有同步关系的时候，需要在两个设备之间规定一个共同的时间参考(时钟)。</code>即由同宽同距(同频同相)的时钟信号控制每个设备(部件/线程)，分别完成相应的操作</li><li>这两(多)个量的变化之间 <code>可能</code>没有联系，突出的是这两(多)个量<code>一段时间段内随时间的变化过程之间的对应关系</code>。比如上述第一个例子中两者的变化没有联系，而第二个例子中是一者的变化引起另一者的变化</li></ol><h2 id="二、异步"><a href="#二、异步" class="headerlink" title="二、异步"></a>二、异步</h2><blockquote><p>与同步概念相反，两(多)者在随时间变化过程中没有相对/约束关系</p></blockquote><p>比如：</p><ul><li>异步：多线程异步、进程异步</li><li>异步传输：一种通讯方式，对设备需求简单，异步双方不需要共同的时钟。</li></ul><h2 id="三、编程中的使用"><a href="#三、编程中的使用" class="headerlink" title="三、编程中的使用"></a>三、编程中的使用</h2><p>在操作系统中：同步执行的代码的执行过程有顺序性。而并发带来的异步性，每个进(线)程的代码都以其相对独立的不可预知的速度向前推进。</p><p>在计算机中，同步异步常见的两处使用场景：</p><ul><li>线程同步、异步</li><li>同步通信、异步通信(指的是计算机内部件之间的通信)</li><li>同步传输、异步传输(指的是计算机网络中的数据传输，原理基本上与上相同，增加了一些内容，详见下文)</li></ul><h3 id="3-1-线程同步、异步"><a href="#3-1-线程同步、异步" class="headerlink" title="3.1 线程同步、异步"></a>3.1 线程同步、异步</h3><h4 id="3-1-1-同步"><a href="#3-1-1-同步" class="headerlink" title="3.1.1 同步"></a>3.1.1 同步</h4><p>线程之间存在一定的约束关系，在执行过程中，存在一定的<code>前后顺序</code>。可能是出于临界资源的占用，也可能是等待另一条线程执行结果的返回等原因，需要执行完前一个，才能再执行下一个，<code>需要等待、协调运行</code></p><h4 id="3-1-1-异步"><a href="#3-1-1-异步" class="headerlink" title="3.1.1 异步"></a>3.1.1 异步</h4><p>紧贴上面的概念，异步可以解释为两(多)者之间在随时间的执行过程中，两者之间没有约束关系，相互独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。</p><p><code>异步和多线程并不是一个同等关系，异步是最终目的，多线程只是我们实现异步的一种手段</code>。异步是当一个调用请求发送给被调用者，而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。</p><h3 id="3-2-同步通信、异步通信"><a href="#3-2-同步通信、异步通信" class="headerlink" title="3.2 同步通信、异步通信"></a>3.2 同步通信、异步通信</h3><p>总线通信控制主要解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调如何配合，通常用4种方式：同步通信、异步通信、半同步通信、分离式通信。</p><ul><li><p>同步通信中通信双方由统一时标控制数据传送。即双方按统一的传输周期进行信息传输，双方按约定好的时序进行联络，在规定的时钟周期内分别完成相应的操作。</p></li><li><p>异步通信中没有公共的时钟标准，不要求所有部件严格的统一操作时间，而是采用应答方式(又称握手方式)，即当主模块发出请求信号时，一直等待从模块反馈回来响应信号后，才开始通信。</p></li><li><p>异步通信的应答方式又可分为不互锁、半互锁和全互锁三种类型。不互锁方式通信双方没有相互制约关系；半互锁方式通信双方有简单的制约关系；全互锁方式通信双方有完全的制约关系。其中全互锁通信可靠性最高；</p></li></ul><p>详见总线通信控制 ——《计组》</p><h3 id="3-3-同步、异步传输"><a href="#3-3-同步、异步传输" class="headerlink" title="3.3 同步、异步传输"></a>3.3 同步、异步传输</h3><p>在网络通信过程中，通信双方要交换数据，需要高度的协同工作。为了正确的解释信号，接收方必须确切地知道信号应当何时接收和处理，因此定时是至关重要的。</p><p>在计算机网络中，定时的因素称为位同步。同步是要接收方按照发送方发送的每个位的起止时刻和速率来接收数据，否则会产生误差。</p><p>通常可以采用同步或异步的传输方式对位进行同步处理。</p><p>首先是两者的不同</p><table><thead><tr><th></th><th>同步传输</th><th>异步传输</th></tr></thead><tbody><tr><td><code>同步</code></td><td><code>外同步</code></td><td><code>自同步</code>（见底部总结）</td></tr><tr><td>传输格式</td><td>面向 <code>比特</code>的传输，每个信息帧中包含若干个字符( <code>单位是帧</code>)</td><td>面向 <code>字符</code>的传输，每个字符帧只包含一个字符( <code>单位是字符</code>)</td></tr><tr><td>时钟</td><td>要求接收时钟和发送时钟同频同相，通过特定的时钟线路协调时序</td><td>不要求接收时钟和发送时钟完全同步，对时序的要求较低</td></tr><tr><td>数据流</td><td>发送端发送<code>连续</code>的比特流</td><td>发送端发送完一个字节后，可经过任意长的时间间隔再发送</td></tr></tbody></table><p>是否拥有同一个时钟序列进行工作，或者是以数据块为单位进行数据传输，是同步传输和异步传输之间的差别；</p><p>同步效率更高，更加适合对速度要求高的传输，当然这种通信对时序的要求也更高，硬件更复杂。</p><h4 id="3-3-1-位同步"><a href="#3-3-1-位同步" class="headerlink" title="3.3.1 位同步"></a>3.3.1 位同步</h4><p>要求接收端根据发送端发送数据的起止时间和时钟频率，来校正自己的时间基准和时钟频率，这个过程叫位同步。可见，位同步的目的是使接收端接收的每一位信息都与发送端保持同步。</p><img src = '/images/OS/bit_sync.png' width = '80%'><h4 id="3-3-2-同步通信"><a href="#3-3-2-同步通信" class="headerlink" title="3.3.2 同步通信"></a>3.3.2 同步通信</h4><p>同步通信是一种比特同步通信技术，要求发收双方具有同频同相的同步时钟信号，只需在传送报文的最前面附加特定的同步字符，当接收端确认接收到同步字符后，发收双方建立同步，此后便在 <code>同步时钟的控制下</code>逐位发送/接收。</p><p>同步通信是一种连续串行传送数据的通信方式，一次通信只传送一帧信息，<code>由同步字符、数据字符和校验字符（CRC）组成。(见上图)</code></p><ul><li>同步字符：位于帧的开头，用于确认数据字符的开始；</li><li>数据字符：在同步字符之后，个数没有限制，由所需传输的数据块长度来决定；</li><li>校验字符：有1到2个，用于接收端对接收到的字符序列进行正确性的校验</li></ul><p>同步这种方式中因为分组相比异步大得多，很长一段数据才会有额外的辅助位负载，所以效率更高，更加适合对速度要求高的传输，当然这种通信对时序的要求也更高。</p><p>随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。</p><p>另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。</p><blockquote><p>“同步通信”的通信双方必须先建立同步，即双方的时钟要调整到同一个频率。收发双方不停地发送和接收连续的同步比特流。但这时还有两种不同的同步方式。一种是使用全网同步，用一个非常精确的主时钟对全网所有结点上的时钟进行同步。另一种是使用准同步，各结点的时钟之间允许有微小的误差，然后采用其他措施实现同步传输。</p></blockquote><h4 id="3-3-3-异步通信"><a href="#3-3-3-异步通信" class="headerlink" title="3.3.3 异步通信"></a>3.3.3 异步通信</h4><blockquote><p>异步通信指两个互不同步的设备通过计时机制或其他技术进行数据传输。异步通信中两个字符之间的时间间隔是不固定的，而在一个字符内各位的时间间隔是固定的。基本上，发送方可以随时传输数据，而接收方必须在信息到达时准备好接收。</p></blockquote><p>这种传输通常是很小的分组，比如一个字符为一组，为这个组配备起始位和结束位。所以这种传输方式的效率是比较低的，毕竟额外加入了很多的辅助位作为负载，常用在低速的传输中。</p><p>异步通信，是以字符或者字节为单位组成字符帧进行传输。<code>字符帧格式中包括空闲位、起始位、资料位、奇偶校验位、停止位。(见上图)</code></p><p>以RS232协议规定为例，异步通信一个字符一个字符地传输，每个字符一位一位地传输，并且传输一个字符时：</p><ul><li>总是以“起始位”开始（低电平，逻辑值0），以“停止位”结束，字符之间没有固定的时间间隔要求。</li><li>字符数据本身由5~8位数据位组成，接着字符后面是一位校验位（也可以没有校验位）</li><li>最后是一位或一位半或二位停止位</li><li>停止位后面是不定长的空闲位(处于逻辑“1”状态，表示当前线路上没有资料传送)。</li><li>停止位和空闲位都规定为高电平（逻辑值１），这样就保证起始位开始处一定有一个下跳沿。</li></ul><p>异步通信是按字符传输的，接收设备在收到起始信号之后只要在一个字符的传输时间内能和发送设备保持同步就能正确接收。下一个字符起始位的到来又使同步重新校准(<code>依靠检测起始位来实现发送与接收方的时钟 自同步的</code>)。这样，只要发送端和接收端协商好字符帧格式和波特率，就可以由各自的时钟来控制数据的发送和接收。</p><p>举个例子，我们的键盘按下一个按键，发出一个字符信号，异步传输机制就会为它加上前后的辅助同步信息，帮助接收方识别到我们按下了哪一个按键。因为我们敲击键盘的节奏不固定，所以异步是一种很适合的方式</p><p>用于异步通信的连接在OSI(开放系统互连)参考模型的物理层中被定义。</p><blockquote><p>“异步通信”是一种很常用的通信方式。</p><p>异步通信在发送字符时，所发送的字符之间的时间间隔可以是任意的。当然，接收端必须时刻做好接收的准备（如果接收端主机的电源都没有加上，那么发送端发送字符就没有意义，因为接收端根本无法接收）。发送端可以在任意时刻开始发送字符，因此必须在每一个字符的开始和结束的地方加上标志，即加上开始位和停止位，以便使接收端能够正确地将每一个字符接收下来。</p></blockquote><p>异步通信的好处是通信设备简单、便宜，但传输效率较低（因为开始位和停止位的开销所占比例较大）。</p><p>异步通信也可以是以帧作为发送的单位。接收端必须随时做好接收帧的准备。这时，帧的首部必须设有一些特殊的比特组合，使得接收端能够找出一帧的开始。这也称为 <code>帧定界</code>。</p><p>帧定界还包含确定帧的结束位置，这有两种方法：</p><ul><li>一种是在帧的尾部设有某种特殊的比特组合来标志帧的结束</li><li>在帧首部中设有帧长度的字段</li></ul><p>需要注意的是，在异步发送帧时，并不是说发送端对帧中的每一个字符都必须加上开始位和停止位后再发送出去，而是说，发送端可以在任意时间发送一个帧，而帧与帧之间的时间间隔也可以是任意的。在一帧中的所有比特是连续发送的。发送端不需要在发送一帧之前和接收端进行协调（不需要先进行比特同步）。</p><h4 id="3-3-4-总结"><a href="#3-3-4-总结" class="headerlink" title="3.3.4 总结"></a>3.3.4 总结</h4><h5 id="1-异步通信方式的特点"><a href="#1-异步通信方式的特点" class="headerlink" title="1.异步通信方式的特点"></a>1.异步通信方式的特点</h5><p>异步通信是按字符传输的。每传输一个字符就用起始位来进行收、发双方的同步。不会因收发双方的时钟频率的小的偏差导致错误。</p><p>这种传输方式利用每一帧的起、止信号来建立发送与接收之间的同步。特点是：<code>每帧内部各位均采用固定的时间间隔，而帧与帧之间的间隔时随即的</code>。接收机完全靠每一帧的起始位和停止位来识别字符时正在进行传输还是传输结束。</p><p>（使用串口USART中的串行异步通信是一个代表）</p><h5 id="2-同步通信方式的特点"><a href="#2-同步通信方式的特点" class="headerlink" title="2.同步通信方式的特点"></a>2.同步通信方式的特点</h5><p>进行数据传输时，发送和接收双方要保持完全的同步，因此，要求接收和发送设备必须使用同一时钟。</p><p>优点是可以实现高速度、大容量的数据传送；缺点是要求发生时钟和接收时钟保持严格同步，同时硬件复杂。</p><p>（SPI总线是一个典型代表）</p><h5 id="3-对比："><a href="#3-对比：" class="headerlink" title="3.对比："></a>3.对比：</h5><p>可以这样说，不管是异步通信还是同步通信都需要进行同步，只是异步通信通过传送字符内的起始位来进行同步，而同步通信采用共用外部时钟来进行同步。所以，可以说前者是 <code>自同步</code>，后者是 <code>外同步</code>。同时，同步要求收发两端对时间的精确度要求很高，异步没有同步要求那么高。</p><p>自同步、外同步：</p><ul><li>同步传输：是发送端的发送、接收端的接收是同步的，在统一的时钟信号下进行，发一位，接一位。同步传输的数据格式是一种外同步方式所采用的数据格式。对这种方式，在发送的一帧数据中不包含同步字符。同步信号SYNC通过专门的控制线加到串行的接口上。当SYNC一到达，表明数据部分开始，接口就连续接收数据和CRC校验码。    </li><li>异步传输：发送端的发送、接收端的接收不用时钟同步。发送端发一个字符，接收端等接收到之后按字符的始、止位来实现自同步，处理一个字符。</li></ul><h5 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h5><p>在大量使用异步与同步传输的大型机/终端环境中</p><ul><li>异步传输用于传输来自用户周期性按键的终端的字符。接收系统知道等待下一次按键，即使这会花费较多的时间。</li><li>相反，同步传输用作定期传输大量信息的大型系统之间的数据链路。协议为在公用电话系统上利用慢速链路而进行了优化，因此无关位将从传输中删除，并且时钟用于隔开字符。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、同步&quot;&gt;&lt;a href=&quot;#一、同步&quot; class=&quot;headerlink&quot; title=&quot;一、同步&quot;&gt;&lt;/a&gt;一、同步&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;协调，实现步调一致。两个或几个随时间变化的量，在变化过程中(在时域序列上相对位置)保持一定的相对/</summary>
      
    
    
    
    <category term="OS" scheme="https://tenloy.github.io/categories/OS/"/>
    
    
    <category term="多线程" scheme="https://tenloy.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CI-CD</title>
    <link href="https://tenloy.github.io/2021/04/12/02_CI-CD/"/>
    <id>https://tenloy.github.io/2021/04/12/02_CI-CD/</id>
    <published>2021-04-12T14:59:20.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、常见的Travis-CI与Jenkins"><a href="#一、常见的Travis-CI与Jenkins" class="headerlink" title="一、常见的Travis CI与Jenkins"></a>一、常见的Travis CI与Jenkins</h2><p><a href="https://zhuanlan.zhihu.com/p/67805669">参考链接：谁才是世界上最好的 CI/CD 工具？</a></p><p><strong>On-Premise vs Hosted</strong></p><ul><li>On-Premise 需要用户搭建自己的服务器来运行 CI/CD 工具。</li><li>Hosted CI/CD 工具是一个 SaaS 服务，不需要用户搭建自己的服务器。</li></ul><p>常见的 CI/CD 工具</p><ul><li><p>TeamCity 和 Jenkins 属于 “On-Premise” 阵营</p></li><li><p>Travis CI 属于 “Hosted” 阵营</p></li><li><p>AppVeyor 和 Azure Pipelines 则是既能 “On-Premise” 又能 “Hosted” </p></li></ul><p>如果在 CI/CD 过程中，需要连接到不同的内网服务。那么 On-Premise 的 CI/CD 工具适合这样的使用场景，你可以把 Build Agent 部署在内网的机器上，这样可以轻松地连接内网资源。</p><p>如果你不需要连接内网资源，那么 Hosted CI/CD Service 就是你的最佳选择了，有以下几个优势：</p><ul><li>维护成本：Hosted CI/CD Service 可以说是零维护成本了，整个运行环境都由服务商托管。相比于 On-Premise 的CI/CD 工具，使用者需要自己花大量时间搭建与维护服务器，对于 Hosted CI/CD Service 来说，使用者完全不需要担心背后服务器的维护。</li><li>Clean的运行环境：假设你在为你的 Python 项目寻求一个 CI/CD 工具，而你的 Python 项目需要同时对 Python 2.7, 3.6, 3.7 进行持续集成，那么 Hosted CI/CD Service 完全可以满足你的需要。On-Premise 的机器上，你需要对不同的 Python 版本而烦恼，而 Hosted CI/CD Service 每次都会创建一个新的运行环境，想用哪个 Python 版本就用哪个。</li><li>预装的软件和运行时：每一个项目在做持续集成时，往往会需要依赖不同的运行时和工具链，Hosted CI/CD Service 会帮你预装好许多常用的软件和运行时，大大减少了搭建环境的时间。</li><li>价格：价格成本也是我们在技术选型要重点考虑的一点。<ul><li>On-Premise 的 TeamCity 和 Jenkins：虽然他们都是免费使用的，但是使用者都需要搭建自己的服务器，不论是用自己的物理机还是使用 Azure 或是 AWS 上的虚拟机，这都是一个花费。特别是对于大规模的持续集成的需求下，这会是个很大的价格成本。</li><li>对于开源项目，Hosted CI/CD Service 有着很大的优势，Travis CI、AppVeyor 和 Azure Pipelines 对于开源项目都是完全免费的。</li><li>对于私有项目，Travis CI 和 AppVeyor 是收费的，而 Azure Pipelines 有一个月 1800 分钟的免费额度。可见，对于私有项目，Azure Pipelines 有很大的优势。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、常见的Travis-CI与Jenkins&quot;&gt;&lt;a href=&quot;#一、常见的Travis-CI与Jenkins&quot; class=&quot;headerlink&quot; title=&quot;一、常见的Travis CI与Jenkins&quot;&gt;&lt;/a&gt;一、常见的Travis CI与Jenki</summary>
      
    
    
    
    <category term="软件工程(化)" scheme="https://tenloy.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E5%8C%96/"/>
    
    
    <category term="CI/CD" scheme="https://tenloy.github.io/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo+Github Pages搭建个人博客</title>
    <link href="https://tenloy.github.io/2021/04/10/01_GithubPages-Hexo/"/>
    <id>https://tenloy.github.io/2021/04/10/01_GithubPages-Hexo/</id>
    <published>2021-04-10T10:25:24.000Z</published>
    <updated>2021-06-23T06:05:15.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Hexo配置和基本使用"><a href="#一、Hexo配置和基本使用" class="headerlink" title="一、Hexo配置和基本使用"></a>一、Hexo配置和基本使用</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown(或其他渲染引擎) 解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p><a href="https://hexo.io/zh-cn/docs/github-pages">hexo文档</a></p><h3 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h3><h4 id="1-2-1-init"><a href="#1-2-1-init" class="headerlink" title="1.2.1 init"></a>1.2.1 init</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder] <span class="comment"># 新建一个网站。如果没有设置folder，Hexo默认在目前的文件夹建立网站。</span></span><br></pre></td></tr></table></figure><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h4 id="1-2-2-new"><a href="#1-2-2-new" class="headerlink" title="1.2.2 new"></a>1.2.2 new</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt; <span class="comment"># 新建一篇文章</span></span><br></pre></td></tr></table></figure><ul><li>如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。</li><li>如果标题包含空格的话，请使用引号括起来。</li></ul><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about/me <span class="string">&quot;About me&quot;</span></span><br><span class="line"><span class="comment"># 以上命令会创建一个 `source/about/me.md` 文件，同时 Front Matter 中的 title 为 `&quot;About me&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意！title 是必须指定的！如果你这么做并不能达到你的目的：</span></span><br><span class="line">hexo new page --path about/me</span><br><span class="line"><span class="comment"># 此时 Hexo 会创建 `source/_posts/about/me.md`，同时 `me.md` 的 Front Matter 中的 title 为 `&quot;page&quot;`。这是因为在上述命令中，hexo-cli 将 `page` 视为指定文章的标题、并采用默认的 `layout`。</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-generate"><a href="#1-2-3-generate" class="headerlink" title="1.2.3 generate"></a>1.2.3 generate</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate  <span class="comment"># 生成静态文件。可以简写为hexo g</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站。<code>hexo g -d</code> 与 <code>hexo d -g</code> 两个命令的作用是相同的。</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动。Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h4 id="1-2-4-deploy"><a href="#1-2-4-deploy" class="headerlink" title="1.2.4 deploy"></a>1.2.4 deploy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy <span class="comment"># 部署网站。可以简写为：hexo d</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><h4 id="1-2-5-server"><a href="#1-2-5-server" class="headerlink" title="1.2.5 server"></a>1.2.5 server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server  <span class="comment"># 启动服务器。可以简写为：hexo s</span></span><br></pre></td></tr></table></figure><p>默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h4 id="1-2-6-clean"><a href="#1-2-6-clean" class="headerlink" title="1.2.6 clean"></a>1.2.6 clean</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。</span></span><br></pre></td></tr></table></figure><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h4 id="1-2-7-其他"><a href="#1-2-7-其他" class="headerlink" title="1.2.7 其他"></a>1.2.7 其他</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt; <span class="comment"># 发表草稿</span></span><br><span class="line">hexo render &lt;file1&gt; [file2] ... <span class="comment"># 渲染文件。可通过参数-o,--output来设置输出路径</span></span><br><span class="line">hexo migrate &lt;<span class="built_in">type</span>&gt; <span class="comment"># 从其他博客系统 迁移内容 https://hexo.io/zh-cn/docs/migration</span></span><br><span class="line">hexo list &lt;<span class="built_in">type</span>&gt;  <span class="comment">#列出网站资料</span></span><br><span class="line">hexo version  <span class="comment"># 显示 Hexo 版本</span></span><br></pre></td></tr></table></figure><h2 id="二、主题配置"><a href="#二、主题配置" class="headerlink" title="二、主题配置"></a>二、主题配置</h2><p><a href="https://github.com/Tenloy/hexo-theme-archer">fork的theme</a></p><p>根据喜好随便改：配置简书、RSS</p><p><strong>GIT</strong>子模块：</p><ul><li>现在我们的Blog项目受GitHub管理，是个仓库，其中包含了一个主题仓库。其中对主题仓库的修改，要在外层仓库、theme仓库分别提交一次</li><li>Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。 <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git-子模块</a></li></ul><h2 id="三、Travis-CI配置"><a href="#三、Travis-CI配置" class="headerlink" title="三、Travis CI配置"></a>三、Travis CI配置</h2><p>持续集成（Continuous integration，简称CI）</p><p>可以在其中加入一些自动化命令的执行，如每次commit，自动hexo algolia、hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</p><p><a href="https://mfrank2016.github.io/breeze-blog/2020/05/02/hexo/hexo-start/#toc-heading-12">参考链接</a></p><p>但并没有以下问题：</p><blockquote><p>注意：有两种类型的 <code>github pages</code>，一种是使用 <code>用户名.github.io</code> 作为项目名，一种是使用其它名称。虽然看起来只是名字不一样，但两种方式其实是有差异的，前一种方式里，网页静态文件只能存放在 master 分支，所以如果想要把博客源文件也存到同一个仓库，必须使用其它分支来存放，相应的 travis ci 监听和推送的分支也需要修改，当然也可以使用另一个新的仓库来存放。后一种方式则没这个限制，通常使用名为 <code>gh-pages</code> 作为分支名，<code>Hexo</code> 内默认设置的分支也是叫这个名字。这里我们使用的是后一种方案，即源文件和生成的网页静态文件存放在同一个仓库，源文件在 <code>master</code> 分支，静态文件在 <code>gh-pages</code> 分支。</p></blockquote><h2 id="四、algolia站内搜索配置"><a href="#四、algolia站内搜索配置" class="headerlink" title="四、algolia站内搜索配置"></a>四、algolia站内搜索配置</h2><p>algolia网站本质上就是提供了数据库，提供了接口给使用者，供其将要被检索的内容上传。</p><p>hexo-algolia工具就是完成了文档中内容的摘取，然后上传，上传的各项内容，其key就相当于数据库的表字段。</p><ul><li><p>hexo-algolia 要1.2.2版本之前，之后去掉了content字段，即表中不存储文章内容，所以不能搜索文章内容</p></li><li><p>上传content字段之后，可能会因为某条内容的索引数据太大而报错。那只能对该条内容的<code>content</code>字段进行屏蔽</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AlgoliaSearchError: Record at the position 0 objectID=d8676bd7611266ed2404ee6cee119d4a4a911cb0 is too big size=12920 bytes. Contact us if you need an extended quota</span><br><span class="line">    at success (D:\metang326.github.io\node_modules\hexo-algolia\node_modules\algoliasearch\src\AlgoliaSearchCore.js:375:32)</span><br><span class="line">    at process._tickCallback (node.js:369:9)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/hexo-algolia/lib/command.js 添加代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> publishedPagesAndPosts.map(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> storedPost = _.pick(data, [</span><br><span class="line">          <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;date&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;slug&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;excerpt&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;permalink&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;layout&#x27;</span></span><br><span class="line">        ]);</span><br><span class="line"><span class="comment">// 添加判断，对指定的文章删除content字段</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> storedPost.permalink === <span class="string">&quot;string&quot;</span> &amp;&amp;</span><br><span class="line">            storedPost.permalink.indexOf(<span class="string">&quot;10_Web-Module&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">          storedPost = _.pick(data, [</span><br><span class="line">            <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;date&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;slug&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;excerpt&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;permalink&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;layout&#x27;</span></span><br><span class="line">          ]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>algolia网站配置步骤<a href="https://blog.csdn.net/qq_35479468/article/details/107335663">参考链接</a></p><h2 id="五、评论系统配置"><a href="#五、评论系统配置" class="headerlink" title="五、评论系统配置"></a>五、评论系统配置</h2><p><a href="https://www.heson10.com/posts/3217.html">https://www.heson10.com/posts/3217.html</a></p><p><a href="https://blog.shuiba.co/comment-systems-recommendation">https://blog.shuiba.co/comment-systems-recommendation</a></p><p>gitalk</p><h2 id="附：GitBook的使用注意点"><a href="#附：GitBook的使用注意点" class="headerlink" title="附：GitBook的使用注意点"></a>附：GitBook的使用注意点</h2><h3 id="6-1-不支持本地导出HTML"><a href="#6-1-不支持本地导出HTML" class="headerlink" title="6.1 不支持本地导出HTML"></a>6.1 不支持本地导出HTML</h3><p>新版本不支持本地导出的HTML跳转，解决方案：</p><ul><li><p>在_book文件夹中找到gitbook-&gt;theme.js文件。</p></li><li><p>在代码中搜索 <code>if(m)for(n.handler&amp;&amp;</code></p></li><li><p>将<code>if(m)</code>改成<code>if(false)</code>，再重新打开index.html即可 </p></li></ul><p>缺点：每次都会重置侧边栏。如果是部署后访问，侧边栏点击跳转后，不会重置状态</p><h3 id="6-2-默认主题运行报错"><a href="#6-2-默认主题运行报错" class="headerlink" title="6.2 默认主题运行报错"></a>6.2 默认主题运行报错</h3><p>在使用该主题的过程中，发现经常会在控制台报下面的错误，没有找到是哪里的原因，官方也一直没有修复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme.js:4UncaughtTypeError:Cannot read property&#39;split&#39; of undefined</span><br></pre></td></tr></table></figure><p>后来在 <a href="https://github.com/maxkoryukov/theme-default/commit/811fcca17fcc84ad9ff3f940a4194dbffa62a31d">这里</a> 看到一个解决方法，需要修改本地的 GitBook Theme 模板。下面是具体步骤：</p><ul><li><p>进入 GitBook 默认主题所在的文件夹 <code>用户主目录</code> -&gt; <code>.gitbook</code> -&gt; <code>versions</code> -&gt; <code>3.2.2</code> -&gt; <code>node_modules</code> -&gt; <code>gitbook-plugin-theme-default</code> -&gt; <code>src</code> -&gt; <code>js</code> -&gt; <code>theme</code>，打开 <code>navigation.js</code>，找到 <code>getChapterHash</code> 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getChapterHash</span>(<span class="params">$chapter</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $link = $chapter.children(<span class="string">&#x27;a&#x27;</span>),      </span><br><span class="line">      hash = $link.attr(<span class="string">&#x27;href&#x27;</span>).split(<span class="string">&#x27;#&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(hash) hash =<span class="string">&#x27;#&#x27;</span>+hash;</span><br><span class="line">  <span class="keyword">return</span>(!!hash)? hash :<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将该函数修改为下面的形式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getChapterHash</span>(<span class="params">$chapter</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $link = $chapter.children(<span class="string">&#x27;a&#x27;</span>),      </span><br><span class="line">      hash,      </span><br><span class="line">      href,      </span><br><span class="line">      parts;</span><br><span class="line">  <span class="keyword">if</span>($link.length)&#123;      </span><br><span class="line">    href = $link.attr(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(href)&#123;          </span><br><span class="line">      parts = href.split(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span>(parts.length&gt;<span class="number">1</span>)&#123;              </span><br><span class="line">        hash = parts[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(hash) hash =<span class="string">&#x27;#&#x27;</span>+hash;</span><br><span class="line">  <span class="keyword">return</span>(!!hash)? hash :<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回到 <code>gitbook-plugin-theme-default</code> 文件夹，运行 <code>npm install</code> 重新编译文件。</p></li></ul><h3 id="6-3-anchor-navigation-ex插件回到顶部"><a href="#6-3-anchor-navigation-ex插件回到顶部" class="headerlink" title="6.3 anchor-navigation-ex插件回到顶部"></a>6.3 <code>anchor-navigation-ex</code>插件回到顶部</h3><ul><li>如果文章有1级标题就必定好使</li><li>如果没有就：第一次好使，之后不好使。锚点设置的有问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Hexo配置和基本使用&quot;&gt;&lt;a href=&quot;#一、Hexo配置和基本使用&quot; class=&quot;headerlink&quot; title=&quot;一、Hexo配置和基本使用&quot;&gt;&lt;/a&gt;一、Hexo配置和基本使用&lt;/h2&gt;&lt;h3 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://tenloy.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>AutoreleasePool</title>
    <link href="https://tenloy.github.io/2021/04/06/iOS/RunLoop/"/>
    <id>https://tenloy.github.io/2021/04/06/iOS/RunLoop/</id>
    <published>2021-04-06T19:16:47.000Z</published>
    <updated>2021-06-23T06:05:15.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Autorelease简介"><a href="#一、Autorelease简介" class="headerlink" title="一、Autorelease简介"></a>一、Autorelease简介</h2><p>iOS开发中的Autorelease机制是为了延时释放对象。自动释放的概念看上去很像ARC，但实际上这更类似于C语言中自动变量的特性。</p><p>自动变量：在超出变量作用域后将被废弃；<br> 自动释放池：在超出释放池生命周期后，向其管理的对象实例的发送<code>release</code>消息。</p><h3 id="1-1-MRC下使用自动释放池"><a href="#1-1-MRC下使用自动释放池" class="headerlink" title="1.1 MRC下使用自动释放池"></a>1.1 MRC下使用自动释放池</h3><p>在MRC环境中使用自动释放池需要用到<code>NSAutoreleasePool</code>对象，其生命周期就相当于C语言变量的作用域。对于所有调用过<code>autorelease</code>方法的对象，在废弃<code>NSAutoreleasePool</code>对象时，都将调用<code>release</code>实例方法。用源代码表示如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="comment">//第一步：生成并持有释放池NSAutoreleasePool对象;</span></span><br><span class="line"><span class="type">NSAutoreleasePool</span> <span class="operator">*</span>pool <span class="operator">=</span> [[<span class="type">NSAutoreleasePool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：调用对象的autorelease实例方法;</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：废弃NSAutoreleasePool对象;</span></span><br><span class="line">[pool drain];   <span class="comment">//向pool管理的所有对象发送消息，相当于[obj release]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obi已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))</span></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br></pre></td></tr></table></figure><p>理解<code>NSAutoreleasePool</code>对象的生命周期，如下图所示：</p><img src="/images/RunLoop/AutoreleasePool5.png" width = "50%" alt="" align=center /><h3 id="1-2-ARC下使用自动释放池"><a href="#1-2-ARC下使用自动释放池" class="headerlink" title="1.2 ARC下使用自动释放池"></a>1.2 ARC下使用自动释放池</h3><p>ARC环境不能使用<code>NSAutoreleasePool</code>类也不能调用<code>autorelease</code>方法，代替它们实现对象自动释放的是<code>@autoreleasepool</code>块和<code>__autoreleasing</code>修饰符。比较两种环境下的代码差异如下图：</p><img src="/images/RunLoop/AutoreleasePool4.png" width = "60%" alt="" align=center /><p>如图所示，<code>@autoreleasepool</code>块替换了<code>NSAutoreleasePoool</code>类对象的生成、持有及废弃这一过程。而附有<code>__autoreleasing</code>修饰符的变量替代了<code>autorelease</code>方法，将对象注册到了<code>Autoreleasepool</code>；由于ARC的优化，<code>__autorelease</code>是可以被省略的，所以简化后的ARC代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式使用<code>__autoreleasing</code>修饰符的情况非常少见，这是因为ARC的很多情况下，即使是不显式的使用<code>__autoreleasing</code>，也能实现对象被注册到释放池中。主要包括以下几种情况：</p><ol><li>编译器会进行优化，检查方法名是否以<code>alloc/new/copy/mutableCopy</code>开始，如果不是则自动将返回对象注册到<code>Autoreleasepool</code>;</li><li>访问附有<code>__weak</code>修饰符的变量时，实际上必定要访问注册到<code>Autoreleasepool</code>的对象，即会自动加入<code>Autoreleasepool</code>;</li><li>id的指针或对象的指针(id*，NSError **)，在没有显式地指定修饰符时候，会被默认附加上<code>__autoreleasing</code>修饰符，加入<code>Autoreleasepool</code></li></ol><p><strong>注意：</strong>如果编译器版本为LLVM.3.0以上，即使ARC无效<code>@autoreleasepool</code>块也能够使用；如下源码所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [obj autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、AutoRelease原理"><a href="#二、AutoRelease原理" class="headerlink" title="二、AutoRelease原理"></a>二、AutoRelease原理</h2><h3 id="2-1-使用-autoreleasepool"><a href="#2-1-使用-autoreleasepool" class="headerlink" title="2.1 使用@autoreleasepool{}"></a>2.1 使用@autoreleasepool{}</h3><p>我们在<code>main</code>函数中写入自动释放池相关的测试代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了探究释放池的底层实现，我们在终端使用<code>clang -rewrite-objc + 文件名</code>命令将上述OC代码转化为C++源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0);</span><br><span class="line">     &#125;<span class="comment">//大括号对应释放池的作用域</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过编译器<code>clang</code>命令转化后，我们看到的所谓的<code>@autoreleasePool</code>块，其实对应着<code>__AtAutoreleasePool</code>的结构体。</p><h3 id="2-2-分析结构体-AtAutoreleasePool的具体实现"><a href="#2-2-分析结构体-AtAutoreleasePool的具体实现" class="headerlink" title="2.2 分析结构体__AtAutoreleasePool的具体实现"></a>2.2 分析结构体__AtAutoreleasePool的具体实现</h3><p>在源码中找到<code>__AtAutoreleasePool</code>结构体的实现代码，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line">__AtAutoreleasePool`结构体包含了：构造函数、析构函数和一个边界对象；</span><br><span class="line"> 构造函数内部调用：`objc_autoreleasePoolPush()`方法，返回边界对象`atautoreleasepoolobj`</span><br><span class="line"> 析构函数内部调用：`objc_autoreleasePoolPop()`方法，传入边界对象`atautoreleasepoolobj</span><br></pre></td></tr></table></figure><p>分析<code>main</code>函数中<code>__autoreleasepool</code>结构体实例的生命周期是这样的：<br> <code>__autoreleasepool</code>是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面<code>main</code>函数的代码简化如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">        void <span class="operator">*</span>atautoreleasepoolobj <span class="operator">=</span> objc_autoreleasePoolPush();</span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop"><a href="#2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop" class="headerlink" title="2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop"></a>2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop</h3><p>进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对<code>AutoreleasePoolPage</code>对应静态方法<code>push</code>和<code>pop</code>的封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-理解AutoreleasePoolPage"><a href="#2-4-理解AutoreleasePoolPage" class="headerlink" title="2.4 理解AutoreleasePoolPage"></a>2.4 理解AutoreleasePoolPage</h3><p><code>AutoreleasePoolPage</code>是一个C++中的类，打开<code>Runtime</code>的源码工程，在<code>NSObject.mm</code>文件中可以找到它的定义，摘取其中的关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大致在641行代码开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> &#123;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)  <span class="comment">//空池占位</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil                <span class="comment">//边界对象(即哨兵对象）</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);</span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;                  <span class="comment">//校验AutoreleasePagePoolPage结构是否完整</span></span><br><span class="line">    id *next;                             <span class="comment">//指向新加入的autorelease对象的下一个位置，初始化时指向begin()</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;               <span class="comment">//当前所在线程，AutoreleasePool是和线程一一对应的</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;   <span class="comment">//指向父节点page，第一个结点的parent值为nil</span></span><br><span class="line">    AutoreleasePoolPage *child;           <span class="comment">//指向子节点page，最后一个结点的child值为nil</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;                 <span class="comment">//链表深度，节点个数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;                       <span class="comment">//数据容纳的一个上限</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实，<strong>每个自动释放池都是是由若干个<code>AutoreleasePoolPage</code>组成的双向链表结构</strong>，如下图所示:</p><img src="/images/RunLoop/AutoreleasePool3.png" width = "90%" alt="" align=center /><p><code>AutoreleasePoolPage</code>中拥有<code>parent</code>和<code>child</code>指针，分别指向上一个和下一个<code>page</code>；当前一个<code>page</code>的空间被占满(每个<code>AutorelePoolPage</code>的大小为4096字节)时，就会新建一个<code>AutorelePoolPage</code>对象并连接到链表中，后来的  Autorelease对象也会添加到新的<code>page</code>中；</p><p>另外，当<code>next== begin()</code>时，表示<code>AutoreleasePoolPage</code>为空；当<code>next == end()</code>，表示<code>AutoreleasePoolPage</code>已满。</p><h3 id="2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用"><a href="#2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用" class="headerlink" title="2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用"></a>2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用</h3><p>在<code>AutoreleasePoolPage</code>的源码中，我们很容易找到边界对象(哨兵对象)的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define POOL_BOUNDARY nil</span><br></pre></td></tr></table></figure><p>边界对象其实就是<code>nil</code>的别名，而它的作用事实上也就是为了起到一个标识的作用。</p><p>每当自动释放池初始化调用<code>objc_autoreleasePoolPush</code>方法时，总会通过<code>AutoreleasePoolPage</code>的<code>push</code>方法，将<code>POOL_BOUNDARY</code>放到当前<code>page</code>的栈顶，并且返回这个边界对象；</p><p>而在自动释放池释放调用<code>objc_autoreleasePoolPop</code>方法时，又会将边界对象以参数传入，这样自动释放池就会向释放池中对象发送<code>release</code>消息，直至找到第一个边界对象为止。</p><h3 id="2-6-理解objc-autoreleasePoolPush方法"><a href="#2-6-理解objc-autoreleasePoolPush方法" class="headerlink" title="2.6 理解objc_autoreleasePoolPush方法"></a>2.6 理解objc_autoreleasePoolPush方法</h3><p>经过前面的分析，<code>objc_autoreleasePoolPush</code>最终调用的是    <code>AutoreleasePoolPage</code>的<code>push</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1.</span>        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针</span></span><br><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    id *ret = next;</span><br><span class="line">    *next = obj;</span><br><span class="line">    next++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotPage已满时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotpage不存在时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，每次调用<code>push</code>其实就是创建一个新的AutoreleasePool，在对应的<code>AutoreleasePoolPage</code>中插入一个<code>POOL_BOUNDARY</code> ，并且返回插入的<code>POOL_BOUNDARY</code> 的内存地址。<code>push</code>方法内部调用的是<code>autoreleaseFast</code>方法，并传入边界对象(<code>POOL_BOUNDARY</code>)。<code>hotPage</code>可以理解为当前正在使用的<code>AutoreleasePoolPage</code>。</p><p>自动释放池最终都会通过<code>page-&gt;add(obj)</code>方法将边界对象添加到释放池中，而这一过程在<code>autoreleaseFast</code>方法中被分为三种情况：</p><ol><li>当前<code>page</code>存在且不满，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中，即<code>next</code>指向的位置</li><li>当前<code>page</code>存在但是已满，调用<code>autoreleaseFullPage</code>初始化一个新的<code>page</code>，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中</li><li>当前<code>page</code>不存在时，调用<code>autoreleaseNoPage</code>创建一个<code>hotPage</code>，再调用<code>page-&gt;add(obj)</code> 方法将对象添加至<code>page</code>的栈中</li></ol><h3 id="2-7-objc-autoreleasePoolPop方法"><a href="#2-7-objc-autoreleasePoolPop方法" class="headerlink" title="2.7 objc_autoreleasePoolPop方法"></a>2.7 objc_autoreleasePoolPop方法</h3><p>AutoreleasePool的释放调用的是<code>objc_autoreleasePoolPop</code>方法，此时需要传入边界对象作为参数。这个边界对象正是每次执行<code>objc_autoreleasePoolPush</code>方法返回的对象<code>atautoreleasepoolobj</code>；</p><p>同理，我们找到<code>objc_autoreleasePoolPop</code>最终调用的方法，即<code>AutoreleasePoolPage</code>的<code>pop</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span>   <span class="comment">//POOL_BOUNDARY的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);   <span class="comment">//通过POOL_BOUNDARY找到对应的page</span></span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        <span class="comment">// This check is not valid with DebugPoolAllocation off</span></span><br><span class="line">        <span class="comment">// after an autorelease with a pool page but no pool in place.</span></span><br><span class="line">        _objc_fatal(<span class="string">&quot;invalid or prematurely-freed autorelease pool %p; &quot;</span>, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();   <span class="comment">// 记录最高水位标记</span></span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);   <span class="comment">//向栈中的对象发送release消息，直到遇到第一个哨兵对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="comment">// 删除空掉的节点</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，首先根据传入的边界对象地址找到边界对象所处的<code>page</code>；然后选择当前<code>page</code>中最新加入的对象一直向前清理，可以向前跨越若干个<code>page</code>，直到边界所在的位置；清理的方式是向这些对象发送一次<code>release</code>消息，使其引用计数减一；</p><p>另外，清空<code>page</code>对象还会遵循一些原则：</p><ol><li>如果当前的<code>page</code>中存放的对象少于一半，则子<code>page</code>全部删除；</li><li>如果当前当前的<code>page</code>存放的多余一半（意味着马上将要满），则保留一个子<code>page</code>，节省创建新<code>page</code>的开销;</li></ol><h3 id="2-8-autorelease方法"><a href="#2-8-autorelease方法" class="headerlink" title="2.8 autorelease方法"></a>2.8 autorelease方法</h3><p>上述是对自动释放池整个生命周期的分析，现在我们来理解延时释放对象<code>autorelease</code>方法的实现，首先查看该方法的调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- [NSObject autorelease]</span><br><span class="line">└── id objc_object::rootAutorelease()</span><br><span class="line">    └── id objc_object::rootAutorelease2()</span><br><span class="line">        └── static id AutoreleasePoolPage::autorelease(id obj)</span><br><span class="line">            └── static id AutoreleasePoolPage::autoreleaseFast(id obj)</span><br><span class="line">                ├── id *add(id obj)</span><br><span class="line">                ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)</span><br><span class="line">                │   ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                │   └── id *add(id obj)</span><br><span class="line">                └── static id *autoreleaseNoPage(id obj)</span><br><span class="line">                    ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                    └── id *add(id obj)</span><br></pre></td></tr></table></figure><p>如上所示，<code>autorelease</code>方法最终也会调用上面提到的 <code>autoreleaseFast</code>方法，将当前对象加到<code>AutoreleasePoolPage</code>中。关于<code>autoreleaseFast</code>的分析这里不再累述，我们主要来考虑一下两次调用的区别：</p><p><code>autorelease</code>函数和<code>push</code>函数一样，关键代码都是调用<code>autoreleaseFast</code>函数向自动释放池的链表栈中添加一个对象，不过<code>push</code>函数入栈的是一个边界对象，而<code>autorelease</code>函数入栈的是一个具体的Autorelease的对象。</p><h2 id="三、AutoreleasePool与NSThread、NSRunLoop的关系"><a href="#三、AutoreleasePool与NSThread、NSRunLoop的关系" class="headerlink" title="三、AutoreleasePool与NSThread、NSRunLoop的关系"></a>三、AutoreleasePool与NSThread、NSRunLoop的关系</h2><p>由于<code>AppKit</code>和<code>UIKit</code>框架的优化，我们很少需要显式的创建一个自动释放池块。这其中就涉及到<code>AutoreleasePool</code>与<code>NSThread</code>、<code>NSRunLoop</code>的关系。</p><h3 id="3-1-RunLoop和NSThread的关系"><a href="#3-1-RunLoop和NSThread的关系" class="headerlink" title="3.1 RunLoop和NSThread的关系"></a>3.1 RunLoop和NSThread的关系</h3><p><code>RunLoop</code>是用于控制线程生命周期并接收事件进行处理的机制，其实质是一个<code>do-While</code>循环。在苹果文档找到关于<a href="https://links.jianshu.com/go?to=https://developer.apple.com/documentation/foundation/nsrunloop%23//apple_ref/doc/constant_group/Run_Loop_Modes">NSRunLoop</a>的介绍如下：</p><blockquote><p>Your application neither creates or explicitly manages NSRunLoop objects. Each NSThread object—including the application’s main thread—has an NSRunLoop object automatically created for it as needed. If you need to access the current thread’s run loop, you do so with the class method currentRunLoop.</p></blockquote><p>总结<code>RunLoop</code>与<code>NSThread</code>(线程)之间的关系如下：</p><ol><li><code>RunLoop</code>与线程是一一对应关系，每个线程(包括主线程)都有一个对应的<code>RunLoop</code>对象；其对应关系保存在一个全局的Dictionary里；</li><li>主线程的<code>RunLoop</code>默认由系统自动创建并启动；而其他线程在创建时并没有<code>RunLoop</code>，若该线程一直不主动获取，就一直不会有<code>RunLoop</code>；</li><li>苹果不提供直接创建<code>RunLoop</code>的方法；所谓其他线程<code>Runloop</code>的创建其实是发生在第一次获取的时候，系统判断当前线程没有<code>RunLoop</code>就会自动创建；</li><li>当前线程结束时，其对应的<code>Runloop</code>也被销毁；</li></ol><h3 id="3-2-RunLoop和AutoreleasePool的关系"><a href="#3-2-RunLoop和AutoreleasePool的关系" class="headerlink" title="3.2 RunLoop和AutoreleasePool的关系"></a>3.2 RunLoop和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p></blockquote><p>如上所述，主线程的<code>NSRunLoop</code>在监测到事件响应开启每一次<code>event loop</code>之前，会自动创建一个<code>autorelease pool</code>，并且会在<code>event loop</code>结束的时候执行<code>drain</code>操作，释放其中的对象。</p><h3 id="3-3-Thread和AutoreleasePool的关系"><a href="#3-3-Thread和AutoreleasePool的关系" class="headerlink" title="3.3 Thread和AutoreleasePool的关系"></a>3.3 Thread和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself.</p></blockquote><p>如上所述， 包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</p><h2 id="四、AutoreleasePool在主线程上的释放时机"><a href="#四、AutoreleasePool在主线程上的释放时机" class="headerlink" title="四、AutoreleasePool在主线程上的释放时机"></a>四、AutoreleasePool在主线程上的释放时机</h2><h3 id="4-1-理解主线程上的自动释放过程"><a href="#4-1-理解主线程上的自动释放过程" class="headerlink" title="4.1 理解主线程上的自动释放过程"></a>4.1 理解主线程上的自动释放过程</h3><p>分析主线程<code>RunLoop</code>管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：<code>po [NSRunLoop currentRunLoop]</code>，具体效果如下：</p><img src="/images/RunLoop/AutoreleasePool2.png" width = "70%" alt="" align=center /><p>我们看到主线程<code>RunLoop</code>中有两个与自动释放池相关的<code>Observer</code>，它们的 <code>activities</code>分别为<code>0x1</code>和<code>0xa0</code>这两个十六进制的数，转为二进制分别为<code>1</code>和<code>10100000</code>，对应<code>CFRunLoopActivity</code>的类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>),          <span class="comment">//0x1，启动Runloop循环</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>),            </span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>),        </span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>),  <span class="comment">//0xa0，即将进入休眠     </span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>),   </span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),           <span class="comment">//0xa0，退出RunLoop循环  </span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下：</p><ol><li>App启动后，苹果在主线程<code>RunLoop</code>里注册了两个<code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>;</li><li>第一个<code>Observer</code>监视的事件是<code>Entry</code>(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code>创建自动释放池。<code>order = -2147483647</code>(即32位整数最小值)表示其优先级最高，可以保证创建释放池发生在其他所有回调之前;</li><li>第二个<code>Observer</code>监视了两个事件<code>BeforeWaiting</code>(准备进入休眠)时调用<code>_objc_autoreleasePoolPop()</code>和<code>_objc_autoreleasePoolPush()</code>释放旧的池并创建新池；<code>Exit</code>(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code>来释放自动释放池。<code>order = 2147483647</code>(即32位整数的最大值)表示其优先级最低，保证其释放池子发生在其他所有回调之后;</li><li>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 <code>RunLoop</code>创建好的<code>AutoreleasePool</code>环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>AutoreleasePool</code>了;</li></ol><p>最后，也可以结合图示理解主线程上自动释放对象的具体流程：</p><img src="/images/RunLoop/AutoreleasePool.png" width = "70%" alt="" align=center /><ol><li>程序启动到加载完成后，主线程对应的<code>RunLoop</code>会停下来等待用户交互</li><li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li><li><code>RunLoop</code>检测到事件后，就会创建自动释放池;</li><li>所有的延迟释放对象都会被添加到这个池子中;</li><li>在一次完整的运行循环结束之前，会向池中所有对象发送<code>release</code>消息，然后自动释放池被销毁;</li></ol><h3 id="4-2-测试主线程上的对象自动释放过程"><a href="#4-2-测试主线程上的对象自动释放过程" class="headerlink" title="4.2 测试主线程上的对象自动释放过程"></a>4.2 测试主线程上的对象自动释放过程</h3><p>下面的代码创建了一个Autorelease对象<code>string</code>，并且通过<code>weakString</code>进行弱引用(不增加引用计数，所以不会影响对象的生命周期)，具体如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">TestMemoryVC</span> ()</span><br><span class="line"><span class="meta">@property</span> (nonatomic,<span class="keyword">weak</span>)<span class="type">NSString</span> <span class="operator">*</span>weakString;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">TestMemoryVC</span></span><br><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>string <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@&quot;</span>,@<span class="string">&quot;WUYUBEICHEN&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.weakString <span class="operator">=</span> string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewWillAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewDidAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewDidAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//viewWillAppear:WUYUBEICHEN</span></span><br><span class="line"><span class="comment">//viewDidAppear:(null)</span></span><br></pre></td></tr></table></figure><p><strong>代码分析：</strong>自动变量的<code>string</code>在离开<code>viewDidLoad</code>的作用域后，会依靠当前主线程上的<code>RunLoop</code>迭代自动释放。最终<code>string</code>对象在<code>viewDidAppear</code>方法执行前被释放(<code>RunLoop</code>完成此次迭代)。</p><h2 id="五、AutoreleasePool子线程上的释放时机"><a href="#五、AutoreleasePool子线程上的释放时机" class="headerlink" title="五、AutoreleasePool子线程上的释放时机"></a>五、AutoreleasePool子线程上的释放时机</h2><p>子线程默认不开启<code>RunLoo</code>p，那么其中的延时对象该如何释放呢？其实这依然要从<code>Thread</code>和<code>AutoreleasePool</code>的关系来考虑：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p></blockquote><p>也就是说，每一个线程都会维护自己的 <code>Autoreleasepool</code>栈，所以子线程虽然默认没有开启<code>RunLoop</code>，但是依然存在<code>AutoreleasePool</code>，在子线程退出的时候会去释放<code>autorelease</code>对象。</p><p>前面讲到过，ARC会根据一些情况进行优化，添加<code>__autoreleasing</code>修饰符，其实这就相当于对需要延时释放的对象调用了<code>autorelease</code>方法。从源码分析的角度来看，如果子线程中没有创建<code>AutoreleasePool</code> ，而一旦产生了<code>Autorelease</code>对象，就会调用<code>autoreleaseNoPage</code>方法自动创建<code>hotpage</code>，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p><h2 id="六、AutoreleasePool需要手动添加的情况"><a href="#六、AutoreleasePool需要手动添加的情况" class="headerlink" title="六、AutoreleasePool需要手动添加的情况"></a>六、AutoreleasePool需要手动添加的情况</h2><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建<code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html%23//apple_ref/doc/uid/20000047">苹果文档</a>中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ol><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ol><p>而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>obj</code>因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的<code>RunLoop</code>管理的；因为<code>for</code>循环在当前线程没有执行完毕，<code>Runloop</code>也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在<code>viewDidAppear</code>方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">             <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">             <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Autorelease简介&quot;&gt;&lt;a href=&quot;#一、Autorelease简介&quot; class=&quot;headerlink&quot; title=&quot;一、Autorelease简介&quot;&gt;&lt;/a&gt;一、Autorelease简介&lt;/h2&gt;&lt;p&gt;iOS开发中的Autorelease</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="RunLoop" scheme="https://tenloy.github.io/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>iOS-interview</title>
    <link href="https://tenloy.github.io/2021/04/06/iOS/Interview/"/>
    <id>https://tenloy.github.io/2021/04/06/iOS/Interview/</id>
    <published>2021-04-06T13:16:47.000Z</published>
    <updated>2021-06-23T06:05:15.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、算法与数据结构"><a href="#一、算法与数据结构" class="headerlink" title="一、算法与数据结构"></a>一、算法与数据结构</h2><blockquote><p> TLE    Time Limit Exceed(超时)</p></blockquote><ul><li>链表中是否有环</li><li>一个整型数组，将所有元素拼接成一个最大数输出</li><li>大型数组里面装了几万个数，找到前5个，不能用for循环。TopK问题，建小/大顶堆</li><li>贪心</li><li>LRU</li><li>N万个点勾勒一个国家的范围，然后染色</li><li>剑指offer 42：连续子数组的最大和</li><li>hash表</li><li>用底层设计一个缓存，上限是40mb</li><li>二叉树按层次遍历</li><li>数组链表的使用场景</li><li>数组底层内存如何优化</li><li>10进制转16进制 算法</li><li>寻找两个正序数组的中位数</li><li>接雨水</li></ul><h2 id="二、OC相关知识"><a href="#二、OC相关知识" class="headerlink" title="二、OC相关知识"></a>二、OC相关知识</h2><h3 id="2-1-TaggedPointer"><a href="#2-1-TaggedPointer" class="headerlink" title="2.1 TaggedPointer"></a>2.1 TaggedPointer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *strongString;</span><br><span class="line">@property (nonatomic, weak)   NSString *weakString;</span><br><span class="line"></span><br><span class="line">_strongString &#x3D;  [NSString stringWithFormat:@&quot;%@&quot;,@&quot;string1&quot;];</span><br><span class="line">_weakString &#x3D;  _strongString;</span><br><span class="line"></span><br><span class="line">_strongString &#x3D; nil;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, _weakString);</span><br></pre></td></tr></table></figure><p><img src="/images/Interview/TaggedPoint.png" alt="TaggedPoint"></p><h3 id="2-2-KVO"><a href="#2-2-KVO" class="headerlink" title="2.2 KVO"></a>2.2 KVO</h3><ul><li>为什么KVO不释放 会闪退</li><li>推荐了一个facebook的安全使用kvo</li></ul><h3 id="2-3-KVC"><a href="#2-3-KVC" class="headerlink" title="2.3 KVC"></a>2.3 KVC</h3><h3 id="2-4-Block"><a href="#2-4-Block" class="headerlink" title="2.4 Block"></a>2.4 Block</h3><h4 id="2-4-1-Block1：讲讲Block的底层实现"><a href="#2-4-1-Block1：讲讲Block的底层实现" class="headerlink" title="2.4.1 Block1：讲讲Block的底层实现"></a>2.4.1 Block1：讲讲Block的底层实现</h4><ul><li>Block底层也是struct封装的，本质是个对象，拥有ISA指针</li><li>Block中的代码以函数的形式存在于代码段，Block对应的struct有一个指针类型成员，记录了函数地址</li><li>Block会对代码中使用到的局部变量进行捕获<ul><li>auto变量：值捕获</li><li>static变量：地址捕获</li><li>全局变量：不捕获，直接访问</li></ul></li></ul><h4 id="2-4-2-block的底层原理"><a href="#2-4-2-block的底层原理" class="headerlink" title="2.4.2 __block的底层原理"></a>2.4.2 __block的底层原理</h4><ul><li>编译器会将 __block变量包装成一个对象</li><li>再次使用的时候是实现的底层形成的 __Block_byref_xx_y类型的结构体中的成员变量</li></ul><h4 id="2-4-3-block会造成循环引用吗"><a href="#2-4-3-block会造成循环引用吗" class="headerlink" title="2.4.3 __block会造成循环引用吗"></a>2.4.3 __block会造成循环引用吗</h4><h4 id="2-4-4-例题"><a href="#2-4-4-例题" class="headerlink" title="2.4.4 例题"></a>2.4.4 例题</h4><ol><li><p>如果调用一个赋值为空的 block，会发生什么情况？闪退的那个地址值（address）是多少？为什么？</p><p>0x10. 参考Block的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;  &#x2F;&#x2F;地址值0x10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如下</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^test)(int);</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) test block;</span><br><span class="line">@property (nonatomic, assign) int b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    _b &#x3D; 1;</span><br><span class="line">    int a &#x3D; 100;</span><br><span class="line">    _block &#x3D; ^(int value)&#123;</span><br><span class="line">        return a+value+_b;  &#x2F;&#x2F; 问题2：block会捕获哪些变量？捕获了a、self</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[_block class]);</span><br><span class="line">    </span><br><span class="line">    if (a&gt;10) &#123;</span><br><span class="line">        a &#x3D; 10;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        a &#x3D; 20;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%d&quot;,_block(1)); &#x2F;&#x2F; 问题1：102。对a是值捕获，改变无效。</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 问题3：如果该页面是二级页面，退出时，会调用dealloc吗？会，block是assign修饰的，block是在栈上，不对self产生强引用。如果修饰符换成copy呢？不会调用dealloc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-Runtime"><a href="#2-5-Runtime" class="headerlink" title="2.5 Runtime"></a>2.5 Runtime</h3><h4 id="2-5-1-Category中能添加成员变量吗？为什么？"><a href="#2-5-1-Category中能添加成员变量吗？为什么？" class="headerlink" title="2.5.1 Category中能添加成员变量吗？为什么？"></a>2.5.1 Category中能添加成员变量吗？为什么？</h4><p>分类的底层结构体中就没有ivars这个成员，存放不了成员变量。</p><h4 id="2-5-2-Category的数据在编译运行过程中具体是怎么处理的？"><a href="#2-5-2-Category的数据在编译运行过程中具体是怎么处理的？" class="headerlink" title="2.5.2 Category的数据在编译运行过程中具体是怎么处理的？"></a>2.5.2 Category的数据在编译运行过程中具体是怎么处理的？</h4><ol><li><p>通过Runtime加载某个类的所有Category数据</p></li><li><p>把所有Category的方法、属性、协议数据，合并到一个大数组中</p><ul><li>后面参与编译的Category数据，会在数组的前面</li></ul></li><li><p>将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</p></li></ol><h4 id="2-5-3-说说-load与-initialize"><a href="#2-5-3-说说-load与-initialize" class="headerlink" title="2.5.3 说说+load与+initialize"></a>2.5.3 说说+load与+initialize</h4><ol><li>调用时机：+load方法会在runtime加载类、分类时调用；+initialize方法会在类第一次接收到消息时调用</li><li>调用方式：+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用；+initialize是通过objc_msgSend进行调用的</li></ol><h4 id="2-5-4-消息发送-传递机制"><a href="#2-5-4-消息发送-传递机制" class="headerlink" title="2.5.4 消息发送/传递机制"></a>2.5.4 消息发送/传递机制</h4><p>objc_msgSend()函数会依据接受者（调用方法的对象）的类型和选择子（方法名）来调用适当的方法。</p><ol><li>接收者会根据isa指针找到接收者自己所属的类，然后在所属类的”方法列表“（method list）中从上向下遍历。如果能找到与选择子名称相符的方法，就根据IMP指针跳转到方法的实现代码，调用这个方法的实现。</li><li>如果找不到与选择子名称相符的方法，接收者会根据所属类的superClass指针，沿着类的继承体系继续向上查找（向父类查找），如果 能找到与名称相符的方法，就根据IMP指针跳转到方法的实现代码，调用这个方法的实现。</li><li>如果在继承体系中还是找不到与选择子相符的方法，此时就会执行”<code>消息转发（message forwarding）</code>“操作。</li></ol><h4 id="2-5-5-消息转发"><a href="#2-5-5-消息转发" class="headerlink" title="2.5.5 消息转发"></a>2.5.5 消息转发</h4><p><img src="/images/Interview/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png" alt="消息转发"></p><p>消息转发分为两大阶段。第一阶段叫做“动态方法解析（dynamic method resolution）”，或者叫“动态方法决议”。第二阶段涉及到“完整的消息转发机制（full forwarding mechanism）”，或者叫“完整的消息转发原理”。</p><h5 id="第一阶段：动态方法解析"><a href="#第一阶段：动态方法解析" class="headerlink" title="第一阶段：动态方法解析"></a>第一阶段：动态方法解析</h5><p>动态方法解析的意思就是，征询消息接受者所属的类，看其是否能动态添加方法，以处理当前“这个未知的选择子（unknown selector）“。实例对象在接受到无法解读的消息后，首先会调用其<code>所属类</code>的下列<code>类方法</code>:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)selector</span><br></pre></td></tr></table></figure><p>类对象在接受到无法解读的消息后，那么运行期系统就会调用另外的一个方法，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)selector</span><br></pre></td></tr></table></figure><p>如果运行期系统已经执行完了动态方法解析，那么消息接受者自己就无法再以动态新增方法的形式来响应包含该未知选择子的消息了，此时就进入了第二阶段——<code>完整的消息转发</code>。运行期系统会请求消息接受者以其他手段来处理与消息相关的方法调用。</p><h5 id="第二阶段：又细分为两小步"><a href="#第二阶段：又细分为两小步" class="headerlink" title="第二阶段：又细分为两小步"></a>第二阶段：又细分为两小步</h5><h5 id="2-1-备援接受者-replacement-receiver"><a href="#2-1-备援接受者-replacement-receiver" class="headerlink" title="2.1 备援接受者(replacement receiver)"></a>2.1 备援接受者(replacement receiver)</h5><p>当前接收者还有第二次机会能处理未知的选择子，在这一步中，运行期系统会问它：能不能把这条消息转给其他接收者来处理。与该步骤对应的处理方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)selector &#x2F;&#x2F;方法参数代表未知的选择子</span><br></pre></td></tr></table></figure><ul><li>若当前接收者能找到备援对象，则将其返回，此时运行期系统(Runtime)会把消息转给那个对象，消息转发过程结束</li><li>若找不到，就返回nil，此时启动完整的消息转发机制。</li></ul><p>通过此方案，我们可以用”组合”(composition)来模拟出“多重继承”(multiple inheritance) 的某些特性。在一个对象内部，可能还有一系列其他对象，该对象可经由此方法将能够处理某选择子的相关内部对象返回，这样的话，在外界看来，好像是该对象亲自处理了这些消息似的。</p><p>请注意，我们无法操作经由这一步所转发的消息。若是想在发送给备援接收者之前先修改消息内容，那就得通过完整的消息转发机制来做了。</p><h5 id="2-2-完整的消息转发"><a href="#2-2-完整的消息转发" class="headerlink" title="2.2 完整的消息转发"></a>2.2 完整的消息转发</h5><p>首先创建NSInvocation对象，把与尚未处理的那条消息有关的全部细节都封于其中。此对象包含选择子、目标(target)及参数。<br>在触发NSInvocation对象时，“消息派发系统”(message-dispatch system)将亲自出马，把消息指派给目标对象。</p><p>此步骤需要先实现一个方法，来返回方法的签名：返回值类型、参数类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure><p>然后会调用下列方法来转发消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation*)invocation</span><br></pre></td></tr></table></figure><p>这个方法可以实现得很简单：只需改变调用目标，使消息在新目标上得以调用即可。然而这样实现出来的方法与“备援接收者”方案所实现的方法等效，所以很少有人采用这么简单的实现方式。比较有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或是改换选择子，等等。</p><h4 id="2-5-6-常见面试题"><a href="#2-5-6-常见面试题" class="headerlink" title="2.5.6 常见面试题"></a>2.5.6 常见面试题</h4><ul><li><p>Methodswizzing使用中遇到过什么问题吗，怎么避免</p></li><li><p>类和一些分类都hook( methodswizzing)了一个方法，会发生什么</p></li><li><p>a和b互换方法，c方法在不知情的状况下和a互换了方法，会有什么问题，a执行的是哪个方法，如何避免这个问题</p></li><li><p>本类一个方法，分类中有一个同名的方法，怎么调用本类的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)callClassMethod &#123;</span><br><span class="line">    u_int count;</span><br><span class="line">    Method *methods &#x3D; class_copyMethodList([Student class], &amp;count);</span><br><span class="line">    NSInteger index &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        SEL name &#x3D; method_getName(methods[i]);</span><br><span class="line">        NSString *strName &#x3D; [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">        if ([strName isEqualToString:@&quot;run&quot;]) &#123;</span><br><span class="line">            index &#x3D; i;  &#x2F;&#x2F; 先获取原类方法在方法列表中的索引。分类的在前，后面的本类中的会覆盖前面的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 调用方法</span><br><span class="line">    Student *stu &#x3D; [[Student alloc] init];</span><br><span class="line">    SEL sel &#x3D; method_getName(methods[index]);</span><br><span class="line">    IMP imp &#x3D; method_getImplementation(methods[index]);</span><br><span class="line">    ((void (*)(id, SEL))imp)(stu,sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分类文件 +声明 -实现，调用会崩溃吗，为什么</p></li><li><p>分类为什么不能扩展属性？用runtime 关联对象 为什么就能实现增加属性？内部数据结构怎么处理的的</p></li></ul><h3 id="2-6-RunLoop"><a href="#2-6-RunLoop" class="headerlink" title="2.6 RunLoop"></a>2.6 RunLoop</h3><h4 id="2-6-1-RunLoop的大概流程及常见运用"><a href="#2-6-1-RunLoop的大概流程及常见运用" class="headerlink" title="2.6.1 RunLoop的大概流程及常见运用"></a>2.6.1 RunLoop的大概流程及常见运用</h4><p>Timers Sources Blocks Source0 Source1</p><p>运用：线程保活、NSTimer滑动停止工作、监控引用卡顿(比如使用CADisplayLink，添加到runloop中)等</p><h4 id="2-6-2-自动释放池"><a href="#2-6-2-自动释放池" class="headerlink" title="2.6.2 自动释放池"></a>2.6.2 自动释放池</h4><p><a href="https://www.jianshu.com/p/7bd2f85f03dc">iOS内存管理-深入解析自动释放池</a></p><h5 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1) 实现原理"></a>1) 实现原理</h5><h5 id="2-NSThread、NSRunLoop、Autorelease的关系"><a href="#2-NSThread、NSRunLoop、Autorelease的关系" class="headerlink" title="2) NSThread、NSRunLoop、Autorelease的关系"></a>2) NSThread、NSRunLoop、Autorelease的关系</h5><p>总结<code>NSThread</code>(线程)与<code>RunLoop</code>之间的关系如下：</p><ul><li>线程与<code>RunLoop</code>是一一对应关系，每个线程(包括主线程)都有一个对应的<code>RunLoop</code>对象；其对应关系保存在一个全局的Dictionary里；</li><li>主线程的<code>RunLoop</code>默认由系统自动创建并启动；而其他线程在创建时并没有<code>RunLoop</code>，若该线程一直不主动获取，就一直不会有<code>RunLoop</code>；</li><li>苹果不提供直接创建<code>RunLoop</code>的方法；所谓其他线程<code>Runloop</code>的创建其实是发生在第一次获取的时候，系统判断当前线程没有<code>RunLoop</code>就会自动创建；</li><li>当前线程结束时，其对应的<code>Runloop</code>也被销毁；</li></ul><p><code>RunLoop</code>与<code>AutoreleasePool</code>的关系：</p><ul><li>主线程的<code>NSRunLoop</code>在监测到事件响应开启每一次<code>event loop</code>之前，会自动创建一个<code>autorelease pool</code>，并且会在<code>event loop</code>结束的时候执行<code>drain</code>操作，释放其中的对象。</li></ul><p><code>Thread</code>和<code>AutoreleasePool</code>的关系：</p><ul><li>包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</li></ul><h5 id="3-AutoreleasePool在主线程上的释放时机"><a href="#3-AutoreleasePool在主线程上的释放时机" class="headerlink" title="3) AutoreleasePool在主线程上的释放时机"></a>3) AutoreleasePool在主线程上的释放时机</h5><ol><li>程序启动到加载完成后，主线程对应的<code>RunLoop</code>会停下来等待用户交互</li><li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li><li><code>RunLoop</code>检测到事件后，就会创建自动释放池;</li><li>所有的延迟释放对象都会被添加到这个池子中;</li><li>在一次完整的运行循环结束之前，会向池中所有对象发送<code>release</code>消息，然后自动释放池被销毁;</li></ol><h5 id="4-AutoreleasePool在子线程上的释放时机"><a href="#4-AutoreleasePool在子线程上的释放时机" class="headerlink" title="4) AutoreleasePool在子线程上的释放时机"></a>4) AutoreleasePool在子线程上的释放时机</h5><p>子线程默认不开启<code>RunLoo</code>p，那么其中的延时对象该如何释放呢？其实这依然要从<code>Thread</code>和<code>AutoreleasePool</code>的关系来考虑：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p></blockquote><p>也就是说，每一个线程都会维护自己的 <code>Autoreleasepool</code>栈，所以子线程虽然默认没有开启<code>RunLoop</code>，但是依然存在<code>AutoreleasePool</code>，在子线程退出的时候会去释放<code>autorelease</code>对象。</p><h5 id="5-AutoreleasePool需要手动添加的情况"><a href="#5-AutoreleasePool需要手动添加的情况" class="headerlink" title="5) AutoreleasePool需要手动添加的情况"></a>5) AutoreleasePool需要手动添加的情况</h5><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建<code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html%23//apple_ref/doc/uid/20000047">苹果文档</a>中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ol><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ol><h4 id="2-6-3-其他"><a href="#2-6-3-其他" class="headerlink" title="2.6.3 其他"></a>2.6.3 其他</h4><ul><li>runloop运行逻辑</li><li>runloop跟线程什么关系，runloop怎么唤起线程</li><li>子线程的runloop怎么获取，具体应用场景有哪些</li><li>线程保活具体怎么做</li><li>你讲到runloop有多种mode,那为什么要设计多种mode呢，一个组合mode行不行</li></ul><h3 id="2-7-内存管理"><a href="#2-7-内存管理" class="headerlink" title="2.7 内存管理"></a>2.7 内存管理</h3><h4 id="2-7-1-iOS的内存管理机制"><a href="#2-7-1-iOS的内存管理机制" class="headerlink" title="2.7.1 iOS的内存管理机制"></a>2.7.1 iOS的内存管理机制</h4><h5 id="1-64位后出现的TaggedPoint"><a href="#1-64位后出现的TaggedPoint" class="headerlink" title="1) 64位后出现的TaggedPoint"></a>1) 64位后出现的TaggedPoint</h5><p>Tagged Pointer专门用来存储例如NSNumber、NSDate、NSString等小对象数据，这种数据绝大多数4字节都够满足需求了，在64位系统下就会造成极大的浪费，所以它会将值存在Tagged Pointer，而不是将它作为一个地址，值另外存储，它的内存并不存储在堆中，不需要malloc和free，可以极大得提高创建和读写效率，并且节省内存空间。</p><ul><li>当指针(8字节)不够存储数据时，才会使用动态分配内存的方式来存储数据<ul><li>NSString达到10位就放不下了</li><li>注意：当使用字符串字面量，给NSString实例赋值时，实例的类型是__NSCFConstantString，而不会是NSTaggedPointerString。其他数据类型使用字面量创建实例时，就没有这个限制</li></ul></li><li>objc_msgSend能识别Tagged Pointer，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销(消息发送流程)</li><li>release()方法中，释放之前，会先判断是否是TaggedPointer</li><li>如何判断一个指针是否为Tagged Pointer？iOS平台，指针的最高有效位是1(第64bit);   Mac平台，指针的最低有效位是1</li></ul><h5 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="2) 引用计数"></a>2) 引用计数</h5><p>如果不是TaggedPoint，那么内存管理仍是靠引用计数的</p><h5 id="3-64位系统中，ISA的改变"><a href="#3-64位系统中，ISA的改变" class="headerlink" title="3) 64位系统中，ISA的改变"></a>3) 64位系统中，ISA的改变</h5><p>由普通的地址 → nonpointer (day10-Runtime ISA详解)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -- OBJC 1.0</span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    &#x2F;&#x2F; 在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">#pragma mark -- OBJC 2.0</span><br><span class="line">&#x2F;&#x2F;从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息</span><br><span class="line">&#x2F;**</span><br><span class="line"> 共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</span><br><span class="line"> *&#x2F;</span><br><span class="line">union isa_t</span><br><span class="line">&#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    #define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">    #define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">    #define ISA_MAGIC_VALUE 0x000001a000000001ULL  &#x2F;&#x2F; magic的值，如果对应的1a，表示对象已经初始化成功</span><br><span class="line">    #define RC_ONE          (1ULL&lt;&lt;45)</span><br><span class="line">    #define RC_HALF         (1ULL&lt;&lt;18)</span><br><span class="line">    struct &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         注意，越前面的成员放在越低位</span><br><span class="line">         p&#x2F;x obj.isa &#x3D; 0000000000000000000 0 0 0 011010 000100000000000011110100111010101 0 0 1</span><br><span class="line">                         extra_rc                 magic             shiftcls                  nonpointer</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t nonpointer        : 1;  &#x2F;&#x2F; 0 代表普通的指针，存储着Class、Meta-Class对象的内存地址； 1 代表优化过，使用位域存储更多的信息</span><br><span class="line">        &#x2F;**</span><br><span class="line">         objc_setAssociatedObject简单可以验证。</span><br><span class="line">         注意：是&#96;设置过&#96;，清除了也算。</span><br><span class="line">         如果没有，释放时会更快的意思是：见下源码</span><br><span class="line">         void *objc_destructInstance(id obj)&#123; &#x2F;&#x2F; objc-runtime-new.mm，对象在释放时调用</span><br><span class="line">             if (obj) &#123;</span><br><span class="line">                 if (obj-&gt;hasCxxDtor()) object_cxxDestruct(obj);  &#x2F;&#x2F; 有析构函数，调用析构函数</span><br><span class="line">                 if (obj-&gt;hasAssociatedObjects()) _object_remove_assocations(obj); &#x2F;&#x2F; 有关联对象，移除关联对象</span><br><span class="line">                 obj-&gt;clearDeallocating();</span><br><span class="line">             &#125;</span><br><span class="line">             return obj;</span><br><span class="line">         &#125;</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t has_assoc         : 1;  &#x2F;&#x2F; 是否有设置过关联对象(associatedObject)，如果没有，释放时会更快</span><br><span class="line">        &#x2F;**</span><br><span class="line">         析构函数(destructor)与构造函数相反，是当对象的生命周期结束时，自动地被调用运行。它最主要的目的在于，清空并释放对象先前创建或是占用的存储器资源。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;  &#x2F;&#x2F; 是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</span><br><span class="line">        uintptr_t shiftcls          : 33; &#x2F;&#x2F; shift cls 存储着Class、Meta-Class对象的内存地址信息</span><br><span class="line">        uintptr_t magic             : 6;  &#x2F;&#x2F; 用于在调试时分辨对象是否未完成初始化</span><br><span class="line">        &#x2F;**</span><br><span class="line">         加个__weak简单可以验证。</span><br><span class="line">         注意：是&#96;指向过&#96;，弱引用销毁了也算</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t weakly_referenced : 1;  &#x2F;&#x2F; 是否有被弱引用指向过，如果没有，释放时会更快</span><br><span class="line">        uintptr_t deallocating      : 1;  &#x2F;&#x2F; 对象是否正在释放</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;  &#x2F;&#x2F; 引用计数器是否过大无法存储在isa(extra_rc字段)中。如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</span><br><span class="line">        uintptr_t extra_rc          : 19; &#x2F;&#x2F; 里面存储的值是引用计数器减1 （举例的对象引用计数器是1，所以这里是0）</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-SideTables-—-引用计数、Weak引用的管理"><a href="#4-SideTables-—-引用计数、Weak引用的管理" class="headerlink" title="4) SideTables — 引用计数、Weak引用的管理"></a>4) SideTables — 引用计数、Weak引用的管理</h5><ul><li>weak哈希表怎么保存键值对的，说说哈希表的实现，以什么作为key保存到哈希表的</li></ul><p><img src="../../images/Interview/SideTables.png" alt="SideTables"></p><ul><li>弱引用表在APP中存在什么位置？(微博) MachO哪个段？数据段吧</li></ul><h5 id="5-C指针需要自己管理释放"><a href="#5-C指针需要自己管理释放" class="headerlink" title="5) C指针需要自己管理释放"></a>5) C指针需要自己管理释放</h5><h4 id="2-7-2-手写一个MRC-setter方法"><a href="#2-7-2-手写一个MRC-setter方法" class="headerlink" title="2.7.2 手写一个MRC setter方法"></a>2.7.2 手写一个MRC setter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)setCar:(MJCar *)car</span><br><span class="line">&#123;</span><br><span class="line">    if (_car !&#x3D; car) &#123;   &#x2F;&#x2F; 需要先判断赋值与正在持有的值是否是同一个，避免错误release</span><br><span class="line">        [_car release];  &#x2F;&#x2F; 赋值之前，需要将之前的数据release</span><br><span class="line">        _car &#x3D; [car retain]; </span><br><span class="line">      &#x2F;*</span><br><span class="line">      MRC下：赋值给属性，引用计数是+1的，赋值给成员变量，引用计数不变。区别主要是在于Setter方法内部做的一次retain操作</span><br><span class="line">      ARC下：给成员变量赋值，也会对被赋值对象造成强引用(ARC下通过KVC来访问私有API)。</span><br><span class="line">      *&#x2F; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-3-weak的实现原理"><a href="#2-7-3-weak的实现原理" class="headerlink" title="2.7.3 weak的实现原理"></a>2.7.3 weak的实现原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">▼ dealloc</span><br><span class="line">  ▼ _objc_rootDealloc</span><br><span class="line">    ▼ rootDealloc</span><br><span class="line">      ▶ free</span><br><span class="line">      ▼ object_dispose</span><br><span class="line">        ▼ objc_destructInstance</span><br><span class="line">          ▶ object_cxxDestruct          &#x2F;&#x2F;调用C++析构函数(如果有的话)，会清除自己的成员变量</span><br><span class="line">          ▶ _object_remove_assocations  &#x2F;&#x2F;移除关联对象</span><br><span class="line">          ▶ clearDeallocating           &#x2F;&#x2F;将指向当前对象的弱指针置为nil</span><br><span class="line">        ▶ free</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">__weak <span class="keyword">typeof</span>(self) weakSelf = self;</span><br><span class="line">[weakSelf method];  <span class="comment">// 是否有问题？会崩溃，weak源码里会判断是否是deallocing，是这个状态的话就直接抛出异常了</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)method&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-4-野指针、僵尸对象"><a href="#2-7-4-野指针、僵尸对象" class="headerlink" title="2.7.4 野指针、僵尸对象"></a>2.7.4 野指针、僵尸对象</h4><ul><li><p>野指针：地址值是个不合法的地址。</p><ul><li>可能是不能访问的区域</li><li>可能是数据已经被释放</li></ul></li><li><p>僵尸对象：1个已经被释放的对象 就叫做僵尸对象。</p></li><li><p>使用**<code>野指针访问僵尸对象</code><strong>有的时候会出问题报错（</strong><code>EXC_BAD_ACCESS</code>**），有的时候不会出问题。</p><p>当OC对象<code>引用计数为0被释放</code>就变成了僵尸对象，此时僵尸对象的内存已经被系统回收，虽然该对象的数据可能还存在于内存中(申请空间时，才初始化)，但僵尸对象已经不是稳定对象，不可以再访问或者使用，它的内存是随时可能被别的对象申请而占用的。</p></li><li><p>僵尸对象的检测：在Xcode中设置Edit Scheme -&gt; Diagnostics -&gt; Zombie Objects</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zombie Objects hook 住了对象的dealloc方法，在回收对象时，不将其真的回收，而是把它转化为僵尸对象。这种对象所在的内存无法重用，因此不可遭到重写，所以将随机变成必然。</span><br><span class="line">系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择器，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序，这非常有利于调试。</span><br></pre></td></tr></table></figure></li><li><p>修改：检测到之后，把野指针置为nil即可</p></li></ul><h3 id="2-8-属性关键字、对象所有权修饰符"><a href="#2-8-属性关键字、对象所有权修饰符" class="headerlink" title="2.8 属性关键字、对象所有权修饰符"></a>2.8 属性关键字、对象所有权修饰符</h3><p>参考链接：<a href="https://juejin.cn/post/6844904067425124366">OC - 属性关键字和所有权修饰符</a></p><h4 id="2-8-1-assign-和-weak-关键字的区别有哪些？"><a href="#2-8-1-assign-和-weak-关键字的区别有哪些？" class="headerlink" title="2.8.1 assign 和 weak 关键字的区别有哪些？"></a>2.8.1 assign 和 weak 关键字的区别有哪些？</h4><ul><li><code>weak</code>只能修饰对象，而<code>assign</code>既可以修饰对象也可以修饰基本数据类型；</li><li><code>assign</code>修饰的对象在被释放后，指针仍然指向原对象地址；而<code>weak</code>修饰的对象在被释放之后会自动置指针为 nil；</li><li>相同点：在修饰对象的时候，<code>assign</code>和<code>weak</code>都不改变对象的引用计数。</li></ul><h4 id="2-8-2-copy-strong的底层实现-百度"><a href="#2-8-2-copy-strong的底层实现-百度" class="headerlink" title="2.8.2 copy strong的底层实现(百度)"></a>2.8.2 copy strong的底层实现(百度)</h4><p><a href="https://www.jianshu.com/p/bc16a644784d">https://www.jianshu.com/p/bc16a644784d</a></p><p><strong>结论</strong></p><ul><li><code>copy</code>和<code>strong</code>修饰的属性在底层编译的不一致，主要还是llvm中对其进行了不同的处理的结果。<code>copy</code>的赋值是通过<code>objc_setProperty</code>，而strong的赋值时通过<code>self + 内存平移</code>（即将指针通过平移移至name所在的位置，然后赋值），然后还原成 <code>strong</code>类型</li><li><code>strong &amp; copy</code> 在底层调用<code>objc_storeStrong</code>，本质是<code>新值retain，旧值release</code></li><li><code>weak</code> 在底层调用<code>objc_initWeak</code></li></ul><h2 id="三、运行库与三方库API"><a href="#三、运行库与三方库API" class="headerlink" title="三、运行库与三方库API"></a>三、运行库与三方库API</h2><h3 id="3-1-UI-—-UIKit-与-QuartzCore"><a href="#3-1-UI-—-UIKit-与-QuartzCore" class="headerlink" title="3.1 UI — UIKit 与 QuartzCore"></a>3.1 UI — UIKit 与 QuartzCore</h3><h4 id="3-1-1-触摸事件的分发机制"><a href="#3-1-1-触摸事件的分发机制" class="headerlink" title="3.1.1 触摸事件的分发机制"></a>3.1.1 触摸事件的分发机制</h4><p><a href="https://www.jianshu.com/p/74a2f44840fa">参考链接</a></p><ul><li>hitTest:withEvent:</li><li>pointInside:withEvent:</li></ul><h4 id="3-1-2-异步渲染"><a href="#3-1-2-异步渲染" class="headerlink" title="3.1.2 异步渲染"></a>3.1.2 异步渲染</h4><p>异步渲染就是在子线程进行绘制，然后拿到主线程显示。</p><p>UIView的显示是通过CALayer实现的，CALayer的显示则是通过contents进行的。异步渲染的实现原理是当我们改变UIView的frame时，会调用layer的setNeedsDisplay，然后调用layer的display方法。我们不能在非主线程将内容绘制到layer的context上，但我们单独开一个子线程通过<code>CGBitmapContextCreateImage()</code>绘制内容，绘制完成之后切回主线程，将内容赋值到contents上。</p><h4 id="3-1-3-离屏渲染"><a href="#3-1-3-离屏渲染" class="headerlink" title="3.1.3 离屏渲染"></a>3.1.3 离屏渲染</h4><p>什么是离屏渲染？</p><ul><li>如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域。如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。</li></ul><p>什么情况会导致离屏渲染？</p><ul><li><p>以阴影为例，为什么它会导致离屏渲染。因为<a href="https://cloud.tencent.com/product/gpu?from=10680">GPU</a>的渲染是遵循“画家算法”，一层一层绘制的，但阴影很特殊，它需要全部内容绘制完成，再根据外轮廓进行绘制。这就导致了，阴影这一层要一直占据一块内存区域，这就导致了离屏渲染。</p></li><li><p>类似导致离屏渲染的情况还有：</p><ul><li>cornerRadius+clipsToBounds</li><li>group opacity 组透明度</li><li>mask 遮罩</li><li>UIBlurEffect 毛玻璃效果</li></ul></li></ul><p>有一篇文章详细的讨论了这些情况：<a href="https://zhuanlan.zhihu.com/p/72653360">关于iOS离屏渲染的深入研究</a></p><h4 id="3-1-4-UIView与CALayer的关系"><a href="#3-1-4-UIView与CALayer的关系" class="headerlink" title="3.1.4 UIView与CALayer的关系"></a>3.1.4 UIView与CALayer的关系</h4><ul><li><p>创建UIView对象时，UIView内部会自动创建一个层(CALayer对象)，通过UIView的layer属性可以访问这个层。当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图渲染，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了UIView的显示</p></li><li><p>UIView相比CALayer最大区别是UIView继承自UIResponder，可以响应用户事件，而CALayer不可以；UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。</p></li><li><p>UIView本身，更像是一个CALayer的管理器，访问它的和绘图、坐标相关的属性，如frame，bounds等，实际上内部都是访问它所在CALayer的相关属性</p></li><li><p>UIView和CALayer是相互依赖的关系。UIView依赖CALayer提供的内容，CALayer依赖UIView提供的容器来显示绘制的内容。归根到底CALayer是这一切的基础，如果没有CALayer，UIView自身也不会存在，UIView是一个特殊的CALayer实现，添加了响应事件的能力。</p></li><li><p>高级：UIView的layer树形在系统内部被系统维护着三份copy</p><ul><li>逻辑树：就是代码里可以操纵的，例如更改layer的属性（阴影，圆角等）就在这一份</li><li>动画树：这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作</li><li>显示树：这棵树的内容是当前正被显示在屏幕上的内容</li><li>这三棵树的逻辑结构都是一样的，区别只有各自的属性</li></ul></li></ul><h4 id="3-1-5-Core-Animation"><a href="#3-1-5-Core-Animation" class="headerlink" title="3.1.5 Core Animation"></a>3.1.5 Core Animation</h4><ul><li><p>与UIView动画的关系：UIView动画其实就是对Core Animation的一种封装，向客户程序员呈现更简洁的接口</p></li><li><p>动画执行过程中是否响应事件？UIView的block animation在执行过程中不能响应其自身的触摸事件。</p></li><li><p>动画的属性（字节）</p><ul><li>CAAnimation  anchorpoint fillmode fillModeforward</li></ul></li></ul><h4 id="3-1-6-UITableView重用机制"><a href="#3-1-6-UITableView重用机制" class="headerlink" title="3.1.6 UITableView重用机制"></a>3.1.6 UITableView重用机制</h4><h4 id="3-1-7-CADisplayLink"><a href="#3-1-7-CADisplayLink" class="headerlink" title="3.1.7 CADisplayLink"></a>3.1.7 CADisplayLink</h4><p><strong>CADisplayLink是一个定时器对象，它可以让你与屏幕刷新频率相同的速率来刷新你的视图</strong><br> 目前iOS中的屏幕刷新速率是60Hz。也就是每秒刷新60次。那么我们可以利用CADisplayLink对象使我们想要执行的代码块每秒执行60次。当然我们也可以设置CADisplayLink的属性<code>preferredFramesPerSecond</code>来改变刷新次数为30次或15次。</p><p>CADisplayLink为什么比NSTimer精确？</p><ul><li><p>CADisplayLink 和 NSTimer 都需要注册到 runloop 的 model</p></li><li><p>iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。</p><p>那如果掉帧，CADisplayLink肯定也受影响吧</p></li><li><p> 既然都依赖 runloop，为什么NSTimer就会被runloop影响的不精确，CADisaplyLink就没事呢？</p></li><li><p><a href="https://www.cnblogs.com/xyq-208910/p/6590829.html">https://www.cnblogs.com/xyq-208910/p/6590829.html</a></p></li></ul><h3 id="3-2-Foundation"><a href="#3-2-Foundation" class="headerlink" title="3.2 Foundation"></a>3.2 Foundation</h3><ul><li>NSString、NSArray相关的类簇概念了解一下<ul><li>当hook方法时，要用真正的类名，不能用这个类簇名</li></ul></li></ul><h3 id="3-3-WebKit-—-WKWebview"><a href="#3-3-WebKit-—-WKWebview" class="headerlink" title="3.3 WebKit — WKWebview"></a>3.3 WebKit — WKWebview</h3><ul><li>cookie同步</li><li>post body</li><li>webp图片处理</li><li>NSURLProtocol的机制，有什么问题，拦截的成功率</li><li>除了NSURLProtocol还有什么方式能拦截请求：说hook ajax xmlhttprequest的open set方法</li><li>白屏检测：为什么会白屏，怎么监测，webViewWebContentProcessDidTerminate触发了就是白屏？因为其他问题，WK进程崩溃了，这个方法就不会调用吗</li><li>白屏优化</li><li>BRBridge的通信机制<ul><li>数据是怎么传递的，复杂数据是怎么编码、序列化、反序列化的</li><li>为什么要用iframe，原生的API message那一套行不行。不够灵活，且有兼容性，UIWebView、WKWebView之间不能无缝衔接</li></ul></li><li>webview的优化点：<ul><li>缓存</li><li>WKWebview进程是单独的，启动时涉及内核，所以耗时？要进行相关的优化吗？进程开始就创建一个，really？还是扯呢</li><li>HTTP2.0 相比HTTP1.1，报文压缩，加快传输速度</li><li>Webp图片压缩</li></ul></li></ul><h3 id="3-4-常见三方库"><a href="#3-4-常见三方库" class="headerlink" title="3.4 常见三方库"></a>3.4 常见三方库</h3><ul><li>看过什么源码</li><li>是带着问题看的，还是系统得看</li><li>带着什么问题，找到答案了吗。比如atomic的实现</li><li>二面确实就是问优化的东西：SD 和YYCache的缓存机制的区别，以及淘汰规则，最后设计一个LRU的方案</li><li>lottie的原理：lottie json 描述了 关键帧和参数，iOS通过解析iOS，转为代码 就可以实现动画</li></ul><h3 id="3-5-图像处理相关"><a href="#3-5-图像处理相关" class="headerlink" title="3.5 图像处理相关"></a>3.5 图像处理相关</h3><ul><li>png图片压缩机制</li><li>jpg png sd底层能够是如何解析的</li><li>webp 和 Lottie 在对动图的优化，webp压缩算法 丢弃了什么(通过丢掉 高频部分，达到一定程度的压缩??)<ul><li>webp 虽然解码时间边长了，但是100k的图片能压缩到4k不到？</li></ul></li></ul><h3 id="3-6-音视频相关"><a href="#3-6-音视频相关" class="headerlink" title="3.6 音视频相关"></a>3.6 音视频相关</h3><ul><li><a href="https://mp.weixin.qq.com/s/IGA3caeXMB-upTFiV8MuYg">极致首帧播放方案 - 零首帧解决方案 — 字节</a></li><li>学习资料，见《多读书》</li></ul><h3 id="3-6-Others"><a href="#3-6-Others" class="headerlink" title="3.6 Others"></a>3.6 Others</h3><ul><li>App 换肤(字节)</li><li>骨架屏：<a href="https://github.com/tigerAndBull/TABAnimated">https://github.com/tigerAndBull/TABAnimated</a></li><li>一个UIView如何实现UIScrollView，思路？加手势 调整 bounds？</li></ul><h2 id="四、操作系统"><a href="#四、操作系统" class="headerlink" title="四、操作系统"></a>四、操作系统</h2><h3 id="4-1-多线程"><a href="#4-1-多线程" class="headerlink" title="4.1 多线程"></a>4.1 多线程</h3><h4 id="4-1-1-概念"><a href="#4-1-1-概念" class="headerlink" title="4.1.1 概念"></a>4.1.1 概念</h4><p><img src="../../images/Interview/Thread.png" alt="Thread"></p><h4 id="4-1-2-多线程的几种方案"><a href="#4-1-2-多线程的几种方案" class="headerlink" title="4.1.2 多线程的几种方案"></a>4.1.2 多线程的几种方案</h4><p>NSThread、GCD、NSOperationQueue的区别？各自的一些优点，以及应用场景</p><ul><li>NSThread：实现常驻线程，创建并开启RunLoop</li><li>GCD：dispatch_group、dispatch_barry、</li><li>NSOperationQueue：面向对象的封装，可以监控任务的状态、取消任务</li></ul><h4 id="4-1-3-串行-并行、同步-异步"><a href="#4-1-3-串行-并行、同步-异步" class="headerlink" title="4.1.3 串行/并行、同步/异步"></a>4.1.3 串行/并行、同步/异步</h4><ul><li>串行与并行是队列的属性：一个队列中，可以放很多task任务。<code>影响的是任务的执行方式</code><ul><li>串行队列：队列中的任务依次执行，一个执行完成之后，下一个才能开始(一次放出一个)</li><li>并行队列：队列中的任务并发执行，一个执行的同时，另一个可以同时执行(每当CPU访问该队列就放出一个)</li></ul></li><li>同步与异步是，同步异步函数赐予任务task的属性。<code>影响的是能不能开启新的线程</code></li><li>异步和一个并行队列结合：发布一次任务，就创建一个子线程，所以发布了多少个任务，会同时存在多少个线程(假设任务执行时间够长、系统不限制最大线程数)</li><li>异步和一个串行队列结合：发布一次任务，就创建一个子线程，但是无论发布多少次任务，都是同时只存在一个子线程(因为上一个任务完成，线程就回收了)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;微博一面：下面程序的耗时、打印顺序。A方法耗时2s</span><br><span class="line">dispatch_queue_t aSerialQueue &#x3D; dispatch_queue_create(“xxx_name”,DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">dispatch_async(aSerialQueue, ^(void) &#123;</span><br><span class="line">&#x2F;&#x2F; 1.执行方法A </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(aSerialQueue, ^(void) &#123;</span><br><span class="line">&#x2F;&#x2F; 2.执行方法A </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.执行方法A</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;答：1-2-3, 6s</span><br></pre></td></tr></table></figure><h4 id="4-1-4-常见的线程同步的手段"><a href="#4-1-4-常见的线程同步的手段" class="headerlink" title="4.1.4 常见的线程同步的手段"></a>4.1.4 常见的线程同步的手段</h4><ul><li><p>原子操作</p><p>我们在声明一个变量的时候一般会使用<code>nonatomic</code>，这个就是非原子操作；原子操作是<code>atomic</code>。</p><p>简单的加减使用原子操作具有更高的性能优势。注意是加减，不是增删！！</p><p>也就是说仅仅对于getter,setter是线程安全的，两个线程都去对变量赋值是安全的。对于比如NSMutableArray类型的增删操作不是线程安全的</p></li><li><p>线程锁</p><p>锁可以保护临界区，代码在临界区同一时间只会被一个线程执行。有互斥锁、递归锁、读写锁、分布锁、自旋锁、双重检查锁等等。</p></li><li><p>条件、信号量</p><p>有个BOOL类型的变量，当线程A进入临界区时把BOOL值置为NO，如果线程B准备进入临界区时发现BOOL值为NO就挂起等待，当线程A出临界区时把BOOL置为YES，线程B会被唤醒并继续执行。</p><p>条件就是使用信号量在线程之间相互发生信号。</p><p>条件通常被使用来说明资源可用性，或用来确保任务以特定的顺序执行。</p></li><li><p>使用Selector</p><p>selector方法允许你的线程以异步的方式来传递消息，以确保它们在同一个线程上面执行是同步的。</p><p>比如<code>NSObject</code>中的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performSelector:withObject:afterDelay:</span><br><span class="line">performSelectorInBackground:withObject:</span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-1-4-都有哪些锁"><a href="#4-1-4-都有哪些锁" class="headerlink" title="4.1.4 都有哪些锁"></a>4.1.4 都有哪些锁</h4><p>互斥锁、递归锁、读写锁、分布锁、自旋锁、双重检查锁等等</p><ul><li>说说读写锁</li></ul><p>分类自旋锁、互斥锁。性能从高到低排序(仅供参考，不同环境下有差异)</p><ul><li>os_unfair_lock(iOS10)</li><li>OSSpinLock</li><li>dispatch_semaphore(常用)</li><li>pthread_mutex（常用）</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSCondition</li><li>pthread_mutex(recursive) （为了保证能递归加锁，内部肯定是有一些逻辑的，所以性能上稍差点）</li><li>NSRecursiveLock</li><li>NSConditionLock</li><li>@synchronized</li></ul><h4 id="4-1-5-死锁"><a href="#4-1-5-死锁" class="headerlink" title="4.1.5 死锁"></a>4.1.5 死锁</h4><p>死锁的原因：只有4个条件都满足时，才会出现死锁。</p><ul><li>互斥(Mutual exclusion)：任一时刻只允许一个进程使用资源;</li><li>请求和保持(Request and hold)：进程在请求其余资源时，不主动释放已经占用的资源; </li><li>非剥夺(Nonpreemptive)：进程已经占用的资源，不会被强制剥夺;</li><li>环路等待(Circular Wait)：环路中的每一条边是进程在请求另一进程已经占有的资源。</li></ul><p>如何解决？</p><h4 id="4-1-6-其他常见问题"><a href="#4-1-6-其他常见问题" class="headerlink" title="4.1.6 其他常见问题"></a>4.1.6 其他常见问题</h4><ul><li><p>如果要在GCD里面取消任务 怎么操作</p></li><li><p>创建队列的时候， 这个 label 你有没有用到过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure></li><li><p>多线程并发，多少比较合适，有没有了解过相关的标准。AFN、SD中都是多少</p></li><li><p>如果有多个任务来回做，它们有优先级的处理，要怎么做？（线程的优先级、任务的优先级可以理解为一个东西，都是任务的优先级，它与线程是绑定的）</p></li><li><p>已经执行的任务可能干扰不了，那排队未执行的任务根据优先级要怎么调整</p></li><li><p>多个异步任务依赖的处理方案</p></li><li><p>多读单写的实现：pthread_rwlock、dispatch_barrier_async</p></li><li><p>atomic是线程安全吗</p><p>atomic只能保证setter、getter方法之间是线程安全的。并不能保证使用属性、方法的过程是线程安全的，比如对NSMutableArray实例的使用，setter、getter过程是安全的，但接下来对NSMutableArray实例的使用（addObject）是有线程安全隐患的。还需要自己加锁</p><p>或者说，若属性是指针类型，只能保证对属性这个指针变量本身的读写是线程安全的，并不保证对指针指向的内存空间的读写是否线程安全</p></li><li><p>题目：启动N个线程，这N个线程要不间断按顺序打印数字1-N</p></li><li><p>多线程的线程安全问题(微博)</p></li></ul><h3 id="4-2-文件系统"><a href="#4-2-文件系统" class="headerlink" title="4.2 文件系统"></a>4.2 文件系统</h3><p>请尽可能详细地描述从磁盘上读取一份数据到CPU进行处理的过程中发生了什么？（网易，以下非标准答案）</p><ol><li>代码申请fopen，通过syscall中断进入内核态</li><li>内核开始在自己的结构体中寻找文件指向的vnode，检查文件权限和状态之后，创建file descriptor返回给程序</li><li>程序继续运行，申请读取文件，再次陷入内核态</li><li>内核发起IO中断，由文件系统驱动handle文件系统驱动进一步联系磁盘驱动，磁盘驱动转专交IO中断处理权给硬件</li><li>硬件读取文件内容进入mapped IO virtual memory就绪以后再次启动IO中断返回内核</li><li>内核从mapped vm内读取内容，在SMAP机制的设备上会继续调用copy_out将数据从内核态转移到进程的user space vm内</li><li>程序开始读取内核转交的内存</li></ol><h2 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a>五、计算机网络</h2><p>请尽可能详细的描述在浏览器上输入一个网页地址到整个网页完全展示的过程中发生了什么？(网易，以下非标准答案)</p><ol><li>解析URL浏览器识别scheme头，识别类型http:// https:// mailto:// schemeHeaders://等，并应用用户的设置</li><li>解析URL识别到网页URI，发起dns请求定向主机，成功以后，开始准备协议: http协议、https协议。发起tcp连接，Chrome浏览器可能在一次tcp中传输多个http内容</li><li>https证书校验。强制https设置检查，检查是否有https网站请求了http资源，检查完成以后开始下载资源</li><li>网页html开始加载。通过chromium， webkit等引擎渲染网页，每一个资源下载完成都会触发一次差异渲染，但也有浏览器策略会要求全部css和js下载完成才开始渲染内容</li><li>调用网页申请的初始化js</li><li>渲染完成以后进入runloop监听事件，处理用户输入，调用js</li></ol><ol><li>首先是DNS解析。</li><li>数据链路层-源mac本机，如果是局域网，目的mac就是服务器的mac。如果是广域网目的mac就是路由器的mac。</li><li>ip层-源ip本机，如果是局域网，目的ip就是服务器的ip。如果是广域网目的ip就是路由器的ip。</li><li>tcp层-源端口系统随机分配，目的端口HTTP的话默认是80端口 HTTPS443</li><li>tcp三次握手，如果是https还有tls四次握手。</li><li>开始传输http数据。</li></ol><h3 id="5-1-HTTP1-1-2-0"><a href="#5-1-HTTP1-1-2-0" class="headerlink" title="5.1 HTTP1.1 2.0"></a>5.1 HTTP1.1 2.0</h3><ul><li><p>霜神的HTTP网络全套的blog</p></li><li><p>HTTPS与HTTP的关系，就是加了个SSL？SSL与TLS的关系</p></li><li><p>HTTP2.0了解吗，相比之前的优化</p><ul><li>报文压缩</li><li>请求头压缩，是怎么压缩的？</li><li>多路复用、分用</li><li>服务器推送？</li></ul></li></ul><h3 id="5-2-HTTPS"><a href="#5-2-HTTPS" class="headerlink" title="5.2 HTTPS"></a>5.2 HTTPS</h3><p><a href="https://juejin.cn/post/6844903901037084686">https://juejin.cn/post/6844903901037084686</a></p><h4 id="5-2-1-连接过程"><a href="#5-2-1-连接过程" class="headerlink" title="5.2.1 连接过程"></a>5.2.1 连接过程</h4><ul><li><p>HTTPS的连接过程：TLS SSL 预置密钥</p></li><li><p>握手阶段细分为五步: </p><ol><li>客户端发送出协议版本号，一个客户端生成的随机数，以及客户端支持的加密方法。 </li><li>服务端确认双方使用的加密方法，并给出数字证书以及一个服务器生成的随机数。</li><li>客户端确认数字证书有效，然后生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，发送给服务端。</li><li>服务端使用自己的私钥，解密出随机数。 </li><li>客户端和服务端根据约定的加密方法，使用前面的三个随机数生成对话密钥，用来加密接下来的对话。</li></ol></li><li><p>预备主密钥？？</p></li><li><p>如果第4步失败了，两端会怎么办？不知道是不是下面这个答案 <a href="https://halfrost.com/https_tls1-2_handshake/#toc-6">https://halfrost.com/https_tls1-2_handshake/#toc-6</a></p><ul><li>Server 拿到 EncryptedPreMasterSecret 以后，用自己的 RSA 私钥解密。解密以后还需要再次校验 PreMasterSecret 中的 ProtocolVersion 和 ClientHello 中传递的 ProtocolVersion 是否一致。如果不相等，校验失败，Server 会根据下面说的规则重新生成 PreMasterSecret，并继续进行握手。</li><li>在任何情况下，如果处理一个 RSA 加密的预备主密钥消息失败的时候，或版本号不是期望的时候，一个 TLS Server 一定不能产生一个警报。作为替代，它必须以一个随机生成的预备主密钥继续握手流程。出于定位问题的意图将失败的真正原因记录在日志中可能是有帮助的。但必须注意避免泄露信息给攻击者（例如，计时，日志文件或其它渠道）</li></ul></li></ul><h4 id="5-2-2-CA证书"><a href="#5-2-2-CA证书" class="headerlink" title="5.2.2 CA证书"></a>5.2.2 CA证书</h4><p>其中有什么内容：颁发机构、过期时间、密钥</p><h3 id="5-3-TCP"><a href="#5-3-TCP" class="headerlink" title="5.3 TCP"></a>5.3 TCP</h3><ul><li><p>TCP协议的流量控制机制、分片原理</p></li><li><p>三次握手与四次挥手</p><ul><li><p>讲一下三次握手与四次挥手的过程。握手为什么要三次、挥手为什么要四次？</p></li><li><p>三次握手与四次挥手：<a href="https://mp.weixin.qq.com/s/CzhBX1H_H37xFWEiYkumZw">https://mp.weixin.qq.com/s/CzhBX1H_H37xFWEiYkumZw</a></p></li><li><p>三次握手：<a href="https://mp.weixin.qq.com/s/EEAADJBQwvgPiVwagUxUcg">https://mp.weixin.qq.com/s/EEAADJBQwvgPiVwagUxUcg</a></p></li><li><p>四次挥手：<a href="https://mp.weixin.qq.com/s/oRBCqEcvfX7HEOWWx9i1RA">https://mp.weixin.qq.com/s/oRBCqEcvfX7HEOWWx9i1RA</a></p></li></ul></li></ul><h3 id="5-4-Socket"><a href="#5-4-Socket" class="headerlink" title="5.4 Socket"></a>5.4 Socket</h3><ul><li>socket保证连接，心跳包</li></ul><h3 id="5-5-断点下载实现原理"><a href="#5-5-断点下载实现原理" class="headerlink" title="5.5 断点下载实现原理"></a>5.5 断点下载实现原理</h3><h3 id="5-6-POST数据格式"><a href="#5-6-POST数据格式" class="headerlink" title="5.6 POST数据格式"></a>5.6 POST数据格式</h3><p>默认POST提交方式是application/x-www-form-urlencoded，这个是application/json</p><h2 id="六、编译、链接、装载"><a href="#六、编译、链接、装载" class="headerlink" title="六、编译、链接、装载"></a>六、编译、链接、装载</h2><ul><li>编译过程<ul><li>中间的binding过程，可以做什么优化：减少动态库、动态库改静态库？</li></ul></li><li>app启动流程，从启动经历了哪些步骤</li><li>堆栈符号化定位</li><li>写一个APP，原则上一个文件就能搞定所有的事情，我们为什么还搞那么多文件，那么多类</li><li>内存和虚拟内存 如何映射</li><li>混合架构的framework 静态库 需要分离么</li><li>静态库中包含分类文件，如何调用。</li><li>为什么需要加Objc，静态库的加载流程，Objc的语义？</li><li>组件化编译慢怎么解决？</li></ul><h2 id="七、数据库"><a href="#七、数据库" class="headerlink" title="七、数据库"></a>七、数据库</h2><ul><li>以txt文本文件为例，实现类似数据库的增删改查，比如存储信息为通讯录：姓名 电话 手机号 超长的介绍</li><li>存储 文件和数据库 选择</li><li>比fmdb更好的优化方案</li></ul><h3 id="7-1-Protocol-Buffers-PB"><a href="#7-1-Protocol-Buffers-PB" class="headerlink" title="7.1 Protocol Buffers(PB)"></a>7.1 Protocol Buffers(PB)</h3><p>Protocol Buffers(简称Protobuf, PB) ，是Google出品的序列化框架，与开发语言无关，和平台无关，具有良好的可扩展性。Protobuf和所有的序列化框架一样，都可以用于数据存储、通讯协议。</p><p>Protobuf支持生成代码的语言包括Java、Python、C++、Go、JavaNano、Ruby、C#，<a href="https://link.jianshu.com/?t=https://developers.google.com/protocol-buffers/">官网地址</a>。</p><p>Portobuf的序列化的结果体积要比XML、JSON小很多，XML和JSON的描述信息太多了，导致消息要大；此外Portobuf还使用了Varint 编码，减少数据对空间的占用。</p><p>Portobuf序列化和反序列化速度比XML、JSON快很多，是直接把对象和字节数组做转换，而XML和JSON还需要构建成XML或者JSON对象结构。</p><p><a href="https://juejin.cn/post/6844903622266847246">https://juejin.cn/post/6844903622266847246</a></p><ul><li>protobuf 是怎么进行解析的， 有啥可以优化点</li></ul><h2 id="八、软件工程"><a href="#八、软件工程" class="headerlink" title="八、软件工程"></a>八、软件工程</h2><h3 id="8-1-工程化"><a href="#8-1-工程化" class="headerlink" title="8.1 工程化"></a>8.1 工程化</h3><h3 id="8-2-UML"><a href="#8-2-UML" class="headerlink" title="8.2 UML"></a>8.2 UML</h3><p><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80">UML</a> 是统一建模语言的简称，它是一种由一整套图表组成的标准化建模语言。UML用于帮助系统开发人员阐明，展示，构建和记录软件系统的产出。UML代表了一系列在大型而复杂系统建模中被证明是成功的做法，是开发面向对象软件和软件开发过程中非常重要的一部分。UML主要使用图形符号来表示软件项目的设计，使用UML可以帮助项目团队沟通、探索潜在的设计和验证软件的架构设计。</p><p>UML 图表可大致分为结构性图表和行为性图表两种。</p><ul><li><p>结构性图表显示了系统在不同抽象层次和实现层次上的静态结构以及它们之间的相互关系。</p></li><li><p>结构性图表中的元素表示系统中具意义的概念，可能包括抽象的、现实的和實作的概念。</p></li><li><p>结构性图表有七种类型：类图、组件图…</p></li></ul><p>类图可以没用过，但最起码能看懂会画</p><h2 id="九、设计模式与框架"><a href="#九、设计模式与框架" class="headerlink" title="九、设计模式与框架"></a>九、设计模式与框架</h2><h3 id="9-1-Apple-MVC与传统MVC"><a href="#9-1-Apple-MVC与传统MVC" class="headerlink" title="9.1 Apple MVC与传统MVC"></a>9.1 Apple MVC与传统MVC</h3><h3 id="9-2-MVVM"><a href="#9-2-MVVM" class="headerlink" title="9.2 MVVM"></a>9.2 MVVM</h3><ul><li>RAC 冷信号</li><li>RAC 数据流</li><li>RAC 如果出现 A-&gt;B-&gt;C-&gt;A, 那么怎么断环</li></ul><h3 id="9-3-MVP"><a href="#9-3-MVP" class="headerlink" title="9.3 MVP"></a>9.3 MVP</h3><p>优点：说了相比MVC的改进</p><p>缺点：说了相比MVVM的不足</p><h3 id="9-4-组件化"><a href="#9-4-组件化" class="headerlink" title="9.4 组件化"></a>9.4 组件化</h3><ul><li>模块解耦：中心化 去中心化</li><li>组件化、模块化的理解：划分粒度</li><li>组件化：多仓库、路由</li><li>组件化二进制化<ul><li>有赞：<a href="https://tech.youzan.com/you-zan-ji-yu-er-jin-zhi-de-bian-yi-ti-xiao-ce-lue/">https://tech.youzan.com/you-zan-ji-yu-er-jin-zhi-de-bian-yi-ti-xiao-ce-lue/</a></li><li>知乎：<a href="https://www.infoq.cn/article/hxh8ceu6st5xwolyynt8">https://www.infoq.cn/article/hxh8ceu6st5xwolyynt8</a></li></ul></li></ul><h3 id="9-5-设计模式"><a href="#9-5-设计模式" class="headerlink" title="9.5 设计模式"></a>9.5 设计模式</h3><ul><li><p>常用的设计模式，熟练哪一个，用纸笔画一下类图，什么结构、联系</p></li><li><p>平时会画类图吗，如果不画，那平时设计架构，怎么跟别人沟通讲解呢，每个类在干什么、具体什么联系、别人怎么修改你的</p></li><li><p>一些设计模式的优缺点</p></li><li><p>看过AF源码 ，AF用了哪些设计模式（58同城）</p></li></ul><h2 id="十、性能问题监测及优化-必问"><a href="#十、性能问题监测及优化-必问" class="headerlink" title="十、性能问题监测及优化(必问)"></a>十、性能问题监测及优化(必问)</h2><h3 id="10-1-流畅性-FPS"><a href="#10-1-流畅性-FPS" class="headerlink" title="10.1 流畅性(FPS)"></a>10.1 流畅性(FPS)</h3><ul><li><a href="https://blog.csdn.net/Hello_Hwc/article/details/84311933?utm_source=app&app_version=4.5.7">iOS 性能优化 - TimeProfiler分析代码耗时</a></li><li>卡顿检测：<ul><li>例如runloop能检测卡顿 是在runloop哪个阶段 多线程runloop收集到卡顿 如何告诉主线程</li><li>子线程一直去ping主线程 算不算？</li><li>不然就是FPS监控 CADisplayLink 其他不知道了</li></ul></li></ul><h3 id="10-2-内存"><a href="#10-2-内存" class="headerlink" title="10.2 内存"></a>10.2 内存</h3><blockquote><p>OOM，是 Out of Memory 的缩写，指的是 App 占用的内存达到了 iOS 系统对单个 App 占用内存上限后，而被系统强杀掉的现象</p></blockquote><ul><li>内存过高被杀死，如何定位大概位置</li><li>内存泄露监控，说一下思路（如果你自己写一个检测内存泄露的工具，你会怎么写）</li></ul><h3 id="10-3-崩溃"><a href="#10-3-崩溃" class="headerlink" title="10.3 崩溃"></a>10.3 崩溃</h3><blockquote><p> 检测、采集、防崩溃</p></blockquote><ul><li><p>Crash产生的原因，都有哪些种类：exception、signal等，</p></li><li><p>对于难处理的exception、signal是怎么处理的</p></li><li><p>NSSetUncaughtExceptionHandler一定能采集到吗？什么是采集不到的</p></li><li><p>后台崩溃是采集不到的，那怎么采集后台崩溃呢？</p></li><li><p>对于Mach层次的异常，是怎么捕获的</p><p>Mach为XNU的微内核，Mach异常为最底层的内核级异常，在iOS系统中，底层Crash先触发Mach异常，然后再转换为对应的signal信号。</p></li><li><p><a href="https://www.jianshu.com/p/04f822f929f0">iOS Mach 异常、Unix 信号 和NSException 异常</a></p></li><li><p><a href="https://time.geekbang.org/column/article/88600">12 | iOS 崩溃千奇百怪，如何全面监控？</a></p></li><li><p><a href="https://www.jianshu.com/p/930d7f77df6c">iOS中Crash采集及PLCrashReporter使用</a></p></li><li><p>自己编写防崩溃组件，功能：</p><ul><li>常见崩溃的预防拦截<ul><li>比如给NSArray、NSDictionary添加分类，hook方法，处理insert nil的crash</li><li>运用消息转发机制，处理unrecognized selector的方法</li><li>这些拦截，是一直开着，还是只debug开着，线上开着这个，会造成其它未知的错误吗  </li></ul></li><li>其它崩溃的采集、崩溃信息的可视化、统计<ul><li>都上传了什么数据：backtrace C函数获取调用堆栈。是什么时机调用的呢？</li><li>怎么可视化</li></ul></li></ul></li><li><p>bugly无法获取的崩溃有哪些</p></li><li><p>数组越界的处理，除了hook外，有什么更好的处理方式</p></li><li><p>Crash收集防护怎么做，常见的Crash场景，怎么收集上报的，OOM性能怎么监控，如果让你打造一款Bugly,你会考虑怎么设计</p></li><li><p>swift的crash怎么捕捉，好像oc的不适用？不知道swift的 但是Mach异常捕获 Unix信号捕获 应该都可以用</p></li><li><p><a href="https://faisalmemon.github.io/ios-crash-dump-analysis-book/zh/">https://faisalmemon.github.io/ios-crash-dump-analysis-book/zh/</a></p></li></ul><h3 id="10-4-网络层优化"><a href="#10-4-网络层优化" class="headerlink" title="10.4 网络层优化"></a>10.4 网络层优化</h3><ul><li>安全性<ul><li>防中间人攻击？单向校验，双向校验还是双向认证</li><li>AFN中关于安全校验的一些API</li><li>了解榕树贷款的证书机制</li></ul></li><li>了解别人能抓包的原因，配置的什么证书就可以了？为什么可以？处于证书信任链中？<ul><li>https抓包是怎么实现的？就是charls原理 中间人劫持 模拟发送请求</li><li><a href="https://www.jianshu.com/p/405f9d76f8c4">https://www.jianshu.com/p/405f9d76f8c4</a></li></ul></li><li>HTTPDNS</li><li>弱网优化<ul><li>一般是可以通过重试和改用udp来改善用户体验<ul><li>疑问：目的是提高弱网下的请求成功率。重试的话，请求太多也会造成问题吧？这里应该有更细的策略。</li><li>然后UDP，我可以理解为减少了握手所以更快资源更少，但UDP怎么解决可靠性问题？<ul><li>QUIC 全称 Quick UDP Internet Connection, 是谷歌公司研发的一种基于 UDP 协议的低时延互联网传输协议。在2018年IETF会议中，HTTP-over-QUIC协议被重命名为HTTP/3，并成为 HTTP 协议的第三个正式版本。参考链接：<a href="https://cloud.tencent.com/developer/article/1407615">QUIC网络协议简介</a></li></ul></li></ul></li><li>apns携带一部分数据过去，用户即使网络不好，通过通知打开应用也能展示<ul><li>APNS Payload 不能超过4096，之前貌似是256 提高到4096的</li></ul></li></ul></li></ul><h3 id="10-5-启动速度优化"><a href="#10-5-启动速度优化" class="headerlink" title="10.5 启动速度优化"></a>10.5 启动速度优化</h3><p>先知道启动流程 — 从点击图标到展示完成</p><p>每个节点的底层原理，premain之前的优化，didfinish的优化。</p><blockquote><p>优化方案及数据</p></blockquote><p>冷启动速度</p><ul><li>运行，有个环境变量，配置之后可以打印premain耗时情况</li><li>冷启动时间的统计：kill进程并不代表一定就是真正的冷启动流程，必须等刚刚运行时占用的内存被真正回收掉。可以卸载APP或者重启手机。1.2s左右</li><li>main阶段的时间统计：APPdelegate时间戳 - main函数时间戳。2.7 2.8s左右</li><li>插桩、重排是优化哪个阶段的，效果是多少。premain</li></ul><p>二进制重排</p><ul><li><p>为什么：缺页中断影响执行速度 </p></li><li><p>原理：Clang插桩</p></li><li><p>配置路径：build setting - order file</p></li></ul><h3 id="10-6-包体积优化"><a href="#10-6-包体积优化" class="headerlink" title="10.6 包体积优化"></a>10.6 包体积优化</h3><ul><li>优化手段：资源瘦身、代码瘦身等</li><li>怎么检测项目中无用代码<ul><li>背后的检测原理知道吗</li><li>检测出来的无用代码都是没有用的吗（可能是有用的，runtime会换方法）</li></ul></li></ul><p>注意：搞点高技术含量的，别说一些烂大街的</p><h3 id="10-7-LLVM中间代码优化"><a href="#10-7-LLVM中间代码优化" class="headerlink" title="10.7 LLVM中间代码优化"></a>10.7 LLVM中间代码优化</h3><blockquote><p>LLVM pass是否了解过，有编写过吗</p></blockquote><h3 id="10-8-应用安全"><a href="#10-8-应用安全" class="headerlink" title="10.8 应用安全"></a>10.8 应用安全</h3><h4 id="10-8-1-网络安全"><a href="#10-8-1-网络安全" class="headerlink" title="10.8.1 网络安全"></a>10.8.1 网络安全</h4><h4 id="10-8-2-防逆向"><a href="#10-8-2-防逆向" class="headerlink" title="10.8.2 防逆向"></a>10.8.2 防逆向</h4><h3 id="10-9-电量优化"><a href="#10-9-电量优化" class="headerlink" title="10.9 电量优化"></a>10.9 电量优化</h3><p>如果应用要一直更新定位，怎样操作才省电？</p><ul><li>pushkit</li></ul><h3 id="10-10-Xcode提供的优化手段"><a href="#10-10-Xcode提供的优化手段" class="headerlink" title="10.10 Xcode提供的优化手段"></a>10.10 Xcode提供的优化手段</h3><h4 id="10-10-1-Analyze静态分析"><a href="#10-10-1-Analyze静态分析" class="headerlink" title="10.10.1 Analyze静态分析"></a>10.10.1 Analyze静态分析</h4><p>僵尸对象诊断可以帮助快速定位多数情况下的野指针问题，但也有时候不能奏效，这个时候只能利用Xcode的Analyze静态分析帮助检查可能出问题的地方，仔细检查问题所在，比较费时。</p><p>使用方法很简单，选中Xcode顶部导航栏Product-Analyze或使用快捷键Command+Shift+B，分析需要花一些时间，然后左侧会列出编辑器发现的存在潜在问题的地方，选中蓝色图标对应的问题项会跳到问题项所在的代码行。但这只能给出一些潜在提示，帮助搜索问题所在，不一定和我们的bug相关。</p><h3 id="10-11-常见面试题"><a href="#10-11-常见面试题" class="headerlink" title="10.11 常见面试题"></a>10.11 常见面试题</h3><ul><li>做过哪些性能优化</li><li>线上有做性能检测措施吗？比如卡顿(FPS检查)上报(上报堆栈)</li><li>崩溃率有统计过吗？万2左右(Keep)算不错了</li><li>应用安全方面？<ul><li>ptrace 防lldb 远程debug</li></ul></li><li>APM （Application Performance Management，即应用性能管理，在分布式领域也称为分布式跟踪管理）对企业的应用系统进行实时监控，它是用于实现对应用程序性能管理和故障管理的系统化的解决方案。<ul><li>matrix(矩阵、模型)  —— 微信开源的工具 <a href="https://github.com/Tencent/matrix">https://github.com/Tencent/matrix</a></li></ul></li><li><a href="https://satanwoo.github.io/2017/07/30/xlog/">微信高性能线上日志系统xlog剖析 — SatanWoo</a></li><li>知道苹果原生出的性能检测框架吗？（百度）<ul><li>说是新特性</li><li><a href="https://mp.weixin.qq.com/s/66UvtkfPP3vDObLNk6W3Yg">使用 XCTest 消除动画卡顿？</a></li></ul></li></ul><h2 id="十一、Swift"><a href="#十一、Swift" class="headerlink" title="十一、Swift"></a>十一、Swift</h2><ul><li><p>oc怎么转换成SwiftUI</p></li><li><p>swift 为什么推荐使用 结构体，swift数组为什么选择使用 结构体。类和结构体的区别</p></li><li><p>静态库中swift与OC如何实现混编？</p></li><li><p>swift 与 OC混编 module的原理是什么？</p></li><li><p>swift 与 OC 混编 module的配置流程？</p></li><li><p>oc的 KVO 你已经知道了，那么 swift 的KVO 原理懂么</p></li><li><p>Swift的修饰词</p></li><li><p>转JSON：kakaJson、HandlyJson <a href="https://www.jianshu.com/p/e9d933ce7c74">https://www.jianshu.com/p/e9d933ce7c74</a></p><p><img src="../../images/Interview/JSONParsePerformance.jpeg" alt="Thread"></p></li></ul><h2 id="十二、JavaScript与RN"><a href="#十二、JavaScript与RN" class="headerlink" title="十二、JavaScript与RN"></a>十二、JavaScript与RN</h2><ul><li>跨平台的方案分析，选型以及优化点</li></ul><ol><li><p>原型继承</p></li><li><p>写过JS吗？获取一个元素试试？</p></li></ol><p>document.getElementById:()</p><ol start="3"><li>写过CSS样式吗？选择器的权重</li></ol><p>默认/继承样式 &lt; 标签选择器 &lt; 类选择器 &lt; “ID”选择器 &lt; 行内样式 &lt; “!important”修饰符</p><p>通配符选择器仅大于继承样式，但是不推荐使用</p><ol start="4"><li>组件的生命周期 </li></ol><p><a href="https://www.jianshu.com/p/7b4fe125aa92">https://www.jianshu.com/p/7b4fe125aa92</a></p><ol start="5"><li>props state 区别</li></ol><p><code>props（“properties” 的缩写）</code>和 <code>state</code> 都是普通的 <code>JavaScript</code> 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的几个重要的不同点就是：</p><ul><li><code>props</code> 是传递给组件的（类似于函数的形参），而 <code>state</code> 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</li><li><code>props</code> 是不可修改的，所有 <code>React</code> 组件都必须像纯函数一样保护它们的 <code>props</code> 不被更改。 由于 <code>props</code> 是传入的，并且它们不能更改，因此我们可以将任何仅使用 <code>props</code> 的 <code>React</code> 组件视为 <code>pureComponent</code>，也就是说，在相同的输入下，它将始终呈现相同的输出。</li><li><code>state</code> 是在组件中创建的，一般在 <code>constructor</code>中初始化 <code>state</code></li><li><code>state</code> 是多变的、可以修改，每次<code>setState</code>都异步更新的。</li></ul><h2 id="十三、开放题"><a href="#十三、开放题" class="headerlink" title="十三、开放题"></a>十三、开放题</h2><h3 id="13-1-项目"><a href="#13-1-项目" class="headerlink" title="13.1 项目"></a>13.1 项目</h3><ul><li>感觉有亮点的项目讲一下</li><li>遇到了哪些问题以及怎么解决的</li><li>开发中遇到问题是怎么排查的，讲一下解决问题的思路及手段</li></ul><h3 id="13-2-其他"><a href="#13-2-其他" class="headerlink" title="13.2 其他"></a>13.2 其他</h3><ul><li>哪个项目是你觉得最有经验、心得的？</li><li>最有成就感的一项技术产出是什么</li></ul><ul><li><p>如果多个组件，还有 弹窗，前后台切换，页面push等等 都可能 控制 播放器的播放和停止，那么你怎么设计一个无依赖的方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 通知。但通知有一个大问题，就是不好管理，然后没有传递链(抖音应该不会用这么low的方案...)</span><br><span class="line">2. 中间状态 statefulwidget（题目的意思可能在考察组件化的概念）</span><br><span class="line">3. 但感觉面试官不满意答案2...</span><br></pre></td></tr></table></figure></li></ul><h2 id="待归类"><a href="#待归类" class="headerlink" title="待归类"></a>待归类</h2><p>CI构建，编译打包流程；(Jenkins、fastlane。就是持续集成，讲讲你的理解，怎么配置，怎么构建之类)</p><ul><li>自动打包是其中的一个功能</li></ul><p>Runtime/Runloop这种机制，为啥要设计这种机制呢，编译时运行时；</p><p>几种多线程方案的利弊；</p><p>APP安装包都有什么，怎么瘦身，背后怎么做的，哪些场景可能会引起包体积增大；</p><p>怎么看待异常；</p><p>进程和线程；</p><p>对iOS新技术有关注吗（我说了Flutter，那Flutter具体怎么做的，事件响应怎么设计之类的。。。）</p><p>ˇ好未来</p><p>1：组件化 理解 解耦 方式<br>2：项目结构 模块<br>3：网络模块 怎么处理  AFNetWorking  源码  NSURLConnection  NSURLSession的区别<br>4:  HTTP HTTPS  加密过程<br>5：TCP网络三次握手<br>6：网络相关常见错误码<br>7：自动释放池  自动师范池与runloop的区别<br>8：堆和栈的区别<br>9：block  为什么要用copy修饰  注意点<br>10： 启动优化  load  initialize 的区别<br>11：App 打包成 api 做了那些事<br>12：自动化搭建<br>13：线上的问题的定位 修复 监护 卡顿<br>14：崩溃类型  解决方案<br>15：空指针<br>16：单例<br>17：设计模式<br>18：原生和H5的交互  释放时间 监控白屏 其他坑<br>19：内存占用  内存泄漏<br>20：卡顿：tableView    切圆角  离屏渲染<br>21：最近学习东西<br>22：isa </p><p>了解过 __ attribute__((constructor))相关函数么？作用是什么 ？</p><ul><li><p><a href="https://www.jianshu.com/p/dd425b9dc9db">https://www.jianshu.com/p/dd425b9dc9db</a></p></li><li><p><a href="https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html">https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html</a></p></li></ul><p>多个非系统动态库的合并？需要合并么，如果需要，怎么合并</p><p>iOS6以下系统，默认navBar和tabBar都不占空间。</p><p>iOS7及以上系统默认：</p><ul><li>self.navigationController.navigationBar.translucent(半透明)为YES</li><li>self.edgesForExtendedLayout = UIRectEdgeAll</li><li>此时，self.view.frame.origin.y从0开始（屏幕最上部、navigationBar的顶部）。</li></ul><p>设置translucent=NO、与edgesForExtendedLayout=UIRectEdgeNone 都会使self.view.frame.origin.y下移(navBar高度)个像素，即self.view中的子控件布局从navBar下方开始</p><ul><li>如果只设置后者，由于navBar是透明的，会出现64像素的黑色区域。设置背景色、背景图片都有点问题，所以最好设置前者</li></ul><p>iOS7之后也增加了一个self.tabBarController.tabBar.translucent的属性，默认为YES。效果同上</p><p>注意：在viewDidLoad中打印self.view.frame是屏幕宽高，在viewWillAppear及之后的生命周期方法中，才会因为上面的设置而改变</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、算法与数据结构&quot;&gt;&lt;a href=&quot;#一、算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、算法与数据结构&quot;&gt;&lt;/a&gt;一、算法与数据结构&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; TLE    Time Limit Exceed(超时)</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="interview" scheme="https://tenloy.github.io/tags/interview/"/>
    
  </entry>
  
</feed>
