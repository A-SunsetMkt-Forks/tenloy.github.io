<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tenloy&#39;s Blog</title>
  
  <subtitle>学习 记录</subtitle>
  <link href="https://tenloy.github.io/atom.xml" rel="self"/>
  
  <link href="https://tenloy.github.io/"/>
  <updated>2021-07-03T15:03:45.157Z</updated>
  <id>https://tenloy.github.io/</id>
  
  <author>
    <name>Tenloy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入浅出GCD常用API</title>
    <link href="https://tenloy.github.io/2021/06/29/14_GCD/"/>
    <id>https://tenloy.github.io/2021/06/29/14_GCD/</id>
    <published>2021-06-29T19:12:21.000Z</published>
    <updated>2021-07-03T15:03:45.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是多线程编程？"><a href="#一、什么是多线程编程？" class="headerlink" title="一、什么是多线程编程？"></a>一、什么是多线程编程？</h2><p>先来复习一下<code>操作系统</code>中线程相关的知识点：</p><h3 id="1-1-代码的运行"><a href="#1-1-代码的运行" class="headerlink" title="1.1 代码的运行"></a>1.1 代码的运行</h3><p><strong>首先，代码是怎么运行的？</strong></p><ul><li>源代码通过编译器转换为CPU命令列(二进制编码)，应用程序就是CPU命令列和数据的汇集，在应用程序启动后，首先便将包含在应用程序中的CPU命令列配置在内存中。</li><li>CPU从应用程序指定的地址开始，一个一个的执行CUP命令列。在OC的if语句和for语句等控制语句或函数调用的情况下，执行命令列的地址会远离当前的位置（位置迁移），但是由于一个CUP一次只能执行一个命令，不能执行某处分开的并列的两个命令，因此通过CPU执行的CPU命令列就好比一条无分叉的大道，其执行不会出现分歧。</li></ul><p><strong>一个CPU执行的CPU命令列尾一条无分叉的路径即为“线程”</strong></p><h3 id="1-2-上下文切换"><a href="#1-2-上下文切换" class="headerlink" title="1.2 上下文切换"></a>1.2 上下文切换</h3><blockquote><p>OS X和ios的核心XNU内核在发生操作系统事件时（如每隔一定时间，唤起系统调用等情况）会切换执行路经。执行中路经的状态，例如CPU的寄存器的信息保存到各自路经专用的内存块中，从切换目标路经专用的内存块中，复原CPU寄存器的信息，继续执行切换路经的CPU命令列，这被称为“上下文切换”</p></blockquote><p>上下文切换是并行（单处理器中进程被交替执行，表现出并发外部特征）`的核心关键。</p><p>单核中的多线程是并发，其实是顺序执行的，只不过CPU高速的切换，表面看起来像是并行。<br>多核中的多线程，在线程数小于 &lt; CPU核数时，是真正的并行。</p><p>关于并发和并行的区别，可以看<a href="https://www.jianshu.com/p/446bf121ff8f">上一篇中的介绍</a></p><p><strong>iOS和OS X的核心 — XNU内核决定应当使用的线程数，并只生成所需的线程执行处理，另外，当处理结束，应当执行的处理数减少时，XNU内核会结束不再需要的线程，XNU内核仅使用并行队列便可完美的管理并行执行处理的线程</strong></p><h3 id="1-3-多线程编程的优缺点"><a href="#1-3-多线程编程的优缺点" class="headerlink" title="1.3 多线程编程的优缺点"></a>1.3 多线程编程的优缺点</h3><ul><li><p><strong>优点：</strong>保证应用程序的响应性能</p></li><li><p><strong>缺点</strong>：是易发生各种问题，比如：数据竞争、死锁，而且使用太多线程会消耗大量内存，引起大量的上下文切换，大幅度降低系统的响应性能。</p></li></ul><h3 id="1-4-主线程"><a href="#1-4-主线程" class="headerlink" title="1.4 主线程"></a>1.4 主线程</h3><p>应用程序启动时。通过最先执行的线程，即‘主线程’来描绘用户界面、处理触摸屏幕的事件，如果在该线程中进行长时间的处理，会造成主线程阻塞，会妨碍主线程中被称为RunLoop的主循环执行，从而导致不能更新用户界面、应用程序画面长时间停滞等问题</p><p><strong>GCD大大简化了偏于复杂的多线程编程的源代码，与Block结合使用，只需要将要执行的任务并追加到适当的Dispatch Queue</strong></p><h2 id="二、GCD基础篇"><a href="#二、GCD基础篇" class="headerlink" title="二、GCD基础篇"></a>二、GCD基础篇</h2><p>Grand Central Dispatch(GCD)</p><ul><li>是Apple推出的一套多线程解决方案，它拥有系统级的线程管理机制，开发者不需要再管理线程的生命周期，只需要关注于要执行的任务即可。</li><li>是异步执行任务的技术之一，用非常简洁的技术方法，实现了极为复杂繁琐的多线程编程</li></ul><p>GCD的源码libdispatch版本很多，源代码风格各版本都有不同，但大体逻辑没有太大变化。libdispatch的源码下载地址<a href="https://opensource.apple.com/tarballs/libdispatch/">在这里</a>。</p><h3 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h3><p>阅读GCD的源码之前，先了解一些相关知识，方便后面的理解。</p><h4 id="2-1-1-DISPATCH-DECL"><a href="#2-1-1-DISPATCH-DECL" class="headerlink" title="2.1.1 DISPATCH_DECL"></a>2.1.1 DISPATCH_DECL</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_DECL(name) typedef struct name##_s *name##_t</span></span><br></pre></td></tr></table></figure><p>GCD中的变量大多使用了这个宏，比如<code>DISPATCH_DECL(dispatch_queue)</code>展开后是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">dispatch_queue_t</span>；</span></span><br></pre></td></tr></table></figure><p>它的意思是定义一个<code>dispatch_queue_t</code>类型的指针，指向了一个<code>dispatch_queue_s</code>类型的结构体。</p><h4 id="2-1-2-fastpath-vs-slowpath"><a href="#2-1-2-fastpath-vs-slowpath" class="headerlink" title="2.1.2 fastpath vs slowpath"></a>2.1.2 fastpath vs slowpath</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastpath(x) ((typeof(x))__builtin_expect((long)(x), ~0l))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> slowpath(x) ((typeof(x))__builtin_expect((long)(x), 0l))</span></span><br></pre></td></tr></table></figure><p><code>__builtin_expect</code>是编译器用来优化执行速度的函数，fastpath表示条件更可能成立，slowpath表示条件更不可能成立。我们在阅读源码的时候可以做忽略处理。</p><h4 id="2-1-3-TSD"><a href="#2-1-3-TSD" class="headerlink" title="2.1.3 TSD"></a>2.1.3 TSD</h4><p>Thread Specific Data(TSD)是指线程私有数据。在多线程中，会用全局变量来实现多个函数间的数据共享，局部变量来实现内部的单独访问。TSD则是能够在同一个线程的不同函数中被访问，在不同线程时，相同的键值获取的数据随线程不同而不同。可以通过pthread的相关api来实现TSD:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *, <span class="keyword">void</span> (* _Nullable)(<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* _Nullable <span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span>)</span></span>;</span><br><span class="line"><span class="comment">//set方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> , <span class="keyword">const</span> <span class="keyword">void</span> * _Nullable)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-常用数据结构"><a href="#2-2-常用数据结构" class="headerlink" title="2.2 常用数据结构"></a>2.2 常用数据结构</h3><h4 id="2-2-1-dispatch-object-s结构体"><a href="#2-2-1-dispatch-object-s结构体" class="headerlink" title="2.2.1 dispatch_object_s结构体"></a>2.2.1 dispatch_object_s结构体</h4><p>dispatch_object_s是GCD最基础的结构体，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GCD的基础结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_STRUCT_HEADER</span>(object);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//os object头部宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OS_OBJECT_HEADER(isa, ref_cnt, xref_cnt) \</span></span><br><span class="line">        isa; <span class="comment">/* must be pointer-sized */</span> \  <span class="comment">//isa</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> ref_cnt; \             <span class="comment">//引用计数</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> xref_cnt               <span class="comment">//外部引用计数，两者都为0时释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dispatch结构体头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_STRUCT_HEADER(x) \</span></span><br><span class="line">    _OS_OBJECT_HEADER( \</span><br><span class="line">    <span class="keyword">const</span> struct dispatch_#<span class="meta">#x##_vtable_s *do_vtable, \  <span class="comment">//vtable结构体</span></span></span><br><span class="line">    do_ref_cnt, \</span><br><span class="line">    do_xref_cnt); \                            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \   <span class="comment">//下一个do</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> \         <span class="comment">//目标队列</span></span><br><span class="line">    <span class="keyword">void</span> *do_ctxt; \                               <span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">void</span> *do_finalizer; \                          <span class="comment">//销毁时调用函数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> do_suspend_cnt;                   <span class="comment">//suspend计数，用作暂停标志</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-dispatch-continuation-s结构体"><a href="#2-2-2-dispatch-continuation-s结构体" class="headerlink" title="2.2.2 dispatch_continuation_s结构体"></a>2.2.2 dispatch_continuation_s结构体</h4><p>dispatch_continuation_s结构体主要封装block和function，<code>dispatch_async</code>中的block最终都会封装成这个数据类型，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_CONTINUATION_HEADER</span>(continuation);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//continuation结构体头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_CONTINUATION_HEADER(x) \</span></span><br><span class="line">    _OS_OBJECT_HEADER( \</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *do_vtable, \                            do_ref_cnt, \</span><br><span class="line">    do_xref_cnt); \                                 <span class="comment">//_OS_OBJECT_HEADER定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \    <span class="comment">//下一个任务</span></span><br><span class="line">    <span class="keyword">dispatch_function_t</span> dc_func; \                  <span class="comment">//执行内容</span></span><br><span class="line">    <span class="keyword">void</span> *dc_ctxt; \                                <span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">void</span> *dc_data; \                                <span class="comment">//相关数据</span></span><br><span class="line">    <span class="keyword">void</span> *dc_other;                                 <span class="comment">//其他</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-dispatch-object-t联合体"><a href="#2-2-3-dispatch-object-t联合体" class="headerlink" title="2.2.3 dispatch_object_t联合体"></a>2.2.3 dispatch_object_t联合体</h4><p>dispatch_object_t是个union的联合体，可以用dispatch_object_t代表这个联合体里的所有数据结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> *_<span class="title">os_obj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *_<span class="title">do</span>;</span>             <span class="comment">//object结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *_<span class="title">dc</span>;</span>       <span class="comment">//任务,dispatch_aync的block会封装成这个数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *_<span class="title">dq</span>;</span>              <span class="comment">//队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> *_<span class="title">dqa</span>;</span>        <span class="comment">//队列属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_group_s</span> *_<span class="title">dg</span>;</span>              <span class="comment">//群组操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_s</span> *_<span class="title">ds</span>;</span>             <span class="comment">//source结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_s</span> *_<span class="title">dm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_msg_s</span> *_<span class="title">dmsg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_timer_aggregate_s</span> *_<span class="title">dta</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_attr_s</span> *_<span class="title">dsa</span>;</span>       <span class="comment">//source属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> *_<span class="title">dsema</span>;</span>       <span class="comment">//信号量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_data_s</span> *_<span class="title">ddata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_io_s</span> *_<span class="title">dchannel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_operation_s</span> *_<span class="title">doperation</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_disk_s</span> *_<span class="title">ddisk</span>;</span></span><br><span class="line">&#125; <span class="keyword">dispatch_object_t</span> __attribute__((__transparent_union__));</span><br></pre></td></tr></table></figure><h4 id="2-2-4-DISPATCH-VTABLE-HEADER宏"><a href="#2-2-4-DISPATCH-VTABLE-HEADER宏" class="headerlink" title="2.2.4 DISPATCH_VTABLE_HEADER宏"></a>2.2.4 DISPATCH_VTABLE_HEADER宏</h4><p>GCD中常见结构体（比如queue、semaphore等）的vtable字段中定义了很多函数回调，在后续代码分析中会经常看到，定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dispatch vtable的头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_VTABLE_HEADER(x) \</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> do_type; \     <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> do_kind; \       <span class="comment">//种类，比如:group/queue/semaphore</span></span><br><span class="line">    <span class="built_in">size_t</span> (*<span class="keyword">const</span> do_debug)(struct dispatch_#<span class="meta">#x##_s *, char *, size_t); \ <span class="comment">//debug用</span></span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*<span class="keyword">const</span> do_invoke)(struct dispatch_#<span class="meta">#x##_s *); \    <span class="comment">//invoke回调</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in"><span class="keyword">long</span></span> (*<span class="keyword">const</span> do_probe)(struct dispatch_#<span class="meta">#x##_s *); \   <span class="comment">//probe回调</span></span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*<span class="keyword">const</span> do_dispose)(struct dispatch_#<span class="meta">#x##_s *);     <span class="comment">//dispose回调，销毁时调用</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dx_xxx开头的宏定义，后续文章会用到，本质是调用vtable的do_xxx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_type(x) (x)-&gt;do_vtable-&gt;do_type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_metatype(x) ((x)-&gt;do_vtable-&gt;do_type &amp; _DISPATCH_META_TYPE_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_kind(x) (x)-&gt;do_vtable-&gt;do_kind</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_debug(x, y, z) (x)-&gt;do_vtable-&gt;do_debug((x), (y), (z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_dispose(x) (x)-&gt;do_vtable-&gt;do_dispose(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_invoke(x) (x)-&gt;do_vtable-&gt;do_invoke(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_probe(x) (x)-&gt;do_vtable-&gt;do_probe(x)</span></span><br></pre></td></tr></table></figure><h4 id="2-2-5-dispatch-queue-s-队列结构"><a href="#2-2-5-dispatch-queue-s-队列结构" class="headerlink" title="2.2.5 dispatch_queue_s(队列结构)"></a>2.2.5 dispatch_queue_s(队列结构)</h4><p>dispatch_queue_s是队列的结构体，也是GCD中开发者接触最多的结构体了，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_STRUCT_HEADER</span>(queue);    <span class="comment">//基础header</span></span><br><span class="line">    DISPATCH_QUEUE_HEADER;            <span class="comment">//队列头部，见下面的定义</span></span><br><span class="line">    DISPATCH_QUEUE_CACHELINE_PADDING; <span class="comment">// for static queues only</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//队列自己的头部定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_HEADER \</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">volatile</span> dq_running; \                       <span class="comment">//队列运行的任务数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_head</span>;</span> \   <span class="comment">//链表头部节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_tail</span>;</span> \   <span class="comment">//链表尾部节点</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq_specific_q; \                     <span class="comment">//specific队列</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dq_width; \                                  <span class="comment">//队列并发数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dq_is_thread_bound:<span class="number">1</span>; \                  <span class="comment">//是否线程绑定</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dq_serialnum; \                         <span class="comment">//队列的序列号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dq_label; \                               <span class="comment">//队列名</span></span><br><span class="line">    DISPATCH_INTROSPECTION_QUEUE_LIST;</span><br></pre></td></tr></table></figure><p>队列的do_table中有很多函数指针，阅读queue的源码时会遇到dx_invoke或者dx_probe等函数，它们其实就是调用vtable中定义的函数。下面看一下相关定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main-queue和普通queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_INSTANCE</span>(queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_queue_dispose,    <span class="comment">//销毁时调用</span></span><br><span class="line">    .do_invoke = _dispatch_queue_invoke,      <span class="comment">//invoke函数</span></span><br><span class="line">    .do_probe = _dispatch_queue_probe,        <span class="comment">//probe函数</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,         <span class="comment">//debug回调</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//global-queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_SUBCLASS_INSTANCE</span>(queue_root, queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_ROOT_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;global-queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_pthread_root_queue_dispose,  <span class="comment">//global-queue销毁时调用</span></span><br><span class="line">    .do_probe = _dispatch_root_queue_probe,              <span class="comment">//_dispatch_wakeup时会调用</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,                    <span class="comment">//debug回调</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="三、GCD的API"><a href="#三、GCD的API" class="headerlink" title="三、GCD的API"></a>三、GCD的API</h2><h3 id="3-1-Dispatch-Queue-调度队列"><a href="#3-1-Dispatch-Queue-调度队列" class="headerlink" title="3.1 Dispatch Queue(调度队列)"></a>3.1 Dispatch Queue(调度队列)</h3><p><code>dispatch_queue</code>可以说是GCD编程中使用频率最高的API，这一节主要讲一下queue的相关用法和原理，关于queue的数据结构和常用定义见上节。</p><ul><li>Dispatch Queue按照追加的顺序（先进先出FIFO）执行处理</li><li>Dispatch Queue分两种：<ul><li>一种是等待现在执行中处理结束的 Serial Dispatch Queue(串行调度队列)</li><li>一种是不等待现在执行中处理结束的 Concurrent Dispatch Queue(并行调度队列)</li></ul></li><li>Dispatch Queue实例：<ul><li>库内置了两个队列：<ul><li>Main Dispatch Queue(串行队列)：追加到Main Dispatch Queue中的处理在主线程的RunLoop中执行</li><li>Global Dispatch Queue(并行队列)</li></ul></li><li>也可以用 dispatch_queue_create 来创建串行、并行队列</li></ul></li></ul><h4 id="3-1-1-使用"><a href="#3-1-1-使用" class="headerlink" title="3.1.1 使用"></a>3.1.1 使用</h4><h5 id="1-Global-Dispatch-Queue-并行队列"><a href="#1-Global-Dispatch-Queue-并行队列" class="headerlink" title="1. Global Dispatch Queue(并行队列)"></a>1. Global Dispatch Queue(并行队列)</h5><p>Global Dispatch Queue有4个执行优先级</p><ul><li>最高优先级（High Priority）</li><li>默认优先级（Default Priority）</li><li>低优先级（Low Priority）</li><li>后台优先级（Background Priority）</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br><span class="line"></span><br><span class="line">dispatch_get_global_queue(优先级变量, unsigned long flags)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Global</span> Dispatch Quene有如下<span class="number">8</span>种:</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(High Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(<span class="keyword">Default</span> Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Low Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Background Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(High Overcommit Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(<span class="keyword">Default</span> Overcommit Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Low Overcommit Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Background Overcommit Priority)</span><br></pre></td></tr></table></figure><ul><li><p>优先级中附有 Overcommit 的 Global Dispatch Quene 使用在 Serial Dispatch Quene中。</p><p>不管系统状态如何，都会强制生成线程的 Dispatch Quene。所以这也是不要大量生成串行队列的原因。对于并行队列，不管生成多少，由于XNU内核<strong>只使用有效管理的线程</strong>，不会出现大量创建线程的状况。</p></li><li><p>同XNU内核用于 Global Dispatch Queue 的线程并<strong>不能保证实时性</strong>，所以优先级只是个大致判断。</p></li><li><p><strong>XNU内核管理，会将各自使用的队列的执行优先级，作为线程的执行优先级使用，所以添加任务时，需要选择与处理的任务对应优先级的队列。</strong></p></li><li><p>对上面两种队列执行 dispatch_retain 函数和 dispatch_release 函数无效，开发者无需关心这两者的保留、释放</p></li></ul><h5 id="2-dispatch-queue-create-创建队列"><a href="#2-dispatch-queue-create-创建队列" class="headerlink" title="2. dispatch_queue_create(创建队列)"></a>2. dispatch_queue_create(创建队列)</h5><ul><li><p>1个并行队列 + 多个异步任务(dispatch_async) = 会开启多线程</p></li><li><p>多个(1个串行队列+1个(同步/异步)任务(dispatch_sync)) = 多线程</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @参数1 指定Dispatch Queue名称（推荐使用应用程序ID这种逆序全程域名，该名称便于Xcode和Instruments调试，会出现在CrashLog中）</span></span><br><span class="line"><span class="comment"> * @参数2 Serial Dispatch Queue指定为NULL；Concurrent Dispatch Queue指定为DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 为表示Dispatch Queue的&quot;dispatch_queue_t类型&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create (<span class="string">&quot;com.example.MySerialDispatchQueue&quot;</span> , <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_release(mySerialDispatchQueue)</span><br></pre></td></tr></table></figure><ul><li><p>dispatch_queue_t 类型变量，必须程序员自己负责释放，像OC的引用计数式内存管理一样，需要通过 <code>dispatch_retain</code> 函数和 <code>dispatch_release</code> 函数的引用计数来管理内存。</p></li><li><p>在 <code>dispatch_async</code>、<code>diapatch_sync</code> 函数中追加 Block 到 Dispatch Queue（该 Block 通过 dispatch_retain 函数持有 Dispatch Queue）</p></li><li><p>一旦 Block 执行结束，就要通过 dispatch_release 函数函数释放该 Block 持有的 Dispatch Queue。</p></li></ul><p><strong>释放时机：</strong></p><ul><li><p>在 dispatch_async 函数中追加 Block 到 Dispatch Queue 后，即是立刻释放 Dispatch Queue，该 Dispatch Queue 由于被 Block 持有也不会废弃，因而 Block 能够执行，Block 执行结束后释放该 Block 持有的 Dispatch Queue，这时谁都不持有 Dispatch Queue，因此它被废弃。</p></li><li><p>在通过函数或方法名获取 Dispatch Queue 以及其他名称中包含 <code>creat</code> 的API生成的对象时，有必要通过 dispatch_retain 函数持有，并在不需要时通过 dispatch_release 函数释放。</p></li></ul><p>系统对于一个串行队列，就只生成并使用一个线程，所以串行队列的生成个数应当仅限所必需的数量，不能大量生成。</p><p>对于并行队列，不管生成多少，由于XNU内核<strong>只使用有效管理的线程</strong>，不会出现串行队列那种问题。</p><h5 id="3-dispatch-set-target-queue"><a href="#3-dispatch-set-target-queue" class="headerlink" title="3. dispatch_set_target_queue"></a>3. dispatch_set_target_queue</h5><p>dispatch_queue_create函数生成的队列，生成的线程优先级为 Global Dispatch Queue 的默认优先级。</p><p>变更生成的Dispatch Queue的执行优先级要使用dispatch_set_target_queue函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> mySerialDispatchQueue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.example.gcd.MySerialDispatchQueue&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> globalDispatchQueueBackground = <span class="built_in">dispatch_get_global_queue</span>(DISPATCH_PRIORITY_BACKGROUND ,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 指定要变更执行优先级的Dispatch Queue为dispatch_set_target_queue函数的第一个参数</span></span><br><span class="line"><span class="comment"> * 指定与要使用的执行优先级相同优先级的Dispatch Queue为第二个参数（目标）</span></span><br><span class="line"><span class="comment"> * Main Dispatch Queue和Global Dispatch Queue不可指定为第一个参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">dispatch_set_target_queue</span>(mySerialDispatchQueue, globalDispatchQueueBackground);</span><br></pre></td></tr></table></figure><p>用途：</p><ul><li>变更执行优先级</li><li>目标队列会变成第一个参数队列中任务的执行阶层<ul><li>多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某一个 Serial Dispatch Queue，那么原先本应并行执行的多个 Serial Dispatch Queue，在目标 Serial Dispatch Queue 上只能同时执行一个处理（可防止 Serial Dispatch Queue 处理并行执行）</li><li>使多个serial队列变并行为串行</li></ul></li></ul><h5 id="4-dispatch-async与dispatch-sync"><a href="#4-dispatch-async与dispatch-sync" class="headerlink" title="4. dispatch_async与dispatch_sync"></a>4. dispatch_async与dispatch_sync</h5><p>当我们处理耗时操作时，比如读取数据库、请求网络数据，为了避免这些耗时操作卡住UI,可将耗时任务放到子线程中，执行完成后再通知主线程更新UI。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Submits a block for asynchronous execution on a dispatch queue and returns immediately.</span></span><br><span class="line"><span class="comment">  在分派队列上提交一个用于异步执行的块，然后立即返回。如果不是主队列就会开启新的线程，但不管开启不开启，都是马上返回的，不会阻塞！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async</span><span class="params">(<span class="keyword">dispatch_queue_t</span> queue, <span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  dispatch_sync：Submits a block object for execution and returns after that block finishes executing.</span></span><br><span class="line"><span class="comment">  即在当前线程同步执行任务，执行完毕才能继续往下执行。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync</span><span class="params">(<span class="keyword">dispatch_queue_t</span> queue, DISPATCH_NOESCAPE <span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br></pre></td></tr></table></figure><p>代码示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">//耗时操作</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">         <span class="comment">//更新UI</span></span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-1-2-原理"><a href="#3-1-2-原理" class="headerlink" title="3.1.2 原理"></a>3.1.2 原理</h4><h5 id="1-dispatch-get-global-queue"><a href="#1-dispatch-get-global-queue" class="headerlink" title="1. dispatch_get_global_queue"></a>1. dispatch_get_global_queue</h5><p>dispatch_get_global_queue用于获取一个全局队列，先看一下它的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_get_global_queue</span><span class="params">(<span class="keyword">long</span> priority, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(<span class="keyword">unsigned</span> <span class="keyword">long</span>)DISPATCH_QUEUE_OVERCOMMIT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装调用_dispatch_get_root_queue函数</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_get_root_queue(priority,</span><br><span class="line">            flags &amp; DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_t</span> _dispatch_get_root_queue(<span class="keyword">long</span> priority, <span class="keyword">bool</span> overcommit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (overcommit) <span class="built_in"><span class="keyword">switch</span></span> (priority) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_NON_INTERACTIVE:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (priority) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_NON_INTERACTIVE:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列优先级有八个，分别为低、默认、高、后台以及对应的overcommit。枚举定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY = <span class="number">0</span>,                <span class="comment">//低优先级</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY,         <span class="comment">//低优先级+overcommit</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY,                <span class="comment">//默认优先级</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY,     <span class="comment">//默认优先级+overcommit</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY,                   <span class="comment">//高优先级</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY,        <span class="comment">//高优先级+overcommit</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY,             <span class="comment">//后台</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY,  <span class="comment">//后台+overcomit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_dispatch_get_root_queue</code>从_dispatch_root_queues结构体中获取对应优先级的队列。最后1bit为1的代表overcommit，带有overcommit标记的队列会在任务提交时新创建一个线程处理它。</p><p><code>_dispatch_root_queues</code>取出的<code>dispatch_queue_s</code>队列的do_ctxt字段表示queue的线程池，定义于<code>_dispatch_root_queue_contexts</code>结构体中，每个线程池的最大线程数限制是255。</p><p>下面看一下global queue的do_vtable结构体，它比较重要的是do_probe的调用函数<code>_dispatch_root_queue_probe</code>,这个函数在后续的分析中会用到。结构体定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//global queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_SUBCLASS_INSTANCE</span>(queue_root, queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_ROOT_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;global-queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_pthread_root_queue_dispose, <span class="comment">//销毁时调用</span></span><br><span class="line">    .do_probe = _dispatch_root_queue_probe,             <span class="comment">//重要，唤醒队列时调用</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,                   <span class="comment">//debug回调</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="2-dispatch-get-main-queue"><a href="#2-dispatch-get-main-queue" class="headerlink" title="2. dispatch_get_main_queue"></a>2. dispatch_get_main_queue</h5><p>该API的使用主要是在更新UI时获取<code>dispatch_get_main_queue()</code>并把任务提交到主队列中。它的源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义，返回到是_dispatch_main_q</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_get_main_queue() \</span></span><br><span class="line">        <span class="built_in">DISPATCH_GLOBAL_OBJECT</span>(<span class="keyword">dispatch_queue_t</span>, _dispatch_main_q)</span><br><span class="line"></span><br><span class="line"><span class="comment">//main_queue结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> _<span class="title">dispatch_main_q</span> =</span> &#123;</span><br><span class="line">    .do_vtable = <span class="built_in">DISPATCH_VTABLE</span>(queue),</span><br><span class="line">    .do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">            DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],  <span class="comment">//目标队列</span></span><br><span class="line">    .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,   </span><br><span class="line">    .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,  </span><br><span class="line">    .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">    .dq_label = <span class="string">&quot;com.apple.main-thread&quot;</span>,   <span class="comment">//队列名</span></span><br><span class="line">    .dq_running = <span class="number">1</span>,          </span><br><span class="line">    .dq_width = <span class="number">1</span>,            <span class="comment">//最大并发数是1，串行队列</span></span><br><span class="line">    .dq_is_thread_bound = <span class="number">1</span>,  <span class="comment">//线程绑定</span></span><br><span class="line">    .dq_serialnum = <span class="number">1</span>,        <span class="comment">//序列号为1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main queue设置了并发数为1，即串行队列,并且将targetq指向com.apple.root.default-overcommit-priority队列。</p><h5 id="3-dispatch-queue-create"><a href="#3-dispatch-queue-create" class="headerlink" title="3. dispatch_queue_create"></a>3. dispatch_queue_create</h5><p><code>dispatch_queue_create</code>主要用来创建自定义的队列，流程图和源码如下：</p><img src="/images/GCD/dispatch_queue-1.png" alt="img" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_queue_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用dispatch_queue_create_with_target</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dispatch_queue_create_with_target</span>(label, attr,</span><br><span class="line">            DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dispatch_queue_create具体实现函数</span></span><br><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_queue_create_with_target</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_queue_attr_t</span> attr, <span class="keyword">dispatch_queue_t</span> tq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq;</span><br><span class="line">   <span class="comment">//申请内存空间</span></span><br><span class="line">    dq = _dispatch_alloc(<span class="built_in">DISPATCH_VTABLE</span>(queue),</span><br><span class="line">            <span class="built_in"><span class="keyword">sizeof</span></span>(struct dispatch_queue_s) - DISPATCH_QUEUE_CACHELINE_PAD);</span><br><span class="line">  <span class="comment">//初始化，设置自定义队列的基本属性，方法实现见下面</span></span><br><span class="line">    _dispatch_queue_init(dq);</span><br><span class="line">    <span class="keyword">if</span> (label) &#123;</span><br><span class="line">       <span class="comment">//设置队列名</span></span><br><span class="line">        dq-&gt;dq_label = <span class="built_in">strdup</span>(label);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (attr == DISPATCH_QUEUE_CONCURRENT) &#123;</span><br><span class="line">       <span class="comment">//并行队列设置dq_width为UINT32_MAX</span></span><br><span class="line">        dq-&gt;dq_width = UINT32_MAX;</span><br><span class="line">        <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">           <span class="comment">//默认targetq，优先级为DISPATCH_QUEUE_PRIORITY_DEFAULT</span></span><br><span class="line">            tq = _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">           <span class="comment">//默认targetq，优先级为DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY</span></span><br><span class="line">            <span class="comment">// Default target queue is overcommit!</span></span><br><span class="line">            tq = _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置自定义队列的目标队列，dq队列的任务会放到目标队列执行</span></span><br><span class="line">    dq-&gt;do_targetq = tq;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_introspection_queue_create(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列初始化方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_init(<span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    dq-&gt;do_next = (struct dispatch_queue_s *)DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dq-&gt;dq_running = <span class="number">0</span>;      <span class="comment">//队列当前运行时初始为0</span></span><br><span class="line">    dq-&gt;dq_width = <span class="number">1</span>;        <span class="comment">//队列并发数默认为1，串行队列</span></span><br><span class="line">    dq-&gt;dq_serialnum = <span class="built_in">dispatch_atomic_inc_orig</span>(&amp;_dispatch_queue_serial_numbers,</span><br><span class="line">            relaxed);          <span class="comment">//序列号,在_dispatch_queue_serial_numbers基础上原子性加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码介绍了自定义队列是如何创建的，初始化时会将dq_width默认设置为1，即串行队列。如果外部设置attr为DISPATCH_QUEUE_CONCURRENT，将并发数改为UINT32_MAX；<br>自定义队列的serialnum是在_dispatch_queue_serial_numbers基础上原子性加一，即从12开始累加。1到11被保留的序列号定义如下（后续版本有改动，自定义序列从16开始累加）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skip zero        //跳过0</span></span><br><span class="line"><span class="comment">// 1 - main_q       //主队列</span></span><br><span class="line"><span class="comment">// 2 - mgr_q        //管理队列</span></span><br><span class="line"><span class="comment">// 3 - mgr_root_q   //管理队列的目标队列</span></span><br><span class="line"><span class="comment">// 4,5,6,7,8,9,10,11 - global queues   //全局队列</span></span><br><span class="line"><span class="comment">// we use &#x27;xadd&#x27; on Intel, so the initial value == next assigned</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">volatile</span> _dispatch_queue_serial_numbers = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>同时还会设置队列的target_queue，向队列提交的任务，都会被放到它的目标队列来执行。串行队列的target_queue是一个支持overcommit的全局队列，而全局队列的底层则是一个线程池。</p><p>借用一张队列的图片：</p><img src="/images/GCD/dispatch_queue-2.png" alt="img" style="zoom:80%;" /><h5 id="4-dispatch-async"><a href="#4-dispatch-async" class="headerlink" title="4. dispatch_async"></a>4. dispatch_async</h5><p><code>dispatch_async</code>用来异步执行任务，它的代码比较复杂，我们可以分成三个阶段来看，第一阶段是更新队列链表，第二部分是从队列取任务，第三部分则是执行任务。每个阶段都有一张流程图表示，觉得代码多的话可以直接看每个阶段对应的流程图。</p><p>首先看一下<code>dispatch_async</code>的入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> (^work)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch_async_f</span>(dq, _dispatch_Block_copy(work),</span><br><span class="line">            _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_async封装调用了dispatch_async_f函数，先将block拷贝到堆上，避免block执行前被销毁，同时传入_dispatch_call_block_and_release来保证block执行后会执行Block_release。下面看一下dispatch_async_f的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">//如果是串行队列，执行dispatch_barrier_async_f，和当前函数的不同点在于</span></span><br><span class="line">       <span class="comment">//.do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_barrier_async_f</span>(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将任务封装到dispatch_continuation_t结构体中</span></span><br><span class="line">    dc = <span class="built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)DISPATCH_OBJ_ASYNC_BIT;  <span class="comment">//将vtable设置为ASYNC标志位</span></span><br><span class="line">    dc-&gt;dc_func = func; </span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;do_targetq) &#123;</span><br><span class="line">       <span class="comment">//如果有do_targetq，将任务放到目标队列执行</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将任务压入队列(FIFO)</span></span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来分析一下_dispatch_queue_push，这是一个宏定义，展开后的调用栈如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_push</span><br><span class="line">└──_dispatch_trace_queue_push</span><br><span class="line">    └──_dispatch_queue_push</span><br></pre></td></tr></table></figure><p>看一下_dispatch_queue_push的具体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_push(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> _tail) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">tail</span> =</span> _tail._do;</span><br><span class="line">    <span class="comment">//判断链表中是否已经存在节点，有的话返回YES,否则返回NO</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">fastpath</span>(_dispatch_queue_push_list2(dq, tail, tail))) &#123;</span><br><span class="line">       <span class="comment">//将任务放到链表头部</span></span><br><span class="line">        _dispatch_queue_push_slow(dq, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断链表中是否已经存在节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> _dispatch_queue_push_list2(<span class="keyword">dispatch_queue_t</span> dq, struct dispatch_object_s *head,</span><br><span class="line">        struct dispatch_object_s *tail) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">prev</span>;</span></span><br><span class="line">    tail-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将tail原子性赋值给dq-&gt;dq_items_tail，同时返回之前的值并赋给prev</span></span><br><span class="line">    prev = <span class="built_in">dispatch_atomic_xchg2o</span>(dq, dq_items_tail, tail, release);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(prev)) &#123;</span><br><span class="line">       <span class="comment">//如果prev不等于NULL，直接在链表尾部添加节点</span></span><br><span class="line">        prev-&gt;do_next = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表中之前有元素返回YES，否则返回NO</span></span><br><span class="line">    <span class="keyword">return</span> (prev != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将节点放到链表开头</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_push_slow(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        struct dispatch_object_s *obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dx_type</span>(dq) == DISPATCH_QUEUE_ROOT_TYPE &amp;&amp; !dq-&gt;dq_is_thread_bound) &#123;</span><br><span class="line">       <span class="comment">//原子性的将head存储到链表头部</span></span><br><span class="line">        <span class="built_in">dispatch_atomic_store2o</span>(dq, dq_items_head, obj, relaxed);</span><br><span class="line">        <span class="comment">//唤醒global queue队列</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_wakeup_global(dq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将obj放到链表头部并执行_dispatch_wakeup函数里的dx_probe()函数</span></span><br><span class="line">    _dispatch_queue_push_list_slow2(dq, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出<code>_dispatch_queue_push</code>分为两种情况：</p><ul><li>如果队列的链表不为空，将节点添加到链表尾部，即dq-&gt;dq_item_tail=dc。然后队列会按先进先出(FIFO)来处理任务。</li><li>如果队列此时为空，进入到<code>_dispatch_queue_push_slow</code>函数。<ul><li>如果队列是全局队列会进入if分支，原子性的将节点添加到队列开头，并执行<code>_dispatch_queue_wakeup_global</code>唤醒全局队列；</li><li>如果队列是主队列或自定义串行队列if分支判断不成立，执行<code>_dispatch_queue_push_list_slow2</code>函数，它会将节点添加到队列开头并执行<code>_dispatch_wakeup</code>函数唤醒队列。</li></ul></li></ul><p><code>dispatch_async</code>第一阶段的工作主要是封装外部任务并添加到队列的链表中，可以用下图来表示：</p><img src="/images/GCD/dispatch_queue-3.png" alt="img" style="zoom:80%;" /><p>接着来看队列唤醒的逻辑，主要分成主队列和全局队列的唤醒和任务执行逻辑：</p><p>1、如果是主队列，会先调用<code>_dispatch_wakeup</code>唤醒队列，然后执行<code>_dispatch_main_queue_wakeup</code>函数来唤醒主线程的Runloop，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> _dispatch_wakeup(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dou._do))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//_dispatch_queue_probe判断dq_items_tail是否为空，if分支不成立</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dx_probe</span>(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果dou._do-&gt;do_suspend_cnt==0，返回YES,否则返回NO；</span></span><br><span class="line">    <span class="comment">//同时将DISPATCH_OBJECT_SUSPEND_LOCK赋值给dou._do-&gt;do_suspend_cnt</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dispatch_atomic_cmpxchg2o</span>(dou._do, do_suspend_cnt, <span class="number">0</span>,</span><br><span class="line">            DISPATCH_OBJECT_SUSPEND_LOCK, release)) &#123;</span><br><span class="line">            <span class="comment">//因为主线程do_suspend_cnt非0，所以主线程if分支判断成功</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">        <span class="keyword">if</span> (dou._dq == &amp;_dispatch_main_q) &#123;</span><br><span class="line">            <span class="comment">//主队列的任务执行和Runloop关联，唤醒主队列</span></span><br><span class="line">            <span class="keyword">return</span> _dispatch_main_queue_wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放到目标队列中，重新走_dispatch_queue_push方法</span></span><br><span class="line">    _dispatch_retain(dou._do);</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> tq = dou._do-&gt;do_targetq;</span><br><span class="line">    _dispatch_queue_push(tq, dou._do);</span><br><span class="line">    <span class="keyword">return</span> tq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒主线程Runloop</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span> _dispatch_main_queue_wakeup(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = &amp;_dispatch_main_q;</span><br><span class="line">    <span class="keyword">if</span> (!dq-&gt;dq_is_thread_bound) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只初始化一次mach_port_t</span></span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(&amp;_dispatch_main_q_port_pred, dq,</span><br><span class="line">            _dispatch_runloop_queue_port_init);</span><br><span class="line">    _dispatch_runloop_queue_wakeup_thread(dq);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒runloop</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_runloop_queue_wakeup_thread(<span class="keyword">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> mp = (<span class="keyword">mach_port_t</span>)dq-&gt;do_ctxt;</span><br><span class="line">    <span class="keyword">if</span> (!mp) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒主线程的runloop</span></span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = _dispatch_send_wakeup_runloop_thread(mp, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (kr) &#123;</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_TIMEOUT:</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_TIMED_OUT:</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_INVALID_DEST:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。用Xcode在block处打断点就会看到下图中的调用栈:</p><img src="/images/GCD/dispatch_queue-4.png" alt="img" style="zoom:80%;" /><p>2、如果是全局队列，调用_dispatch_queue_wakeup_global函数，它封装调用了核心函数<code>_dispatch_queue_wakeup_global_slow</code>，调用栈和核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_wakeup_global_slow</span><br><span class="line">└──_dispatch_queue_wakeup_global2</span><br><span class="line">    └──_dispatch_queue_wakeup_global_slow</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_queue_wakeup_global_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">unsigned</span> <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="keyword">dispatch_root_queue_context_t</span> qc = dq-&gt;do_ctxt;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = n;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    _dispatch_debug_root_queue(dq, __func__);</span><br><span class="line">    <span class="comment">//初始化dispatch_root_queue_context_s</span></span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(&amp;pred, <span class="literal">NULL</span>, _dispatch_root_queues_init);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">    <span class="comment">//为了防止有些timer每隔一分钟调用，线程执行任务后会有65s的超时用来等待signal唤醒</span></span><br><span class="line">    <span class="comment">//降低线程频繁创建销毁的性能消耗</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(qc-&gt;dgq_thread_mediator)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">dispatch_semaphore_signal</span>(qc-&gt;dgq_thread_mediator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!--i) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测线程池可用大小，如果还有，则将线程池减一</span></span><br><span class="line">    <span class="keyword">uint32_t</span> j, t_count = qc-&gt;dgq_thread_pool_size;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!t_count) &#123;</span><br><span class="line">          <span class="comment">//线程池已达到最大使用量</span></span><br><span class="line">            _dispatch_root_queue_debug(<span class="string">&quot;pthread pool is full for root queue: &quot;</span></span><br><span class="line">                    <span class="string">&quot;%p&quot;</span>, dq);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i &gt; t_count ? t_count : i;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="built_in">dispatch_atomic_cmpxchgvw2o</span>(qc, dgq_thread_pool_size, t_count,</span><br><span class="line">            t_count - j, &amp;t_count, relaxed));</span><br><span class="line">   <span class="comment">//创建新的线程，入口函数是_dispatch_worker_thread</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        _dispatch_retain(dq);</span><br><span class="line">        <span class="keyword">while</span> ((r = <span class="built_in">pthread_create</span>(pthr, attr, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r != EAGAIN) &#123;</span><br><span class="line">                (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(r);</span><br><span class="line">            &#125;</span><br><span class="line">            _dispatch_temporary_resource_shortage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!attr) &#123;</span><br><span class="line">            r = <span class="built_in">pthread_detach</span>(*pthr);</span><br><span class="line">            (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (--j);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_USE_PTHREAD_POOL</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新的线程后执行<code>_dispatch_worker_thread</code>函数，代码简化后如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * _dispatch_worker_thread(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> timeout = (pqc ? <span class="number">5ull</span> : <span class="number">65ull</span>) * NSEC_PER_SEC;</span><br><span class="line">    <span class="comment">//为了防止有些timer每隔一分钟调用，线程执行任务后会有65s的超时用来等待signal唤醒</span></span><br><span class="line">    <span class="comment">//降低线程频繁创建销毁的性能消耗</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//取出一个任务并执行</span></span><br><span class="line">        _dispatch_root_queue_drain(dq);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">dispatch_semaphore_wait</span>(qc-&gt;dgq_thread_mediator,</span><br><span class="line">            <span class="built_in">dispatch_time</span>(<span class="number">0</span>, timeout)) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//将线程池加一</span></span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_inc2o</span>(qc, dgq_thread_pool_size, relaxed);</span><br><span class="line">    _dispatch_queue_wakeup_global(dq);</span><br><span class="line">    _dispatch_release(dq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从队列取任务的入口是_dispatch_root_queue_drain函数，简化的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_drain(<span class="keyword">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="comment">// ensure that high-level memory management techniques do not leak/crash</span></span><br><span class="line">    <span class="keyword">if</span> (dispatch_begin_thread_4GC) &#123;</span><br><span class="line">        <span class="built_in">dispatch_begin_thread_4GC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//autoreleasepool的push操作</span></span><br><span class="line">    <span class="keyword">void</span> *pool = _dispatch_autorelease_pool_push();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_COCOA_COMPAT</span></span></span><br><span class="line"></span><br><span class="line">    _dispatch_perfmon_start();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">item</span>;</span></span><br><span class="line">    <span class="comment">//取出队列的头部节点(FIFO)</span></span><br><span class="line">    <span class="keyword">while</span> ((item = <span class="built_in">fastpath</span>(_dispatch_queue_concurrent_drain_one(dq)))) &#123;</span><br><span class="line">        <span class="comment">//对取出的内容进行处理，核心函数</span></span><br><span class="line">        _dispatch_continuation_pop(item);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_perfmon_end();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="comment">//autoreleasepool的pop操作</span></span><br><span class="line">    _dispatch_autorelease_pool_pop(pool);</span><br><span class="line">    <span class="keyword">if</span> (dispatch_end_thread_4GC) &#123;</span><br><span class="line">        <span class="built_in">dispatch_end_thread_4GC</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_COCOA_COMPAT</span></span></span><br><span class="line"></span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列唤醒后的工作主要是用线程池(全局队列)或者唤醒Runloop(主队列)的方式从队列的链表中依次取出要执行的任务，流程图如下：</p><img src="/images/GCD/dispatch_queue-5.png" alt="img" style="zoom:80%;" /><p>队列的任务取出之后就是核心的执行逻辑了，也就是<code>_dispatch_continuation_pop</code>函数的逻辑，代码和流程图如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg;</span><br><span class="line"></span><br><span class="line">    _dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);</span><br><span class="line">    <span class="comment">//判断传入的内容是不是队列，如果是的话执行_dispatch_queue_invoke函数，否的话就是block型的</span></span><br><span class="line">    <span class="comment">//任务，直接执行block即可</span></span><br><span class="line">    <span class="comment">//dispatch_barrier_async到自定义并行队列时,dou._do是用户创建的自定义queue，此时会执行</span></span><br><span class="line">    <span class="comment">//_dispatch_queue_invoke，并且用信号量保证barrier的任务不会和其他任务同时执行，后续分析</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DISPATCH_OBJ_IS_VTABLE</span>(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dx_invoke</span>(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否带有DISPATCH_OBJ_ASYNC_BIT标志位</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_ASYNC_BIT) &#123;</span><br><span class="line">        dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dc1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是group</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;</span><br><span class="line">        dg = dc-&gt;dc_data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dispatch_continuation_t结构体，执行dc-&gt;dc_func(dc-&gt;ctxt)</span></span><br><span class="line">    <span class="comment">//本质是调用Block_layout结构体的invoke执行block的实现代码</span></span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="keyword">if</span> (dg) &#123;</span><br><span class="line">       <span class="comment">//如果是群组执行dispatch_group_leave</span></span><br><span class="line">        <span class="built_in">dispatch_group_leave</span>(dg);</span><br><span class="line">        _dispatch_release(dg);</span><br><span class="line">    &#125;</span><br><span class="line">     _dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dc1)) &#123;</span><br><span class="line">        _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/GCD/dispatch_queue-6.png" alt="img" style="zoom:80%;" /><p>总结一下：<code>dispatch_async</code>的流程是用链表保存所有提交的block，然后在底层线程池中，依次取出block并执行；而向主队列提交block则会向主线程的Runloop发送消息并唤醒Runloop，接着会在回调函数中取出block并执行。</p><h5 id="5-dispatch-sync"><a href="#5-dispatch-sync" class="headerlink" title="5. dispatch_sync"></a>5. dispatch_sync</h5><p>了解了dispatch_async的逻辑后，再来看下dispatch_sync的实现和流程。<code>dispatch_sync</code>主要封装调用了<code>dispatch_sync_f</code>函数，看一下具体代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">       <span class="comment">//串行队列执行同步方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_barrier_sync_f</span>(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">       <span class="comment">//global queue不要求执行顺序，直接执行具体的block</span></span><br><span class="line">        <span class="comment">// the global concurrent queues do not need strict ordering</span></span><br><span class="line">        (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//并发队列压入同步方法</span></span><br><span class="line">    _dispatch_sync_f2(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，后续逻辑主要分为两种情况：</p><p>1、向串行队列提交同步任务，执行dispatch_barrier_sync_f函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_sync_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!<span class="built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_running, <span class="number">0</span>, <span class="number">1</span>, acquire))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_barrier_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果队列无任务执行，调用_dispatch_barrier_sync_f_invoke执行任务。<code>_dispatch_barrier_sync_f_invoke</code>代码逻辑展开后如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_barrier_sync_f_invoke(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="comment">//任务执行核心逻辑，将当前线程的dispatch_queue_key设置为dq，然后执行block，</span></span><br><span class="line">    <span class="comment">//执行完之后再恢复到之前的old_dq</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line">    _dispatch_client_callout(ctxt, func);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果队列中存在其他任务，用信号量的方法唤醒，然后继续执行下一个任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f2(dq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">dispatch_atomic_dec2o</span>(dq, dq_running, release) == <span class="number">0</span>)) &#123;</span><br><span class="line">        _dispatch_wakeup(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果队列存在其他任务或者被挂起，调用<code>_dispatch_barrier_sync_f_slow</code>函数，等待该队列的任务执行完之后用信号量通知队列继续执行任务。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_barrier_sync_f_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = _dispatch_get_thread_semaphore();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dc</span> =</span> &#123;</span><br><span class="line">        .dc_data = dq,</span><br><span class="line">        .dc_func = func,</span><br><span class="line">        .dc_ctxt = ctxt,</span><br><span class="line">        .dc_other = (<span class="keyword">void</span>*)sema,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dbss</span> =</span> &#123;</span><br><span class="line">        .do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_BARRIER_BIT |</span><br><span class="line">                DISPATCH_OBJ_SYNC_SLOW_BIT),</span><br><span class="line">        .dc_func = _dispatch_barrier_sync_f_slow_invoke,</span><br><span class="line">        .dc_ctxt = &amp;dc,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_INTROSPECTION</span></span><br><span class="line">        .dc_data = (<span class="keyword">void</span>*)_dispatch_thread_self(),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//使用信号量等待其他任务执行完成</span></span><br><span class="line">    _dispatch_queue_push(dq, &amp;dbss);</span><br><span class="line">    _dispatch_thread_semaphore_wait(sema); <span class="comment">// acquire</span></span><br><span class="line">    _dispatch_put_thread_semaphore(sema);</span><br><span class="line">    <span class="comment">//收到signal信号，继续执行当前任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        _dispatch_function_recurse(dq, ctxt, func);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_function_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、向并发队列提交同步任务，执行<code>_dispatch_sync_f2</code>函数。如果队列存在其他任务，或者队列被挂起，或者有正在执行的任务，则调用<code>_dispatch_sync_f_slow</code>函数，使用信号量等待，否则直接调用<code>_dispatch_sync_f_invoke</code>执行任务。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_sync_f2(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> running = <span class="built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">    <span class="comment">// re-check suspension after barrier check &lt;rdar://problem/15242126&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(running &amp; <span class="number">1</span>) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq))) &#123;</span><br><span class="line">        running = <span class="built_in">dispatch_atomic_sub2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, running == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列存在其他任务|队列被挂起|有正在执行的任务，信号等待</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_sync_f_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func,</span><br><span class="line">        <span class="keyword">bool</span> wakeup) &#123;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = _dispatch_get_thread_semaphore();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dss</span> =</span> &#123;</span><br><span class="line">        .do_vtable = (<span class="keyword">void</span>*)DISPATCH_OBJ_SYNC_SLOW_BIT,</span><br><span class="line">        .dc_func = func,</span><br><span class="line">        .dc_ctxt = ctxt,</span><br><span class="line">        .dc_data = (<span class="keyword">void</span>*)_dispatch_thread_self(),</span><br><span class="line">        .dc_other = (<span class="keyword">void</span>*)sema,</span><br><span class="line">    &#125;;</span><br><span class="line">    _dispatch_queue_push_wakeup(dq, &amp;dss, wakeup);</span><br><span class="line">    <span class="comment">//信号等待</span></span><br><span class="line">    _dispatch_thread_semaphore_wait(sema);</span><br><span class="line">    _dispatch_put_thread_semaphore(sema);</span><br><span class="line">    <span class="comment">//信号唤醒，执行同步任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        _dispatch_function_recurse(dq, ctxt, func);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_function_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">dispatch_atomic_sub2o</span>(dq, dq_running, <span class="number">2</span>, relaxed) == <span class="number">0</span>)) &#123;</span><br><span class="line">        _dispatch_wakeup(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_sync</code>的逻辑主要是将任务放入队列，并用线程专属信号量做等待，保证每次只会有一个block在执行。流程图如下：</p><img src="/images/GCD/dispatch_queue-7.png" alt="img" style="zoom:80%;" /><h4 id="3-1-3-总结"><a href="#3-1-3-总结" class="headerlink" title="3.1.3 总结"></a>3.1.3 总结</h4><p>dispatch_async将任务添加到队列的链表中并唤醒队列，全局队列唤醒时中会从线程池里取出可用线程，如果没有则会新建线程，然后在线程中执行队列取出的任务;主队列会唤醒主线程的Runloop，然后在Runloop循环中通知GCD执行主队列提交的任务。</p><p>dispatch_sync一般都在当前线程执行,如果是主队列的任务还是会切换到主线程执行。它使用线程信号量来实现串行执行的功能。</p><h3 id="3-2-Dispatch-Semaphore"><a href="#3-2-Dispatch-Semaphore" class="headerlink" title="3.2 Dispatch Semaphore"></a>3.2 Dispatch Semaphore</h3><h4 id="3-2-1-API介绍"><a href="#3-2-1-API介绍" class="headerlink" title="3.2.1 API介绍"></a>3.2.1 API介绍</h4><p>Dispatch Semaphore是持有计数的信号，该信号是多线程编程中的计数类型信号。所谓信号，类似过马路时常用的手旗，可以通过时举起手旗，不可以通过时放下手旗。</p><p>在Dispatch Semaphore中，使用计数来实现该功能：<strong>计数为0时等待，计数为1或大于1时，减去1而不等待</strong>。</p><p>信号量的使用比较简单，主要就三个API：<code>create</code>、<code>wait</code>和<code>signal</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 使用dispatch_semaphore_create函数生成Dispatch Semaphore</span></span><br><span class="line"><span class="comment"> * 参数value是信号量计数的初始值</span></span><br><span class="line"><span class="comment"> * 函数名称中包含create，必须自己通过dispatch_release函数释放，和dispatch_retain函数持有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">dispatch_semaphore_t</span> <span class="title">dispatch_semaphore_create</span><span class="params">(<span class="keyword">intptr_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当Dispatch Semaphore的计数值大于等于1，或者待机中计数值大于等于1时，对该计数进行减法并从dispatch_semaphore_wait函数返回。</span></span><br><span class="line"><span class="comment"> * 当Dispatch Semaphore的计数值为0时会等待(直到超时)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timeout：等待时间 dispatch_time_t类型。DISPATCH_TIME_FOREVER</span></span><br><span class="line"><span class="comment"> * @return 返回值与dispatch_group_wait函数相同，0表示执行完；超时时返回非0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">intptr_t</span> <span class="title">dispatch_semaphore_wait</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让信号量值加一，如果有通过dispatch_semaphore_wait函数等待Dispatch Semaphore的计数值增加的线程，会由系统唤醒最先等待的线程执行。</span></span><br><span class="line"><span class="function"><span class="keyword">intptr_t</span> <span class="title">dispatch_semaphore_signal</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 </span></span><br><span class="line"><span class="built_in">dispatch_release</span>(semaphore);</span><br></pre></td></tr></table></figure><h4 id="3-2-2-原理"><a href="#3-2-2-原理" class="headerlink" title="3.2.2 原理"></a>3.2.2 原理</h4><h5 id="1-dispatch-semaphore-t"><a href="#1-dispatch-semaphore-t" class="headerlink" title="1.dispatch_semaphore_t"></a>1.dispatch_semaphore_t</h5><p>首先看一下<code>dispatch_semaphore_s</code>的结构体定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> &#123;</span></span><br><span class="line">    DISPATCH_STRUCT_HEADER(semaphore);</span><br><span class="line">    <span class="keyword">semaphore_t</span> dsema_port;    <span class="comment">//等同于mach_port_t信号</span></span><br><span class="line">    <span class="keyword">long</span> dsema_orig;           <span class="comment">//初始化的信号量值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_value; <span class="comment">//当前信号量值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_sent_ksignals;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_group_waiters;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dsema_notify_head</span>;</span> <span class="comment">//notify的链表头部</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dsema_notify_tail</span>;</span> <span class="comment">//notify的链表尾部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-dispatch-semaphore-create"><a href="#2-dispatch-semaphore-create" class="headerlink" title="2. dispatch_semaphore_create"></a>2. dispatch_semaphore_create</h5><p><code>dispatch_semaphore_create</code>用来创建信号量，创建时需要指定value，内部会将value的值存储到dsema_value(当前的value)和dsema_orig(初始value)中，value的值必须大于或等于0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_semaphore_t</span> <span class="title">dispatch_semaphore_create</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//value值需大于或等于0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//申请dispatch_semaphore_t的内存</span></span><br><span class="line">    dsema = (<span class="keyword">dispatch_semaphore_t</span>)_dispatch_alloc(DISPATCH_VTABLE(semaphore),</span><br><span class="line">            <span class="keyword">sizeof</span>(struct dispatch_semaphore_s) -</span><br><span class="line">            <span class="keyword">sizeof</span>(dsema-&gt;dsema_notify_head) -</span><br><span class="line">            <span class="keyword">sizeof</span>(dsema-&gt;dsema_notify_tail));</span><br><span class="line">    <span class="comment">//调用初始化函数</span></span><br><span class="line">    _dispatch_semaphore_init(value, dsema);</span><br><span class="line">    <span class="keyword">return</span> dsema;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化结构体信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_semaphore_init(<span class="keyword">long</span> value, <span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = dou._dsema;</span><br><span class="line">    dsema-&gt;do_next = (<span class="keyword">dispatch_semaphore_t</span>)DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dsema-&gt;do_targetq = dispatch_get_global_queue(</span><br><span class="line">            DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dsema-&gt;dsema_value = value; <span class="comment">//设置信号量的当前value值</span></span><br><span class="line">    dsema-&gt;dsema_orig = value;  <span class="comment">//设置信号量的初始value值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接着来看Dispatch Semaphore很容易忽略也是最容易造成App崩溃的地方，即信号量的释放。</strong></p><p>创建Semaphore的时候会将do_vtable指向_dispatch_semaphore_vtable，_dispatch_semaphore_vtable的结构定义了信号量销毁的时候会执行<code>_dispatch_semaphore_dispose</code>方法，相关代码实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore的vtable定义</span></span><br><span class="line">DISPATCH_VTABLE_INSTANCE(semaphore,</span><br><span class="line">    .do_type = DISPATCH_SEMAPHORE_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;semaphore&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_semaphore_dispose,  <span class="comment">//销毁时执行的回调函数</span></span><br><span class="line">    .do_debug = _dispatch_semaphore_debug,      <span class="comment">//debug函数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放信号量的函数</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_semaphore_dispose(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = dou._dsema;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value &lt; dsema-&gt;dsema_orig) &#123;</span><br><span class="line">       <span class="comment">//Warning:信号量还在使用的时候销毁会造成崩溃</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(</span><br><span class="line">                <span class="string">&quot;Semaphore/group object deallocated while in use&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_port) &#123;</span><br><span class="line">        kr = semaphore_destroy(mach_task_self(), dsema-&gt;dsema_port);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果销毁时信号量还在使用，那么dsema_value会小于dsema_orig，则会引起崩溃，这是一个特别需要注意的地方。这里模拟一下信号量崩溃的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> semephore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">dispatch_semaphore_wait(semephore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">//重新赋值或者将semephore = nil都会造成崩溃,因为此时信号量还在使用中</span></span><br><span class="line">semephore = dispatch_semaphore_create(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h5 id="3-dispatch-semaphore-wait"><a href="#3-dispatch-semaphore-wait" class="headerlink" title="3. dispatch_semaphore_wait"></a>3. dispatch_semaphore_wait</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_wait</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore_wait</code>先将信号量的dsema值原子性减一，并将新值赋给value。如果value大于等于0就立即返回，否则调用<code>_dispatch_semaphore_wait_slow</code>函数，等待信号量唤醒或者timeout超时。<code>_dispatch_semaphore_wait_slow</code>函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_semaphore_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema,</span><br><span class="line">        <span class="keyword">dispatch_time_t</span> timeout) &#123;</span><br><span class="line">    <span class="keyword">long</span> orig;</span><br><span class="line">    <span class="keyword">mach_timespec_t</span> _timeout;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">again:</span><br><span class="line">    orig = dsema-&gt;dsema_sent_ksignals;</span><br><span class="line">    <span class="keyword">while</span> (orig) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_sent_ksignals, orig,</span><br><span class="line">                orig - <span class="number">1</span>, &amp;orig, relaxed)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> nsec = _dispatch_timeout(timeout);</span><br><span class="line">            _timeout.tv_sec = (typeof(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">            _timeout.tv_nsec = (typeof(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">            kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig = dsema-&gt;dsema_value;</span><br><span class="line">        <span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">                    &amp;orig, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">            kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_semaphore_wait_slow</code>函数根据timeout的类型分成了三种情况处理：</p><ol><li>DISPATCH_TIME_NOW：若<code>desma_value</code>小于0，对其加一并返回超时信号KERN_OPERATION_TIMED_OUT，原子性加一是为了抵消<code>dispatch_semaphore_wait</code>函数开始的减一操作。</li><li>DISPATCH_TIME_FOREVER：调用系统的<code>semaphore_wait</code>方法，直到收到<code>signal</code>调用。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kr = semaphore_wait(dsema-&gt;dsema_port);</span><br></pre></td></tr></table></figure><ol start="3"><li>default：调用内核方法<code>semaphore_timedwait</code>计时等待，直到有信号到来或者超时了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore_wait</code>的流程图可以用下图表示：</p><img src="/images/GCD/dispatch-semaphore-1.png" alt="img" style="zoom:80%;" /><h5 id="4-dispatch-semaphore-signal"><a href="#4-dispatch-semaphore-signal" class="headerlink" title="4. dispatch_semaphore_signal"></a>4. dispatch_semaphore_signal</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_signal</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value == LONG_MIN)) &#123;</span><br><span class="line">       <span class="comment">//Warning：value值有误会造成崩溃，详见下篇dispatch_group的分析</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(<span class="string">&quot;Unbalanced call to dispatch_semaphore_signal()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将dsema_value调用原子方法加1，如果大于零就立即返回0，否则进入<code>_dispatch_semaphore_signal_slow</code>方法，该函数会调用内核的<code>semaphore_signal</code>函数唤醒在<code>dispatch_semaphore_wait</code>中等待的线程。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> _dispatch_semaphore_signal_slow(<span class="keyword">dispatch_semaphore_t</span> dsema) &#123;</span><br><span class="line">    _dispatch_retain(dsema);</span><br><span class="line">    (<span class="keyword">void</span>)dispatch_atomic_inc2o(dsema, dsema_sent_ksignals, relaxed);</span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">    DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line"></span><br><span class="line">    _dispatch_release(dsema);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore_signal</code>的流程比较简单，可以用下图表示：</p><img src="/images/GCD/dispatch-semaphore-2.png" alt="img" style="zoom:80%;" /><h5 id="5-总结篇"><a href="#5-总结篇" class="headerlink" title="5. 总结篇"></a>5. 总结篇</h5><p>Dispatch Semaphore信号量主要是<code>dispatch_semaphore_wait</code>和<code>dispatch_semaphore_signal</code>函数，<code>wait</code>会将信号量值减一，如果大于等于0就立即返回，否则等待信号量唤醒或者超时；<code>signal</code>会将信号量值加一，如果value大于0立即返回，否则唤醒某个等待中的线程。</p><p>需要注意的是信号量在销毁或重新创建的时候如果还在使用则会引起崩溃，详见上面的分析。</p><h4 id="3-2-3-应用"><a href="#3-2-3-应用" class="headerlink" title="3.2.3 应用"></a>3.2.3 应用</h4><p>1、信号量常用于对资源进行加锁操作，防止多线程访问修改数据出现结果不一致甚至崩溃的问题，代码示例如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在init等函数初始化</span></span><br><span class="line">_lock = dispatch_semaphore_create(<span class="number">1</span>); </span><br><span class="line">dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); </span><br><span class="line"><span class="comment">//修改Array或字典等数据的信息</span></span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(_lock);</span><br></pre></td></tr></table></figure><p>2、信号量也可用于链式请求，比如用来限制请求频次：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式请求，限制网络请求串行执行，第一个请求成功后再开始第二个请求</span></span><br><span class="line">- (<span class="keyword">void</span>)chainRequestCurrentConfig &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        NSArray *<span class="built_in">list</span> = @[@<span class="string">&quot;1&quot;</span>,@<span class="string">&quot;2&quot;</span>,@<span class="string">&quot;3&quot;</span>];</span><br><span class="line">        <span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">        [<span class="built_in">list</span> enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">            [self fetchConfigurationWithCompletion:^(NSDictionary *dict) &#123;</span><br><span class="line">                dispatch_semaphore_signal(semaphore);</span><br><span class="line">            &#125;];</span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)fetchConfigurationWithCompletion:(<span class="keyword">void</span>(^)(NSDictionary *dict))completion &#123;</span><br><span class="line">    <span class="comment">//AFNetworking或其他网络请求库</span></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">//模拟网络请求</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        !completion ? nil : completion(nil);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-Dispatch-Group"><a href="#3-3-Dispatch-Group" class="headerlink" title="3.3 Dispatch Group"></a>3.3 Dispatch Group</h3><p>dispatch_group可以将GCD的任务合并到一个组里来管理。可以指定当追加到Dispatch Queue中的多个处理全部结束时，执行某种操作。</p><p>无论是串行还是并行队列，Dispatch Group都可监视这些处理执行的结束。一旦检测到所有的处理执行结束，就可将结束的处理追加到Dispatch Queue中。</p><h4 id="3-3-1-dispatch-group-create"><a href="#3-3-1-dispatch-group-create" class="headerlink" title="3.3.1 dispatch_group_create"></a>3.3.1 dispatch_group_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 创建与block相关联的新group。 因为函数名中含有create，所以在使用结束后需要过&quot;dispatch_release&quot;函数释放。</span></span><br><span class="line"><span class="keyword">dispatch_group_t</span></span><br><span class="line">dispatch_group_create(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><p>Dispatch Group的本质是一个初始value为LONG_MAX的semaphore，通过信号量来实现一组任务的管理，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_group_t</span> <span class="title">dispatch_group_create</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//申请内存空间</span></span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg = (<span class="keyword">dispatch_group_t</span>)_dispatch_alloc(</span><br><span class="line">            DISPATCH_VTABLE(group), <span class="keyword">sizeof</span>(struct dispatch_semaphore_s));</span><br><span class="line">    <span class="comment">//使用LONG_MAX初始化信号量结构体</span></span><br><span class="line">    _dispatch_semaphore_init(LONG_MAX, dg);</span><br><span class="line">    <span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当value等于LONG_MAX时表示所有任务已完成。</strong></p><h4 id="3-3-2-dispatch-group-enter"><a href="#3-3-2-dispatch-group-enter" class="headerlink" title="3.3.2 dispatch_group_enter"></a>3.3.2 dispatch_group_enter</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 手动指示一个block已进入group</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">dispatch_group_t</span> group);</span><br></pre></td></tr></table></figure><p><code>dispatch_group_enter</code> 的逻辑是将 <code>dispatch_group_t</code> 转换成 <code>dispatch_semaphore_t</code> 后将 <code>dsema_value</code> 的值减一。源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_enter</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(</span><br><span class="line">                <span class="string">&quot;Too many nested calls to dispatch_group_enter()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-dispatch-group-leave"><a href="#3-3-3-dispatch-group-leave" class="headerlink" title="3.3.3 dispatch_group_leave"></a>3.3.3 dispatch_group_leave</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 手动指示group中的某个block已完成</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(<span class="keyword">dispatch_group_t</span> group);</span><br></pre></td></tr></table></figure><p><code>dispatch_group_leave</code> 的逻辑是将 <code>dispatch_group_t</code> 转换成 <code>dispatch_semaphore_t</code> 后将 <code>dsema_value</code> 的值加一。源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_leave</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(<span class="string">&quot;Unbalanced call to dispatch_group_leave()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value == LONG_MAX)) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)_dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当value等于LONG_MAX时表示所有任务已完成，调用<code>_dispatch_group_wake</code>唤醒group，因此<code>dispatch_group_leave</code>与<code>dispatch_group_enter</code>需成对出现。</p><ul><li><p>当调用了<code>dispatch_group_enter</code>而没有调用<code>dispatch_group_leave</code>时，会造成value值不等于LONG_MAX而不会走到唤醒逻辑，<code>dispatch_group_notify</code>函数的block无法执行或者<code>dispatch_group_wait</code>收不到<code>semaphore_signal</code>信号而卡住线程。</p></li><li><p>当<code>dispatch_group_leave</code>比<code>dispatch_group_enter</code>多调用了一次时，dispatch_semaphore_t的value会等于LONGMAX+1（2147483647+1），即long的负数最小值 LONG_MIN(–2147483648)。因为此时value小于0，所以会出现”Unbalanced call to dispatch_group_leave()”的崩溃，这是一个特别需要注意的地方。</p></li></ul><h4 id="3-3-4-dispatch-group-async"><a href="#3-3-4-dispatch-group-async" class="headerlink" title="3.3.4 dispatch_group_async"></a>3.3.4 dispatch_group_async</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将block提交到调度队列，并将block与给定的调度group关联。相比dispatch_async函数不同的是通过第一个参数，指定Block属于指定的Dispatch Group</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_async(<span class="keyword">dispatch_group_t</span> group,</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,</span><br><span class="line"><span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure><p>源码分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> db)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//封装调用dispatch_group_async_f函数</span></span><br><span class="line">    dispatch_group_async_f(dg, dq, _dispatch_Block_copy(db),</span><br><span class="line">            _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async_f</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    _dispatch_retain(dg);</span><br><span class="line">    <span class="comment">//先调用dispatch_group_enter操作</span></span><br><span class="line">    dispatch_group_enter(dg);</span><br><span class="line">    dc = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="comment">//DISPATCH_OBJ_GROUP_BIT会在_dispatch_continuation_pop方法中用来判断是否为group，如果为group会执行dispatch_group_leave</span></span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_GROUP_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dc-&gt;dc_data = dg;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width != <span class="number">1</span> &amp;&amp; dq-&gt;do_targetq) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_group_async</code> 的原理和 <code>dispatch_async</code> 比较类似，区别点在于group操作会带上DISPATCH_OBJ_GROUP_BIT标志位。添加group任务时会先执行 <code>dispatch_group_enter</code> ，然后在任务执行时会对带有该标记的执行 <code>dispatch_group_leave</code> 操作。</p><p><code>dispatch_group_async_f </code>与 <code>dispatch_async_f</code>代码类似，主要执行了以下操作：</p><ol><li><p>调用dispatch_group_enter</p></li><li><p>将block和queue等信息记录到dispatch_continuation_t中，并将它加入到group的链表中。</p></li><li><p>_dispatch_continuation_pop执行时会判断任务是否为group，是的话执行完任务再调用dispatch_group_leave以达到信号量value的平衡。</p></li></ol><p><code>_dispatch_continuation_pop</code>简化后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg;</span><br><span class="line">    _dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);</span><br><span class="line">    <span class="comment">//判断是否为队列，是的话执行队列的invoke函数</span></span><br><span class="line">    <span class="keyword">if</span> (DISPATCH_OBJ_IS_VTABLE(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> dx_invoke(dou._do);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//dispatch_continuation_t结构体，执行具体任务</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;</span><br><span class="line">        dg = dc-&gt;dc_data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="keyword">if</span> (dg) &#123;</span><br><span class="line">       <span class="comment">//这是group操作，执行leave操作对应最初的enter</span></span><br><span class="line">        dispatch_group_leave(dg);</span><br><span class="line">        _dispatch_release(dg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-dispatch-group-wait"><a href="#3-3-5-dispatch-group-wait" class="headerlink" title="3.3.5 dispatch_group_wait"></a>3.3.5 dispatch_group_wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @abstract 同步地等待，直到与一个group相关联的所有block都完成，或者直到指定的超时已经过去</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timeout 指定等待时间 dispatch_time_t类型的值 (DISPATCH_TIME_FOREVER 一直)</span></span><br><span class="line"><span class="comment"> * @returrn  如果返回值不为0，表示经过等待，任务还在执行中; 如果为0，全部执行结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">intptr_t</span> </span><br><span class="line">dispatch_group_wait(<span class="keyword">dispatch_group_t</span> group, <span class="keyword">dispatch_time_t</span> timeout);</span><br></pre></td></tr></table></figure><p>源码分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_group_wait</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_time_t</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_group_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前value的值为初始值，表示任务都已经完成，直接返回0，如果timeout为0的话返回超时。其余情况会调用_dispatch_group_wait_slow方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout) &#123;</span><br><span class="line">    <span class="keyword">long</span> orig;</span><br><span class="line">    <span class="keyword">mach_timespec_t</span> _timeout;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="keyword">void</span>)dispatch_atomic_inc2o(dsema, dsema_group_waiters, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> nsec = _dispatch_timeout(timeout);</span><br><span class="line">            _timeout.tv_sec = (typeof(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">            _timeout.tv_nsec = (typeof(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">            kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig = dsema-&gt;dsema_group_waiters;</span><br><span class="line">        <span class="keyword">while</span> (orig) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_group_waiters, orig,</span><br><span class="line">                    orig - <span class="number">1</span>, &amp;orig, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到跟dispatch_semaphore的<code>_dispatch_semaphore_wait_slow</code>方法很类似，不同点在于等待完之后调用的again函数会调用<code>_dispatch_group_wake</code>唤醒当前group。</p><h4 id="3-3-6-dispatch-group-notify"><a href="#3-3-6-dispatch-group-notify" class="headerlink" title="3.3.6 dispatch_group_notify"></a>3.3.6 dispatch_group_notify</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @abstract 当与一个group相关联的所有block都完成时，将一个block提交到队列中。不管指定什么样的Dispatch Queue，在追加指定的Block时，之前与Dispatch Group相关联的block都已执行结束。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param queue/block 在追加到该Dispatch Group中的全部处理执行结束时，将第三个参数的Block追加到第二个参数的Dispatch Queue中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_notify(<span class="keyword">dispatch_group_t</span> group,</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,</span><br><span class="line"><span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_notify</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> db)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装调用dispatch_group_notify_f函数</span></span><br><span class="line">    dispatch_group_notify_f(dg, dq, _dispatch_Block_copy(db),</span><br><span class="line">            _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_notify_f</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> (*func)(<span class="keyword">void</span> *))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="comment">//封装结构体</span></span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> prev, dsn = _dispatch_continuation_alloc();</span><br><span class="line">    dsn-&gt;do_vtable = (<span class="keyword">void</span> *)DISPATCH_OBJ_ASYNC_BIT;</span><br><span class="line">    dsn-&gt;dc_data = dq;</span><br><span class="line">    dsn-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dsn-&gt;dc_func = func;</span><br><span class="line">    dsn-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    _dispatch_retain(dq);</span><br><span class="line">    <span class="comment">//将结构体放到链表尾部，如果链表为空同时设置链表头部节点并唤醒group</span></span><br><span class="line">    prev = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, dsn, release);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(prev)) &#123;</span><br><span class="line">        prev-&gt;do_next = dsn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_retain(dg);</span><br><span class="line">        dispatch_atomic_store2o(dsema, dsema_notify_head, dsn, seq_cst);</span><br><span class="line">        dispatch_atomic_barrier(seq_cst); <span class="comment">// &lt;rdar://problem/11750916&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (dispatch_atomic_load2o(dsema, dsema_value, seq_cst) == LONG_MAX) &#123;</span><br><span class="line">            _dispatch_group_wake(dsema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_group_notify的具体实现在dispatch_group_notify_f函数里，逻辑就是将block和queue封装到dispatch_continuation_t里，并将它加到链表的尾部，如果链表为空同时还会设置链表的头部节点。如果dsema_value的值等于初始值，则调用_dispatch_group_wake执行唤醒逻辑。</p><h4 id="3-3-7-dispatch-group-wake-内部API"><a href="#3-3-7-dispatch-group-wake-内部API" class="headerlink" title="3.3.7 dispatch_group_wake(内部API)"></a>3.3.7 dispatch_group_wake(内部API)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wake(<span class="keyword">dispatch_semaphore_t</span> dsema) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> next, head, tail = <span class="literal">NULL</span>, dc;</span><br><span class="line">    <span class="keyword">long</span> rval;</span><br><span class="line">   <span class="comment">//将dsema的dsema_notify_head赋值为NULL，同时将之前的内容赋给head</span></span><br><span class="line">    head = dispatch_atomic_xchg2o(dsema, dsema_notify_head, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line">        <span class="comment">//将dsema的dsema_notify_tail赋值为NULL，同时将之前的内容赋给tail</span></span><br><span class="line">        tail = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    rval = (<span class="keyword">long</span>)dispatch_atomic_xchg2o(dsema, dsema_group_waiters, <span class="number">0</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (rval) &#123;</span><br><span class="line">        <span class="comment">// wake group waiters</span></span><br><span class="line">        _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">kern_return_t</span> kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        &#125; <span class="keyword">while</span> (--rval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line">        <span class="comment">// async group notify blocks</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            next = fastpath(head-&gt;do_next);</span><br><span class="line">            <span class="keyword">if</span> (!next &amp;&amp; head != tail) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!(next = fastpath(head-&gt;do_next))) &#123;</span><br><span class="line">                    dispatch_hardware_pause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">dispatch_queue_t</span> dsn_queue = (<span class="keyword">dispatch_queue_t</span>)head-&gt;dc_data;</span><br><span class="line">            dc = _dispatch_continuation_free_cacheonly(head);</span><br><span class="line">            <span class="comment">//执行dispatch_group_notify的block，见dispatch_queue的分析</span></span><br><span class="line">            dispatch_async_f(dsn_queue, head-&gt;dc_ctxt, head-&gt;dc_func);</span><br><span class="line">            _dispatch_release(dsn_queue);</span><br><span class="line">            <span class="keyword">if</span> (slowpath(dc)) &#123;</span><br><span class="line">                _dispatch_continuation_free_to_cache_limit(dc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((head = next));</span><br><span class="line">        _dispatch_release(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_group_wake</code>首先会循环调用<code>semaphore_signal</code>唤醒等待group的信号量，使<code>dispatch_group_wait</code>函数中等待的线程得以唤醒；然后依次获取链表中的元素并调用<code>dispatch_async_f</code>异步执行<code>dispatch_group_notify</code>函数中注册的回调，使得notify中的block得以执行。</p><h4 id="3-3-8-dispatch-release"><a href="#3-3-8-dispatch-release" class="headerlink" title="3.3.8 dispatch_release"></a>3.3.8 dispatch_release</h4><p>与追加 Block 到 Dispatch Queue 时同样，Block 通过 dispatch_retain 函数持有 Dispatch Group，从而使得该 Block 属于 Dispatch Group，这样如果 Block 执行结束，该 Block 就通过 dispatch_release 函数释放持有的Dispatch Group。</p><p>一旦Dispatch Group使用结束，不用考虑属于该Dispatch Group的Block，立即通过dispatch_release函数释放即可。</p><h4 id="3-3-9-原理小结"><a href="#3-3-9-原理小结" class="headerlink" title="3.3.9 原理小结"></a>3.3.9 原理小结</h4><p>dispatch_group本质是个初始值为LONG_MAX的信号量，等待group中的任务完成其实是等待value恢复初始值。<br> <code>dispatch_group_enter </code> 和 <code>dispatch_group_leave</code> 必须成对出现：</p><ul><li>如果前者比后者多一次，则wait函数等待的线程不会被唤醒和注册notify的回调block不会执行；</li><li>如果后者比前者多一次，则会引起崩溃。</li></ul><h3 id="3-4-dispatch-barrier-async"><a href="#3-4-dispatch-barrier-async" class="headerlink" title="3.4 dispatch_barrier_async"></a>3.4 dispatch_barrier_async</h3><h4 id="3-4-1-使用"><a href="#3-4-1-使用" class="headerlink" title="3.4.1 使用"></a>3.4.1 使用</h4><p>变无序为有序。</p><p>当多线程并发读写同一个资源时，为了保证资源读写的正确性，可以用Barrier Block解决该问题。<br>Dispatch Barrier会确保队列中先于Barrier Block提交的任务都完成后再执行它，并且执行时队列不会同步执行其它任务，等Barrier Block执行完成后再开始执行其他任务。代码示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建自定义并行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.gcdTest.queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;  <span class="comment">//第一步：执行dispatch_barrier_async之前的任务</span></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_barrier_async</span>(queue, ^&#123;  <span class="comment">//第二步：执行dispatch_barrier_async函数添加的任务</span></span><br><span class="line">    <span class="comment">//barrier block,可用于写操作</span></span><br><span class="line">    <span class="comment">//确保资源更新过程中不会有其他线程读取</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work2&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123; <span class="comment">// 第三步：队列恢复为一般的动作，追加到Concurrent Dispatch Queue的处理又开始并行执行</span></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里有个需要注意也是官方文档上提到的一点，如果我们调用dispatch_barrier_async时将Barrier blocks提交到一个global queue，barrier blocks执行效果与dispatch_async()一致；</p><p><strong>只有将 Barrier blocks 提交到使用 DISPATCH_QUEUE_CONCURRENT 属性创建的并行queue时它才会表现的如同预期。</strong></p><h4 id="3-4-2-原理"><a href="#3-4-2-原理" class="headerlink" title="3.4.2 原理"></a>3.4.2 原理</h4><p><code>dispatch_barrier_async</code>是开发中解决多线程读写同一个资源比较好的方案，接下来看一下它的实现。<br>该函数封装调用了<code>dispatch_barrier_async_f</code>，它和dispatch_async_f类似，不同点在于vtable多了DISPATCH_OBJ_BARRIER_BIT标志位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_async_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    dc = <span class="built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_async_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置do_vtable的标志位，从队列中取任务时会用到</span></span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line"></span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_barrier_async</code>如果传入的是global queue，在唤醒队列时会执行<code>_dispatch_queue_wakeup_global</code>函数，故执行效果同<code>dispatch_async</code>一致，验证了使用篇中的备注内容；<br><code>dispatch_barrier_async</code>传的queue为自定义队列时，<code>_dispatch_continuation_pop</code>参数是自定义的queue，然后在<code>_dispatch_continuation_pop</code>中执行自定义队列的dx_invoke函数，即<code>dispatch_queue_invoke</code>。它的调用栈是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_invoke</span><br><span class="line">└──_dispatch_queue_class_invoke</span><br><span class="line">    └──dispatch_queue_invoke2</span><br><span class="line">        └──_dispatch_queue_drain</span><br></pre></td></tr></table></figure><p>重点看一下_dispatch_queue_drain函数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_dispatch_thread_semaphore_t</span> _dispatch_queue_drain(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = dou._dq, orig_tq, old_dq;</span><br><span class="line">    old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dc</span>, *<span class="title">next_dc</span>;</span></span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = <span class="number">0</span>;</span><br><span class="line">    orig_tq = dq-&gt;do_targetq;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dq-&gt;dq_items_tail) &#123;</span><br><span class="line">        dc = _dispatch_queue_head(dq);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)) &#123;</span><br><span class="line">               <span class="comment">//barrier block执行时修改了do_suspend_cnt导致此时为YES</span></span><br><span class="line">               <span class="comment">//保证barrier block执行时其他block不会同时执行</span></span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dq-&gt;dq_running &gt; dq-&gt;dq_width) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> redirect = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">fastpath</span>(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">DISPATCH_OBJ_IS_VTABLE</span>(dc) &amp;&amp;</span><br><span class="line">                        (<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_BARRIER_BIT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dq-&gt;dq_running &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">goto</span> out;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    redirect = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            next_dc = _dispatch_queue_next(dq, dc);</span><br><span class="line">            <span class="keyword">if</span> (redirect) &#123;</span><br><span class="line">                _dispatch_continuation_redirect(dq, dc);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//barrier block之前的block已经执行完，开始执行barrier block</span></span><br><span class="line">            <span class="keyword">if</span> ((sema = _dispatch_barrier_sync_f_pop(dq, dc, <span class="literal">true</span>))) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            _dispatch_continuation_pop(dc);</span><br><span class="line">            _dispatch_perfmon_workitem_inc();</span><br><span class="line">        &#125; <span class="keyword">while</span> ((dc = next_dc));</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line">    <span class="keyword">return</span> sema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while循环中依次取出任务并调用<code>_dispatch_continuation_redirect</code>函数，使得block并发执行。当遇到DISPATCH_OBJ_BARRIER_BIT标记时，会修改do_suspend_cnt标志以保证后续while循环时直接goto out。barrier block的任务执行完之后<code>_dispatch_queue_class_invoke</code>会将do_suspend_cnt重置回去，所以barrier block之后的任务会继续执行。</p><p><code>dispatch_barrier_async</code>的流程见下图：</p><img src="/images/GCD/dispatch_queue-8.png" alt="img" style="zoom:80%;" /><h3 id="3-5-dispatch-apply"><a href="#3-5-dispatch-apply" class="headerlink" title="3.5 dispatch_apply"></a>3.5 dispatch_apply</h3><p>dispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联 API。该函数 <strong>按指定的次数</strong> 将指定的Block追加到指定的队列中，并等待全部处理执行结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1：重复次数</span></span><br><span class="line"><span class="comment"> * 参数2：执行队列</span></span><br><span class="line"><span class="comment"> * 参数3：任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRORITY_DEFAULT,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_apply</span>(<span class="number">10</span>, queue, ^(<span class="keyword">size_t</span> index)&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(@<span class="string">&quot;%zu&quot;</span>,index);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog（@<span class="string">&quot;done&quot;</span>）;</span><br></pre></td></tr></table></figure><ul><li><p>Global Dispatch Queue中执行，所以各个处理的执行时间不定，但是输出结果的最后必定是done，这是因为dispatch_apply函数会等待全部处理执行结束。</p></li><li><p>dispatch_apply和dispatch_sync函数一样，会等待处理执行结束，因此推荐在dispatch_async函数中非同步的执行dispatch_apply函数</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRORITY_DEFAULT,0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在Global Dispatch Queue中非同步执行</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;Global Dispatch Queue,等待dispatch_apply函数中全部处理执行结束</span><br><span class="line">    dispatch_apply([array count], queue, ^(size_t index)&#123;   </span><br><span class="line">  </span><br><span class="line">      &#x2F;&#x2F;并列处理包含在NSArray对象的全部对象  index为0-10</span><br><span class="line">       NSLog(@&quot;%zu ：%@&quot;,index,[array objectAtIndex:index]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;dispatch_apply函数中的处理全部执行结束</span><br><span class="line">   &#x2F;&#x2F;在Main Dispatch Queue中非同步执行</span><br><span class="line">   dispatch_async(dispatch_get_main_queue(),^&#123;</span><br><span class="line">   </span><br><span class="line">     &#x2F;&#x2F;在Main Dispatch Queue中执行处理</span><br><span class="line">     NSLog（@&quot;done&quot;）;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-6-dispatch-suspend-dispatch-resume"><a href="#3-6-dispatch-suspend-dispatch-resume" class="headerlink" title="3.6 dispatch_suspend/dispatch_resume"></a>3.6 dispatch_suspend/dispatch_resume</h3><p>队列的挂起与恢复</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dispatch_suspend函数挂起指定的Dispatch Queue</span></span><br><span class="line"><span class="built_in">dispatch_suspend</span>(queue)</span><br><span class="line"><span class="comment">//dispatch_suspend函数恢复指定的Dispatch Queue</span></span><br><span class="line"><span class="built_in">dispatch_resume</span>(queue)</span><br></pre></td></tr></table></figure><p>函数<strong>对已经执行的处理没有影响</strong>。</p><ul><li>挂起后，追加到Dispatch Queue中但尚未执行的处理，在此之后停止执行</li><li>恢复后使得这些处理能继续执行</li></ul><h3 id="3-7-dispatch-once"><a href="#3-7-dispatch-once" class="headerlink" title="3.7 dispatch_once"></a>3.7 dispatch_once</h3><p>dispatch_once函数时保证在应用程序执行中只执行一次指定处理的API，即使同时多线程调用也是线程安全的。常用于创建单例、swizzeld method等功能。</p><h4 id="3-7-1-API介绍"><a href="#3-7-1-API介绍" class="headerlink" title="3.7.1 API介绍"></a>3.7.1 API介绍</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">//创建单例、method swizzled或其他任务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-7-2-原理"><a href="#3-7-2-原理" class="headerlink" title="3.7.2 原理"></a>3.7.2 原理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用dispatch_once_f来处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">dispatch_block_t</span> block)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_once</code>封装调用了<code>dispatch_once_f</code>函数，其中通过_dispatch_Block_invoke来执行block任务，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invoke是指触发block的具体实现，感兴趣的可以看一下Block_layout的结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_Block_invoke(bb) \</span></span><br><span class="line">        ((<span class="keyword">dispatch_function_t</span>)((struct Block_layout *)bb)-&gt;invoke)</span><br></pre></td></tr></table></figure><p>接着看一下具体的实现函数<code>dispatch_once_f</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once_f</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> * <span class="title">volatile</span> *<span class="title">vval</span> =</span></span><br><span class="line">            (struct _dispatch_once_waiter_s**)val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> <span class="title">dow</span> =</span> &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> *<span class="title">tail</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dispatch_atomic_cmpxchg</span>(vval, <span class="literal">NULL</span>, &amp;dow, acquire)) &#123;</span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_atomic_maximally_synchronizing_barrier</span>();</span><br><span class="line">        <span class="comment">// above assumed to contain release barrier</span></span><br><span class="line">        tmp = <span class="built_in">dispatch_atomic_xchg</span>(vval, DISPATCH_ONCE_DONE, relaxed);</span><br><span class="line">        tail = &amp;dow;</span><br><span class="line">        <span class="keyword">while</span> (tail != tmp) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!tmp-&gt;dow_next) &#123;</span><br><span class="line">                <span class="built_in">dispatch_hardware_pause</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            sema = tmp-&gt;dow_sema;</span><br><span class="line">            tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">            _dispatch_thread_semaphore_signal(sema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dow.dow_sema = _dispatch_get_thread_semaphore();</span><br><span class="line">        tmp = *vval;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dispatch_atomic_cmpxchgvw</span>(vval, tmp, &amp;dow, &amp;tmp, release)) &#123;</span><br><span class="line">                dow.dow_next = tmp;</span><br><span class="line">                _dispatch_thread_semaphore_wait(dow.dow_sema);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _dispatch_put_thread_semaphore(dow.dow_sema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可知<code>dispatch_once</code>的流程图大致如下：</p><img src="/images/GCD/dispatch_once.png" alt="img" style="zoom:80%;" /><p>首先看一下<code>dispatch_once</code>中用的的原子性操作<code>dispatch_atomic_cmpxchg(vval, NULL, &amp;dow, acquire)</code>，它的宏定义展开之后会将$dow赋值给vval，如果vval的初始值为NULL，返回YES,否则返回NO。</p><p>接着结合上面的流程图来看下<code>dispatch_once</code>的代码逻辑：</p><p>首次调用<code>dispatch_once</code>时，因为外部传入的dispatch_once_t变量值为nil，故vval会为NULL，故if判断成立。然后调用<code>_dispatch_client_callout</code>执行block，然后在block执行完成之后将vval的值更新成<code>DISPATCH_ONCE_DONE</code>表示任务已完成。最后遍历链表的节点并调用<code>_dispatch_thread_semaphore_signal</code>来唤醒等待中的信号量；</p><p>当其他线程同时也调用<code>dispatch_once</code>时，因为if判断是原子性操作，故只有一个线程进入到if分支中，其他线程会进入else分支。在else分支中会判断block是否已完成，如果已完成则跳出循环；否则就是更新链表并调用<code>_dispatch_thread_semaphore_wait</code>阻塞线程，等待if分支中的block完成后再唤醒当前等待的线程。</p><h4 id="3-7-3-总结"><a href="#3-7-3-总结" class="headerlink" title="3.7.3 总结"></a>3.7.3 总结</h4><p><code>dispatch_once</code>用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执行block，等block执行完再唤醒所有等待中的线程。</p><p><code>dispatch_once</code>常被用于创建单例、swizzeld method等功能。</p><h3 id="3-8-Dispatch-I-O与Dispatch-Data对象"><a href="#3-8-Dispatch-I-O与Dispatch-Data对象" class="headerlink" title="3.8 Dispatch I/O与Dispatch Data对象"></a>3.8 Dispatch I/O与Dispatch Data对象</h3><p>通过 Dispatch I/O 读写文件，使用 Global Dispatch Queue 将一个文件按大小 read/write。提升读取、写入速度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建队列</span></span><br><span class="line">pipe_q = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;PipeQ&quot;</span>,<span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Dispatch I/O对象</span></span><br><span class="line">pipe_channel = <span class="built_in">dispatch_io_create</span>(DISPATCH_IO_STREAM,fd,pipe_q,^(<span class="keyword">int</span> err)&#123;</span><br><span class="line">   <span class="built_in">close</span>(fd);   <span class="comment">//发生错误时执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">*out_fd = fdpair[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一次读取的最大字节</span></span><br><span class="line"><span class="built_in">dispatch_io_set_high_water</span>(pipe_channel, SIZE_MIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一次读取的最小字节</span></span><br><span class="line"><span class="built_in">dispatch_io_set_low_water</span>(pipe_channel,SIZE_MAX);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开始异步读取</span></span><br><span class="line"><span class="built_in">dispatch_io_read</span>(pipe_channel,<span class="number">0</span>,SIZE_MAX,pipe_q, ^(<span class="keyword">bool</span> done,<span class="keyword">dispatch_data_t</span> pipe data,<span class="keyword">int</span> err)&#123;</span><br><span class="line"><span class="comment">//每当各个分割的文件快读取结束时，将含有文件块数据的Dispatch Data传递给dispatch_io_read函数指定的读取结束时回调用的Block。回调用的Block分析传递过来的Dispatch Data并进行结合处理</span></span><br><span class="line">   <span class="keyword">if</span>(err == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">size_t</span> len = <span class="built_in">dispatch_data_get_size</span>(pipe data);</span><br><span class="line">       <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> *bytes = <span class="literal">NULL</span>;</span><br><span class="line">          <span class="keyword">char</span> *encoded;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">dispatch_data_t</span> md = <span class="built_in">dispatch_data_create_map</span>(pipe data,(<span class="keyword">const</span> <span class="keyword">void</span> **)&amp;bytes,&amp;len);</span><br><span class="line">          <span class="built_in">asl_set</span>((aslmsg)merged_msg,ASL_KEY_AUX_DATA,encoded);</span><br><span class="line">          <span class="built_in">free</span>(encoded);</span><br><span class="line">          _asl_send_message(<span class="literal">NULL</span>,merged_msg,<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">          <span class="built_in">asl_msg_release</span>(merged_msg);</span><br><span class="line">          <span class="built_in">dispatch_release</span>(md);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(done)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">dispatch_semaphore_signal</span>(sem);</span><br><span class="line">         <span class="built_in">dispatch_release</span>(pipe_channel);</span><br><span class="line">         <span class="built_in">dispatch_release</span>(pipe_q);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-9-dispatch-source"><a href="#3-9-dispatch-source" class="headerlink" title="3.9 dispatch_source"></a>3.9 dispatch_source</h3><p>Dispatch Source是BSD系统内核惯有功能kqueue的包装，kqueue是在XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。它的CPU负荷非常小，尽量不占用资源。当事件发生时，Dispatch Source会在指定的Dispatch Queue中执行事件的处理。</p><h4 id="3-9-1-使用"><a href="#3-9-1-使用" class="headerlink" title="3.9.1 使用"></a>3.9.1 使用</h4><p>dispatch_source最常见的用法就是用来实现定时器，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_source_t</span> source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(source, dispatch_time(DISPATCH_TIME_NOW, <span class="number">0</span>), <span class="number">3</span> * NSEC_PER_SEC, <span class="number">0</span>);</span><br><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">    <span class="comment">//定时器触发时执行</span></span><br><span class="line">   NSLog(@<span class="string">&quot;timer响应了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动timer</span></span><br><span class="line">dispatch_resume(source);</span><br></pre></td></tr></table></figure><p><code>Dispatch Source</code>定时器的代码看似很简单，但其实是GCD中坑最多的API了，如果处理不好很容易引起Crash。关于<code>Dispatch Source</code>定时器需要注意的知识点请参考文章最后的总结篇。</p><h4 id="3-9-2-原理"><a href="#3-9-2-原理" class="headerlink" title="3.9.2 原理"></a>3.9.2 原理</h4><h5 id="1-dispatch-source-create"><a href="#1-dispatch-source-create" class="headerlink" title="1. dispatch_source_create"></a>1. dispatch_source_create</h5><p><code>dispatch_source_create</code>函数用来创建dispatch_source_t对象，简化后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_source_t</span> <span class="title">dispatch_source_create</span><span class="params">(<span class="keyword">dispatch_source_type_t</span> type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uintptr_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mask,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">dispatch_queue_t</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//申请内存空间</span></span><br><span class="line">    ds = _dispatch_alloc(DISPATCH_VTABLE(source),</span><br><span class="line">            <span class="keyword">sizeof</span>(struct dispatch_source_s));</span><br><span class="line">    <span class="comment">//初始化ds</span></span><br><span class="line">    _dispatch_queue_init((<span class="keyword">dispatch_queue_t</span>)ds);</span><br><span class="line">    ds-&gt;dq_label = <span class="string">&quot;source&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ds-&gt;do_ref_cnt++; <span class="comment">// the reference the manager queue holds</span></span><br><span class="line">    ds-&gt;do_ref_cnt++; <span class="comment">// since source is created suspended</span></span><br><span class="line">    <span class="comment">//默认处于暂状态，需要手动调用resume</span></span><br><span class="line">    ds-&gt;do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_INTERVAL;</span><br><span class="line">    ds-&gt;do_targetq = &amp;_dispatch_mgr_q;</span><br><span class="line">    <span class="comment">// First item on the queue sets the user-specified target queue</span></span><br><span class="line">    <span class="comment">//设置事件回调的队列</span></span><br><span class="line">    dispatch_set_target_queue(ds, q);</span><br><span class="line">    _dispatch_object_debug(ds, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-dispatch-source-set-timer"><a href="#2-dispatch-source-set-timer" class="headerlink" title="2. dispatch_source_set_timer"></a>2. dispatch_source_set_timer</h5><p>dispatch_source_set_timer实际上调用了_dispatch_source_set_timer，看一下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_source_set_timer(<span class="keyword">dispatch_source_t</span> ds, <span class="keyword">dispatch_time_t</span> start,</span><br><span class="line">        <span class="keyword">uint64_t</span> interval, <span class="keyword">uint64_t</span> leeway, <span class="keyword">bool</span> source_sync) &#123;</span><br><span class="line">    <span class="comment">//首先屏蔽非timer类型的source</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!ds-&gt;ds_is_timer) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">ds_timer</span>(ds-&gt;ds_refs).flags &amp; DISPATCH_TIMER_INTERVAL)) &#123;</span><br><span class="line">        <span class="built_in">DISPATCH_CLIENT_CRASH</span>(<span class="string">&quot;Attempt to set timer on a non-timer source&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建dispatch_set_timer_params结构体绑定source和timer参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span>;</span></span><br><span class="line">    params = _dispatch_source_timer_params(ds, start, interval, leeway);</span><br><span class="line">    _dispatch_source_timer_telemetry(ds, params-&gt;ident, &amp;params-&gt;values);</span><br><span class="line">    <span class="built_in">dispatch_retain</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (source_sync) &#123;</span><br><span class="line">       <span class="comment">//将source当做队列使用，执行dispatch_barrier_async_f压入队列，</span></span><br><span class="line">       <span class="comment">//核心函数为_dispatch_source_set_timer2</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, params,</span><br><span class="line">                _dispatch_source_set_timer2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_source_set_timer2(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_source_set_timer</code>实际上是调用了<code>_dispatch_source_set_timer2</code>函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_timer2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="comment">// Called on the source queue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span> =</span> context;</span><br><span class="line">    <span class="comment">//暂停队列，避免修改过程中定时器被触发了。</span></span><br><span class="line">    <span class="built_in">dispatch_suspend</span>(params-&gt;ds);</span><br><span class="line">    <span class="comment">//在_dispatch_mgr_q队列上执行_dispatch_source_set_timer3(params)</span></span><br><span class="line">    <span class="built_in">dispatch_barrier_async_f</span>(&amp;_dispatch_mgr_q, params,</span><br><span class="line">            _dispatch_source_set_timer3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_source_set_timer2</code>函数的逻辑是在_dispatch_mgr_q队列执行<code>_dispatch_source_set_timer3(params)</code>，接下来的逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_timer3(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="comment">// Called on the _dispatch_mgr_q</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span> =</span> context;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = params-&gt;ds;</span><br><span class="line">    ds-&gt;ds_ident_hack = params-&gt;ident;</span><br><span class="line">    <span class="built_in">ds_timer</span>(ds-&gt;ds_refs) = params-&gt;values;</span><br><span class="line">    ds-&gt;ds_pending_data = <span class="number">0</span>;</span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_or2o</span>(ds, ds_atomic_flags, DSF_ARMED, release);</span><br><span class="line">    <span class="comment">//恢复队列，对应着_dispatch_source_set_timer2函数中的dispatch_suspend</span></span><br><span class="line">    <span class="built_in">dispatch_resume</span>(ds);</span><br><span class="line">    <span class="comment">// Must happen after resume to avoid getting disarmed due to suspension</span></span><br><span class="line">    <span class="comment">//根据下一次触发时间将timer进行排序</span></span><br><span class="line">    _dispatch_timers_update(ds);</span><br><span class="line">    <span class="built_in">dispatch_release</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (params-&gt;values.flags &amp; DISPATCH_TIMER_WALL_CLOCK) &#123;</span><br><span class="line">        _dispatch_mach_host_calendar_change_register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行提交到_dispatch_mgr_q队列的block时，会调用&amp;_dispatch_mgr_q-&gt;do_invoke函数，即&amp;_dispatch_mgr_q的vtable中定义的<code>_dispatch_mgr_thread</code>。接下来会走到<code>_dispatch_mgr_invoke</code>函数。在这个函数里用I/O多路复用功能的select来实现定时器功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="built_in">select</span>(FD_SETSIZE, &amp;tmp_rfds, &amp;tmp_wfds, <span class="literal">NULL</span>,</span><br><span class="line">            poll ? (struct timeval*)&amp;timeout_immediately : <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>当内层的 <code>_dispatch_mgr_q</code> 队列被唤醒后，还会进一步唤醒外层的队列(当初用户指定的那个)，并在指定队列上执行 timer 触发时的 block。</p><h5 id="3-dispatch-source-set-event-handler"><a href="#3-dispatch-source-set-event-handler" class="headerlink" title="3. dispatch_source_set_event_handler"></a>3. dispatch_source_set_event_handler</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_source_set_event_handler</span><span class="params">(<span class="keyword">dispatch_source_t</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将block进行copy后压入到队列中</span></span><br><span class="line">    handler = _dispatch_Block_copy(handler);</span><br><span class="line">    _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, handler,</span><br><span class="line">            _dispatch_source_set_event_handler2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_event_handler2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = (<span class="keyword">dispatch_source_t</span>)_dispatch_queue_get_current();</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(<span class="built_in">dx_type</span>(ds) == DISPATCH_SOURCE_KEVENT_TYPE);</span><br><span class="line">    <span class="keyword">dispatch_source_refs_t</span> dr = ds-&gt;ds_refs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ds-&gt;ds_handler_is_block &amp;&amp; dr-&gt;ds_handler_ctxt) &#123;</span><br><span class="line">        <span class="built_in">Block_release</span>(dr-&gt;ds_handler_ctxt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置上下文，保存提交的block等信息</span></span><br><span class="line">    dr-&gt;ds_handler_func = context ? _dispatch_Block_invoke(context) : <span class="literal">NULL</span>;</span><br><span class="line">    dr-&gt;ds_handler_ctxt = context;</span><br><span class="line">    ds-&gt;ds_handler_is_block = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-dispatch-source-set-cancel-handler"><a href="#4-dispatch-source-set-cancel-handler" class="headerlink" title="4. dispatch_source_set_cancel_handler"></a>4. dispatch_source_set_cancel_handler</h5><p><code>dispatch_source_set_cancel_handler</code>与<code>dispatch_source_set_event_handler</code>功能类似，保存一下取消事件处理的上下文信息。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_source_set_cancel_handler</span><span class="params">(<span class="keyword">dispatch_source_t</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">dispatch_block_t</span> handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将block进行copy后压入到队列中</span></span><br><span class="line">    handler = _dispatch_Block_copy(handler);</span><br><span class="line">    _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, handler,</span><br><span class="line">            _dispatch_source_set_cancel_handler2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_cancel_handler2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = (<span class="keyword">dispatch_source_t</span>)_dispatch_queue_get_current();</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(<span class="built_in">dx_type</span>(ds) == DISPATCH_SOURCE_KEVENT_TYPE);</span><br><span class="line">    <span class="keyword">dispatch_source_refs_t</span> dr = ds-&gt;ds_refs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ds-&gt;ds_cancel_is_block &amp;&amp; dr-&gt;ds_cancel_handler) &#123;</span><br><span class="line">        <span class="built_in">Block_release</span>(dr-&gt;ds_cancel_handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存事件取消的信息</span></span><br><span class="line">    dr-&gt;ds_cancel_handler = context;</span><br><span class="line">    ds-&gt;ds_cancel_is_block = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-dispatch-resume-dispatch-suspend"><a href="#5-dispatch-resume-dispatch-suspend" class="headerlink" title="5. dispatch_resume/dispatch_suspend"></a>5. dispatch_resume/dispatch_suspend</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//恢复</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_resume</span><span class="params">(<span class="keyword">dispatch_object_t</span> dou)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DISPATCH_OBJECT_TFB</span>(_dispatch_objc_resume, dou);</span><br><span class="line">    <span class="comment">// Global objects cannot be suspended or resumed.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">dx_type</span>(dou._do) == DISPATCH_QUEUE_ROOT_TYPE)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将do_suspend_cnt原子性减二，并返回之前存储的值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> suspend_cnt = <span class="built_in">dispatch_atomic_sub_orig2o</span>(dou._do,</span><br><span class="line">             do_suspend_cnt, DISPATCH_OBJECT_SUSPEND_INTERVAL, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(suspend_cnt &gt; DISPATCH_OBJECT_SUSPEND_INTERVAL)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(suspend_cnt == DISPATCH_OBJECT_SUSPEND_INTERVAL)) &#123;</span><br><span class="line">        _dispatch_wakeup(dou._do);</span><br><span class="line">     <span class="keyword">return</span> _dispatch_release(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DISPATCH_CLIENT_CRASH</span>(<span class="string">&quot;Over-resume of an object&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_suspend</span><span class="params">(<span class="keyword">dispatch_object_t</span> dou)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DISPATCH_OBJECT_TFB</span>(_dispatch_objc_suspend, dou);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">dx_type</span>(dou._do) == DISPATCH_QUEUE_ROOT_TYPE)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将do_suspend_cnt原子性加二</span></span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_add2o</span>(dou._do, do_suspend_cnt,</span><br><span class="line">            DISPATCH_OBJECT_SUSPEND_INTERVAL, relaxed);</span><br><span class="line">    _dispatch_retain(dou._do);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断队列是否暂停的依据是do_suspend_cnt是否大于等于2,全局队列和主队列默认都是小于2的，即处于启动状态。<br>而dispatch_source_create方法中，do_suspend_cnt初始为DISPATCH_OBJECT_SUSPEND_INTERVAL，即默认处于暂停状态，需要手动调用resume开启。<br>代码定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPEND_LOCK        1u</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPEND_INTERVAL    2u</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPENDED(x) \</span></span><br><span class="line">        ((x)-&gt;do_suspend_cnt &gt;= DISPATCH_OBJECT_SUSPEND_INTERVAL)</span><br></pre></td></tr></table></figure><h4 id="3-9-3-总结"><a href="#3-9-3-总结" class="headerlink" title="3.9.3 总结"></a>3.9.3 总结</h4><p>Dispatch Source使用最多的就是用来实现定时器，source创建后默认是暂停状态，需要手动调用<code>dispatch_resume</code>启动定时器。<code>dispatch_after</code>只是封装调用了dispatch source定时器，然后在回调函数中执行定义的block。</p><p>Dispatch Source定时器使用时也有一些需要注意的地方，不然很可能会引起crash：</p><ol><li>循环引用：因为dispatch_source_set_event_handler回调是个block，在添加到source的链表上时会执行copy并被source强引用，如果block里持有了self，self又持有了source的话，就会引起循环引用。正确的方法是使用weak+strong或者提前调用dispatch_source_cancel取消timer。</li><li><code>dispatch_resume</code>和<code>dispatch_suspend</code>调用次数需要平衡，如果重复调用dispatch_resume则会崩溃,因为重复调用会让<code>dispatch_resume</code>代码里if分支不成立，从而执行了DISPATCH_CLIENT_CRASH(“Over-resume of an object”)导致崩溃。</li><li>source在suspend状态下，如果直接设置source = nil或者重新创建source都会造成crash。正确的方式是在resume状态下调用dispatch_source_cancel(source)后再重新创建。</li></ol><h3 id="3-10-dispatch-after-延迟执行"><a href="#3-10-dispatch-after-延迟执行" class="headerlink" title="3.10 dispatch_after(延迟执行)"></a>3.10 dispatch_after(延迟执行)</h3><h4 id="3-10-1-使用"><a href="#3-10-1-使用" class="headerlink" title="3.10.1 使用"></a>3.10.1 使用</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取精确时间点</span></span><br><span class="line"><span class="comment">typedef uint64_t dispatch_time_t;</span></span><br><span class="line"><span class="comment">#define DISPATCH_TIME_NOW (0ull)</span></span><br><span class="line"><span class="comment">#define DISPATCH_TIME_FOREVER (~0ull)</span></span><br><span class="line"><span class="comment">* 参数1:  开始时间  DISPATCH_TIME_NOW(现在的时间)</span></span><br><span class="line"><span class="comment">* 参数2：多久后  数值和NSEC_PER_SEC的乘积得到单位为毫微秒的数值，ull是C语言的数值字面量，是显示表明类型时使用的字符串（表示‘unsigned long long’） ，NSEC_PER_MSEC表示毫秒单位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW , <span class="number">3</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1：指定时间用的dispatch_time_t类型的值，dispatch_time_t类型的值使用dispatch_time函数或者dispatch _walltime函数生成</span></span><br><span class="line"><span class="comment"> * 参数2：指定要追加处理的Dispatch Queue</span></span><br><span class="line"><span class="comment"> * 参数3：指定记述要执行处理的Block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dispatch_after(time , dispatch_get_main_queue(), ^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;waited at least three seconds &quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>dispatch_after 函数并不是在指定时间后执行处理，而只是在指定时间追加处理到 Dispatch Queue，上述代码与3秒后用 dispatch_async 函数追加 Block 到 Main Dispatch Queue 的相同。</li><li>因为 Main Dispatch Queue 在主线程的 RunLoop 中执行，所以在比如每隔 1/60 秒执行的 RunLoop 中，Block 最快在3秒后执行，最慢在 3秒+1/60秒 后执行，并且在 Main Dispatch Queue 有大量处理追加或主线程的处理本身有延迟是，这个时间会更长。</li></ul><p>dispatch_walltime 函数由 POSLX 中使用的 struct timespec 类型的时间得到 dispatch _time_t 类型的值。</p><p>dispatch _time函数通常用于计算相对时间。</p><p>dispatch_walltime函数用于计算绝对时间，需要指定精确时间参数，可作为粗略的闹钟功能使用。</p><h4 id="3-10-2-原理"><a href="#3-10-2-原理" class="headerlink" title="3.10.2 原理"></a>3.10.2 原理</h4><p><code>dispatch_after</code>是基于Dispatch Source的定时器实现的，函数内部直接调用<code>dispatch_after_f</code>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_after_f</span><span class="params">(<span class="keyword">dispatch_time_t</span> when, <span class="keyword">dispatch_queue_t</span> queue, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> delta, leeway;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds;</span><br><span class="line">    <span class="comment">//屏蔽DISPATCH_TIME_FOREVER类型</span></span><br><span class="line">    <span class="keyword">if</span> (when == DISPATCH_TIME_FOREVER) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_DEBUG</span></span><br><span class="line">        <span class="built_in">DISPATCH_CLIENT_CRASH</span>(</span><br><span class="line">                <span class="string">&quot;dispatch_after_f() called with &#x27;when&#x27; == infinity&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delta = _dispatch_timeout(when);</span><br><span class="line">    <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_async_f</span>(queue, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    leeway = delta / <span class="number">10</span>; <span class="comment">// &lt;rdar://problem/13447496&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (leeway &lt; NSEC_PER_MSEC) leeway = NSEC_PER_MSEC;</span><br><span class="line">    <span class="keyword">if</span> (leeway &gt; <span class="number">60</span> * NSEC_PER_SEC) leeway = <span class="number">60</span> * NSEC_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this function can and should be optimized to not use a dispatch source</span></span><br><span class="line">    <span class="comment">//创建dispatch_source</span></span><br><span class="line">    ds = <span class="built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(ds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dc-&gt;dc_data = ds;</span><br><span class="line">    <span class="comment">//将dispatch_continuation_t存储到上下文中</span></span><br><span class="line">    <span class="built_in">dispatch_set_context</span>(ds, dc);</span><br><span class="line">    <span class="comment">//设置timer并启动</span></span><br><span class="line">    <span class="built_in">dispatch_source_set_event_handler_f</span>(ds, _dispatch_after_timer_callback);</span><br><span class="line">    <span class="built_in">dispatch_source_set_timer</span>(ds, when, DISPATCH_TIME_FOREVER, leeway);</span><br><span class="line">    <span class="built_in">dispatch_resume</span>(ds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timer到时之后，会调用<code>_dispatch_after_timer_callback</code>函数，在这里取出上下文里的block并执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_after_timer_callback(<span class="keyword">void</span> *ctxt) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = ctxt, dc1;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = dc-&gt;dc_data;</span><br><span class="line">    dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">    <span class="comment">//执行任务的block并执行</span></span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="comment">//清理数据</span></span><br><span class="line">    <span class="built_in">dispatch_source_cancel</span>(ds);</span><br><span class="line">    <span class="built_in">dispatch_release</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dc1)) &#123;</span><br><span class="line">        _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、GCD的实现补充"><a href="#四、GCD的实现补充" class="headerlink" title="四、GCD的实现补充"></a>四、GCD的实现补充</h2><h3 id="4-1-Dispatch-Quene"><a href="#4-1-Dispatch-Quene" class="headerlink" title="4.1 Dispatch Quene"></a>4.1 Dispatch Quene</h3><h4 id="4-1-1-Dispatch-Quene实现所需"><a href="#4-1-1-Dispatch-Quene实现所需" class="headerlink" title="4.1.1 Dispatch Quene实现所需"></a>4.1.1 Dispatch Quene实现所需</h4><p>GCD的实现会使用下面这些工具，但不仅仅只有这些：</p><ul><li>用于管理追加的Block的C语言实现的FIFO队列；</li><li>Atomic函数中实现的用于排他控制的轻量级信号；</li><li>用于管理线程的C语言实现的一些容器。</li></ul><p><strong>GCD 是在系统级即iOS和OS X的核心XNU内核级上实现，所以开发者无论如何努力编写线程关系代码，<code>性能</code>都不可能胜过XNU内核级所实现的GCD。</strong></p><p>用于实现Dispatch Queue的几个软件组件框架：</p><ul><li>组件libdispatch提供Dispatch Quene技术；</li><li>组件Libc(pthreads)提供pthread_workquene技术；</li><li>组件XNU内核提供workquene技术。</li></ul><h4 id="4-1-2-执行上下文"><a href="#4-1-2-执行上下文" class="headerlink" title="4.1.2  执行上下文"></a>4.1.2  执行上下文</h4><p>Dispatch Quene通过结构体和链表，被实现为FIFO队列。</p><p>Block并不是直接加入FIFO队列，而是先加入 <code>Dispatch Continuation</code> 这一 <code>dispatch_continuation_t类型</code> 结构体中，然后再加入 FIFO 队列。该 Dispatch Continuation 用于记忆 Block 所属的 Dispatch Group 和其他一些信息，相当于一般常说的**<code>执行上下文</code>**。</p><p>上一节在讲 <code>Global Dispatch Queue</code> 的时候，我们介绍过8种类型，这8种 Global Dispatch Quene 各使用一个pthread_workquene。GCD初始化时，使用 <code>pthread_workquene_creat_np</code> 函数生成 pthread_workquene。</p><p>pthread_workquene包含在Libc提供的pthreads API 中。其使用bsdthread_register和workq_open系统调用，<strong>在初始化XNU内核的workquene之后获取workquene信息</strong>。</p><p>XNU内核持有4种workquene：</p><ul><li>WORKQUENE_HIGH_PRIOQUENE</li><li>WORKQUENE_Default_PRIOQUENE</li><li>WORKQUENE_Low_PRIOQUENE</li><li>WORKQUENE_BG_PRIOQUENE</li></ul><p>以上4种执行优先级的workqueue，其执行优先级与Global Dispatch Quene的四种执行优先级相同。</p><p><strong>Global Dispatch Queue → Libc pthread_wordqueue → XNU workqueue</strong></p><img src="/images/GCD/gcd-imp-1.jpg" style="zoom:80%"><h4 id="4-1-3-Dispatch-Queue执行Block的过程"><a href="#4-1-3-Dispatch-Queue执行Block的过程" class="headerlink" title="4.1.3  Dispatch Queue执行Block的过程"></a>4.1.3  Dispatch Queue执行Block的过程</h4><ol><li><p>在Global Dispatch Queue 中执行Block时，libdispatch 从Global Dispatch Queue自身的FIFO队列取出<code>Dispatch Continuation</code></p></li><li><p>调用<code>pthread_workqueue_additem_np</code>函数将该Global Dispatch Queue 本身、符合其优先级的workqueue信息以及执行Dispatch Continuation的回调函数等传递给参数。</p></li><li><p>pthread_workqueue_additem_np函数使用<code>workq_kernreturn系统调用</code>，通知workqueue增加应当执行的项目。</p><p>根据该通知，XNU内核基于系统状态判断是否要生成线程。如果是<code>Overcommit优先级</code>的Global Dispatch Queue ，workqueue则始终生成线程(该线程虽然与iOS和OS X中通常使用的线程大致相同，但是有一部分pthread API不能使用)。</p><p>因为workqueue生成的线程在实现用于workqueue的线程计划表中运行，他的<code>上下文切换(shift context)</code>与普通的线程有很大的不同。这也是我们使用GCD的原因。</p></li><li><p>workqueue的线程 –&gt; 执行pthread_workqueue函数 –&gt; 该函数调用libdispatch的回调函数。在该回调函数中执行加入到Global Dispatch Queue中的下一个Block。</p></li><li><p>Block执行结束后，进行通知Dispatch Group结束、释放Dispatch Continuation等处理，开始准备执行加入到Global Dispatch Queue中的下一个Block</p></li></ol><h3 id="4-2-Dispatch-Source"><a href="#4-2-Dispatch-Source" class="headerlink" title="4.2 Dispatch Source"></a>4.2 Dispatch Source</h3><p>GCD中除了主要的Dispatch Queue外，还有不太引人注目的Dispatch Source。它是BSD系内核惯有功能<code>kqueue的包装</code>。</p><p><strong>kqueue是XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。其CPU负荷非常小，尽量不占用资源。kqueue可以说是应用程序处理XNU内核中发生的各种事件的方法中最优秀的一种。</strong></p><p>Dispatch Source可处理以下事件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_SOURCE_TYPE_DATA_ADD   变量增加</span><br><span class="line">DISPATCH_SOURCE_TYPE_DATA_OR    变量OR</span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_SEND  MACH端口发送</span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_RECV  MACH端口接收</span><br><span class="line">DISPATCH_SOURCE_TYPE_PROC   检测到与进程相关的事件</span><br><span class="line">DISPATCH_SOURCE_TYPE_READ   可读取文件映像</span><br><span class="line">DISPATCH_SOURCE_TYPE_SIGNAL 接收信号</span><br><span class="line">DISPATCH_SOURCE_TYPE_TIMER  定时器</span><br><span class="line">DISPATCH_SOURCE_TYPE_VNODE  文件系统有变更</span><br><span class="line">DISPATCH_SOURCE_TYPE_WRITE  可写入文件映像</span><br></pre></td></tr></table></figure><p>事件发生时，在指定的Dispatch Queue中可执行事件的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatc_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  基于READ事件作成Dispatch Source</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">dispatch_source_t</span> source = <span class="built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_READ, sockfd, <span class="number">0</span> , queuq);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定发生READ事件时执行的处理 */</span>    </span><br><span class="line"><span class="built_in">dispatch_source_set_event_handler</span>(source, ^&#123;</span><br><span class="line">    <span class="comment">// 处理结束，取消Dispatch Source</span></span><br><span class="line">    <span class="built_in">dispatch_source_cancel</span>(source);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定取消Dispatch Source时的处理 */</span></span><br><span class="line"><span class="built_in">dispatch_source_set_cancel_handler</span>(source, ^&#123;</span><br><span class="line">    <span class="comment">/* 释放Dispatch Source(自身) */</span></span><br><span class="line">    <span class="built_in">dispatch_release</span>(source);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动Dispatch Source */</span></span><br><span class="line"><span class="built_in">dispatch_resume</span>(source);</span><br></pre></td></tr></table></figure><p>与上面代码非常相似的代码，使用在了Core Foundation框架的用于异步网络的<code>API CFSocket</code>中。因为<strong>Foundation框架的异步网络API是通过CFSocket实现</strong>的，所以可享受到仅使用Foundation框架的Dispatch Source(即GCD)带来的好处。</p><p>一旦将任务追加到Dispatch Queue中，就没有办法将任务取消，也没有办法在执行中取消任务。Dispatch Source是可以取消的，而且取消时的处理可以block的形式作为参数配置。<strong>在必须使用kqueue的情况下，推荐大家使用Dispatch Source，比较简单</strong>。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="https://xiaozhuanlan.com/iOSDevNotes">iOS开发笔记 — 小专栏</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、什么是多线程编程？&quot;&gt;&lt;a href=&quot;#一、什么是多线程编程？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是多线程编程？&quot;&gt;&lt;/a&gt;一、什么是多线程编程？&lt;/h2&gt;&lt;p&gt;先来复习一下&lt;code&gt;操作系统&lt;/code&gt;中线程相关的知识点：&lt;</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="GCD" scheme="https://tenloy.github.io/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>AutoreleasePool</title>
    <link href="https://tenloy.github.io/2021/06/29/14_AutoreleasePool/"/>
    <id>https://tenloy.github.io/2021/06/29/14_AutoreleasePool/</id>
    <published>2021-06-29T16:19:21.000Z</published>
    <updated>2021-07-03T15:03:45.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Autorelease简介"><a href="#一、Autorelease简介" class="headerlink" title="一、Autorelease简介"></a>一、Autorelease简介</h2><p>iOS开发中的Autorelease机制是为了延时释放对象。自动释放的概念看上去很像ARC，但实际上这更类似于C语言中自动变量的特性。</p><p>自动变量：在超出变量作用域后将被废弃；<br> 自动释放池：在超出释放池生命周期后，向其管理的对象实例的发送<code>release</code>消息。</p><h3 id="1-1-MRC下使用自动释放池"><a href="#1-1-MRC下使用自动释放池" class="headerlink" title="1.1 MRC下使用自动释放池"></a>1.1 MRC下使用自动释放池</h3><p>在MRC环境中使用自动释放池需要用到<code>NSAutoreleasePool</code>对象，其生命周期就相当于C语言变量的作用域。对于所有调用过<code>autorelease</code>方法的对象，在废弃<code>NSAutoreleasePool</code>对象时，都将调用<code>release</code>实例方法。用源代码表示如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="comment">//第一步：生成并持有释放池NSAutoreleasePool对象;</span></span><br><span class="line"><span class="type">NSAutoreleasePool</span> <span class="operator">*</span>pool <span class="operator">=</span> [[<span class="type">NSAutoreleasePool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：调用对象的autorelease实例方法;</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：废弃NSAutoreleasePool对象;</span></span><br><span class="line">[pool drain];   <span class="comment">//向pool管理的所有对象发送消息，相当于[obj release]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obi已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))</span></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br></pre></td></tr></table></figure><p>理解<code>NSAutoreleasePool</code>对象的生命周期，如下图所示：</p><img src="/images/RunLoop/AutoreleasePool5.png" width = "50%" alt="" align=center /><h3 id="1-2-ARC下使用自动释放池"><a href="#1-2-ARC下使用自动释放池" class="headerlink" title="1.2 ARC下使用自动释放池"></a>1.2 ARC下使用自动释放池</h3><p>ARC环境不能使用<code>NSAutoreleasePool</code>类也不能调用<code>autorelease</code>方法，代替它们实现对象自动释放的是<code>@autoreleasepool</code>块和<code>__autoreleasing</code>修饰符。比较两种环境下的代码差异如下图：</p><img src="/images/RunLoop/AutoreleasePool4.png" width = "60%" alt="" align=center /><p>如图所示，<code>@autoreleasepool</code>块替换了<code>NSAutoreleasePoool</code>类对象的生成、持有及废弃这一过程。而附有<code>__autoreleasing</code>修饰符的变量替代了<code>autorelease</code>方法，将对象注册到了<code>Autoreleasepool</code>；由于ARC的优化，<code>__autorelease</code>是可以被省略的，所以简化后的ARC代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式使用<code>__autoreleasing</code>修饰符的情况非常少见，这是因为ARC的很多情况下，即使是不显式的使用<code>__autoreleasing</code>，也能实现对象被注册到释放池中。主要包括以下几种情况：</p><ol><li>编译器会进行优化，检查方法名是否以<code>alloc/new/copy/mutableCopy</code>开始，如果不是则自动将返回对象注册到<code>Autoreleasepool</code>;</li><li>访问附有<code>__weak</code>修饰符的变量时，实际上必定要访问注册到<code>Autoreleasepool</code>的对象，即会自动加入<code>Autoreleasepool</code>;</li><li>id的指针或对象的指针(id*，NSError **)，在没有显式地指定修饰符时候，会被默认附加上<code>__autoreleasing</code>修饰符，加入<code>Autoreleasepool</code></li></ol><p><strong>注意：</strong>如果编译器版本为LLVM.3.0以上，即使ARC无效<code>@autoreleasepool</code>块也能够使用；如下源码所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [obj autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、AutoRelease原理"><a href="#二、AutoRelease原理" class="headerlink" title="二、AutoRelease原理"></a>二、AutoRelease原理</h2><h3 id="2-1-使用-autoreleasepool"><a href="#2-1-使用-autoreleasepool" class="headerlink" title="2.1 使用@autoreleasepool{}"></a>2.1 使用@autoreleasepool{}</h3><p>我们在<code>main</code>函数中写入自动释放池相关的测试代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了探究释放池的底层实现，我们在终端使用<code>clang -rewrite-objc + 文件名</code>命令将上述OC代码转化为C++源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0);</span><br><span class="line">     &#125;<span class="comment">//大括号对应释放池的作用域</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过编译器<code>clang</code>命令转化后，我们看到的所谓的<code>@autoreleasePool</code>块，其实对应着<code>__AtAutoreleasePool</code>的结构体。</p><h3 id="2-2-分析结构体-AtAutoreleasePool的具体实现"><a href="#2-2-分析结构体-AtAutoreleasePool的具体实现" class="headerlink" title="2.2 分析结构体__AtAutoreleasePool的具体实现"></a>2.2 分析结构体__AtAutoreleasePool的具体实现</h3><p>在源码中找到<code>__AtAutoreleasePool</code>结构体的实现代码，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line">__AtAutoreleasePool`结构体包含了：构造函数、析构函数和一个边界对象；</span><br><span class="line"> 构造函数内部调用：`objc_autoreleasePoolPush()`方法，返回边界对象`atautoreleasepoolobj`</span><br><span class="line"> 析构函数内部调用：`objc_autoreleasePoolPop()`方法，传入边界对象`atautoreleasepoolobj</span><br></pre></td></tr></table></figure><p>分析<code>main</code>函数中<code>__autoreleasepool</code>结构体实例的生命周期是这样的：<br> <code>__autoreleasepool</code>是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面<code>main</code>函数的代码简化如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">        void <span class="operator">*</span>atautoreleasepoolobj <span class="operator">=</span> objc_autoreleasePoolPush();</span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop"><a href="#2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop" class="headerlink" title="2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop"></a>2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop</h3><p>进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对<code>AutoreleasePoolPage</code>对应静态方法<code>push</code>和<code>pop</code>的封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-理解AutoreleasePoolPage"><a href="#2-4-理解AutoreleasePoolPage" class="headerlink" title="2.4 理解AutoreleasePoolPage"></a>2.4 理解AutoreleasePoolPage</h3><p><code>AutoreleasePoolPage</code>是一个C++中的类，打开<code>Runtime</code>的源码工程，在<code>NSObject.mm</code>文件中可以找到它的定义，摘取其中的关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大致在641行代码开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> &#123;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)  <span class="comment">//空池占位</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil                <span class="comment">//边界对象(即哨兵对象）</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);</span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;                  <span class="comment">//校验AutoreleasePagePoolPage结构是否完整</span></span><br><span class="line">    id *next;                             <span class="comment">//指向新加入的autorelease对象的下一个位置，初始化时指向begin()</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;               <span class="comment">//当前所在线程，AutoreleasePool是和线程一一对应的</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;   <span class="comment">//指向父节点page，第一个结点的parent值为nil</span></span><br><span class="line">    AutoreleasePoolPage *child;           <span class="comment">//指向子节点page，最后一个结点的child值为nil</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;                 <span class="comment">//链表深度，节点个数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;                       <span class="comment">//数据容纳的一个上限</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实，<strong>每个自动释放池都是是由若干个<code>AutoreleasePoolPage</code>组成的双向链表结构</strong>，如下图所示:</p><img src="/images/RunLoop/AutoreleasePool3.png" width = "90%" alt="" align=center /><p><code>AutoreleasePoolPage</code>中拥有<code>parent</code>和<code>child</code>指针，分别指向上一个和下一个<code>page</code>；当前一个<code>page</code>的空间被占满(每个<code>AutorelePoolPage</code>的大小为4096字节)时，就会新建一个<code>AutorelePoolPage</code>对象并连接到链表中，后来的  Autorelease对象也会添加到新的<code>page</code>中；</p><p>另外，当<code>next== begin()</code>时，表示<code>AutoreleasePoolPage</code>为空；当<code>next == end()</code>，表示<code>AutoreleasePoolPage</code>已满。</p><h3 id="2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用"><a href="#2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用" class="headerlink" title="2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用"></a>2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用</h3><p>在<code>AutoreleasePoolPage</code>的源码中，我们很容易找到边界对象(哨兵对象)的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define POOL_BOUNDARY nil</span><br></pre></td></tr></table></figure><p>边界对象其实就是<code>nil</code>的别名，而它的作用事实上也就是为了起到一个标识的作用。</p><p>每当自动释放池初始化调用<code>objc_autoreleasePoolPush</code>方法时，总会通过<code>AutoreleasePoolPage</code>的<code>push</code>方法，将<code>POOL_BOUNDARY</code>放到当前<code>page</code>的栈顶，并且返回这个边界对象；</p><p>而在自动释放池释放调用<code>objc_autoreleasePoolPop</code>方法时，又会将边界对象以参数传入，这样自动释放池就会向释放池中对象发送<code>release</code>消息，直至找到第一个边界对象为止。</p><h3 id="2-6-理解objc-autoreleasePoolPush方法"><a href="#2-6-理解objc-autoreleasePoolPush方法" class="headerlink" title="2.6 理解objc_autoreleasePoolPush方法"></a>2.6 理解objc_autoreleasePoolPush方法</h3><p>经过前面的分析，<code>objc_autoreleasePoolPush</code>最终调用的是    <code>AutoreleasePoolPage</code>的<code>push</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1.</span>        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针</span></span><br><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    id *ret = next;</span><br><span class="line">    *next = obj;</span><br><span class="line">    next++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotPage已满时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotpage不存在时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，每次调用<code>push</code>其实就是创建一个新的AutoreleasePool，在对应的<code>AutoreleasePoolPage</code>中插入一个<code>POOL_BOUNDARY</code> ，并且返回插入的<code>POOL_BOUNDARY</code> 的内存地址。<code>push</code>方法内部调用的是<code>autoreleaseFast</code>方法，并传入边界对象(<code>POOL_BOUNDARY</code>)。<code>hotPage</code>可以理解为当前正在使用的<code>AutoreleasePoolPage</code>。</p><p>自动释放池最终都会通过<code>page-&gt;add(obj)</code>方法将边界对象添加到释放池中，而这一过程在<code>autoreleaseFast</code>方法中被分为三种情况：</p><ol><li>当前<code>page</code>存在且不满，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中，即<code>next</code>指向的位置</li><li>当前<code>page</code>存在但是已满，调用<code>autoreleaseFullPage</code>初始化一个新的<code>page</code>，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中</li><li>当前<code>page</code>不存在时，调用<code>autoreleaseNoPage</code>创建一个<code>hotPage</code>，再调用<code>page-&gt;add(obj)</code> 方法将对象添加至<code>page</code>的栈中</li></ol><h3 id="2-7-objc-autoreleasePoolPop方法"><a href="#2-7-objc-autoreleasePoolPop方法" class="headerlink" title="2.7 objc_autoreleasePoolPop方法"></a>2.7 objc_autoreleasePoolPop方法</h3><p>AutoreleasePool的释放调用的是<code>objc_autoreleasePoolPop</code>方法，此时需要传入边界对象作为参数。这个边界对象正是每次执行<code>objc_autoreleasePoolPush</code>方法返回的对象<code>atautoreleasepoolobj</code>；</p><p>同理，我们找到<code>objc_autoreleasePoolPop</code>最终调用的方法，即<code>AutoreleasePoolPage</code>的<code>pop</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span>   <span class="comment">//POOL_BOUNDARY的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);   <span class="comment">//通过POOL_BOUNDARY找到对应的page</span></span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        <span class="comment">// This check is not valid with DebugPoolAllocation off</span></span><br><span class="line">        <span class="comment">// after an autorelease with a pool page but no pool in place.</span></span><br><span class="line">        _objc_fatal(<span class="string">&quot;invalid or prematurely-freed autorelease pool %p; &quot;</span>, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();   <span class="comment">// 记录最高水位标记</span></span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);   <span class="comment">//向栈中的对象发送release消息，直到遇到第一个哨兵对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="comment">// 删除空掉的节点</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，首先根据传入的边界对象地址找到边界对象所处的<code>page</code>；然后选择当前<code>page</code>中最新加入的对象一直向前清理，可以向前跨越若干个<code>page</code>，直到边界所在的位置；清理的方式是向这些对象发送一次<code>release</code>消息，使其引用计数减一；</p><p>另外，清空<code>page</code>对象还会遵循一些原则：</p><ol><li>如果当前的<code>page</code>中存放的对象少于一半，则子<code>page</code>全部删除；</li><li>如果当前当前的<code>page</code>存放的多余一半（意味着马上将要满），则保留一个子<code>page</code>，节省创建新<code>page</code>的开销;</li></ol><h3 id="2-8-autorelease方法"><a href="#2-8-autorelease方法" class="headerlink" title="2.8 autorelease方法"></a>2.8 autorelease方法</h3><p>上述是对自动释放池整个生命周期的分析，现在我们来理解延时释放对象<code>autorelease</code>方法的实现，首先查看该方法的调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- [NSObject autorelease]</span><br><span class="line">└── id objc_object::rootAutorelease()</span><br><span class="line">    └── id objc_object::rootAutorelease2()</span><br><span class="line">        └── static id AutoreleasePoolPage::autorelease(id obj)</span><br><span class="line">            └── static id AutoreleasePoolPage::autoreleaseFast(id obj)</span><br><span class="line">                ├── id *add(id obj)</span><br><span class="line">                ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)</span><br><span class="line">                │   ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                │   └── id *add(id obj)</span><br><span class="line">                └── static id *autoreleaseNoPage(id obj)</span><br><span class="line">                    ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                    └── id *add(id obj)</span><br></pre></td></tr></table></figure><p>如上所示，<code>autorelease</code>方法最终也会调用上面提到的 <code>autoreleaseFast</code>方法，将当前对象加到<code>AutoreleasePoolPage</code>中。关于<code>autoreleaseFast</code>的分析这里不再累述，我们主要来考虑一下两次调用的区别：</p><p><code>autorelease</code>函数和<code>push</code>函数一样，关键代码都是调用<code>autoreleaseFast</code>函数向自动释放池的链表栈中添加一个对象，不过<code>push</code>函数入栈的是一个边界对象，而<code>autorelease</code>函数入栈的是一个具体的Autorelease的对象。</p><h2 id="三、AutoreleasePool与NSThread、NSRunLoop的关系"><a href="#三、AutoreleasePool与NSThread、NSRunLoop的关系" class="headerlink" title="三、AutoreleasePool与NSThread、NSRunLoop的关系"></a>三、AutoreleasePool与NSThread、NSRunLoop的关系</h2><p>由于<code>AppKit</code>和<code>UIKit</code>框架的优化，我们很少需要显式的创建一个自动释放池块。这其中就涉及到<code>AutoreleasePool</code>与<code>NSThread</code>、<code>NSRunLoop</code>的关系。</p><h3 id="3-1-RunLoop和NSThread的关系"><a href="#3-1-RunLoop和NSThread的关系" class="headerlink" title="3.1 RunLoop和NSThread的关系"></a>3.1 RunLoop和NSThread的关系</h3><p><code>RunLoop</code>是用于控制线程生命周期并接收事件进行处理的机制，其实质是一个<code>do-While</code>循环。在苹果文档找到关于<a href="https://links.jianshu.com/go?to=https://developer.apple.com/documentation/foundation/nsrunloop%23//apple_ref/doc/constant_group/Run_Loop_Modes">NSRunLoop</a>的介绍如下：</p><blockquote><p>Your application neither creates or explicitly manages NSRunLoop objects. Each NSThread object—including the application’s main thread—has an NSRunLoop object automatically created for it as needed. If you need to access the current thread’s run loop, you do so with the class method currentRunLoop.</p></blockquote><p>总结<code>RunLoop</code>与<code>NSThread</code>(线程)之间的关系如下：</p><ol><li><code>RunLoop</code>与线程是一一对应关系，每个线程(包括主线程)都有一个对应的<code>RunLoop</code>对象；其对应关系保存在一个全局的Dictionary里；</li><li>主线程的<code>RunLoop</code>默认由系统自动创建并启动；而其他线程在创建时并没有<code>RunLoop</code>，若该线程一直不主动获取，就一直不会有<code>RunLoop</code>；</li><li>苹果不提供直接创建<code>RunLoop</code>的方法；所谓其他线程<code>Runloop</code>的创建其实是发生在第一次获取的时候，系统判断当前线程没有<code>RunLoop</code>就会自动创建；</li><li>当前线程结束时，其对应的<code>Runloop</code>也被销毁；</li></ol><h3 id="3-2-RunLoop和AutoreleasePool的关系"><a href="#3-2-RunLoop和AutoreleasePool的关系" class="headerlink" title="3.2 RunLoop和AutoreleasePool的关系"></a>3.2 RunLoop和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p></blockquote><p>如上所述，主线程的<code>NSRunLoop</code>在监测到事件响应开启每一次<code>event loop</code>之前，会自动创建一个<code>autorelease pool</code>，并且会在<code>event loop</code>结束的时候执行<code>drain</code>操作，释放其中的对象。</p><h3 id="3-3-Thread和AutoreleasePool的关系"><a href="#3-3-Thread和AutoreleasePool的关系" class="headerlink" title="3.3 Thread和AutoreleasePool的关系"></a>3.3 Thread和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself.</p></blockquote><p>如上所述， 包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</p><h2 id="四、AutoreleasePool在主线程上的释放时机"><a href="#四、AutoreleasePool在主线程上的释放时机" class="headerlink" title="四、AutoreleasePool在主线程上的释放时机"></a>四、AutoreleasePool在主线程上的释放时机</h2><h3 id="4-1-理解主线程上的自动释放过程"><a href="#4-1-理解主线程上的自动释放过程" class="headerlink" title="4.1 理解主线程上的自动释放过程"></a>4.1 理解主线程上的自动释放过程</h3><p>分析主线程<code>RunLoop</code>管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：<code>po [NSRunLoop currentRunLoop]</code>，具体效果如下：</p><img src="/images/RunLoop/AutoreleasePool2.png" width = "70%" alt="" align=center /><p>我们看到主线程<code>RunLoop</code>中有两个与自动释放池相关的<code>Observer</code>，它们的 <code>activities</code>分别为<code>0x1</code>和<code>0xa0</code>这两个十六进制的数，转为二进制分别为<code>1</code>和<code>10100000</code>，对应<code>CFRunLoopActivity</code>的类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>),          <span class="comment">//0x1，启动Runloop循环</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>),            </span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>),        </span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>),  <span class="comment">//0xa0，即将进入休眠     </span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>),   </span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),           <span class="comment">//0xa0，退出RunLoop循环  </span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下：</p><ol><li>App启动后，苹果在主线程<code>RunLoop</code>里注册了两个<code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>;</li><li>第一个<code>Observer</code>监视的事件是<code>Entry</code>(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code>创建自动释放池。<code>order = -2147483647</code>(即32位整数最小值)表示其优先级最高，可以保证创建释放池发生在其他所有回调之前;</li><li>第二个<code>Observer</code>监视了两个事件<code>BeforeWaiting</code>(准备进入休眠)时调用<code>_objc_autoreleasePoolPop()</code>和<code>_objc_autoreleasePoolPush()</code>释放旧的池并创建新池；<code>Exit</code>(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code>来释放自动释放池。<code>order = 2147483647</code>(即32位整数的最大值)表示其优先级最低，保证其释放池子发生在其他所有回调之后;</li><li>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 <code>RunLoop</code>创建好的<code>AutoreleasePool</code>环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>AutoreleasePool</code>了;</li></ol><p>最后，也可以结合图示理解主线程上自动释放对象的具体流程：</p><img src="/images/RunLoop/AutoreleasePool.png" width = "70%" alt="" align=center /><ol><li>程序启动到加载完成后，主线程对应的<code>RunLoop</code>会停下来等待用户交互</li><li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li><li><code>RunLoop</code>检测到事件后，就会创建自动释放池;</li><li>所有的延迟释放对象都会被添加到这个池子中;</li><li>在一次完整的运行循环结束之前，会向池中所有对象发送<code>release</code>消息，然后自动释放池被销毁;</li></ol><h3 id="4-2-测试主线程上的对象自动释放过程"><a href="#4-2-测试主线程上的对象自动释放过程" class="headerlink" title="4.2 测试主线程上的对象自动释放过程"></a>4.2 测试主线程上的对象自动释放过程</h3><p>下面的代码创建了一个Autorelease对象<code>string</code>，并且通过<code>weakString</code>进行弱引用(不增加引用计数，所以不会影响对象的生命周期)，具体如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">TestMemoryVC</span> ()</span><br><span class="line"><span class="meta">@property</span> (nonatomic,<span class="keyword">weak</span>)<span class="type">NSString</span> <span class="operator">*</span>weakString;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">TestMemoryVC</span></span><br><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>string <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@&quot;</span>,@<span class="string">&quot;WUYUBEICHEN&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.weakString <span class="operator">=</span> string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewWillAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewDidAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewDidAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//viewWillAppear:WUYUBEICHEN</span></span><br><span class="line"><span class="comment">//viewDidAppear:(null)</span></span><br></pre></td></tr></table></figure><p><strong>代码分析：</strong>自动变量的<code>string</code>在离开<code>viewDidLoad</code>的作用域后，会依靠当前主线程上的<code>RunLoop</code>迭代自动释放。最终<code>string</code>对象在<code>viewDidAppear</code>方法执行前被释放(<code>RunLoop</code>完成此次迭代)。</p><h2 id="五、AutoreleasePool子线程上的释放时机"><a href="#五、AutoreleasePool子线程上的释放时机" class="headerlink" title="五、AutoreleasePool子线程上的释放时机"></a>五、AutoreleasePool子线程上的释放时机</h2><p>子线程默认不开启<code>RunLoo</code>p，那么其中的延时对象该如何释放呢？其实这依然要从<code>Thread</code>和<code>AutoreleasePool</code>的关系来考虑：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p></blockquote><p>也就是说，每一个线程都会维护自己的 <code>Autoreleasepool</code>栈，所以子线程虽然默认没有开启<code>RunLoop</code>，但是依然存在<code>AutoreleasePool</code>，在子线程退出的时候会去释放<code>autorelease</code>对象。</p><p>前面讲到过，ARC会根据一些情况进行优化，添加<code>__autoreleasing</code>修饰符，其实这就相当于对需要延时释放的对象调用了<code>autorelease</code>方法。从源码分析的角度来看，如果子线程中没有创建<code>AutoreleasePool</code> ，而一旦产生了<code>Autorelease</code>对象，就会调用<code>autoreleaseNoPage</code>方法自动创建<code>hotpage</code>，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p><h2 id="六、AutoreleasePool需要手动添加的情况"><a href="#六、AutoreleasePool需要手动添加的情况" class="headerlink" title="六、AutoreleasePool需要手动添加的情况"></a>六、AutoreleasePool需要手动添加的情况</h2><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建<code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html%23//apple_ref/doc/uid/20000047">苹果文档</a>中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ol><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ol><p>而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>obj</code>因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的<code>RunLoop</code>管理的；因为<code>for</code>循环在当前线程没有执行完毕，<code>Runloop</code>也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在<code>viewDidAppear</code>方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">             <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">             <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Autorelease简介&quot;&gt;&lt;a href=&quot;#一、Autorelease简介&quot; class=&quot;headerlink&quot; title=&quot;一、Autorelease简介&quot;&gt;&lt;/a&gt;一、Autorelease简介&lt;/h2&gt;&lt;p&gt;iOS开发中的Autorelease</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="AutoreleasePool" scheme="https://tenloy.github.io/tags/AutoreleasePool/"/>
    
  </entry>
  
  <entry>
    <title>[转]深入理解RunLoop—ibireme</title>
    <link href="https://tenloy.github.io/2021/06/28/13_RunLoop-Reposted-From-ibireme/"/>
    <id>https://tenloy.github.io/2021/06/28/13_RunLoop-Reposted-From-ibireme/</id>
    <published>2021-06-28T16:19:21.000Z</published>
    <updated>2021-07-03T15:03:45.405Z</updated>
    
    <content type="html"><![CDATA[<p>RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p><h2 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    initialize();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模型通常被称作 <a href="http://en.wikipedia.org/wiki/Event_loop">Event Loop</a>。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p><p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p><p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。</p><ul><li><p>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p></li><li><p>CFRunLoopRef 的代码是<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c">开源</a>的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/">http://opensource.apple.com/tarballs/CF/</a> 下载到整个 CoreFoundation 的源码来查看。</p></li></ul><p>(Update: Swift 开源后，苹果又维护了一个跨平台的 CoreFoundation 版本：<a href="https://github.com/apple/swift-corelibs-foundation/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%BA%90%E7%A0%81%E5%8F%AF%E8%83%BD%E5%92%8C%E7%8E%B0%E6%9C%89">https://github.com/apple/swift-corelibs-foundation/，这个版本的源码可能和现有</a> iOS 系统中的实现略不一样，但更容易编译，而且已经适配了 Linux/Windows。)</p><h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份[文档](<a href="http://www.fenestrated.net/~macman/mirrors/Apple">http://www.fenestrated.net/~macman/mirrors/Apple</a> Technotes (As of 2002)/tn/tn2028.html)标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p><p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> CFMutableDictionaryRef loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line">CFRunLoopRef _CFRunLoopGet(<span class="keyword">pthread_t</span> thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p><h2 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p><p>CFRunLoopRef<br>CFRunLoopModeRef<br>CFRunLoopSourceRef<br>CFRunLoopTimerRef<br>CFRunLoopObserverRef</p><p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="/images/RunLoop/RunLoop_0.png" alt="RunLoop_0" style="zoom:60%;" /></p><p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p><p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p><ul><li><p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p></li><li><p>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p></li></ul><p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p><p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry         = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit          = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的 Source/Timer/Observer 被统称为 <strong>mode item</strong>，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p><h2 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h2><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFStringRef _name;            <span class="comment">// Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span></span><br><span class="line">    CFMutableSetRef _sources0;    <span class="comment">// Set</span></span><br><span class="line">    CFMutableSetRef _sources1;    <span class="comment">// Set</span></span><br><span class="line">    CFMutableArrayRef _observers; <span class="comment">// Array</span></span><br><span class="line">    CFMutableArrayRef _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    CFMutableSetRef _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    CFMutableSetRef _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    CFRunLoopModeRef _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    CFMutableSetRef _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p><p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p><p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p><p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure><p>Mode 暴露的管理 mode item 的接口有下面几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure><p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p><p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p><p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p><h2 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h2><p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">文档</a>里的说明，RunLoop 内部的逻辑大致如下:</p><img src="/images/RunLoop/RunLoop_1.png" alt="RunLoop_0" style="zoom:65%;" /><p>其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用DefaultMode启动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunSpecific</span><span class="params">(runloop, modeName, seconds, stopAfterHandle)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">            <span class="comment">/// • 一个基于 port 的Source 的事件。</span></span><br><span class="line">            <span class="comment">/// • 一个 Timer 到时间了</span></span><br><span class="line">            <span class="comment">/// • RunLoop 自身的超时时间到了</span></span><br><span class="line">            <span class="comment">/// • 被其他什么调用者手动唤醒</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 收到消息，处理消息。</span></span><br><span class="line">            handle_msg:</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 执行加入到Loop的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                <span class="comment">/// 被外部调用者强制停止了</span></span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p><h2 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h2><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。<br><img src="/images/RunLoop/RunLoop_3.png" alt="RunLoop_0" style="zoom:70%;" /></p><p>苹果官方将整个系统大致划分为上述4个层次：</p><ul><li>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。</li><li>应用框架层即开发人员接触到的 Cocoa 等框架。</li><li>核心框架层包括各种核心框架、OpenGL 等内容。</li><li>Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="http://opensource.apple.com/">opensource.apple.com</a> 里找到。</li></ul><p>我们在深入看一下 Darwin 这个核心的架构：<br><img src="/images/RunLoop/RunLoop_4.png" alt="RunLoop_0" style="zoom:70%;" /></p><p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。</p><ul><li><p>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。</p></li><li><p>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。</p></li><li><p>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p></li></ul><p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p><p>Mach 的消息定义是在 &lt;mach/message.h&gt; 头文件的，很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">  <span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">&#125; <span class="keyword">mach_msg_base_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_bits_t</span> msgh_bits;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span> msgh_size;</span><br><span class="line">  <span class="keyword">mach_port_t</span> msgh_remote_port;</span><br><span class="line">  <span class="keyword">mach_port_t</span> msgh_local_port;</span><br><span class="line">  <span class="keyword">mach_port_name_t</span> msgh_voucher_port;</span><br><span class="line">  <span class="keyword">mach_msg_id_t</span> msgh_id;</span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure><p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port。</p><p>发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">mach_msg_return_t</span> <span class="title">mach_msg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_header_t</span> *msg,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_option_t</span> option,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> send_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> rcv_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> rcv_name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_timeout_t</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> notify)</span></span>;</span><br></pre></td></tr></table></figure><p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：<br><img src="/images/RunLoop/RunLoop_5.png" alt="RunLoop_0" style="zoom:70%;" /></p><p>这些概念可以参考维基百科: <a href="http://en.wikipedia.org/wiki/System_call">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing)">Trap_(computing)</a>。</p><p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p><p>关于具体的如何利用 mach port 发送信息，可以看看<a href="http://nshipster.com/inter-process-communication/"> NSHipster 这一篇文章</a>，或者<a href="http://segmentfault.com/a/1190000002400329">这里</a>的中文翻译 。</p><p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://www.programmer.com.cn/8121/">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p><h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    common mode items = &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source0 (manual)</span></span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source1 (mach port)</span></span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1b</span>03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Ovserver</span></span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,          <span class="comment">// BeforeWaiting</span></span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Timer</span></span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</span><br><span class="line">            next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，系统默认注册了5个Mode:</p><ol><li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li><li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li><li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li><li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li><li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li></ol><p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p><p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 1. 通知Observers，即将进入RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 4. 触发 Source0 (非基于port的) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 6. 通知Observers，即将进入休眠</span></span><br><span class="line">        <span class="comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 7. sleep to wait msg.</span></span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 8. 通知Observers，线程被唤醒</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果是被Timer唤醒的，回调Timer</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span></span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">while</span> (...);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 10. 通知Observers，即将退出RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p><h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p><p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><p>这个函数内部的调用栈大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p><h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，<del>比如 RunLoop 是用 dispatch_source_t 实现的 Timer</del>（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p><h3 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork       -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection -&gt;AFNetworking</span><br><span class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure><ul><li>CFSocket 是最底层的接口，只负责 socket 通信。</li><li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li><li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li><li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li></ul><p>下面主要介绍下 NSURLConnection 的工作过程。</p><p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p><p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p><img src="/images/RunLoop/RunLoop_network.png" alt="RunLoop_0" style="zoom:65%;" /><p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p><h2 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h2><h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p><a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking%2FAFURLConnectionOperation.m">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread &#x3D; nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread &#x3D; [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state &#x3D; AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p><h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p><p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p><p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p><p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p><p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p><p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p><p>具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m">_ASAsyncTransactionGroup</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="RunLoop" scheme="https://tenloy.github.io/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffer的基本介绍</title>
    <link href="https://tenloy.github.io/2021/06/24/12_Protocol-Buffer/"/>
    <id>https://tenloy.github.io/2021/06/24/12_Protocol-Buffer/</id>
    <published>2021-06-24T17:48:19.000Z</published>
    <updated>2021-07-03T15:03:45.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Protocol buffers (PB) 是一种语言、平台无关，可扩展的序列化数据的格式。和xml、json等数据交换格式一样，也可用于通信协议，数据存储等。</p><ul><li>Protocol buffers 在序列化数据方面，它是<strong>灵活的</strong>，<strong>高效的</strong>(快)。<ul><li>Portobuf序列化和反序列化速度比XML、JSON快很多，是直接把对象和字节数组做转换，而XML和JSON还需要构建成XML或者JSON对象结构。</li><li>一旦定义了要处理的数据的数据结构之后，就可以利用 Protocol buffers 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。</li></ul></li><li>相比于 XML、JSON 来说，Protocol buffers 更加<strong>小巧</strong>，更加<strong>简单</strong>。<ul><li>XML和JSON的描述信息太多了，导致消息要大；</li><li>此外Portobuf还使用了Varint 编码，减少数据对空间的占用。</li></ul></li></ul><p><strong>Protocol buffers 很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式</strong>。</p><p>Protobuf支持生成代码的语言包括Java、Python、C++、Go、JavaNano、Ruby、C#，<a href="https://link.jianshu.com/?t=https://developers.google.com/protocol-buffers/">官网地址</a>。</p><h3 id="1-1-优势"><a href="#1-1-优势" class="headerlink" title="1.1 优势"></a>1.1 优势</h3><p>JSON 和 XML 可能是目前开发者们用来存储和传输数据的标准方案，而 protocol buffers 与之相比有以下优势：</p><ul><li><strong>快速且小巧</strong>：按照 Google 所描述的，protocol buffers 的体积要小<strong>3-10</strong>倍，速度比XML要快<strong>20-100</strong>倍。可以在这篇<a href="https://damienbod.com/2014/01/09/comparing-protobuf-json-bson-xml-with-net-for-file-streams/">文章</a> ，它的作者是 Damien Bod，文中比较了一些主流文本格式的读写速度。</li><li><strong>类型安全</strong>：Protocol buffers 像 Swift 一样是类型安全的，使用 protocol buffers 时 你需要指定每一个属性的类型。</li><li><strong>自动反序列化</strong>：你不需要再去编写任何的解析代码，只需要更新 <strong>.proto</strong> 文件就行了。 file and regenerate the data access classes.</li><li><strong>分享就是关心</strong>：因为支持多种语言，因此可以在不同的平台中共享数据模型，这意味着跨平台的工作会更轻松。</li></ul><h3 id="1-2-局限性"><a href="#1-2-局限性" class="headerlink" title="1.2 局限性"></a>1.2 局限性</h3><p>Protocol buffers 虽然有着诸多优势，但是它也不是万能的:</p><ul><li><strong>时间成本</strong>：在老项目中去使用 protocol buffers 可能会不太高效，因为需要转换成本。同时，项目成员还需要去学习一种新的语法。</li><li><strong>可读性</strong>：XML 和 JSON 的描述性更好，并且易于阅读。Protocol buffers 的原数据无法阅读(类似txt没有样式，不方便阅读)，并且在没有 <strong>.proto</strong> 文件的情况下没办法解析。</li><li><strong>仅仅是不适合而已</strong>：当你想要使用类似于<a href="http://www.w3schools.com/xml/xml_xslt.asp">XSLT</a>这样的样式表时，XML是最好的选择。所以 protocol buffers 并不总是最佳工具。</li><li><strong>不支持</strong>：编译器可能不支持你正在进行中的项目所使用的语言和平台。</li></ul><h2 id="二、iOS中的单独使用"><a href="#二、iOS中的单独使用" class="headerlink" title="二、iOS中的单独使用"></a>二、iOS中的单独使用</h2><h3 id="2-1-定义-proto文件"><a href="#2-1-定义-proto文件" class="headerlink" title="2.1 定义.proto文件"></a>2.1 定义.proto文件</h3><p>首先要定义一个 Person**.proto** 文件。在这个文件中指定了你的数据结构信息。下面以一个Person模型类为例</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proto语法</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;  <span class="comment">// 在第一行声明，我们使用的protobuf语法是proto3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> uid = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">string</span> email = <span class="number">3</span>;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> </span>&#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> number = <span class="number">1</span>;</span><br><span class="line">    PhoneType type = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">repeated</span> PhoneNumber phone = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-转换为源代码文件"><a href="#2-2-转换为源代码文件" class="headerlink" title="2.2 转换为源代码文件"></a>2.2 转换为源代码文件</h3><p>使用 protocol buffers 的编译器，会根据选择的语言创建好一个数据类(Swift 中的 struct)。可以直接在项目中使用这个类/结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protoc *.proto --objc_out=../Class  <span class="comment"># objc_out指定了生成程序的目录，如果是Java，那么是java_out</span></span><br><span class="line"><span class="comment"># 产物是：</span></span><br><span class="line"><span class="comment"># Class/Pro_out/Person.pbobjc.h  Person.pbobjc.m</span></span><br><span class="line"><span class="comment"># Class/Pro_source/Person.proto</span></span><br></pre></td></tr></table></figure><h3 id="2-3-iOS工程中引入Protobuf库"><a href="#2-3-iOS工程中引入Protobuf库" class="headerlink" title="2.3 iOS工程中引入Protobuf库"></a>2.3 iOS工程中引入Protobuf库</h3><ul><li>通过Cocoapods</li><li>通过手动导入</li></ul><h3 id="2-4-使用"><a href="#2-4-使用" class="headerlink" title="2.4 使用"></a>2.4 使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入头文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.pbobjc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">Person *person = [Person new];</span><br><span class="line">person.name = <span class="string">@&quot;weiCL&quot;</span>;</span><br><span class="line">person.uid = <span class="number">20170810</span>;</span><br><span class="line">person.email = <span class="string">@&quot;cl9000@126.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化为Data</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [person data];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;NSData= %@&quot;</span>, data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化为对象</span></span><br><span class="line">Person *person2 = [Person parseFromData:data error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;name:%@ uid:%d email:%@&quot;</span>,person2.name,person2.uid,person2.email);</span><br></pre></td></tr></table></figure><h2 id="三、用在与服务端交互中"><a href="#三、用在与服务端交互中" class="headerlink" title="三、用在与服务端交互中"></a>三、用在与服务端交互中</h2><p>在与服务端交互时，通常使用 JSON 或者 XML 来发送和接收数据，然后根据这些数据生成结构并解析。现在使用 <code>protocol buffers</code> 也类似：</p><ul><li>服务端返回的数据要为pb格式</li><li>移动端使用pb数据的解析配置</li></ul><p>参考链接：<a href="https://juejin.cn/post/6844903622266847246">Protocol Buffers 在 iOS 中的使用</a></p><h2 id="四、编码原理-序列化与反序列化"><a href="#四、编码原理-序列化与反序列化" class="headerlink" title="四、编码原理(序列化与反序列化)"></a>四、编码原理(序列化与反序列化)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可读数据 &#x3D;&#x3D;&#x3D;&#x3D;序列化、字符集编码规则&#x3D;&#x3D;&#x3D;&gt; 二进制</span><br><span class="line">可读数据 &lt;&#x3D;&#x3D;&#x3D;反序列化、字符集编码规则&#x3D;&#x3D;&#x3D;&#x3D; 二进制</span><br></pre></td></tr></table></figure><h3 id="4-1-编码-序列化"><a href="#4-1-编码-序列化" class="headerlink" title="4.1 编码/序列化"></a>4.1 编码/序列化</h3><ul><li><p>Protocol Buffer 序列化采用 Varint、Zigzag 方法，压缩 int 型整数和带符号的整数。对浮点型数字不做压缩（这里可以进一步的压缩，Protocol Buffer 还有提升空间）。</p></li><li><p>对 <code>.proto</code> 文件，会对 option 和 repeated 字段进行检查，若 optional 或 repeated 字段没有被设置字段值，那么该字段在序列化时的数据中是完全不存在的，即不进行序列化（少编码一个字段）。</p></li><li><p>上面这两点做到了压缩数据，使得序列化工作量减少。</p></li><li><p>Protocol Buffer 是 Tag - Value (TLV)的编码方式的实现</p><ul><li><blockquote><p>在通信协议中，TLV（type-length-value或tag-length-value）是一种用于某种协议中可选信息元素的编码方案。TLV 编码的数据流包含记录类型的代码，然后是记录值长度，最后是值本身。</p></blockquote></li><li><p>数据都以 tag - length - value (或者 tag - value)的形式存在二进制数据流中</p></li><li><p>减少了分隔符的使用（比 JSON 和 XML 少了 <code>&#123; &#125; :</code> 这些符号）</p></li><li><p>没有这些分隔符，使得数据存储更加紧凑，也算是再一次减少了数据的体积。</p></li></ul></li><li><p>综上，pb 体积相对较小，如果选用它作为网络数据传输，势必相同数据，消耗的网络流量更少。</p></li></ul><h3 id="4-2-反序列化"><a href="#4-2-反序列化" class="headerlink" title="4.2 反序列化"></a>4.2 反序列化</h3><ul><li>反序列化的实现完全是序列化实现/encode的逆过程。反序列化直接读取二进制字节数据流，同样是一些二进制操作。</li><li>反序列化的时候，通常只需要用到 length。tag 值只是用来标识类型的，Properties 的 setEncAndDec() 方法里面已经把每个类型对应的 decode 解码器初始化好了，所以反序列化的时候，tag 值可以直接跳过，从 length 开始处理。</li><li>XML 的解析过程就复杂一些。XML 需要从文件中读取出字符串，再转换为 XML 文档对象结构模型。之后，再从 XML 文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将 XML 文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗 CPU 的复杂计算。</li></ul><h3 id="4-3-性能"><a href="#4-3-性能" class="headerlink" title="4.3 性能"></a>4.3 性能</h3><ul><li><p>如果很少用到整型数字，浮点型数字，全部都是字符串数据，那么 JSON 和 protocol buffers 性能不会差太多。纯前端之间交互的话，选择 JSON 或者 protocol buffers 差别不是很大。</p></li><li><p>与后端交互过程中，用到 protocol buffers 比较多，笔者认为选择 protocol buffers 除了性能强以外，完美兼容 RPC 调用也是一个重要因素。</p></li></ul><h3 id="4-4-其它特性"><a href="#4-4-其它特性" class="headerlink" title="4.4 其它特性"></a>4.4 其它特性</h3><ol><li>Protocol Buffer 另外一个核心价值在于提供了一套工具，一个编译工具，自动化生成 get/set 代码。简化了多语言交互的复杂度，使得编码解码工作有了生产力。</li><li>Protocol Buffer 不是自我描述的，离开了数据描述 <code>.proto</code> 文件，就无法理解二进制数据流。这点即是优点，使数据具有一定的“加密性”，也是缺点，数据可读性极差。所以 Protocol Buffer 非常适合内部服务之间 RPC 调用和传递数据。</li><li>Protocol Buffer 具有向后兼容的特性，更新数据结构以后，老版本依旧可以兼容，这也是 Protocol Buffer 诞生之初被寄予解决的问题。因为编译器对不识别的新增字段会跳过不处理。</li></ol><p>参考链接：<a href="https://halfrost.com/protobuf_encode/">高效的数据压缩编码方式 Protobuf — halfrost</a>、<a href="https://halfrost.com/protobuf_decode/">Protobuf的序列化/反序列化</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;Protocol buffers (PB) 是一种语言、平台无关，可扩展的序列化数据的格式。和xml、json等数据交换格式</summary>
      
    
    
    
    <category term="Data" scheme="https://tenloy.github.io/categories/Data/"/>
    
    
  </entry>
  
  <entry>
    <title>(二) 动态规划算法</title>
    <link href="https://tenloy.github.io/2021/06/22/11_dynamic-programming/"/>
    <id>https://tenloy.github.io/2021/06/22/11_dynamic-programming/</id>
    <published>2021-06-22T14:40:13.000Z</published>
    <updated>2021-07-03T15:03:45.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、术语介绍"><a href="#一、术语介绍" class="headerlink" title="一、术语介绍"></a>一、术语介绍</h2><p>先来说几个动态规划问题中的术语。</p><p>动态规划(<code>dynamic programming</code>)是运筹学的一个分支，是求解决策过程(<code>decision process</code>)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(<code>multistep decision process</code>)的优化问题时，提出了著名的最优化原理(<code>principle of optimality</code>)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。</p><p><img src="/images/algorithm/dp-1.jpg" alt="多阶段决策问题的图示"></p><h3 id="1-1-阶段"><a href="#1-1-阶段" class="headerlink" title="1.1 阶段"></a>1.1 阶段</h3><ul><li>把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同。</li><li>描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用 <code>k</code> 表示。</li><li>此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。</li></ul><p><strong>在前面的图中，第一个阶段就是点A到点B，第二个阶段是点B到点C，而第三个阶段是点C到点D。</strong></p><h3 id="1-2-状态"><a href="#1-2-状态" class="headerlink" title="1.2 状态"></a>1.2 状态</h3><p>状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它<strong>既是该阶段某路的起点，同时又是前一阶段某支路的终点。</strong></p><p><strong>前面的例子(图)中，初始状态即A，而第一个阶段有两个状态B1和B2，第二个阶段是三个状态C1，C2和C3，而第三个阶段是状态D1和D2。</strong></p><p>过程的状态通常可以用一个或一组数来描述，称为<code>状态变量</code>，用<code>x(k)</code>表示。一般，状态是离散的，但有时为了方便也将状态取成连续的。</p><p>而且在每个阶段的状态维数可以不同。状态变量当过程按所有可能不同的方式发展时，过程各段的状态变量将在某一确定的范围内取值。状态变量取值的集合称为<code>状态集合</code>。</p><h3 id="1-3-无后效性"><a href="#1-3-无后效性" class="headerlink" title="1.3 无后效性"></a>1.3 无后效性</h3><p>我们要求状态具有下面的性质：如果某阶段的状态一旦确定，则在这一阶段以后过程的发展变化仅与此阶段的状态有关，不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。</p><p>换句话说，过程的每一次实现可以用一个状态序列表示。<strong>在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。</strong></p><p>也就是说，<code>未来与过去无关</code>，当前的状态是此前历史（以往决策）的一个完整总结，过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性。（简单点说：过去只能通过影响现在，进而影响未来）</p><h3 id="1-4-决策"><a href="#1-4-决策" class="headerlink" title="1.4 决策"></a>1.4 决策</h3><ul><li>一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为<code>决策</code>。在最优控制中，也称为控制。</li><li><strong>每一个阶段都有若干个决策可供选择。</strong></li><li>在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。</li><li>描述决策的变量称<code>决策变量</code>，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史。</li></ul><p>决策变量的范围称为<code>允许决策集合</code>。</p><img src="/images/algorithm/dp-3.png" style="zoom:70%"><h3 id="1-5-多阶段决策问题与策略"><a href="#1-5-多阶段决策问题与策略" class="headerlink" title="1.5 多阶段决策问题与策略"></a>1.5 多阶段决策问题与策略</h3><p>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策(采取措施)，一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为<code>多阶段决策问题</code>。</p><ul><li><strong>策略</strong>：由每个阶段的决策组成的一个决策序列称为<strong>策略</strong>。<ul><li>每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取。</li></ul></li><li><strong>允许策略集合</strong>：对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为<strong>允许策略集合</strong>。</li><li><strong>最优策略</strong>：允许策略集合中达到最优效果的策略称为<strong>最优策略</strong>。<ul><li>对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。</li></ul></li></ul><h3 id="1-6-状态转移方程"><a href="#1-6-状态转移方程" class="headerlink" title="1.6 状态转移方程"></a>1.6 状态转移方程</h3><p>给定k阶段状态变量 <code>x(k)</code> 的值后，如果这一阶段的决策变量一经确定，第 <code>k+1</code> 阶段的状态变量 <code>x(k+1)</code> 也就完全确定，即 <code>x(k+1)</code> 的值随 <code>x(k)</code> 和第 <code>k</code> 阶段的决策 <code>u(k)</code> 的值变化而变化。</p><p>那么可以把这一关系看成 <code>(x(k),u(k))</code> 与 <code>x(k+1)</code> 确定的对应关系，用 <code>x(k+1) = Tk(x(k),u(k))</code> 表示。这是从 <code>k</code> 阶段到 <code>k+1</code> 阶段状态转移方程的状态转移规律，称为状态转移方程。</p><h3 id="1-7-最优化原理-最优子结构性质"><a href="#1-7-最优化原理-最优子结构性质" class="headerlink" title="1.7 最优化原理/最优子结构性质"></a>1.7 最优化原理/最优子结构性质</h3><ul><li>最优性原理：要求问题的<code>最优策略的子策略也是最优</code>。可以通俗地理解为子问题的局部最优将导致整个问题的全局最优，即<code>一个问题的最优解只取决于其子问题的最优解</code>，子问题的非最优解对问题的求解没有影响。</li><li>最优子结构性质：当一个问题的最优解包含着它的子问题的最优解时，就称此问题具有最优子结构性质。</li></ul><p>一个问题 <code>满足最优化原理</code>也称其 <code>拥有最优子结构性质</code>。</p><p>动态规划引出：</p><p><strong>多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决<code>多阶段决策最优化问题</code>的方法为动态规划方法。</strong></p><h2 id="二、基本思想"><a href="#二、基本思想" class="headerlink" title="二、基本思想"></a>二、基本思想</h2><blockquote><p>动态规划算法通常用于<code>求解最优性问题</code>：在这类问题中，可能会有许多可行解，每一个解都对应于一个值，我们希望找到具有最优值的解。  </p></blockquote><p><strong>动态规划</strong>(DP：Dynamic Programming)是一种重要的程序设计手段，其基本思想是在对一个<strong>多阶段决策</strong>的问题，按照某一顺序，根据每一步所选决策的不同会引起状态的转移，最后会在变化的状态中获取到一个决策序列。</p><p><strong>动态规划</strong>是一种把多阶段过程转化为一系列单阶段问题，逐个求解的方法泛应用于生产调度、工程技术和最优控制等领域。</p><p>动态规划与分治法的异同：</p><ul><li>相同点：都是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li><li>不同点：分治法是将问题划分成相互独立的子问题，因此部分子问题会被重复计算；动态规划方法分解得到的<code>子问题往往不互相独立</code>，而是相互重叠的，从而避免了大量重复计算。</li></ul><p>动态规划的实质是分治思想和解决冗余的结合：</p><ul><li><p>将问题实例分解为更小的、相似的子问题</p></li><li><p>存储子问题的解，在需要时再找出已求得的答案，来避免计算重复的子问题，从而得到多项式时间算法。</p><p>用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的<code>填表格式</code>。</p></li></ul><p>一般来说，只要该问题可以划分成规模更小的子问题，并且原问题的最优解中包含了子问题的最优解(即满足最优化原理)，则可以考虑用动态规划解决。</p><p>动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。当重复子问题的数目比较小时，动态规划的效果也会很差。</p><h2 id="三、适用情况"><a href="#三、适用情况" class="headerlink" title="三、适用情况"></a>三、适用情况</h2><p>一般具有以下3个特征：</p><ul><li><p>满足最优化原理(或称：问题具有最优子结构的性质。<code>是动态规划的基础</code>)</p><p>怎么分析问题是否满足？反证法</p><p><strong>先假设由问题的最优解导出的子问题的解不是最优的 → 然后证明在这个假设下可构造出比原问题最优解更好的解 → 从而导致矛盾，证明最优化原理</strong></p></li><li><p>无后效性</p></li><li><p>有重叠子问题：递归地分解问题时，产生的子问题并不总是独立的（很多子问题重复），一个子问题在下一阶段中可能被多次使用到。<strong>该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势</strong></p><p>动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。<code>其中的关键在于解决冗余</code>，这是动态规划算法的根本目的。动态规划实质上是一种 <code>以空间换时间</code>的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p></li></ul><h2 id="四、基本步骤"><a href="#四、基本步骤" class="headerlink" title="四、基本步骤"></a>四、基本步骤</h2><h3 id="4-1-书面版"><a href="#4-1-书面版" class="headerlink" title="4.1 书面版"></a>4.1 书面版</h3><p>1、分析最优解的性质，并刻画其结构特征。(确定满足最优化原理、划分阶段、确定状态)</p><p>2、递归地定义最优解。(确定状态转移方程(递推方程))</p><p>3、以自底向上或自顶向下(备忘录)的方式计算出最优值</p><p>4、根据计算最优值时得到的信息，从子问题的最优解逐步构造出整个问题的最优解</p><p>步骤1-3是动态规划算法的基本步骤。在只需求出最优值的情形下，步骤4可以省略，步骤3中记录的信息也较少； 若需要求出问题的一个最优解，则必须执行步骤4，步骤3中记录的信息必须足够多，以便构造最优解。</p><p>【问题描述】：给定两个字符串A[m]、B[n]，求它们的最长公共子序列C。</p><p>1、刻画最优解的结构特征</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果temp=A[m]=B[n]，C=temp+max_common_len(A[<span class="number">1</span>,...,m<span class="number">-1</span>],B[<span class="number">1</span>,...,n<span class="number">-1</span>])；</span><br><span class="line">如果A[m]!=B[n]，则C=maxLen(max_common_len(A[<span class="number">1</span>,...,m],B[<span class="number">1</span>,...,n<span class="number">-1</span>])，max_common_len(A[<span class="number">1</span>,...,m<span class="number">-1</span>],B[<span class="number">1</span>,...n]))。</span><br></pre></td></tr></table></figure><p>2、递归的定义最优解的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设C[i,j]表示两个串A[i]与B[j]的最长公共子序列的长度，则</span><br><span class="line"><span class="keyword">if</span> i=j=<span class="number">0</span>, C[i,j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> i,j&gt;<span class="number">0</span> <span class="keyword">and</span> A[i]==B[j], C[i,j]=<span class="number">1</span>+C[i<span class="number">-1</span>,j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span> i,j&gt;<span class="number">0</span> <span class="keyword">and</span> A[i]!=B[j], C[i,j]=max(C[i<span class="number">-1</span>,j],C[i,j<span class="number">-1</span>]).</span><br></pre></td></tr></table></figure><p>3、计算最优解</p><h3 id="4-2-个人理解版本"><a href="#4-2-个人理解版本" class="headerlink" title="4.2 个人理解版本"></a>4.2 个人理解版本</h3><p><strong>第一步：将原问题分解为子问题 — 划分阶段</strong></p><ul><li>把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决。</li><li>子问题的解一旦求出就会被保存，所以每个子问题只需求解一次。</li><li>按照问题的时间或空间特征，把问题分为若干个子问题。划分时，需要注意<strong>划分后的子问题一定要是有序的或者是可排序的</strong>，否则问题就无法求解。(多阶段决策问题)</li></ul><p><strong>第二步：确定状态 — 确定状态、状态空间</strong></p><ul><li>在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题，所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。当然，状态的选择要<code>满足无后效性</code>。</li><li>所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。</li><li><em>比如：求课件中的最大子段和。有n个状态，即状态空间大小为n，每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。因此，用动态规划算法通常只需要多项式时间。</em></li></ul><p><strong>第三步：确定一些初始状态的值</strong></p><ul><li>初始状态，也会被称为边界状态、叶节点状态(对应一个子问题)</li></ul><p><strong>第四步：确定状态转移方程</strong></p><ul><li>定义出什么是状态、在该状态下的值后，就要找出不同的状态之间如何迁移 —— <strong>怎么从本阶段状态(“值”已知)递推到下一阶段的未解状态，直到最终状态</strong>。(递推型)</li><li>状态的迁移可以用递推公式表示，此递推公式也可被称作<strong>状态转移方程</strong>。</li></ul><p><strong>第五步：开始计算</strong></p><ul><li>以 <code>自底向上</code> 或 <code>自顶向下的记忆化方式（备忘录法</code> 计算出最优值，根据计算最优值时得到的信息，构造问题的最优解。</li></ul><img src="/images/algorithm/dp-2.png" style="zoom:70%"><h3 id="4-3-个人总结"><a href="#4-3-个人总结" class="headerlink" title="4.3 个人总结"></a>4.3 个人总结</h3><ul><li>相比动态规划，分治法与贪心法就简单许多。(首先后两者都不用记录前面状态(子问题)的值)</li><li>分治法：先一分为二…然后合二为一… </li><li>贪心法：也算是多阶段决策问题。找出子问题分解思路、确定状态空间、初始状态值。确定状态转移方程这一步有差异，贪心法是自顶向下一层一层分解，遵守贪心选择原则，得出一系列子问题的局部最优解，直到最小子问题，即可组合出原问题的解。</li></ul><h3 id="4-4-备忘录算法"><a href="#4-4-备忘录算法" class="headerlink" title="4.4 备忘录算法"></a>4.4 备忘录算法</h3><p>备忘录方法是动态规划算法的变形，它通过分治思想对原问题进行分解，以<code>存储子问题的解</code>的方式解决冗余计算，并采用自顶向下的递归方式获取问题的最终解。</p><p><strong>备忘录算法与动态规划算法</strong></p><ul><li><p>相同之处：都会对子问题的计算结果进行存储，解决冗余计算</p></li><li><p>不同之处：动态规划算法是<code>自底向上递推</code>求解，而备忘录方法是<code>自顶向下递归</code>求解。</p></li><li><p>当子问题空间中的大量子问题无需求解时，使用备忘录方法较省时。</p></li><li><p>但当无需计算的子问题只有少部分或全部都要计算时，使用动态规划算法，节省递归带来的额外消耗。</p></li></ul><p>比如：求LCS(最长公共子序列)问题中：</p><ul><li>动态规划算法求算，就是自底向上，将所有会出现的子问题都计算并记录下来，而其实有一些子问题在后续的计算中，并不会被用到。</li><li>而备忘录算法求解，就是自顶向下递归，只计算使用到的子问题并记录，</li></ul><p><strong>备忘录算法与直接递归（备忘录方法 = 递归 + 记录表）</strong></p><ul><li>备忘录方法的控制结构与直接递归方法的控制相同(<strong>递归也是分解子问题，自顶向下求解</strong>)，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同的子问题的重复求解</li><li>备忘录：初始化为每个子问题的记录存入一个特殊的值，表示并未求解。在求解过程中，查看相应记录如果是特殊值，表示未求解，否则只要取出该子问题的解答即可。</li></ul><h2 id="五、程序设计-可只看这部分"><a href="#五、程序设计-可只看这部分" class="headerlink" title="五、程序设计(可只看这部分)"></a>五、程序设计(可只看这部分)</h2><h3 id="5-1-三要素"><a href="#5-1-三要素" class="headerlink" title="5.1 三要素"></a>5.1 三要素</h3><p>动态规划的主要难点在于理论上的设计，也就是上面几个步骤的确定，一旦设计完成，实现部分就会非常简单。</p><p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><ul><li>问题的阶段(子问题划分)</li><li>每个阶段的状态</li><li>从前一个阶段转化到后一个阶段之间的递推关系</li></ul><p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为<code>递推可以充分利用前面保存的子问题的解来减少重复计算</code>，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><h3 id="5-2-确定状态转移方程"><a href="#5-2-确定状态转移方程" class="headerlink" title="5.2 确定状态转移方程"></a>5.2 确定状态转移方程</h3><p><img src="/images/algorithm/dp-1.jpg" alt="仍以该图为例"></p><ul><li><strong>阶段</strong>：描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。<ul><li>第一个阶段就是点A到点B，第二个阶段是点B到点C，而第三个阶段是点C到点D。 </li></ul></li><li><strong>状态</strong>：状态通常可以用一个或一组数来描述，称为状态变量，记为x(k)。 <ul><li>初始状态为A，而第一个阶段有两个状态B1和B2，第二个阶段是三个状态C1，C2和C3，而第三个阶段是状态D1和D2。 </li></ul></li><li><strong>决策</strong>：每一个阶段都有若干个决策可供选择，描述决策的变量称决策变量。记为u(k)。</li><li><strong>每个阶段状态的值：</strong>为演变到该状态的前一阶段的状态值F(k) + 决策对应的值。如果发现更优解，覆盖之前的(最优常指耗费最小/路径最短，或是收益最大)。</li></ul><p>所以，状态转移方程为：</p><ul><li><p>如果是收益最大问题：直接就是如上所说：<code>F(k+1) = max&#123; F(k) + u(k) &#125; </code>(有的也用dp表示，更表示动规)</p></li><li><p>如果是耗费最小/路径最短问题：需要多一道程序，因为此时的状态是耗费xx/经历xx路径所达到的效果，而不是题目要求的最小多少耗费/最短多少路径。所以需要一个函数来进行转换，表示达到当前状态所耗费的多少，或所经历的路径长度：<code>dp(F(k+1)) = min&#123; dp(F(k)) + 1/权值 &#125;</code></p><p>如凑零钱问题中，需要的函数可以是dp(n)：定义：输入一个目标金额 n(当前状态的值F(k))，返回凑出目标金额 n 的最少硬币数量：<code>dp(n) = min&#123; dp(n-coin) + 1 | coin ∈ coins &#125;</code></p></li></ul><h3 id="5-3-最优决策表"><a href="#5-3-最优决策表" class="headerlink" title="5.3 最优决策表"></a>5.3 最优决策表</h3><p>确定了动态规划的这三要素，整个求解过程就可以用一个<code>最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态</code>，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的<code>最优值</code>（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="operator">=</span><span class="variable">max</span><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">-</span><span class="number">1</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">-</span><span class="number">1</span><span class="operator">,</span><span class="variable">m</span><span class="operator">-</span><span class="variable">w</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="operator">+</span><span class="variable">P</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-一般的算法设计模式如下"><a href="#5-4-一般的算法设计模式如下" class="headerlink" title="5.4 一般的算法设计模式如下"></a>5.4 一般的算法设计模式如下</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=max（或min）&#123;g(xi<span class="number">-1</span>[j1:j2]), ......, g(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"></span><br><span class="line">t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"></span><br><span class="line">print(x1[j1]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、经典运用"><a href="#六、经典运用" class="headerlink" title="六、经典运用"></a>六、经典运用</h2><ul><li>矩阵连乘</li><li>走金字塔</li><li>最长公共子序列(LCS)</li><li>最长递增子序列(LIS)</li><li>凸多边形最优三角剖分</li><li>背包问题</li><li>双调欧几里得旅行商问题</li><li>“求全路径最短路径的Floyd算法”<br>…<h3 id="6-1-0-1背包问题"><a href="#6-1-0-1背包问题" class="headerlink" title="6.1 0-1背包问题"></a>6.1 0-1背包问题</h3></li></ul><p>【问题描述】<br>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p>对于一种物品，要么装入背包，要么不装。所以对于一种物品的装入状态可以取0和1.我们设物品i的装入状态为xi,xi∈ (0,1)，此问题称为0-11背包问题。</p><p>【数据】<br>物品个数n=5，物品重量$w[n] = {0,2,2,6,5,4}$，物品价值$V[n] = {0,6,3,5,4,6}$（第0位，置为0，不参与计算，只是便于与后面的下标进行统一，无特别用处，也可不这么处理）。总重量$c=10$。背包的最大容量为10，那么在设置数组m大小时，可以设行列值为6和11，那么，对于$m(i,j)$就表示可选物品为$i…n$背包容量为j(总重量)时背包中所放物品的最大价值。</p><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ol><li><p>看了好多，<a href="https://blog.csdn.net/baidu_28312631/article/details/47418773">这一篇博客</a>尤为通俗易懂</p></li><li><p>如果要看备忘录算法、动态规划算法之间的差异，可以看<a href="https://blog.csdn.net/u013309870/article/details/75193592">这篇博客</a>，并做一下<a href="https://leetcode-cn.com/problems/longest-common-subsequence/">求LCS</a>这道题，搜一下它的两种解法</p></li><li><p><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin">动态规划 — 百度百科</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、术语介绍&quot;&gt;&lt;a href=&quot;#一、术语介绍&quot; class=&quot;headerlink&quot; title=&quot;一、术语介绍&quot;&gt;&lt;/a&gt;一、术语介绍&lt;/h2&gt;&lt;p&gt;先来说几个动态规划问题中的术语。&lt;/p&gt;
&lt;p&gt;动态规划(&lt;code&gt;dynamic programming</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://tenloy.github.io/categories/Algorithm/"/>
    
    
    <category term="dp" scheme="https://tenloy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>前端各种模块化方案总结</title>
    <link href="https://tenloy.github.io/2021/06/18/10_Web-Module/"/>
    <id>https://tenloy.github.io/2021/06/18/10_Web-Module/</id>
    <published>2021-06-18T11:09:27.000Z</published>
    <updated>2021-07-03T15:03:45.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、模块化"><a href="#一、模块化" class="headerlink" title="一、模块化"></a>一、模块化</h2><h3 id="1-1-什么是模块化"><a href="#1-1-什么是模块化" class="headerlink" title="1.1 什么是模块化"></a>1.1 什么是模块化</h3><p>那么，到底什么是模块化开发呢？</p><blockquote><p>模块：1、在通信、计算机、数据处理控制系统的电路中，可以组合和更换的硬件单元。2、大型软件系统中的一个具有独立功能的部分。</p></blockquote><ul><li>现实生活中模块化的例子：模块化计算机(cpu、内存、显卡、风扇、硬盘、光驱等等模块)、谷歌模块化手机、模块化房屋</li><li>代码模块化例子：日期模块、数学计算模块、日志模块等，所有这些模块共同组成了程序软件系统</li></ul><p><strong>模块化：</strong></p><ul><li>模块化开发就是<strong>将程序划分成一个个(互相依赖的)小文件/模块来开发，然后将小模块组合起来</strong>；</li><li>这个模块中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；</li><li>这个模块可以将自己希望暴露的变量、函数、对象等导出给其结构使用；</li><li>也可以通过某种方式，导入另外模块中的变量、函数、对象等；</li></ul><p><strong>模块化的好处：</strong></p><ol><li>防止命名冲突</li><li>代码复用（非模块化开发时，代码重用时，引入 js 文件的数目可能少了或者引入的顺序不对，会导致一些问题）</li><li>高维护性（模块之间有高耦合低内聚的特点）</li></ol><h3 id="1-2-JavaScript设计缺陷"><a href="#1-2-JavaScript设计缺陷" class="headerlink" title="1.2 JavaScript设计缺陷"></a>1.2 JavaScript设计缺陷</h3><p>无论你多么喜欢JavaScript，以及它现在发展的有多好，我们都需要承认在<em>Brendan Eich</em>用了10天写出JavaScript的时候，它都有很多的缺陷：</p><ul><li>比如var定义的变量作用域问题；</li><li>比如JavaScript的面向对象并不能像常规面向对象语言一样使用class；</li><li>比如JavaScript没有模块化的问题；</li></ul><p><em>Brendan Eich</em>本人也多次承认过JavaScript设计之初的缺陷，但是随着JavaScript的发展以及标准化，存在的缺陷问题基本都得到了完善。</p><ul><li>JavaScript目前已经得到了快速的发展，无论是web、移动端、小程序端、服务器端、桌面应用都被广泛的使用；</li></ul><p>在网页开发的早期，<em>Brendan Eich</em>开发JavaScript仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的：</p><ul><li>这个时候我们只需要讲JavaScript代码写到<code>&lt;script&gt;</code>标签中即可；</li><li>并没有必要放到多个文件中来编写；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;按钮被点击了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>但是随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂了：</p><ul><li>ajax的出现，前后端开发分离，意味着后端返回数据后，我们需要通过JavaScript进行前端页面的渲染；</li><li>SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现；</li><li>包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤；</li></ul><p>所以，模块化已经是JavaScript一个非常迫切的需求。</p><h3 id="1-3-没有模块化的JavaScript"><a href="#1-3-没有模块化的JavaScript" class="headerlink" title="1.3 没有模块化的JavaScript"></a>1.3 没有模块化的JavaScript</h3><h4 id="1-3-1-技术方案"><a href="#1-3-1-技术方案" class="headerlink" title="1.3.1 技术方案"></a>1.3.1 技术方案</h4><p>演变过程：</p><ul><li><p>全局函数</p><ul><li>”污染”了全局变量，无法保证不与其它模块发生变量名冲突</li><li>没有模块的划分，只能人为的认为它们属于一个模块，但是程序并不能区分哪些函数是同一个模块</li></ul></li><li><p>将函数封装到对象命名空间下</p><ul><li>从代码级别可以明显的区分出哪些函数属于同一个模块</li><li>从某种程度上解决了变量命名冲突的问题，但是并不能从根本上解决命名冲突</li><li>会暴露所有的模块成员，内部状态可以被外部改写，不安全</li><li>命名空间越来越长</li></ul></li><li><p>立即函数调用表达式(<strong>IIFE</strong>，Immediately Invoked Function Expression)</p><ul><li><p>将模块封装为立即执行函数形式，将公有方法，通过在函数内部返回值的形式向外暴露</p></li><li><p>会有人强调<strong>职责单一性</strong>，不要与程序的其它部分直接交互。比如当使用到第三方依赖时，通过向匿名函数注入依赖项的形式，来保证模块的独立性，还使模块之间的依赖关系变得明显</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> add=<span class="function"><span class="keyword">function</span>(<span class="params">v1,v2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1+v2;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123; <span class="attr">add</span>:add &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> calculator=(<span class="function"><span class="keyword">function</span>(<span class="params">cal,$</span>)</span>&#123;</span><br><span class="line">  cal.add2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> v1=$(<span class="string">&#x27;#v1&#x27;</span>).val();</span><br><span class="line">      <span class="keyword">var</span> v2= $(<span class="string">&#x27;#v2&#x27;</span>).val();</span><br><span class="line">     <span class="keyword">return</span> (v1-<span class="number">0</span>)+(v2-<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cal;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.calculator||&#123;&#125;,<span class="built_in">window</span>.$)</span><br><span class="line"><span class="comment">//在这告诉我要jquery</span></span><br><span class="line"><span class="comment">//依赖注入</span></span><br><span class="line"><span class="comment">//很牵强的解决文件依赖问题的方法</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>IIFE也是有很大缺陷的，见下方代码举例</p></li></ul><h4 id="1-3-2-问题举例"><a href="#1-3-2-问题举例" class="headerlink" title="1.3.2 问题举例"></a>1.3.2 问题举例</h4><p>我们先来简单体会一下没有模块化代码的问题。</p><p>我们知道，对于一个大型的前端项目，通常是多人开发的（即使一个人开发，也会将代码划分到多个文件夹中）：</p><ul><li>我们假设有两个人：小明和小丽同时在开发一个项目，并且会将自己的JavaScript代码放在一个单独的js文件中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小明开发了aaa.js文件，代码如下（当然真实代码会复杂的多）：</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;aaa的flag为true&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小丽开发了bbb.js文件，代码如下：</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;bbb使用了flag为false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显出现了一个问题：</p><ul><li>大家都喜欢使用flag来存储一个boolean类型的值；</li><li>但是一个人赋值了true，一个人赋值了false；</li><li>如果之后都不再使用，那么也没有关系；</li></ul><p>但是，小明又开发了ccc.js文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;使用了aaa的flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了：小明发现ccc中的flag值不对</p><ul><li>对于聪明的你，当然一眼就看出来，是小丽将flag赋值为了false；</li><li>但是如果每个文件都有上千甚至更多的代码，而且有上百个文件，你可以一眼看出来flag在哪个地方被修改了吗？</li></ul><p>备注：引用路径如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./aaa.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bbb.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./ccc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以，没有模块化对于一个大型项目来说是灾难性的。</p><h4 id="1-3-3-IIFE的缺陷"><a href="#1-3-3-IIFE的缺陷" class="headerlink" title="1.3.3 IIFE的缺陷"></a>1.3.3 IIFE的缺陷</h4><p>使用IIFE解决上面的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;aaa的flag为true&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">flag</span>: flag &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="keyword">const</span> moduleB = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;bbb使用了flag为false&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ccc.js</span></span><br><span class="line"><span class="keyword">const</span> moduleC = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> flag = moduleA.flag;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;使用了aaa的flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>命名冲突的问题，有没有解决呢？解决了。</p><p>但是，我们其实带来了新的问题：</p><ul><li>第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用；</li><li>第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；</li><li>第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况；</li></ul><p><strong>所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。</strong></p><ul><li>我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码；</li><li>这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性；</li></ul><h3 id="1-4-JavaScript中模块化方案"><a href="#1-4-JavaScript中模块化方案" class="headerlink" title="1.4 JavaScript中模块化方案"></a>1.4 JavaScript中模块化方案</h3><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>。直到ES6（2015）才推出了自己的模块化方案，在此之前，社区制定了一些模块加载方案，最主要的有：</p><p>先有规范，后有实现：</p><ul><li>服务器端规范 <a href="http://www.commonjs.org/">CommonJS</a> =&gt; <a href="https://nodejs.org/">NodeJS</a>、 Browserify</li><li>浏览器端规范 <a href="https://github.com/amdjs/amdjs-api">AMD</a> =&gt; <a href="http://requirejs.org/">RequireJS</a></li><li>浏览器端规范 <a href="https://github.com/amdjs/amdjs-api">CMD</a> =&gt; <a href="http://seajs.org/">SeaJS</a></li></ul><h2 id="二、CommonJS规范"><a href="#二、CommonJS规范" class="headerlink" title="二、CommonJS规范"></a>二、CommonJS规范</h2><h3 id="2-1-CommonJS和Node"><a href="#2-1-CommonJS和Node" class="headerlink" title="2.1 CommonJS和Node"></a>2.1 CommonJS和Node</h3><p>我们需要知道CommonJS是一个规范，最初提出来是在浏览器意外的地方使用，并且当时被命名为<strong>ServerJS</strong>，后来为了体现它的广泛性，修改为<strong>CommonJS</strong>，平时我们也会简称为CJS。</p><ul><li>Node是CommonJS在服务器端一个具有代表性的实现；</li><li>Browserify是CommonJS在浏览器中的一种实现；</li><li>webpack打包工具具备对CommonJS的支持和转换（后面会讲到）；</li></ul><p>所以，Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：</p><h3 id="2-2-Node模块化语法"><a href="#2-2-Node模块化语法" class="headerlink" title="2.2 Node模块化语法"></a>2.2 Node模块化语法</h3><h4 id="2-2-1-模块"><a href="#2-2-1-模块" class="headerlink" title="2.2.1 模块"></a>2.2.1 模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(name, age);</span><br><span class="line">sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面的代码会报错：</span></span><br><span class="line"><span class="comment"> - 那么，就意味着别的模块main中不能随便访问另外一个模块bar中的内容；</span></span><br><span class="line"><span class="comment"> - bar需要 导出 自己想要暴露的变量、函数、对象等；main从bar中 导入 自己想要使用的变量、函数、对象等数据之后，才能使用；</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>在node中每一个文件都是一个独立的模块，有自己的作用域</strong>。在一个模块内变量、函数、对象都属于这个模块，对外是封闭的。</p><p>为了实现模块的导出，Node中使用的是Module的类(提供了一个Module构造函数)，每一个模块都是Module的一个实例，也就是module；</p><p>每个模块(文件)中都包括CommonJS规范的核心变量：exports、module、require；</p><ul><li><p>module：是一个全局对象，代表当前模块。里面保存了模块的信息路径、父子结构信息、曝露出的对象信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.id           <span class="comment">//带有绝对路径的模块文件名</span></span><br><span class="line"><span class="built_in">module</span>.filename      <span class="comment">//模块的文件名，带有绝对路径</span></span><br><span class="line"><span class="built_in">module</span>.loaded       <span class="comment">//表示模块是否已经完成加载</span></span><br><span class="line"><span class="built_in">module</span>.parent     <span class="comment">//返回一个对象，表示调用该模块的模块。</span></span><br><span class="line"><span class="built_in">module</span>.children      <span class="comment">//返回一个数组，表示该模块要用到的其他模块。</span></span><br><span class="line"><span class="built_in">module</span>.exports     <span class="comment">//模块对外输出的值。需要打破模块封装性曝露的方法和属性，都要挂载到module.exports上。其它文件加载该模块,实际上就是读取module.exports属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 /Users/computer/Desktop/ccc/lib.js 文件中 console.log(module);</span></span><br><span class="line">Module &#123;</span><br><span class="line">  id: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">  path: <span class="string">&#x27;/Users/computer/Desktop/ccc&#x27;</span>,</span><br><span class="line">  <span class="built_in">exports</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span> &#125;,</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">&#x27;/Users/computer/Desktop/ccc/main.js&#x27;</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children: [</span><br><span class="line">    Module &#123;...&#125;</span><br><span class="line">  ],</span><br><span class="line">  paths: [ <span class="comment">//查找路径</span></span><br><span class="line">    <span class="string">&#x27;/Users/computer/Desktop/ccc/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/computer/Desktop/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/computer/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/node_modules&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>exports是module.exports的引用。一起负责对模块中的内容进行导出；</p></li><li><p>require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；</p></li></ul><p>在Node.js中，模块分为两类：</p><ul><li><p>第一类，系统核心模块(原生模块)，node自带。用名称直接可以加载。</p><ul><li>fs(file system)：与文件系统交互</li><li>http：提供http服务器功能</li><li>os：提供了与操作系统相关的实用方法和属性</li><li>path：处理文件路径</li><li>querystring：解析url查询字符串</li><li>url：解析url</li><li>util：提供一系列实用小工具</li><li>Buffer </li><li>等等很多，见<a href="http://api.nodejs.cn/">官方文档</a></li><li><strong>核心模块的源码都在Node的lib子目录中。为了提高运行速度，它们安装的时候都会被编译成二进制文件</strong></li></ul></li><li><p>第二类，文件模块，也称自定义模块。用路径加载。</p><p>有一种特殊的文件模块 — 包，被管理在<code>node_modules</code>文件夹中的包，也可以直接用名字加载。</p></li></ul><h4 id="2-2-2-exports导出"><a href="#2-2-2-exports导出" class="headerlink" title="2.2.2 exports导出"></a>2.2.2 exports导出</h4><p><strong>强调：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js 导出内容</span></span><br><span class="line"><span class="built_in">exports</span>.name = name;</span><br><span class="line"><span class="built_in">exports</span>.age = age;</span><br><span class="line"><span class="built_in">exports</span>.sayHello = sayHello;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 导入内容</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面这行代码意味着什么呢？</p><ul><li>意味着main中的bar变量等于exports对象；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main中的bar = bar中的<span class="built_in">exports</span></span><br></pre></td></tr></table></figure><p>所以，我可以编写下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = bar.name;</span><br><span class="line"><span class="keyword">const</span> age = bar.age;</span><br><span class="line"><span class="keyword">const</span> sayHello = bar.sayHello;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"></span><br><span class="line">sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br></pre></td></tr></table></figure><p>模块之间的引用关系：</p><img src="/images/webmodule/moduleref.jpg" alt="图片" style="zoom:70%;" /><p>为了进一步论证，bar和exports是同一个对象：</p><ul><li>所以，bar对象是exports对象的浅拷贝；</li><li>浅拷贝的本质就是一种引用的赋值而已；</li></ul><p>定时器修改对象：</p><img src="/images/webmodule/settimeoutmod.jpg" alt="图片" style="zoom:80%;" /><h4 id="2-2-3-module-exports"><a href="#2-2-3-module-exports" class="headerlink" title="2.2.3 module.exports"></a>2.2.3 module.exports</h4><p>但是Node中我们经常导出东西的时候，又是通过module.exports导出的：</p><ul><li>module.exports和exports有什么关系或者区别呢？</li></ul><p>我们追根溯源，通过维基百科中对CommonJS规范的解析：</p><ul><li>CommonJS中是没有module.exports的概念的；</li><li>但是为了实现模块的导出，Node中使用的是Module的类(提供了一个Module构造函数)，每一个模块都是Module的一个实例，也就是module；</li><li><strong>module才是导出的真正实现者；</strong></li><li>所以在Node中<strong>真正用于导出的其实根本不是exports，而是module.exports</strong>。只是为了实现CommonJS的规范，也为了使用方便，Node为每个模块提供了一个exports对象，让其对module.exports有一个引用而已。</li><li>相当于在每个模块头部，有这样一行命令：<code>var exports = module.exports;</code></li></ul><img src="/images/webmodule/export1.jpg" alt="图片" style="zoom:67%;" /><p><strong>不能直接给exports、module.exports赋值，这样等于切断了exports和module.exports的联系。最终输出的结果只会是module.exports的值</strong>。比如代码这样修改了：</p><img src="/images/webmodule/export2.jpg" alt="图片" style="zoom:67%;" /><img src="/images/webmodule/moduleexports.jpg" alt="moduleexports" style="zoom:68%;" /><h4 id="2-2-4-require"><a href="#2-2-4-require" class="headerlink" title="2.2.4 require"></a>2.2.4 require</h4><h5 id="1-require的加载原理"><a href="#1-require的加载原理" class="headerlink" title="1. require的加载原理"></a>1. require的加载原理</h5><p>前面已经说过，CommonJS 的一个模块，就是一个脚本文件。</p><ul><li><p>CommonJS是同步加载。模块加载的顺序，按照其在代码中出现的顺序</p></li><li><p><code>require</code>命令第一次加载模块时，会执行整个模块(脚本文件)中的js代码，返回该模块的module.exports接口数据。会在内存生成一个该模块对应的module对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> aaa = <span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>); <span class="comment">// aaa.js中的代码在引入时会被运行一次</span></span><br></pre></td></tr></table></figure><p>生成的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">&#x27;...&#x27;</span>,  <span class="comment">// 模块名</span></span><br><span class="line">  <span class="built_in">exports</span>: &#123; ... &#125;,  <span class="comment">// 模块输出的各个接口</span></span><br><span class="line">  loaded: <span class="literal">true</span>,   <span class="comment">// 是一个布尔值，为false表示还没有加载，为true表示已经加载完毕。这是保证每个模块只加载、运行一次的关键。</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。</p></li><li><p>模块被多次引入时（多次执行<code>require</code>命令），CommonJS 模块<strong>只会在第一次加载时运行一次</strong>，以后再加载，会去缓存中取出第一次加载时生成的module对象并返回module.exports。除非手动清除系统缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> aaa = <span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bbb = <span class="built_in">require</span>(<span class="string">&#x27;./bbb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> ccc = <span class="built_in">require</span>(<span class="string">&quot;./ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="keyword">const</span> ccc = <span class="built_in">require</span>(<span class="string">&quot;./ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ccc.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ccc被加载&#x27;</span>);  <span class="comment">// ccc中的代码只会运行一次。</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-require的查找规则"><a href="#2-require的查找规则" class="headerlink" title="2. require的查找规则"></a>2. require的查找规则</h5><p>我们现在已经知道，require是一个函数，可以帮助我们引入一个文件（模块）中导出的对象。</p><p>那么，require的查找规则是怎么样的呢？<a href="https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together">官方文档</a></p><p><strong>这里我总结比较常见的查找规则：</strong>导入格式如下：require(X)</p><ul><li><p>情况一：X是一个核心模块，比如path、http。直接返回核心模块，并且停止查找</p><ul><li>加载核心模块。传入名字，不需要传入路径。因为Node.js已经将核心模块的文件代码编译到了二进制的可执行文件中了。在加载的过程中，原生的核心模块的优先级是是最高的。</li></ul></li><li><p>情况二：X是以 <code>./</code> 或 <code>../</code> 或 <code>/</code>（根目录）开头的</p><ul><li>在Linux或者MAc的操作系统中，/表示系统的根路径。在Windows中，/表示当前文件模块所属的根磁盘路径</li><li>第一步：将X当做一个文件在对应的目录下查找；<ul><li>如果有后缀名，按照后缀名的格式查找对应的文件</li><li>如果没有后缀名，会按照如下顺序：<ol><li>直接查找文件X</li><li>查找X.js文件：当做JavaScript脚本文件解析</li><li>查找X.json文件：以JSON格式解析。<ul><li>如果是加载json文件模块，最好加上后缀.json，能稍微的提高一点加载的速度。</li><li>json文件Node.js也是通过fs读文件的形式读取出来的，然后通过JSON.parse()转换成一个对象</li></ul></li><li>查找X.node文件：以编译后的二进制文件解析。.node文件通常是c/c++写的一些扩展模块</li></ol></li></ul></li><li>第二步：没有找到对应的文件，将X作为一个目录。查找目录下面的index文件<ol><li>查找X/index.js文件</li><li>查找X/index.json文件</li><li>查找X/index.node文件</li></ol></li><li>如果没有找到，那么报错：<code>not found</code></li></ul></li><li><p>情况三：直接是一个X（没有路径），并且X不是一个核心模块</p><ul><li> 比如在<code>/Users/coderwhy/Desktop/Node/TestCode/04_learn_node/05_javascript-module/02_commonjs/main.js</code>中</li></ul><p>  编写 <code>require(&#39;why&#39;)</code></p><ul><li><p>查找顺序：从当前 package 的 node_modules 里面找，找不到就到当前 package 目录上层 node_modules 里面取… 一直找到全局 node_modules 目录。</p><img src="/images/webmodule/require1.jpg" alt="图片" style="zoom:70%;" /></li><li><p>这样找到的往往是文件夹，所以接下来就是处理一个文件目录作为 Node 模块的情况。如果文件目录下有 package.json，就根据它的 main 字段找到 js 文件。如果没有 package.json，那就<strong>默认取文件夹下的 index.js</strong>。</p><p>由于 webpack browsersify 等模块打包工具是兼容 node 的模块系统的，自然也会进行同样的处理流程。不同的是，它们支持更灵活的配置。比如在 webpack 里面，可以通过 alias 和 external 字段配置，实现对默认 import 逻辑的自定义。</p></li><li><p>如果上面的路径中都没有找到，那么报错：<code>not found</code></p></li></ul></li></ul><p>流程图：</p><img src="/images/webmodule/image1.jpg" alt="Alt text" style="zoom:80%;" /><ul><li><p>Node.js会通过同步阻塞的方式看这个路径是否存在。依次尝试，直到找到为止，如果找不到，报错</p></li><li><p>优先从缓存加载：common.js规范：载后，再次加载时，去缓存中取module.exports <a href="http://www.infoq.com/cn/articles/nodejs-module-mechanism/">参考文献</a></p></li></ul><h5 id="3-require的加载顺序"><a href="#3-require的加载顺序" class="headerlink" title="3. require的加载顺序"></a>3. require的加载顺序</h5><p><strong>如果有多个模块的引入，那么加载顺序是什么？</strong></p><p>如果出现下面模块的引用关系，那么加载顺序是什么呢？</p><ul><li>这个其实是一种数据结构：图结构；</li><li>图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）；</li><li>Node采用的是深度优先算法：main -&gt; aaa -&gt; ccc -&gt; ddd -&gt; eee -&gt;bbb</li></ul><p>多个模块的引入关系：</p><img src="/images/webmodule/multiMoudlesinclude.jpg" alt="multiMoudlesinclude" style="zoom:80%;" /><h3 id="2-3-Node的源码解析"><a href="#2-3-Node的源码解析" class="headerlink" title="2.3 Node的源码解析"></a>2.3 Node的源码解析</h3><p>Module类</p><img src="/images/webmodule/moduleclssource.jpg" alt="图片" style="zoom:80%;" /><p>Module.prototype.require函数</p><img src="/images/webmodule/requiremethodsource.jpg" alt="图片" style="zoom:80%;" /><p>Module._load函数</p><img src="/images/webmodule/loadmethodsource.jpg" alt="图片" style="zoom:80%;" /><h2 id="三、ES6-Module"><a href="#三、ES6-Module" class="headerlink" title="三、ES6 Module"></a>三、ES6 Module</h2><h3 id="4-1-认识ES6-Module"><a href="#4-1-认识ES6-Module" class="headerlink" title="4.1 认识ES6 Module"></a>4.1 认识ES6 Module</h3><h4 id="4-1-1-ES6-Module的优势"><a href="#4-1-1-ES6-Module的优势" class="headerlink" title="4.1.1 ES6 Module的优势"></a>4.1.1 ES6 Module的优势</h4><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西，导致完全没办法在编译时做“静态优化”。</p><p>由于 ES6 模块是编译时加载：</p><ul><li><p>可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高</p></li><li><p>使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p></li></ul><p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p><ul><li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li><li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li><li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li></ul><h4 id="4-1-2-自动启动严格模式"><a href="#4-1-2-自动启动严格模式" class="headerlink" title="4.1.2 自动启动严格模式"></a>4.1.2 自动启动严格模式</h4><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><ul><li>其中，尤其需要注意<code>this</code>的限制。<font color=red>ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code></font>。</li><li>参考链接：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式—MDN</a></li><li><a href="https://tenloy.github.io/pnote/web_note/05-JS%E9%AB%98%E7%BA%A7/Sources/3.6_ES5%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html">严格模式—阮一峰</a></li></ul></li></ul><h4 id="4-1-3-浏览器中加载ES6-Module"><a href="#4-1-3-浏览器中加载ES6-Module" class="headerlink" title="4.1.3 浏览器中加载ES6 Module"></a>4.1.3 浏览器中加载ES6 Module</h4><h5 id="1-加载普通js文件"><a href="#1-加载普通js文件" class="headerlink" title="1. 加载普通js文件"></a>1. 加载普通js文件</h5><p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面内嵌的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="javascript"> <span class="comment">// code </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span><span class="javascript"> <span class="comment">//code... </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p></li><li><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载。</p></li></ul><p>下面就是两种异步加载的语法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p><p><code>defer</code>与<code>async</code>的区别是：</p><ul><li><code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；</li><li><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li><li>一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。</li><li>另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</li></ul><h5 id="2-加载ES6-Module"><a href="#2-加载ES6-Module" class="headerlink" title="2. 加载ES6 Module"></a>2. 加载ES6 Module</h5><p>浏览器内嵌、外链 ES6 模块代码，也使用<code>&lt;script&gt;</code>标签，但是都要加入<code>type=&quot;module&quot;</code>属性。</p><p><code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 等同于下面代码。如果网页有多个 &lt;script type=&quot;module&quot;&gt;，它们会按照在页面出现的顺序依次执行。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">&lt;script&gt;标签的async属性也可以打开：</span></span><br><span class="line"><span class="comment">这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。 </span></span><br><span class="line"><span class="comment">同样的：一旦使用了此属性，&lt;script type=&quot;module&quot;&gt;就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&quot;./utils.js&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li><li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul><p>下面是一个示例模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;https://example.com/js/utils.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="built_in">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-4-本地浏览的报错"><a href="#4-1-4-本地浏览的报错" class="headerlink" title="4.1.4 本地浏览的报错"></a>4.1.4 本地浏览的报错</h4><p>代码结构如下（个人习惯）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">└── modules</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><p>index.html中引入两个js文件作为模块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./modules/foo.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果直接在浏览器中运行代码，会报如下错误：</p><img src="/images/webmodule/modulerunerror.jpg" alt="图片" style="zoom:80%;" /><p>这个在MDN上面有给出解释：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules</a></li><li>你需要注意本地测试 — 如果你通过本地加载Html 文件 (比如一个 <code>file://</code> 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。</li><li>你需要通过一个服务器来测试。</li></ul><p>我这里使用的VSCode，VSCode中有一个插件：Live Server</p><ul><li>通过插件运行，可以将我们的代码运行在一个本地服务中；</li></ul><img src="/images/webmodule/liveserver.jpg" alt="图片" style="zoom:80%;" /><h3 id="4-2-ES6-Module的语法"><a href="#4-2-ES6-Module的语法" class="headerlink" title="4.2 ES6 Module的语法"></a>4.2 ES6 Module的语法</h3><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>：</p><ul><li><code>export</code>命令用于规定模块的对外接口</li><li><code>import</code>命令用于输入其他模块提供的功能。</li></ul><h4 id="4-2-1-模块与CommonJS模块的区别"><a href="#4-2-1-模块与CommonJS模块的区别" class="headerlink" title="4.2.1 模块与CommonJS模块的区别"></a>4.2.1 模块与CommonJS模块的区别</h4><h5 id="1-相同点"><a href="#1-相同点" class="headerlink" title="1. 相同点"></a>1. 相同点</h5><p>与CommonJS的相同点：一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。</p><h5 id="2-导出的不同"><a href="#2-导出的不同" class="headerlink" title="2. 导出的不同"></a>2. 导出的不同</h5><p><strong>CommonJS通过module.exports导出的是一个对象，是<code>module.exports</code>属性浅拷贝后导出：</strong></p><ul><li><p>该对象只有在脚本运行完才会生成。</p></li><li><p>导出的是一个对象意味着可以将这个对象的引用在导入模块中赋值给其他变量；但是最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改；</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">count</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    obj.count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">  obj: obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter, mod.obj.count); <span class="comment">// 3  3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter, mod.obj.count); <span class="comment">// 3  4</span></span><br></pre></td></tr></table></figure><p><strong>ES Module通过export导出的不是对象，是一个个导出变量/函数/类本身的引用：</strong></p><p>说法1：</p><ul><li>它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li><li>换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。(由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错)</li><li>所以，<code>import</code>命令叫做“连接” binding 其实更合适。</li></ul><p>说法2：</p><ul><li><p>export在导出一个变量时，js引擎会解析这个语法，并且创建<strong>模块环境记录</strong>（module environment record）；</p></li><li><p><strong>模块环境记录</strong>会和变量进行 <code>绑定</code>（binding），并且这个绑定是实时的；</p></li><li><p>而在导入的地方，我们是可以实时的获取到绑定的最新值的；</p></li></ul><p><strong>export和import绑定的过程：</strong></p><img src="/images/webmodule/bindingProcedure.jpg" alt="图片" style="zoom:70%;" /><p>还是举上面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p><h5 id="3-导入的不同"><a href="#3-导入的不同" class="headerlink" title="3. 导入的不同"></a>3. 导入的不同</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码实质会整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码实质只是从<code>fs</code>模块加载 3 个方法，其他方法不加载。</p><h4 id="4-2-2-export"><a href="#4-2-2-export" class="headerlink" title="4.2.2 export"></a>4.2.2 export</h4><p>export关键字将一个模块中的变量、函数、类等导出；</p><h5 id="1-export-lt-decl-gt"><a href="#1-export-lt-decl-gt" class="headerlink" title="1. export &lt;decl&gt;"></a>1. <code>export &lt;decl&gt;</code></h5><p>方式一：分别导出。在<strong>语句声明</strong>的前面直接加上export关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> message = <span class="string">&quot;my name is why&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export需要指定对外暴露的接口，所以不能直接输出一个值</span></span><br><span class="line"><span class="comment">// export 40; //error</span></span><br></pre></td></tr></table></figure><h5 id="2-export"><a href="#2-export" class="headerlink" title="2. export {}"></a>2. <code>export &#123;&#125;</code></h5><p>方式二：统一导出。将所有需要导出的标识符，放到export后面的 <code>&#123;&#125;</code>中。它与上一种写法是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些数据。</p><ul><li>注意：这里的 <code>&#123;&#125;</code>里面不是ES6的对象字面量的增强写法，<code>&#123;&#125;</code>也不是表示一个对象的；</li><li>所以：<code>export &#123;name: name&#125;</code>，是错误的写法；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-export-lt-gt-as-lt-gt"><a href="#3-export-lt-gt-as-lt-gt" class="headerlink" title="3. export {&lt;&gt; as &lt;&gt;}"></a>3. <code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code></h5><p>方式三：通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字在导出时给<code>标识符</code>起一个别名：<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name <span class="keyword">as</span> fName,</span><br><span class="line">  age <span class="keyword">as</span> fAge,</span><br><span class="line">  sayHello <span class="keyword">as</span> fSayHello1,</span><br><span class="line">  sayHello <span class="keyword">as</span> fSayHello2, <span class="comment">// 重命名后，sayHello可以用不同的名字输出两次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-export导出的是标识符的地址"><a href="#4-export导出的是标识符的地址" class="headerlink" title="4. export导出的是标识符的地址"></a>4. export导出的是标识符的地址</h5><p><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> foo = <span class="string">&#x27;baz&#x27;</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p><p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。</p><h5 id="5-export导出同一个实例"><a href="#5-export导出同一个实例" class="headerlink" title="5. export导出同一个实例"></a>5. export导出同一个实例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br></pre></td></tr></table></figure><p>不同的模块中，加载这个模块，得到的都是同一个实例。对c修改，其他模块导入的数据也会改变</p><h5 id="6-export书写位置"><a href="#6-export书写位置" class="headerlink" title="6. export书写位置"></a>6. export书写位置</h5><p><code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&#x27;bar&#x27;</span> <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><h5 id="7-export书写次数"><a href="#7-export书写次数" class="headerlink" title="7. export书写次数"></a>7. export书写次数</h5><p>一个模块中：<code>export &lt;decl&gt;</code>、<code>export &#123;&#125;</code>、<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code>都是可以出现<code>0-n</code>次的</p><h4 id="4-2-3-import"><a href="#4-2-3-import" class="headerlink" title="4.2.3 import"></a>4.2.3 import</h4><p>import关键字负责从另外一个模块中导入内容。</p><p><strong><code>import</code>语句会执行所加载的模块。如果同一个模块被加载多次，那么模块里的代码只执行一次。</strong></p><p><strong>导入内容的方式也有多种：</strong></p><h5 id="1-import-from-39-39"><a href="#1-import-from-39-39" class="headerlink" title="1. import {} from &#39;&#39;"></a>1. <code>import &#123;&#125; from &#39;&#39;</code></h5><p>方式一：选择导入。<code>import &#123;标识符列表&#125; from &#39;模块&#39;</code>；</p><p>注意：</p><ul><li>大括号里面的变量名，必须与被导入模块对外接口的名称相同。</li><li>这里的<code>&#123;&#125;</code>也不是一个对象，里面只是存放导入的标识符列表内容；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line">sayHello(<span class="string">&quot;Kobe&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; age &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>name</code>和<code>age</code>在两个语句中加载，但是它们对应的是同一个<code>foo.js</code>模块。也就是说，<code>import</code>语句是 Singleton 模式。</p><h5 id="1-import-39-39-的含义"><a href="#1-import-39-39-的含义" class="headerlink" title="1. import &#39;&#39;的含义"></a>1. <code>import &#39;&#39;</code>的含义</h5><p><code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>; </span><br></pre></td></tr></table></figure><p>上面代码仅仅执行<code>lodash</code>模块，但是不导入任何值。</p><p>同样的，如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>; <span class="comment">// 代码加载了两次`lodash`，但是只会执行一次。</span></span><br></pre></td></tr></table></figure><h5 id="2-import-lt-gt-as-lt-gt-from-39-39"><a href="#2-import-lt-gt-as-lt-gt-from-39-39" class="headerlink" title="2.  import {&lt;&gt; as &lt;&gt;} from &#39;&#39;"></a>2.  <code>import &#123;&lt;&gt; as &lt;&gt;&#125; from &#39;&#39;</code></h5><p>方式二：导入时给标识符起别名： <code>import &#123;&lt;&gt; as &lt;&gt;&#125; from &#39;&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> wName, age <span class="keyword">as</span> wAge, sayHello <span class="keyword">as</span> wSayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="3-import-as-lt-gt-from-39-39"><a href="#3-import-as-lt-gt-from-39-39" class="headerlink" title="3.  import * as &lt;&gt; from &#39;&#39;"></a>3.  <code>import * as &lt;&gt; from &#39;&#39;</code></h5><p>方式三：整体导入。将模块功能放到一个模块功能对象(a module object)上，用<code>*</code>指定： <code>import * as &lt;&gt; from &#39;&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.name);</span><br><span class="line"><span class="built_in">console</span>.log(foo.age);</span><br><span class="line">foo.sayHello(<span class="string">&quot;Kobe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.n = &quot;add&quot;; // Type Error: object is not extensible</span></span><br><span class="line"><span class="comment">// foo.f = function () &#123;&#125;; </span></span><br></pre></td></tr></table></figure><p>注意，模块整体加载所在的那个对象，应该是可以静态分析的，所以不允许运行时改变。上面的写法是不允许的。</p><h5 id="4-import导入为只读"><a href="#4-import导入为只读" class="headerlink" title="4. import导入为只读"></a>4. import导入为只读</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line">name = <span class="string">&quot;mod&quot;</span>; <span class="comment">// Syntax Error : &#x27;name&#x27; is read-only;</span></span><br></pre></td></tr></table></figure><p><code>name</code>是只读的。但是，如果<code>name</code>是一个对象，改写其属性是允许的，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</p><h5 id="5-import-from后的路径"><a href="#5-import-from后的路径" class="headerlink" title="5. import from后的路径"></a>5. import from后的路径</h5><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径，<font color=red>后缀名不能省略</font>。</p><p>如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p><h5 id="6-import命令的提升"><a href="#6-import命令的提升" class="headerlink" title="6. import命令的提升"></a>6. import命令的提升</h5><p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p><p>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.symbol&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.promise&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;React&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="7-import中不能使用表达式和变量"><a href="#7-import中不能使用表达式和变量" class="headerlink" title="7. import中不能使用表达式和变量"></a>7. import中不能使用表达式和变量</h5><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">&#x27;f&#x27;</span> + <span class="string">&#x27;oo&#x27;</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module1&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module2&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p><h4 id="4-2-4-export-default"><a href="#4-2-4-export-default" class="headerlink" title="4.2.4 export default"></a>4.2.4 export default</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>前面我们学习的导出功能都是有名字的导出（named exports）：</p><ul><li>在导出export时指定了名字；</li><li>在导入import时需要知道具体的名字；</li></ul><p>还有一种导出叫做默认导出（default export）</p><ul><li>默认导出export时可以不需要指定名字；</li><li>在导入时不需要使用 <code>&#123;&#125;</code>，并且可以自己来指定名字；</li><li>它也方便我们和现有的CommonJS等规范相互操作；</li></ul><h5 id="2-导出与导入格式"><a href="#2-导出与导入格式" class="headerlink" title="2. 导出与导入格式"></a>2. 导出与导入格式</h5><p>也是可以导出变量、函数、类的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出格式1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出格式2：用在非匿名函数前</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出格式3：用在函数变量前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;sub&#x27;</span>); &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sub;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数名`sub`，在模块外部是无效的。加载的时候，视同匿名函数加载。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式1：常用及推荐</span></span><br><span class="line"><span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式2</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.default.sub(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式3</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.sub(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><h5 id="3-export-default的本质"><a href="#3-export-default的本质" class="headerlink" title="3. export default的本质"></a>3. export default的本质</h5><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;  <span class="comment">// 等同于 export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;modules&#x27;</span>; <span class="comment">// 等同于 import foo from &#x27;modules&#x27;;</span></span><br></pre></td></tr></table></figure><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 含义是将变量`a`的值赋给变量`default`。所以，最后一种写法会报错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="comment">// export default var a = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样地，因为`export default`命令的本质是将后面的值，赋给`default`变量，所以可以直接将一个值写在`export default`之后。</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// export 42; // export后面得跟声明，或者&#123;标识符&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-export-default与export"><a href="#4-export-default与export" class="headerlink" title="4. export default与export"></a>4. export default与export</h5><p>注意：在一个模块中，export default是可以与export同时使用的：</p><ul><li>export default用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。</li><li>export是没有限制的。<code>export &lt;decl&gt;</code>、<code>export &#123;&#125;</code>、<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code>都是可以出现<code>0-n</code>次的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">&quot;module1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 在一条`import`语句中，同时输入默认接口和其他接口</span></span><br><span class="line"><span class="keyword">import</span> m, &#123;name&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">//m.sub、name</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">// m.default.sub、m.name</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m, name&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">// m.sub、name</span></span><br></pre></td></tr></table></figure><h4 id="4-2-5-export和import结合"><a href="#4-2-5-export和import结合" class="headerlink" title="4.2.5 export和import结合"></a>4.2.5 export和import结合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js 导出一个sum函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.js做一个中转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js直接从foo中导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><p>如果从一个模块中导入的内容，我们希望再直接导出出去，这个时候可以使用export和import的结合，写成一行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js 导入，但是只是做一个中转</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口改名</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> barSum &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>; <span class="comment">// 甚至在foo.js中导出时，我们可以变化它的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入和导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 相当于实现了模块之间的继承。注意，`export *`命令会忽略后面模块的`default`接口。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名接口改为默认接口的写法如下：</span></span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口也可以改名为具名接口：</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> es6 &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2020 之前，有一种`import`语句，没有对应的复合写法。[ES2020](https://github.com/tc39/proposal-export-ns-from)补上了这个写法。</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;ns&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是，写成一行以后，`sum`实际上并没有被导入当前模块，只是相当于对外转发了这个接口，导致当前模块不能直接使用`sum`。</span></span><br></pre></td></tr></table></figure><p>为什么要这样做呢？</p><ul><li>在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中；</li><li>这样方便指定统一的接口规范，也方便阅读；</li><li>这个时候，我们就可以使用export和import结合使用；</li></ul><h4 id="4-2-6-import"><a href="#4-2-6-import" class="headerlink" title="4.2.6 import()"></a>4.2.6 import()</h4><h5 id="1-import-的背景"><a href="#1-import-的背景" class="headerlink" title="1. import()的背景"></a>1. import()的背景</h5><p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行。所以，<code>import</code>和<code>export</code>命令只能在模块的顶层，是不可以在其放到逻辑代码中（比如在<code>if</code>代码块之中，或在函数之中）的。下面的代码会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。</p><p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;./&#x27;</span> + fileName;</span><br><span class="line"><span class="keyword">const</span> myModual = <span class="built_in">require</span>(path); </span><br><span class="line"><span class="comment">// 上面的语句就是动态加载，`require`到底加载哪一个模块，只有运行时才知道。`import`命令做不到这一点。</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/tc39/proposal-dynamic-import">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(specifier)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p><h5 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h5><p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;<span class="comment">// 加载模块成功以后，这个模块会作为一个对象，当作`then`方法的参数.</span></span><br><span class="line"><span class="comment">//.then(&#123;export1, export2&#125; =&gt; &#123;     // 可以使用对象解构赋值的语法，获取输出接口。</span></span><br><span class="line"><span class="comment">//.then(&#123;default: theDefault&#125; =&gt; &#123;  // 如果是default，那么需要解构重命名</span></span><br><span class="line">    </span><br><span class="line">  <span class="built_in">module</span>.loadPageInto(main); <span class="comment">// module.default来使用默认导出</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    main.textContent = err.message;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想同时加载多个模块，可以采用下面的写法。</span></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module1.js&#x27;</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module2.js&#x27;</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module3.js&#x27;</span>),</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</span><br><span class="line">   ···</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是Promise对象，所以也可以用在async函数中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [module1, module2, module3] =</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module1.js&#x27;</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module2.js&#x27;</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module3.js&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p><h5 id="3-适用场合"><a href="#3-适用场合" class="headerlink" title="3. 适用场合"></a>3. 适用场合</h5><ul><li><p>按需加载。</p><p><code>import()</code>可以在需要的时候，再加载某个模块。比如放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p></li><li><p>条件加载</p><p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p></li><li><p>动态的模块路径</p><p><code>import()</code>允许模块路径动态生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(f()).then(...);  <span class="comment">// 根据函数`f`的返回结果，加载不同的模块。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-7-应用-公共头文件"><a href="#4-2-7-应用-公共头文件" class="headerlink" title="4.2.7 应用: 公共头文件"></a>4.2.7 应用: 公共头文件</h4><p>介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">  url: <span class="string">&#x27;http://my.couchdbserver.local:5984&#x27;</span>,</span><br><span class="line">  admin_username: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">  admin_password: <span class="string">&#x27;admin password&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constants/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> users = [<span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;staff&#x27;</span>, <span class="string">&#x27;ceo&#x27;</span>, <span class="string">&#x27;chief&#x27;</span>, <span class="string">&#x27;moderator&#x27;</span>];</span><br></pre></td></tr></table></figure><p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/index.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">&#x27;./db&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;users&#125; <span class="keyword">from</span> <span class="string">&#x27;./users&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用的时候，直接加载<code>index.js</code>就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;db, users&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants/index.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-2-8-与CommonJS模块化的差异"><a href="#4-2-8-与CommonJS模块化的差异" class="headerlink" title="4.2.8 与CommonJS模块化的差异"></a>4.2.8 与CommonJS模块化的差异</h4><ul><li><p>CommonJS 模块输出的是一个值的拷贝(module.exports的浅拷贝)，ES6 模块输出的是值的引用。</p></li><li><p>CommonJS 模块是运行时加载，ES6 模块是编译(解析)时加载。</p><ul><li><p>运行时加载意味着是js引擎在 执行js代码的过程中 加载模块；所以require可以与变量、表达式等运行时代码结合使用</p></li><li><p>编译时（解析）时加载，意味着import不能和运行时相关的内容放在一起使用：</p><ul><li>比如from后面的路径需要动态获取；</li><li>比如不能将import放到if等语句的代码块中；</li><li>所以我们有时候也称ES Module是静态解析的，而不是动态或者运行时解析的；</li></ul></li></ul></li><li><p>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</p><ul><li>同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行；</li><li>异步的意味着：不会阻塞主线程继续执行；<ul><li>JS引擎在遇到<code>import</code>时会去获取这个js文件的过程是异步的</li><li>设置了 <code>type=module</code> 的script标签，相当于加上了 <code>async</code> 属性；</li><li>如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行；</li></ul></li></ul></li></ul><p>CommonJS代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;main代码执行&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="comment">// 同步加载foo文件，并且执行一次内部的代码</span></span><br><span class="line">  <span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;if语句继续执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES Module代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个js文件的代码不会被阻塞执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、CommonJS模块与ES6模块的混编"><a href="#四、CommonJS模块与ES6模块的混编" class="headerlink" title="四、CommonJS模块与ES6模块的混编"></a>四、CommonJS模块与ES6模块的混编</h2><h3 id="4-3-CommonJS模块加载ES6模块"><a href="#4-3-CommonJS模块加载ES6模块" class="headerlink" title="4.3 CommonJS模块加载ES6模块"></a>4.3 CommonJS模块加载ES6模块</h3><p>通常情况下，CommonJS不能加载ES Module</p><ul><li>因为CommonJS是同步加载的，但是ES Module必须经过静态分析等，无法在这个时候执行JavaScript代码；</li><li>但是这个并非绝对的，某些平台在实现的时候可以对代码进行针对性的解析，也可能会支持；</li></ul><p>可以使用<code>import()</code>这个方法加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-app.mjs&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>上面代码可以在 CommonJS 模块中运行。</p><p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p><h3 id="4-2-ES6模块加载CommonJS模块"><a href="#4-2-ES6模块加载CommonJS模块" class="headerlink" title="4.2 ES6模块加载CommonJS模块"></a>4.2 ES6模块加载CommonJS模块</h3><p>多数情况下，ES Module可以加载CommonJS，但是只能整体加载，不能只加载单一的输出项。</p><ul><li>ES Module在加载CommonJS时，会将其module.exports导出的内容作为default导出方式来使用；</li><li>这个依然需要看具体的实现，比如webpack中是支持的、Node最新的Current（v14.13.1）版本也是支持的；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">const</span> address = <span class="string">&#x27;foo的address&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.address);</span><br></pre></td></tr></table></figure><p>还有一种变通的加载方法，就是使用 Node.js 内置的<code>module.createRequire()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cjs.cjs</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">&#x27;cjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// esm.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = createRequire(<span class="keyword">import</span>.meta.url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cjs = <span class="built_in">require</span>(<span class="string">&#x27;./cjs.cjs&#x27;</span>);</span><br><span class="line">cjs === <span class="string">&#x27;cjs&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。</p><h3 id="4-3-使模块同时支持两种模块化导入"><a href="#4-3-使模块同时支持两种模块化导入" class="headerlink" title="4.3 使模块同时支持两种模块化导入"></a>4.3 使模块同时支持两种模块化导入</h3><p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p><p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p><p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">&#x27;../index.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = cjsModule.foo;</span><br></pre></td></tr></table></figure><p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p><p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>&#123; type: &quot;module&quot; &#125;</code>。</p><p>如果是Node.js中，还有一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;exports&quot;</span>：&#123;</span><br><span class="line">  <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./index.js&quot;</span>，</span><br><span class="line">  <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./esm/wrapper.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p><h2 id="五、Node-js开发中的模块化"><a href="#五、Node-js开发中的模块化" class="headerlink" title="五、Node.js开发中的模块化"></a>五、Node.js开发中的模块化</h2><h3 id="5-1-Node中支持-ES6-Module"><a href="#5-1-Node中支持-ES6-Module" class="headerlink" title="5.1 Node中支持 ES6 Module"></a>5.1 Node中支持 ES6 Module</h3><p>JavaScript 现在常用的有两种模块。</p><ul><li>ES6 模块，简称 ESM；</li><li>CommonJS 模块，简称 CJS。</li></ul><p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p><p>从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持，需要进行以下操作：</p><ul><li>方式一：文件以 <code>.mjs</code> 结尾，表示使用的是ES Module；</li><li>方式二：在package.json中配置字段 <code>type: module</code>，一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。<ul><li>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。</li></ul></li><li>如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</li></ul><p>在之前的版本（比如v12.19.0）中，也是可以正常运行的，但是会报一个警告：</p><img src="/images/webmodule/lstwarning.jpg" alt="图片" style="zoom:80%;" /><p>Node.js 遇到 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p><p>总结为一句话：</p><ul><li><code>.mjs</code>文件总是以 ES6 模块加载</li><li><code>.cjs</code>文件总是以 CommonJS 模块加载</li><li><code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。</li></ul><p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p><h3 id="5-2-Node-js包模块的入口文件设置"><a href="#5-2-Node-js包模块的入口文件设置" class="headerlink" title="5.2 Node.js包模块的入口文件设置"></a>5.2 Node.js包模块的入口文件设置</h3><h4 id="5-2-1-package-json-的-main-字段"><a href="#5-2-1-package-json-的-main-字段" class="headerlink" title="5.2.1 package.json 的 main 字段"></a>5.2.1 package.json 的 main 字段</h4><p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，可以只使用<code>main</code>字段，指定模块加载的入口文件。</p><h5 id="举例：指定入口文件，格式为ESM"><a href="#举例：指定入口文件，格式为ESM" class="headerlink" title="举例：指定入口文件，格式为ESM"></a>举例：指定入口文件，格式为ESM</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有<code>type</code>字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p><p>然后，<code>import</code>命令就可以加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./my-app.mjs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;es-module-package&#x27;</span>;</span><br><span class="line"><span class="comment">// 实际加载的是 ./node_modules/es-module-package/src/index.js</span></span><br></pre></td></tr></table></figure><p>上面代码中，运行该脚本以后，Node.js 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p><p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p><h4 id="5-2-2-package-json-的-exports-字段"><a href="#5-2-2-package-json-的-exports-字段" class="headerlink" title="5.2.2 package.json 的 exports 字段"></a>5.2.2 package.json 的 exports 字段</h4><p><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</p><h5 id="1-给脚本或子目录起别名"><a href="#1-给脚本或子目录起别名" class="headerlink" title="1. 给脚本或子目录起别名"></a>1. 给脚本或子目录起别名</h5><p><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./submodule&quot;</span>: <span class="string">&quot;./src/submodule.js&quot;</span>,  <span class="comment">//给脚本文件 src/submodule.js 起别名</span></span><br><span class="line">    <span class="string">&quot;./features/&quot;</span>: <span class="string">&quot;./src/features/&quot;</span>，<span class="comment">// 给子目录 ./src/features/ 起别名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过别名加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/submodule&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/submodule.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feature <span class="keyword">from</span> <span class="string">&#x27;es-module-package/features/x.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/features/x.js</span></span><br></pre></td></tr></table></figure><p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/private-module.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;./node_modules/es-module-package/private-module.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="2-main-的别名"><a href="#2-main-的别名" class="headerlink" title="2. main 的别名."></a>2. main 的别名<code>.</code></h5><p><code>exports</code>字段的别名如果是<code>.</code> 就代表了是模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./main-legacy.cjs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main-modern.cjs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p><h5 id="3-条件加载"><a href="#3-条件加载" class="headerlink" title="3. 条件加载"></a>3. 条件加载</h5><p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开<code>--experimental-conditional-exports</code>标志。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>, <span class="comment">// 别名`.`的`require`条件指定`require()`命令的入口文件（即 CommonJS 的入口）</span></span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span> <span class="comment">// 别名`.`的`default`条件指定其他情况的入口（即 ES6 的入口）。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法可以简写如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果同时还有其他别名，就不能采用简写，否则或报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./feature&quot;</span>: <span class="string">&quot;./lib/feature.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-Node-js原生模块完全支持ES6-Module"><a href="#5-3-Node-js原生模块完全支持ES6-Module" class="headerlink" title="5.3 Node.js原生模块完全支持ES6 Module"></a>5.3 Node.js原生模块完全支持ES6 Module</h3><p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体加载</span></span><br><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">&#x27;events&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定的输出项</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line">readFile(<span class="string">&#x27;./foo.txt&#x27;</span>, <span class="function">(<span class="params">err, source</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-4-加载路径"><a href="#5-4-加载路径" class="headerlink" title="5.4 加载路径"></a>5.4 加载路径</h3><p>ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 模块中将报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span>;</span><br></pre></td></tr></table></figure><p>为了与浏览器的<code>import</code>加载规则相同，Node.js 的<code>.mjs</code>文件支持 URL 路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo.mjs?query=1&#x27;</span>; <span class="comment">// 加载 ./foo 传入参数 ?query=1</span></span><br></pre></td></tr></table></figure><p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p><p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议）和<code>data:</code>协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以<code>/</code>或<code>//</code>开头的路径）。</p><h3 id="5-5-内部变量"><a href="#5-5-内部变量" class="headerlink" title="5.5 内部变量"></a>5.5 内部变量</h3><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p><p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p><p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p><ul><li><code>arguments</code></li><li><code>require</code></li><li><code>module</code></li><li><code>exports</code></li><li><code>__filename</code></li><li><code>__dirname</code></li></ul><h2 id="六、循环加载"><a href="#六、循环加载" class="headerlink" title="六、循环加载"></a>六、循环加载</h2><p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p><p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p><p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p><h3 id="6-1-CommonJS-模块的循环加载"><a href="#6-1-CommonJS-模块的循环加载" class="headerlink" title="6.1 CommonJS 模块的循环加载"></a>6.1 CommonJS 模块的循环加载</h3><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p><p>让我们来看，Node <a href="https://nodejs.org/api/modules.html#modules_cycles">官方文档</a>里面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;   <span class="comment">// 先输出一个`done`变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>); <span class="comment">// 然后加载另一个脚本文件b.js。注意，此时代码就停在这里，等待`b.js`执行完毕，再往下执行。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.done); <span class="comment">// b.js执行完毕，返回来a.js接着往下执行，直到执行完毕。</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.js 执行完毕&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 执行到这一行，会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。</span></span><br><span class="line"><span class="comment"> 此时：a.js已经执行的部分，只有一行：exports.done = false; 即对于b.js来说，它从a.js只输入一个变量done=false 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.done);</span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.js 执行完毕&#x27;</span>);</span><br><span class="line"><span class="comment">// b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。</span></span><br></pre></td></tr></table></figure><p>我们写一个脚本main.js，验证这个过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.done, b.done);</span><br></pre></td></tr></table></figure><p>执行<code>main.js</code>，运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line">在 b.js 之中，a.done = <span class="literal">false</span></span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 之中，b.done = <span class="literal">true</span></span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done=<span class="literal">true</span>, b.done=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面的代码证明了两件事：</p><ol><li>在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。</li><li><code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行<code>exports.done = true;</code></li></ol><p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</p><p>另外，<strong>由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 安全的写法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>).foo; <span class="comment">// 危险的写法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.good = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.foo(<span class="string">&#x27;good&#x27;</span>, arg); <span class="comment">// 使用的是 a.foo 的最新值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.bad = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(<span class="string">&#x27;bad&#x27;</span>, arg); <span class="comment">// 使用的是一个部分加载时的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p><h3 id="6-2-ES6-模块的循环加载"><a href="#6-2-ES6-模块的循环加载" class="headerlink" title="6.2 ES6 模块的循环加载"></a>6.2 ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p><p>请看下面这个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p><p>让我们一行行来看，ES6 循环加载是怎么处理的：</p><ul><li>首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。</li><li>接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。</li><li>执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</li></ul><p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span> &#125;   <span class="comment">// const foo = () =&gt; &#x27;foo&#x27;; 仍然会执行报错。函数表达式，就不具有提升作用</span></span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;bar&#125;;</span><br></pre></td></tr></table></figure><p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">foo</span><br><span class="line">a.mjs</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>这是因为<strong>函数具有提升作用</strong>，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。</p><p>这也意味着，<strong>如果把函数<code>foo</code>改写成函数表达式，也会报错。</strong></p><h3 id="6-3-代码示例"><a href="#6-3-代码示例" class="headerlink" title="6.3 代码示例"></a>6.3 代码示例</h3><p>我们再来看 ES6 模块加载器<a href="https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md">SystemJS</a>给出的一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">&#x27;./odd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">&#x27;./even&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p><p>运行上面这段代码，结果如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node</span><br><span class="line">&gt; <span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./even.js&#x27;</span>;</span><br><span class="line">&gt; m.even(<span class="number">10</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; m.even(<span class="number">20</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。</p><p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">&#x27;./odd&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.counter = counter;</span><br><span class="line"><span class="built_in">exports</span>.even = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">&#x27;./even&#x27;</span>).even;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var m = require(<span class="string">&#x27;./even&#x27;</span>);</span><br><span class="line">&gt; m.even(10)</span><br><span class="line">TypeError: even is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><h2 id="七、了解：AMD和CMD规范"><a href="#七、了解：AMD和CMD规范" class="headerlink" title="七、了解：AMD和CMD规范"></a>七、了解：AMD和CMD规范</h2><h3 id="7-1-CommonJS规范缺点"><a href="#7-1-CommonJS规范缺点" class="headerlink" title="7.1. CommonJS规范缺点"></a>7.1. CommonJS规范缺点</h3><p>CommonJS加载模块是同步的：</p><ul><li>同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行；</li><li>这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快；</li></ul><p>如果将它应用于浏览器呢？</p><ul><li>浏览器加载js文件需要先从服务器将文件下载下来，之后在加载运行；</li><li>那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作；</li></ul><p>所以在浏览器中，我们通常不使用CommonJS规范：</p><ul><li>当然在webpack中使用CommonJS是另外一回事；</li><li>因为它会将我们的代码转成浏览器可以直接执行的代码；</li></ul><p>在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD：</p><ul><li>但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换；</li><li>AMD和CMD已经使用非常少了，所以这里我们进行简单的演练；</li></ul><h3 id="7-2-AMD规范"><a href="#7-2-AMD规范" class="headerlink" title="7.2. AMD规范"></a>7.2. AMD规范</h3><h4 id="7-2-1-AMD与Require-js"><a href="#7-2-1-AMD与Require-js" class="headerlink" title="7.2.1 AMD与Require.js"></a>7.2.1 AMD与Require.js</h4><p>AMD主要是应用于浏览器的一种模块化规范：</p><ul><li>AMD是Asynchronous Module Definition（异步模块定义）的缩写；</li><li>它采用的是异步加载模块；</li><li>事实上AMD的规范还要早于CommonJS，但是CommonJS目前依然在被使用，而AMD使用的较少了；</li></ul><p>我们提到过，规范只是定义代码的应该如何去编写，只有有了具体的实现才能被应用：</p><ul><li>AMD实现的比较常用的库是require.js和curl.js；</li></ul><h4 id="7-2-2-Require-js的使用"><a href="#7-2-2-Require-js的使用" class="headerlink" title="7.2.2 Require.js的使用"></a>7.2.2 Require.js的使用</h4><p>第一步：下载require.js</p><ul><li>下载地址：<a href="https://github.com/requirejs/requirejs">https://github.com/requirejs/requirejs</a></li><li>找到其中的require.js文件； </li></ul><p>第二步：定义HTML的script标签引入require.js和定义入口文件：</p><ul><li>data-main属性的作用是在加载完src的文件后会加载执行该文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/require.js&quot;</span> <span class="attr">data-main</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三步：编写如下目录和代码(<strong>个人习惯</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">├── lib</span><br><span class="line">│   └── require.js</span><br><span class="line">└── modules</span><br><span class="line">    ├── bar.js</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">      foo: <span class="string">&#x27;./modules/foo&#x27;</span>,</span><br><span class="line">      bar: <span class="string">&#x27;./modules/bar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 开始加载执行foo模块的代码</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;foo&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>modules/bar.js</p><ul><li>如果一个模块不依赖其他，那么直接使用define(function)即可</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;coderwhy&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age, </span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>modules/foo.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">&#x27;bar&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar.name);</span><br><span class="line">  <span class="built_in">console</span>.log(bar.age);</span><br><span class="line">  bar.sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-3-CMD规范"><a href="#7-3-CMD规范" class="headerlink" title="7.3 CMD规范"></a>7.3 CMD规范</h3><h4 id="7-3-1-CMD与SeaJS"><a href="#7-3-1-CMD与SeaJS" class="headerlink" title="7.3.1 CMD与SeaJS"></a>7.3.1 CMD与SeaJS</h4><p>CMD规范也是应用于浏览器的一种模块化规范：</p><ul><li>CMD 是Common Module Definition（通用模块定义）的缩写；</li><li>它也采用了异步加载模块，但是它将CommonJS的优点吸收了过来；</li><li>但是目前CMD使用也非常少了；</li></ul><p>CMD也有自己比较优秀的实现方案：</p><ul><li>SeaJS</li></ul><h4 id="7-3-2-SeaJS的使用"><a href="#7-3-2-SeaJS的使用" class="headerlink" title="7.3.2 SeaJS的使用"></a>7.3.2 SeaJS的使用</h4><h5 id="1-下载SeaJS"><a href="#1-下载SeaJS" class="headerlink" title="1. 下载SeaJS"></a>1. 下载SeaJS</h5><ul><li>下载地址：<a href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li><li>找到dist文件夹下的sea.js</li></ul><h5 id="2-引入sea-js和启动模块"><a href="#2-引入sea-js和启动模块" class="headerlink" title="2. 引入sea.js和启动模块"></a>2. 引入sea.js和启动模块</h5><ul><li><code>seajs</code>是指定主入口文件的，也称为启动模块</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!--在调用 seajs 之前，必须先引入 sea.js 文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  seajs.use(<span class="string">&#x27;./index.js&#x27;</span>);  </span></span><br><span class="line">  /*</span><br><span class="line">   通过 seajs.use() 函数可以启动模块</span><br><span class="line"><span class="javascript">- (<span class="string">&#x27;模块id&#x27;</span> [,callback])加载一个模块，并执行回调函数</span></span><br><span class="line"><span class="javascript">- ([<span class="string">&#x27;模块1&#x27;</span>, <span class="string">&#x27;模块2&#x27;</span>] [,callback])加载多个模块，并执行回调函数</span></span><br><span class="line"><span class="javascript">- callback 参数是可选的。格式为：<span class="function"><span class="keyword">function</span>(<span class="params"> 模块对象 </span>)</span>&#123; 业务代码 &#125;;</span></span><br><span class="line"></span><br><span class="line"> - seajs.use 理论上只用于加载启动，不应该出现在 define 中的模块代码里</span><br><span class="line"><span class="javascript"> - seajs.use 和 DOM ready 事件没有任何关系。要想保证 文档结构加载完毕再执行你的 js 代码，一定要在seajs.use内部通过 <span class="built_in">window</span>.onload 或者 $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span></span><br><span class="line">   */</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-编写如下目录和代码-个人习惯"><a href="#3-编写如下目录和代码-个人习惯" class="headerlink" title="3. 编写如下目录和代码(个人习惯)"></a>3. 编写如下目录和代码(<strong>个人习惯</strong>)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">├── lib</span><br><span class="line">│   └── sea.js</span><br><span class="line">└── modules</span><br><span class="line">    ├── bar.js</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><h5 id="4-定义模块define"><a href="#4-定义模块define" class="headerlink" title="4. 定义模块define"></a>4. 定义模块define</h5><ul><li>在CMD规范中，一个模块就是一个js文件</li></ul><p>module是一个对象，存储了模块的元信息，具体如下：</p><ul><li><p>module.id——模块的ID。</p></li><li><p>module.dependencies——一个数组，存储了此模块依赖的所有模块的ID列表。</p></li><li><p>module.exports——与exports指向同一个对象。</p></li><li><p>module.uri</p></li></ul><p>define 是一个全局函数，用来定义模块：<code>define( factory )</code></p><ul><li>对象<code>&#123;&#125;</code>：这种方式，外部会直接获取到该对象</li><li>字符串<code>&quot;&quot;</code>： 同上</li><li>函数：<code>define(function(require, exports, module)&#123; 模块代码 &#125;);</code>  为了减少出错，定义函数的时候直接把这三个参数写上</li></ul><h5 id="5-导出接口exports和module-exports"><a href="#5-导出接口exports和module-exports" class="headerlink" title="5. 导出接口exports和module.exports"></a>5. 导出接口exports和module.exports</h5><ul><li><p>功能：通过给 exports或module.exports动态的挂载变量、函数或对象，外部会获取到该接口</p></li><li><p>exports 等价于 module.exports。exports能做什么，module.exports就能做什么</p></li><li><p>可以通过多次给exports 挂载属性向外暴露</p></li><li><p>不能直接给 exports 赋值</p></li><li><p>如果想暴露单个变量、函数或对象可以通过直接给 module.exports 赋值 即可</p></li></ul><h5 id="6-依赖模块require"><a href="#6-依赖模块require" class="headerlink" title="6. 依赖模块require"></a>6. 依赖模块require</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 模块标识/模块id</span></span><br><span class="line"><span class="comment">    - 模块标识就是一个`字符串`，用来`标识模块`</span></span><br><span class="line"><span class="comment">    - 模块标识 可以不包含后缀名.js</span></span><br><span class="line"><span class="comment">    - 以 ./或 ../ 开头的相对路径模块，相对于 require 所在模块的路径</span></span><br><span class="line"><span class="comment">    - 不以 ./ 或 ../ 开头的顶级标识，会相对于模块的基础路径解析（配置项中的base）</span></span><br><span class="line"><span class="comment">    - 绝对路径如http://127.0.0.1:8080/js/a.js、/js/a.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">requeire(<span class="string">&#x27;模块id&#x27;</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1.用于根据一个模块id加载/依赖该模块</span></span><br><span class="line"><span class="comment"> 2.参数必须是一个字符串</span></span><br><span class="line"><span class="comment"> 3.该方法会得到 要加载的模块中的 module.exports 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>只能在模块环境define中使用，define(factory)的构造方法第一个参数<strong>必须命名为 require</strong></li><li>不要重命名require函数或者在任何作用域中给 require 重新赋值</li><li>在一个模块系统中，<code>require</code> 加载过的模块会被缓存</li><li>默认 <code>require</code> 是同步加载模块的</li></ul><p><strong>require.async</strong></p><p>SeaJS会在html页面打开时通过静态分析一次性记载所有需要的js文件，如果想要某个js文件在用到时才下载，可以使用require.async：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.async(<span class="string">&#x27;/path/to/module/file&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code of callback...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样只有在用到这个模块时，对应的js文件才会被下载，也就实现了JavaScript代码的按需加载。</p><h5 id="SeaJS高级配置"><a href="#SeaJS高级配置" class="headerlink" title="SeaJS高级配置"></a>SeaJS高级配置</h5><ul><li><strong>alias：别名配置</strong></li><li><strong>paths：路径配置</strong></li><li>vars：变量配置</li><li>map：映射配置</li><li>preload：预加载项</li><li>debug：调试模式</li><li><strong>base：基础路径</strong></li><li>charset：文件编码</li></ul><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./modules/foo&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>bar.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;lilei&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;你好 &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>foo.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(bar.name);</span><br><span class="line">  <span class="built_in">console</span>.log(bar.age);</span><br><span class="line">  bar.sayHello(<span class="string">&quot;韩梅梅&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul><li><p><a href="https://es6.ruanyifeng.com/#docs/module">Module的语法和加载实现 — 阮一峰</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDAzNzkwNA==&mid=2247484285&idx=1&sn=bc37c00b5c58ff42355b1b01ad9b9c0d&chksm=cfe3f082f8947994b5475d365c4460ac0d4b36d6eec68b5dd7c15fc3a0ef1b88f33b776f3f05&scene=178&cur_album_id=1567316742547226629#rd">彻底掌握前端模块化 — codewhy</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、模块化&quot;&gt;&lt;a href=&quot;#一、模块化&quot; class=&quot;headerlink&quot; title=&quot;一、模块化&quot;&gt;&lt;/a&gt;一、模块化&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是模块化&quot;&gt;&lt;a href=&quot;#1-1-什么是模块化&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Web" scheme="https://tenloy.github.io/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>[转]最通俗的 React Fiber(时间分片)</title>
    <link href="https://tenloy.github.io/2021/05/27/09_Fiber/"/>
    <id>https://tenloy.github.io/2021/05/27/09_Fiber/</id>
    <published>2021-05-27T16:51:02.000Z</published>
    <updated>2021-07-03T15:03:45.157Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903975112671239#heading-13">原文链接</a> Fiber 不是一个新的东西，来看一下单处理进程调度</p><h2 id="一、单处理器进程调度"><a href="#一、单处理器进程调度" class="headerlink" title="一、单处理器进程调度"></a>一、单处理器进程调度</h2><img width = "60%" alt="" align=center src="/images/Fiber/16deecc2160c5d19.jpg"/><p>微软 <a href="https://zh.wikipedia.org/zh-cn/DOS"><code>DOS</code></a> 是一个<code>单任务操作系统</code>， 也称为’单工操作系统‘。这种操作系统同一个时间只允许运行一个程序。 <a href="https://www.zhihu.com/people/s.invalid">invalid s</a>在<a href="https://www.zhihu.com/question/319595914/answer/683541635">《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》</a> 的回答中将其称为： ‘<strong>一种压根没有任务调度的“残疾”操作系统</strong>‘.</p><p>在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。</p><p>直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。</p><blockquote><p>注意并发和并行不是同一个概念。</p></blockquote><h3 id="1-1-并发与并行"><a href="#1-1-并发与并行" class="headerlink" title="1.1 并发与并行"></a>1.1 并发与并行</h3><p>现代操作系统都是<strong>多任务操作系统</strong>。进程的调度策略如果按照CPU核心数来划分，可以分为<strong>单处理器调度</strong>和<strong>多处理器调度</strong>。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。</p><p><strong>说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行</strong>。</p><ul><li><p>“龙珠”中的分身术，实质上是一个人，只不过是他运动速度太快，看起来就像分身了。这就是所谓的<strong>并发(Concurrent)</strong>(单处理器)。</p></li><li><p>相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是<strong>并行</strong>(严格地讲这是<code>Master-Slave</code>架构，分身虽然物理存在，但应该没有独立的意志)。</p></li></ul><p>所以说<strong>并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持</strong>。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲<a href="https://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not parallelism</a></p><h3 id="1-2-进程调度策略"><a href="#1-2-进程调度策略" class="headerlink" title="1.2 进程调度策略"></a>1.2 进程调度策略</h3><h4 id="1-2-1-先到先得-First-Come-First-Served-FCFS"><a href="#1-2-1-先到先得-First-Come-First-Served-FCFS" class="headerlink" title="1.2.1 先到先得(First-Come-First-Served, FCFS)"></a>1.2.1 先到先得(First-Come-First-Served, FCFS)</h4><p>这是最简单的调度策略, 简单说就是<strong>没有调度</strong>。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队)。</p><p><code>FCFS</code> 上面 <code>DOS</code> 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。</p><ul><li><p><strong>FCFS 对<code>短进程</code>不利</strong>。 短进程即执行时间非常短的进程。</p><p>举例：可以用饭堂排队来比喻: 在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像<code>长进程</code>一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久…</p></li><li><p><strong>FCFS 对<code>I/O密集</code>不利</strong>。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被选择。 </p><p>举例：ZF部门办业务: 假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平…</p></li></ul><p>所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。</p><h4 id="1-2-2-轮转"><a href="#1-2-2-轮转" class="headerlink" title="1.2.2 轮转"></a>1.2.2 轮转</h4><p>这是一种基于时钟的<strong>抢占策略</strong>，这也是抢占策略中最简单的一种: <strong>公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来</strong>。</p><blockquote><p><strong>决策模式</strong>: <code>抢占策略</code>相对应的有<code>非抢占策略</code>，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。</p></blockquote><p>这种调度策略的要点是<strong>确定合适的时间片长度</strong>: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 <code>FCFS</code> 没什么区别了;  太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。</p><p>因此<strong>时间片的长度最好符合大部分进程完成一次典型交互所需的时间</strong>。</p><p>轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和<code>FCFS</code>一样，轮转策略对I/O进程还是不公平。</p><h4 id="1-2-3-最短进程优先-Shortest-Process-Next-SPN"><a href="#1-2-3-最短进程优先-Shortest-Process-Next-SPN" class="headerlink" title="1.2.3 最短进程优先(Shortest Process Next, SPN)"></a>1.2.3 最短进程优先(Shortest Process Next, SPN)</h4><p>上面说了<code>先到先得</code>策略对<code>短进程</code>不公平，<code>最短进程优先</code>索性就让’最短’的进程优先执行，也就是说: <strong>按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略</strong>。</p><p>这样可以让短进程能得到较快的响应。但是怎么获取或者<strong>评估进程执行时间</strong>呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。</p><p><code>SPN</code> 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。</p><p>另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 <code>FCFS</code> 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。</p><h4 id="1-2-4-最短剩余时间-Shortest-Remaining-Time-SRT"><a href="#1-2-4-最短剩余时间-Shortest-Remaining-Time-SRT" class="headerlink" title="1.2.4 最短剩余时间(Shortest Remaining Time, SRT)"></a>1.2.4 最短剩余时间(Shortest Remaining Time, SRT)</h4><p><strong>SRT 进一步优化了SPN，增加了抢占机制</strong>。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较<em>刚添加的新进程</em>和<em>当前正在执行的老进程</em>的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。</p><p>相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。<strong>另外长进程饥饿问题还是没有解决</strong>。</p><h4 id="1-2-5-最高响应比优先-HRRN"><a href="#1-2-5-最高响应比优先-HRRN" class="headerlink" title="1.2.5 最高响应比优先(HRRN)"></a>1.2.5 最高响应比优先(HRRN)</h4><p><strong>为了解决长进程饥饿问题，同时提高进程的响应速率</strong>。还有一种<code>最高响应比优先的</code>策略，首先了解什么是响应比:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应比 &#x3D; （等待执行时间 + 进程执行时间） &#x2F; 进程执行时间</span><br></pre></td></tr></table></figure><p><strong>这种策略会选择响应比最高的进程优先执行</strong>：</p><ul><li>对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行</li><li>对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行</li></ul><h4 id="1-2-6-反馈法"><a href="#1-2-6-反馈法" class="headerlink" title="1.2.6 反馈法"></a>1.2.6 反馈法</h4><p>SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是<strong>事后反馈</strong>的方式。这种策略下: <strong>每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列</strong>。</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">队列1</span><br><span class="line">队列2</span><br><span class="line">...</span><br><span class="line">队列N</span><br></pre></td></tr></table></figure><p>新增的任务会推入<code>队列1</code>，<code>队列1</code>会按照<code>轮转策略</code>以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入<code>队列2</code>。</p><p><code>队列2</code>会在<code>队列1</code>任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以<code>队列2</code>的轮转时间片长度是2。</p><p>反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。</p><img width = "80%" alt="" align=center src="/images/Fiber/16deecc24dfd080c.png"/><p>没有一种调度策略是万能的, 它需要考虑很多因素:</p><ul><li>响应速率。进程等待被执行的时间</li><li>公平性。兼顾短进程、长进程、I/O进程</li></ul><p>这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。</p><p>上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 <code>Linux</code> 相关的进程调度算法，这方面的资料也非常多, 例如<a href="https://blog.csdn.net/gatieme/article/details/51456569">《Linux进程调度策略的发展和演变》</a>。</p><h2 id="二、浏览器JavaScript执行环境"><a href="#二、浏览器JavaScript执行环境" class="headerlink" title="二、浏览器JavaScript执行环境"></a>二、浏览器JavaScript执行环境</h2><p>JavaScript 是<a href="https://juejin.im/post/6844903553795014663">单线程运行</a>的(就像单行道)，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。</p><blockquote><p>这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个<code>渲染线程</code>，GUI 渲染和 Javascript执行 两者是互斥的。 另外异步 I/O 操作底层实际上可能是多线程的在驱动。</p></blockquote><img width = "65%" alt="" align=center src="/images/Fiber/16deecc35b99001e.jpg"/><p><em>图片来源: <a href="https://developers.google.com/web/fundamentals/performance/rendering">Rendering Performance</a></em></p><p><strong>它只是一个’JavaScript’，同时只能做一件事情，这个和 <code>DOS</code> 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差</strong>。</p><p><strong>对于’前端框架‘来说，解决这种问题有三个方向</strong>:</p><ol><li>优化每个任务，让它有多快就多快。挤压CPU运算量</li><li>快速响应用户，让用户觉得够快，不能阻塞用户的交互</li><li>尝试 Worker 多线程</li></ol><p>Vue 选择的是第1种, 因为对于Vue来说，使用<code>模板</code>让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下<a href="https://www.yuque.com/vueconf/2019/gwn1z0">今年Vue Conf 尤雨溪的演讲</a>，非常棒!；而 React 选择了2种。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。</p><p>React 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, **在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 <code>Reconcilation</code>(中文可以译为<code>协调</code>)**。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc366f124be.png"/><p>在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。</p><p>这样说，你可能没办法体会到，通过下面两个图片来体会一下(<em>图片来源于：<a href="https://twitter.com/dan_abramov">Dan Abramov</a> 的 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 1</a> 演讲, 推荐看一下👍. 另外非常感谢<a href="https://www.zhihu.com/people/BlackGanglion/activities">淡苍</a> 将一个<a href="https://codesandbox.io/s/koyz664q35">类似的DEMO 分享在了 CodeSandbox</a>上🎉，大家自行体验</em>):</p><p>同步模式下的 React:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc3acaf5689.gif" /><p>优化后的 <code>Concurrent</code> 模式下的 React:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc385cc0286.gif" /><p>React 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。</p><p>所以React 是怎么优化的？ 划重点， <strong>为了给用户制造一种应用很快的’假象’，我们不能让一个程序长期霸占着资源。 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的’进程’，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率</strong>。</p><p><strong>所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处</strong>:</p><ul><li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在<a href="https://juejin.im/post/6844903938894872589#heading-1">《「前端进阶」高性能渲染十万条数据(时间分片)》</a> 以及司徒正美的<a href="https://zhuanlan.zhihu.com/p/37095662">《React Fiber架构》</a> 都做了相关实验</li><li>司徒正美在<a href="https://zhuanlan.zhihu.com/p/37095662">《React Fiber架构》</a> 也提到：<strong>给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</strong>。</li></ul><p>这就是为什么React 需要 Fiber 。</p><h2 id="三、何为-Fiber"><a href="#三、何为-Fiber" class="headerlink" title="三、何为 Fiber"></a>三、何为 Fiber</h2><p>对于 React 来说，Fiber 可以从两个角度理解:</p><h3 id="1-一种流程控制原语"><a href="#1-一种流程控制原语" class="headerlink" title="1. 一种流程控制原语"></a>1. 一种流程控制原语</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Fiber 也称<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程</a>、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的<code>Coroutine</code>, 还有前端开发者比较熟悉的 <code>ES6</code> 新增的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator"><code>Generator</code></a>。</p><p><strong>其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制</strong>。要理解协程，你得和普通函数一起来看, 以Generator为例:</p><p>普通函数执行的过程中无法<strong>被中断和恢复</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>Generator</code> 可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    <span class="comment">// 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权</span></span><br><span class="line">    <span class="keyword">if</span> (hasHighPriorityEvent()) &#123;</span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完高优先级事件后，恢复函数调用栈，继续执行...</span></span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React Fiber 的思想和协程的概念是契合的: <strong>React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>浏览器没有抢占的条件, 所以React只能用让出机制?</p><p><strong>答: 没错, 主动让出机制</strong></p><p>一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。</p><p>所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：<a href="https://juejin.im/post/6844903874692661255#heading-7"><strong>合作式调度(Cooperative Scheduling)</strong></a>, 相对应的有<strong>抢占式调度(Preemptive Scheduling)</strong></p><p><strong>这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任</strong>。比如可以由浏览器给我们分配执行时间片(通过<code>requestIdleCallback</code>实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p><img width = "80%" alt="" align=center src="/images/Fiber/16deecc37fdd60d7.png"/><p>这种调度方式很有趣，你会发现<strong>这是一种身份的对调</strong>，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。</p><p>当然你超时不还浏览器也拿你没办法 … 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。</p><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>怎么确定有高优先任务要处理，即什么时候让出？</p><p><strong>答: requestIdleCallback API</strong></p><p>上面代码示例中的 <code>hasHighPriorityEvent()</code> 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。</p><p>只能换一种思路，通过<strong>超时检查的机制来让出控制权</strong>。解决办法是: <em>确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器</em>。</p><p>举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。</p><p>其实浏览器提供了相关的接口 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback"><code>requestIdleCallback</code></a> API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.requestIdleCallback(</span><br><span class="line">  callback: (dealine: IdleDeadline) &#x3D;&gt; void,</span><br><span class="line">  option?: &#123;timeout: number&#125;</span><br><span class="line">  )</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>IdleDeadline</code>的接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IdleDealine &#123;</span><br><span class="line">  didTimeout: boolean &#x2F;&#x2F; 表示任务执行是否超过约定时间</span><br><span class="line">  timeRemaining(): DOMHighResTimeStamp &#x2F;&#x2F; 任务可供执行的剩余时间</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>单从名字上理解的话, <code>requestIdleCallback</code>的意思是<strong>让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕</strong>。</p><p><strong>那浏览器什么时候有空？</strong></p><p>我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecd81f16c6f2.png"/><p><em>你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。</em></p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc428fb4c0b.png"/><p><em>图片来源: <a href="https://juejin.im/post/6844903592831238157">你应该知道的requestIdleCallback</a></em></p><p>浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:</p><ul><li>处理用户输入事件</li><li>Javascript执行</li><li>requestAnimation 调用</li><li>布局 Layout</li><li>绘制 Paint</li></ul><p>上面说理想的一帧时间是 <code>16ms</code> (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 <code>requestIdleCallback</code> 的回调。例如</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc43c710e16.png"/><p><strong>但是在浏览器繁忙的时候，可能不会有盈余时间，这时候<code>requestIdleCallback</code>回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间</strong>。</p><blockquote><p>另外不建议在<code>requestIdleCallback</code>中进行<code>DOM</code>操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 <code>getBoundingClientRect</code>)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。</p></blockquote><p>目前 <code>requestIdleCallback</code> 目前只有Chrome支持。所以目前 React <a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js">自己实现了一个</a>。它利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel"><code>MessageChannel</code></a> 模拟将回调延迟到’绘制操作’之后执行:</p><img width = "100%" alt="" align=center src="/images/Fiber/16deecc5839a3974.png"/><p>简单看一下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ch = <span class="keyword">new</span> MessageChannel()</span><br><span class="line"><span class="keyword">let</span> pendingCallback</span><br><span class="line"><span class="keyword">let</span> startTime</span><br><span class="line"><span class="keyword">let</span> timeout</span><br><span class="line"></span><br><span class="line">ch.port2.onmessage = <span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="comment">// 在绘制之后被执行</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCallback) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = performance.now()</span><br><span class="line">    <span class="comment">// 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间</span></span><br><span class="line">    <span class="comment">// 通过这些数据来计算剩余时间</span></span><br><span class="line">    <span class="comment">// 另外还要处理超时(timeout)，避免任务被饿死</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasRemain &amp;&amp; noTimeout) &#123;</span><br><span class="line">      pendingCallback(deadline)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleRequestIdleCallback</span>(<span class="params">callback, timeout</span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在绘制之前被执行</span></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    startTime = performance.now()</span><br><span class="line">    timeout = timeout</span><br><span class="line">    dosomething()</span><br><span class="line">    <span class="comment">// 调度回调到绘制结束后执行</span></span><br><span class="line">    pendingCallback = callback</span><br><span class="line">    ch.port1.postMessage(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务优先级</strong></p><p>上面说了，为了避免任务被饿死，可以设置一个超时时间. <strong>这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行</strong>. 目前 React 预定义了 5 个优先级, 这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过:</p><ul><li><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li><li><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</li><li><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</li><li><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li><li><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</li></ul><h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><p>React 那为什么不使用 Generator？</p><p><strong>答: 太麻烦</strong></p><p>官方在<a href="https://github.com/facebook/react/issues/7942">《Fiber Principles: Contributing To Fiber》</a> 也作出了解答。主要有两个原因：</p><ol><li>Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。</li><li>Generator 是有状态的, 很难在中间恢复这些状态。</li></ol><blockquote><p>上面理解可能有出入，建议看一下原文</p></blockquote><p>可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。</p><h3 id="2-一个执行单元"><a href="#2-一个执行单元" class="headerlink" title="2. 一个执行单元"></a>2. 一个执行单元</h3><p>Fiber的另外一种解读是’纤维‘：<strong>这是一种数据结构或者说执行单元</strong>。我们暂且不管这个数据结构长什么样，<strong>将它视作一个执行单元，每次执行完一个’执行单元’,  React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</strong>.</p><p>上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：</p><p>假设用户调用 <code>setState</code> 更新组件, 这个待更新的任务会先放入队列中, 然后通过 <code>requestIdleCallback</code> 请求浏览器调度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">updateQueue.push(updateTask);</span><br><span class="line">requestIdleCallback(performWork, &#123;timeout&#125;);</span><br></pre></td></tr></table></figure><p>现在浏览器有空闲或者超时了就会调用<code>performWork</code>来执行任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. performWork 会拿到一个Deadline，表示剩余时间function performWork(deadline) &#123;  // 2. 循环取出updateQueue中的任务  while (updateQueue.length &gt; 0 &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;    workLoop(deadline);  &#125;  // 3. 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度  if (updateQueue.length &gt; 0) &#123;    requestIdleCallback(performWork);  &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>workLoop</code> 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘<code>执行单元</code>‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个<code>执行单元</code>，反之则停止执行，保存现场，等下一次有执行权时恢复</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前的处理现场</span></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork: Fiber | <span class="literal">undefined</span> <span class="comment">// 保存下一个需要处理的工作单元</span></span><br><span class="line"><span class="keyword">let</span> topWork: Fiber | <span class="literal">undefined</span>        <span class="comment">// 保存第一个工作单元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline: IdleDeadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span></span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork == <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = topWork = getNextUnitOfWork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 每执行完一个执行单元，检查一次剩余时间</span></span><br><span class="line">  <span class="comment">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    <span class="comment">// 下文我们再看performUnitOfWork</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交工作，下文会介绍</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCommit) &#123;</span><br><span class="line">    commitAllWork(pendingCommit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>画个流程图吧！</p><img width = "65%" alt="" align=center src="/images/Fiber/16deed1711f281b3.png"/><h2 id="四、React-的Fiber改造"><a href="#四、React-的Fiber改造" class="headerlink" title="四、React 的Fiber改造"></a>四、React 的Fiber改造</h2><p>Fiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。</p><h3 id="1-数据结构的调整"><a href="#1-数据结构的调整" class="headerlink" title="1. 数据结构的调整"></a>1. 数据结构的调整</h3><img width = "65%" alt="" align=center src="/images/Fiber/16deecc72bc9a14c.png"/><p><em>左侧是Virtual DOM，右侧可以看作diff的递归调用栈</em></p><p>上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为<code>Stack Reconcilation</code>. 你可以通过这篇文章<a href="https://juejin.im/post/6844903861434449933">《从Preact中了解React组件和hooks基本原理》</a> 来回顾一下历史。</p><p>栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解…, 递归非常适合树这种嵌套数据结构的处理。</p><p>只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理。 这种调用栈，不是程序所能控制的， 如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。</p><p>因此<strong>首先我们需要对React现有的数据结构进行调整，<a href="https://zhuanlan.zhihu.com/p/36425839"><code>模拟函数调用栈</code></a>, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代</strong>.</p><p>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 <code>Fiber</code>表示, 它的结构大概如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;</span><br><span class="line">  <span class="comment">// Fiber 类型信息</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链表结构</span></span><br><span class="line">  <span class="comment">// 指向父节点，或者render该节点的组件</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向下一个兄弟节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用图片来展示这种关系会更直观一些：</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc6db5530be.png"/><p><strong>使用链表结构只是一个结果，而不是目的，React 开发者一开始的目的是冲着模拟调用栈去的</strong>。这个很多关于Fiber 的文章都有提及, 关于调用栈的详细定义参见<a href="https://en.wikipedia.org/wiki/Call_stack">Wiki</a>：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc9a904099b.png"/><blockquote><p>调用栈最经常被用于存放子程序的<strong>返回地址</strong>。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存<code>本地变量</code>、<code>函数参数</code>、<code>环境传递</code>(Scope?)</p></blockquote><p>React Fiber 也被称为虚拟栈帧(Virtual Stack Frame), 你可以拿它和函数调用栈类比一下, 两者结构非常像:</p><table><thead><tr><th></th><th>函数调用栈</th><th>Fiber</th></tr></thead><tbody><tr><td>基本单位</td><td>函数</td><td>Virtual DOM 节点</td></tr><tr><td>输入</td><td>函数参数</td><td>Props</td></tr><tr><td>本地状态</td><td>本地变量</td><td>State</td></tr><tr><td>输出</td><td>函数返回值</td><td>React Element</td></tr><tr><td>下级</td><td>嵌套函数调用</td><td>子节点(child)</td></tr><tr><td>上级引用</td><td>返回地址</td><td>父节点(return)</td></tr></tbody></table><p>Fiber 和调用栈帧一样, 保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。</p><p>有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 <code>performUnitOfWork</code> 的实现, 它其实就是一个深度优先的遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>fiber 当前需要处理的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>topWork 本次更新的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber: Fiber, topWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对该节点进行处理</span></span><br><span class="line">  beginWork(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在子节点，那么下一个待处理的就是子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有子节点了，上溯查找兄弟节点</span></span><br><span class="line">  <span class="keyword">let</span> temp = fiber;</span><br><span class="line">  <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">    completeWork(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到顶层节点了, 退出</span></span><br><span class="line">    <span class="keyword">if</span> (temp === topWork) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到，下一个要处理的就是兄弟节点</span></span><br><span class="line">    <span class="keyword">if</span> (temp.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> temp.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有, 继续上溯</span></span><br><span class="line">    temp = temp.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以配合上文的 <code>workLoop</code> 一起看，<strong>Fiber 就是我们所说的工作单元，<code>performUnitOfWork</code> 负责对 <code>Fiber</code> 进行操作，并按照深度遍历的顺序返回下一个 Fiber</strong>。</p><p><strong>因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的<code>Fiber</code>继续遍历下去</strong>。</p><p>整个迭代顺序和之前递归的一样, 下图假设在 <code>div.app</code> 进行了更新：</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecca7850a24d.png"/><p><em>比如你在<code>text(hello)</code>中断了，那么下一次就会从 <code>p</code> 节点开始处理</em></p><p>这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的<code>return</code>回溯即可。</p><h3 id="2-两个阶段的拆分"><a href="#2-两个阶段的拆分" class="headerlink" title="2. 两个阶段的拆分"></a>2. 两个阶段的拆分</h3><img width = "85%" alt="" align=center src="/images/Fiber/16deecd830671a70.png"/><p>如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：<code>Reconciliation</code>(协调阶段) 和 <code>Commit</code>(提交阶段).</p><blockquote><p>我在之前的多篇文章中都有提及: <a href="https://juejin.im/post/6844903946016784392">《自己写个React渲染器: 以 Remax 为例(用React写小程序)》</a></p></blockquote><p>除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:</p><ul><li><strong>协调阶段</strong>: 可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为’<code>副作用</code>(Effect)’ . 以下生命周期钩子会在协调阶段被调用：<ul><li><code>constructor</code></li><li><code>componentWillMount</code> 废弃</li><li><code>componentWillReceiveProps</code> 废弃</li><li><code>static getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code> 废弃</li><li><code>render</code></li></ul></li><li><strong>提交阶段</strong>: 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)<strong>一次性执行了。</strong>这个阶段必须同步执行，不能被打断</strong>. 这些生命周期钩子在提交阶段被执行:<ul><li><code>getSnapshotBeforeUpdate()</code> 严格来说，这个是在进入 commit 阶段前调用</li><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul></li></ul><p>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。</p><p>需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，<strong>⚠️React 协调阶段的生命周期钩子可能会被调用多次!</strong>, 例如 <code>componentWillMount</code> 可能会被调用两次。</p><p>因此建议 <strong>协调阶段的生命周期钩子不要包含副作用</strong>. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如<code>componentWillMount</code>、<code>componentWillUpdate</code>. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.</p><p>现在你应该知道为什么’提交阶段’必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在<code>componentDidMount</code>中发起的异步请求、useEffect 中定义的副作用… 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。</p><p>关于为什么要拆分两个阶段，<a href="https://github.com/facebook/react/issues/13186#issuecomment-403959161">这里</a>有更详细的解释。</p><h3 id="3-Reconcilation"><a href="#3-Reconcilation" class="headerlink" title="3. Reconcilation"></a>3. Reconcilation</h3><p>接下来就是就是我们熟知的<code>Reconcilation</code>(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. <strong>思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更</strong>。</p><p>首先再进一步看一下<code>Fiber</code>的结构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">interface Fiber &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的类型信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  <span class="comment">// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)</span></span><br><span class="line">  type: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 结构信息</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子节点的唯一键, 即我们渲染列表传入的key属性</span></span><br><span class="line">  key: <span class="literal">null</span> | string,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 节点实例(状态)：</span></span><br><span class="line">  <span class="comment">//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。</span></span><br><span class="line">  <span class="comment">//        对于类组件来说，这里保存类组件的实例</span></span><br><span class="line">  <span class="comment">//        对于函数组件说，这里为空，因为函数组件没有实例</span></span><br><span class="line">  stateNode: any,</span><br><span class="line">  <span class="comment">// 新的、待处理的props</span></span><br><span class="line">  pendingProps: any,</span><br><span class="line">  <span class="comment">// 上一次渲染的props</span></span><br><span class="line">  memoizedProps: any, <span class="comment">// The props used to create the output.</span></span><br><span class="line">  <span class="comment">// 上一次渲染的组件状态</span></span><br><span class="line">  memoizedState: any,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 副作用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 当前节点的副作用类型，例如节点更新、删除、移动</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line">  <span class="comment">// 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 替身</span></span><br><span class="line"><span class="comment">   * 指向旧树中的节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Fiber 包含的属性可以划分为 5 个部分:</p><ul><li><strong>结构信息</strong> - 这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位</li><li><strong>节点类型信息</strong> - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp</li><li><strong>节点的状态</strong> - 节点的组件实例、props、state等，它们将影响组件的输出</li><li><strong>副作用</strong> - 这个也是新东西. 在 Reconciliation 过程中发现的’副作用’(变更需求)就保存在节点的<code>effectTag</code> 中(想象为打上一个标记). 那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过<code>nextEffect</code>连接起来</li><li><strong>替身</strong> - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，<strong>WIP树</strong>)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的<strong>旧树</strong>，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。</li></ul><p>现在可以放大看看<code>beginWork</code>  是如何对 Fiber 进行比对的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">fiber: Fiber</span>): <span class="title">Fiber</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.tag === WorkTag.HostComponent) &#123;</span><br><span class="line">    <span class="comment">// 宿主节点diff</span></span><br><span class="line">    diffHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.ClassComponent) &#123;</span><br><span class="line">    <span class="comment">// 类组件节点diff</span></span><br><span class="line">    diffClassComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.FunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 函数组件节点diff</span></span><br><span class="line">    diffFunctionalComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他类型节点，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宿主节点比对:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffHostComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新增节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.pendingProps.children;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类组件节点比对也差不多:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffClassComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createInstance(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.hasMounted) &#123;</span><br><span class="line">    <span class="comment">// 调用更新前生命周期钩子</span></span><br><span class="line">    applybeforeUpdateHooks(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用挂载前生命周期钩子</span></span><br><span class="line">    applybeforeMountHooks(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染新节点</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.stateNode.render();</span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line"></span><br><span class="line">  fiber.memoizedState = fiber.stateNode.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子节点比对:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">fiber: Fiber, newChildren: React.ReactNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = fiber.alternate ? fiber.alternate.child : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 全新节点，直接挂载</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber == <span class="literal">null</span>) &#123;</span><br><span class="line">    mountChildFibers(fiber, newChildren)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 新子节点</span></span><br><span class="line">  <span class="keyword">const</span> elements = extraElements(newChildren)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子元素</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevFiber = newFiber;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">    <span class="keyword">const</span> sameType = isSameType(element, oldFiber)</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = cloneFiber(oldFiber, element)</span><br><span class="line">      <span class="comment">// 更新关系</span></span><br><span class="line">      newFiber.alternate = oldFiber</span><br><span class="line">      <span class="comment">// 打上Tag</span></span><br><span class="line">      newFiber.effectTag = UPDATE</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新节点</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = createFiber(element)</span><br><span class="line">      newFiber.effectTag = PLACEMENT</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = DELETION;</span><br><span class="line">      oldFiber.nextEffect = fiber.nextEffect</span><br><span class="line">      fiber.nextEffect = oldFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevFiber &amp;&amp; element) &#123;</span><br><span class="line">      prevFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.</p><p>这里引用一下<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Youtube: Lin Clark presentation in ReactConf 2017</a> 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下:</p><blockquote><p>这篇文章<a href="https://juejin.im/post/6844903582622285831">《React Fiber》</a> 用文字版解释了Link Clark Slide.</p></blockquote><img width = "65%" alt="" align=center src="/images/Fiber/16deecce3162b355.png"/><p>上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了’标签’。 在提交阶段，React 就会将这些打上标签的节点应用变更。</p><h3 id="4-双缓冲"><a href="#4-双缓冲" class="headerlink" title="4. 双缓冲"></a>4. 双缓冲</h3><p><code>WIP 树</code>构建这种技术类似于图形化领域的’<strong>双缓存(Double Buffering)</strong>‘技术，图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。</p><p>放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。</p><p>双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。</p><p>Dan 在 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 16</a> 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，<strong>你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？</strong>:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deeccf3468b00b.png"/><h3 id="5-副作用的收集和提交"><a href="#5-副作用的收集和提交" class="headerlink" title="5. 副作用的收集和提交"></a>5. 副作用的收集和提交</h3><p>接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在<code>completeWork</code>中做, 例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parent = fiber.return</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到达顶端</span></span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="literal">null</span> || fiber === topWork) &#123;</span><br><span class="line">    pendingCommit = fiber</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.nextEffect) &#123;</span><br><span class="line">      parent.nextEffect.nextEffect = fiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.nextEffect = fiber</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.nextEffect) &#123;</span><br><span class="line">    parent.nextEffect = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后了，将所有副作用提交了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllWork</span>(<span class="params">fiber</span>) </span>&#123;  <span class="keyword">let</span> next = fiber  <span class="keyword">while</span>(next) &#123;    <span class="keyword">if</span> (fiber.effectTag) &#123;      <span class="comment">// 提交，偷一下懒，这里就不展开了      commitWork(fiber)    &#125;    next = fiber.nextEffect  &#125;  // 清理现场  pendingCommit = nextUnitOfWork = topWork = null&#125;</span></span><br></pre></td></tr></table></figure><h2 id="五、中断和恢复"><a href="#五、中断和恢复" class="headerlink" title="五、中断和恢复"></a>五、中断和恢复</h2><p>上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。 也就是说，到目前为止：<strong>⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞</strong>。我个人觉得这才是 React Fiber 中最难处理的一部分。</p><p><strong>实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务</strong>。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。</p><p><strong>但是如果不按顺序执行任务，可能会导致前后的状态不一致</strong>。 比如低优先级任务将 <code>a</code> 设置为0，而高优先级任务将 <code>a</code> 递增1, 两个任务的执行顺序会影响最终的渲染结果。因此<strong>要让高优先级任务插队, 首先要保证状态更新的时序</strong>。</p><p>解决办法是: <strong>所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行</strong>, 例如：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deeccf96dac168.png"/><p>红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态, 从而保证<strong>状态的最终一致性</strong>：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd05f86b375.png"/><p>最终红色的高优先级任务 <code>C</code> 执行时的状态值是<code>a=5,b=3</code>. 在恢复控制权时，会按照优先级先执行 <code>C</code>, 前面的<code>A</code>、 <code>B</code>暂时跳过</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd121a8657a.png"/><p>上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子 <code>a</code>、<code>b</code> 可能会影响 <code>Foo</code> 组件树，而 <code>c</code> 会影响 <code>Bar</code> 组件树。所以为了保证<strong>视图的最终一致性</strong>, 所有更新任务都要被执行。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd19b1362c0.png"/><p>首先 <code>C</code> 先被执行，它更新了 <code>Foo</code> 组件</p><p>接着执行 <code>A</code> 任务，它更新了<code>Foo</code> 和 <code>Bar</code> 组件，由于 <code>C</code> 已经以最终状态<code>a=5, b=3</code>更新了<code>Foo</code>组件，这里可以做一下性能优化，直接复用C的更新结果， 不必触发重新渲染。因此 <code>A</code> 仅需更新 <code>Bar</code> 组件即可。</p><p>接着执行 <code>B</code>，同理可以复用 Foo 更新结果。</p><p>道理讲起来都很简单，React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证<strong>状态的一致性</strong>和<strong>视图的一致性</strong>，这给了 React 团队很大的考验，以致于现在都没有正式release出来。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img width = "35%" alt="" align=center src="/images/Fiber/16deecd21336ca41.jpg"/><p><em>同样来自Link Clark 的 Slider</em></p><p>前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作, 地老天荒… 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。</p><p>React 开启 <code>Concurrent Mode</code> 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd2d4124b05.png"/><p><em>来源：<a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s">Flarnie Marchan - Ready for Concurrent Mode?</a></em></p><p>开启 <code>Concurrent Mode</code> 后，我们可以得到以下好处(详见<a href="https://www.youtube.com/watch?v=ByBPyMBTzM0">Concurrent Rendering in React</a>):</p><ul><li>快速响应用户操作和输入，提升用户交互体验</li><li>让动画更加流畅，通过调度，可以让应用保持高帧率</li><li>利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。 比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。</li><li>用<code>Suspense</code> 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。</li></ul><p>但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。</p><p>为了共同创造美好的世界，我们要严律于己，该做的优化还需要做: 纯组件、虚表、简化组件、缓存…</p><p>尤雨溪在今年的<a href="https://www.yuque.com/vueconf/2019">Vue Conf</a>一个观点让我印象深刻：<strong>如果我们可以把更新做得足够快的话，理论上就不需要时间分片了</strong>。</p><p><strong>时间分片并没有降低整体的工作量，该做的还是要做</strong>, 因此React 也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：React Fiber 本质上是为了解决 React 更新低效率的问题，<strong>不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背</strong>.</p><h2 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h2><p>本文之所以能成文，离不开社区上优质的开源项目和资料。</p><p><strong>迷你 Fiber 实现：</strong></p><p>React 现在的代码库太复杂了! 而且一直在变动和推翻自己，<a href="https://www.zhihu.com/people/he-shi-jun">Hax</a> 在 <a href="https://www.zhihu.com/question/270428598/answer/354017709">《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》 </a> 就开玩笑说: Fiber 性价比略低… 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……</p><p>这种工程量不是一般团队能Hold住的， 如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解:</p><ul><li><a href="https://github.com/RubyLouvre/anu">anu</a> <a href="https://github.com/RubyLouvre">司徒正美</a> 开发的类React框架</li><li><a href="https://github.com/132yse/fre">Fre</a> <a href="https://www.zhihu.com/people/132yse">伊撒尔</a> 开发的类React框架，代码很精简⁉️</li><li><a href="https://github.com/Foveluy/Luy">Luy</a></li><li><a href="https://github.com/pomber/didact">didact</a></li></ul><p><strong>优秀的文章 &amp; 演讲：</strong></p><p>本文只是对React Fiber进行了简单的科普，实际上React 的实现比本文复杂的多。如果你想深入理解React Fiber的，下面这些文章不容错过:</p><ul><li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 👍🎦</a> React Fiber 启蒙，YouTube</li><li><a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 16 - Dan Abramov 👍🎦</a></li><li><a href="https://www.youtube.com/watch?v=ByBPyMBTzM0&t=151s">Concurrent Rendering in React - Andrew Clark and Brian Vaughn 👍🎦</a></li><li><a href="https://zhuanlan.zhihu.com/p/37095662">司徒正美: React Fiber架构 👍</a> 看不如写</li><li><a href="https://www.zhihu.com/people/NE_SmallTown/posts">展望 React 17，回顾 React 往事 👍</a> 看完 <a href="https://www.zhihu.com/people/NE_SmallTown">Heaven</a> 的相关文章，会觉得你了解的React 知识真的只是<a href="https://zhuanlan.zhihu.com/jheaven">冰山一角</a>，我们都没资格说我们懂 React。</li><li><a href="https://zhuanlan.zhihu.com/p/36425839">浅入 React16/fiber 系列 👍</a> 同样来自 Heaven</li><li><a href="https://www.zhihu.com/search?type=content&q=requestIdleCallback">淡苍：深入剖析 React Concurrent 👍</a></li><li><a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec">Didact Fiber: Incremental reconciliation  👍</a> 实现了简单的 React Fiber</li><li><a href="https://zhuanlan.zhihu.com/p/26027085">程墨: React Fiber是什么</a></li><li><a href="https://zhuanlan.zhihu.com/p/57346388">译 深入React fiber架构及源码</a></li><li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/">黯羽轻扬: 完全理解React Fiber</a></li><li><a href="https://github.com/facebook/react/issues/7942">Fiber Principles: Contributing To Fiber</a></li><li><a href="https://philippspiess.com/scheduling-in-react/">Scheduling in React</a></li><li><a href="https://juejin.im/post/6844903874692661255">桃翁: Deep In React 之浅谈 React Fiber 架构（一）</a></li><li><a href="https://juejin.im/post/6844903608488558599#heading-12">为 Luy 实现 React Fiber 架构</a></li><li><a href="https://juejin.im/post/6844903582622285831">妖僧风月: React Fiber</a></li><li><a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s">Flarnie Marchan - Ready for Concurrent Mode? 🎦</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/rendering">Web Fundamentals &gt; Performance</a></li><li><a href="https://juejin.im/post/6844903592831238157">你应该知道的requestIdleCallback</a></li><li><a href="https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/">深入探究 eventloop 与浏览器渲染的时序问题</a></li><li><a href="https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/">Accurately measuring layout on the web</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903975112671239#heading-13&quot;&gt;原文链接&lt;/a&gt; Fiber 不是一个新的东西，来看一下单处理进程调度&lt;/p&gt;
&lt;h2 id=&quot;一、单处理器进程调度&quot;&gt;&lt;a href=&quot;#一、单</summary>
      
    
    
    
    <category term="React" scheme="https://tenloy.github.io/categories/React/"/>
    
    
    <category term="Fiber" scheme="https://tenloy.github.io/tags/Fiber/"/>
    
  </entry>
  
  <entry>
    <title>[转]什么是协程</title>
    <link href="https://tenloy.github.io/2021/05/27/08_Coroutine/"/>
    <id>https://tenloy.github.io/2021/05/27/08_Coroutine/</id>
    <published>2021-05-27T10:42:19.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<p>协程，又称微线程，纤程。英文名Coroutine。</p><p>协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。</p><p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p><p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p><p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p><p><strong>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</strong></p><p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;x&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;y&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;z&#x27;</span></span><br></pre></td></tr></table></figure><p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">3</span><br><span class="line">z</span><br></pre></td></tr></table></figure><p>但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。</p><p>看起来A、B的执行有点像多线程，但<strong>协程的特点在于是一个线程执行</strong>，那和多线程比，协程有何优势？</p><ul><li><p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p></li><li><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p></li></ul><p><strong>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</strong></p><p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p><p>来看例子：</p><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p><p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span>(<span class="params">c</span>):</span></span><br><span class="line">    c.<span class="built_in">next</span>()</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br></pre></td></tr></table></figure><p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：</p><ol><li>首先调用c.next()启动生成器；</li><li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</li><li>consumer通过yield拿到消息，处理，又通过yield把结果传回；</li><li>produce拿到consumer处理的结果，继续生产下一条消息；</li><li>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</li></ol><p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p><p>最后套用Donald Knuth的一句话总结协程的特点：</p><p>“子程序就是协程的一种特例。”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;协程，又称微线程，纤程。英文名Coroutine。&lt;/p&gt;
&lt;p&gt;协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。&lt;/p&gt;
&lt;p&gt;子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完</summary>
      
    
    
    
    <category term="OS" scheme="https://tenloy.github.io/categories/OS/"/>
    
    
    <category term="协程" scheme="https://tenloy.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>工程化、动态化、容器化、组件化</title>
    <link href="https://tenloy.github.io/2021/04/29/07_Engineering/"/>
    <id>https://tenloy.github.io/2021/04/29/07_Engineering/</id>
    <published>2021-04-29T19:43:56.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、工程化"><a href="#一、工程化" class="headerlink" title="一、工程化"></a>一、工程化</h2><h3 id="2-1-几个概念"><a href="#2-1-几个概念" class="headerlink" title="2.1 几个概念"></a>2.1 几个概念</h3><p>工程</p><blockquote><p>泛指某项需要投入巨大人力和物力的工作。</p></blockquote><blockquote><p>工程是科学和数学的某种应用，通过这一应用，使自然界的物质和能源的特性能够通过各种结构、机器、产品、系统和过程，是以 <code>最短的时间</code> 和 <code>最少的人力、物力</code> 做出 <code>高效、可靠</code> 且对人类有用的东西。</p></blockquote><p>软件工程</p><blockquote><p>将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中。</p><p>它借鉴传统工程的原则、方法创建软件，以达到提高质量，降低成本的目的。</p></blockquote><p>软件工程是一门指导计算机软件开发和维护的工程学科。是一门交叉性学科(需要用到多种学科的方法支持和指导)，如：</p><ul><li>计算机科学、数学用于构造模型与算法</li><li>工程科学用于制定规范、设计范型、评估成本及确定权衡</li><li>管理科学用于计划、资源、质量、成本等管理</li></ul><h3 id="2-2-工程化"><a href="#2-2-工程化" class="headerlink" title="2.2 工程化"></a>2.2 工程化</h3><p>工程化就是指将软件工程的技术和方法运用在开发中，目的是实现<strong>高效开发(降低难度、有效协同)，降低成本，质量可控</strong>。</p><p>工程化包括环境搭建、开发、测试、构建、部署(发布)等一系列流程：</p><ul><li><strong>环境搭建</strong>：项目创建(脚手架)、框架选型、基础工具(请求库、路由库、基础视图组件等)选型等</li><li><strong>开发</strong>：版本管理(分支、commit、review等)规范、动态化方案、组件化方案等</li><li><strong>构建、部署</strong>：CI/CD(自动化持续集成发布)</li><li><strong>测试</strong>：测试用例，自动化测试</li></ul><p><strong>工程化不是指某个工具，工具化只是实现工程化的方式</strong></p><img src="/images/Engineering/web-engineering.jpg" style="zoom:60%"><h2 id="二、跨平台"><a href="#二、跨平台" class="headerlink" title="二、跨平台"></a>二、跨平台</h2><p>跨平台（英语：cross-platform software、multi-platform software、platform-independent software）泛指编程语言、软件或硬件设备可以在多种操作系统或不同硬件架构的电脑上运作。</p><h2 id="三、动态化"><a href="#三、动态化" class="headerlink" title="三、动态化"></a>三、动态化</h2><h3 id="3-1-什么是动态化？"><a href="#3-1-什么是动态化？" class="headerlink" title="3.1 什么是动态化？"></a>3.1 什么是动态化？</h3><p>移动动态化：移动指的是移动端，包括安卓、iOS。动态化则是动态部署和逻辑下发到客户端的能力。移动动态最好的状态就是让移动应用和 Web 一样，想发就发！</p><h3 id="3-2-移动端动态化方案"><a href="#3-2-移动端动态化方案" class="headerlink" title="3.2 移动端动态化方案"></a>3.2 移动端动态化方案</h3><p>从「支持动态化的程度」、「与原生体验的差异」、「方案集成与功能开发成本的高低」三个维度出发，将市面上的移动端动态化方案分成三个方向（为了节约成本，移动端的动态化方案一般也会<strong>兼顾跨平台</strong>）：</p><img src="/images/Engineering/plans.jpg" style="zoom:80%"><ul><li><p><code>Web增强(Web+)</code>：方向主要基于 WebView 实现，能够进行快速的迭代。不过在性能和稳定性上略差，使用场景有限。</p></li><li><p>GPL  和 DSL 可以看作 <code>Native 增强(Native+)</code> 方向的子方向，Native+ 方向基于 App 内自带的语言解析器，独立于 WebView 实现动态化逻辑的解析、布局和渲染。</p><ul><li><p><code>基于GPL的 Native增强(GPL)</code>：</p><ul><li>这个方向是移动端动态化的热门方向。React Native、Flutter、NativeScript 等等，实现原理各不相同；</li><li>共同的特点是利用了通用编程语言器，可以是系统提供的（如 Javascript），或者是集成到 App 的（如 Dart），再辅以某个布局系统和渲染方案，由于语言是图灵完备的，可以提供完美的动态化解决方案；</li><li>GPL 方案虽然在动态化能力、渲染性能方面效果出色，但 Framework 体积、学习和开发成本等方面却也是相当高。于是产生了基于领域专用语言的解决方案。</li></ul></li><li><p><code>基于DSL的 Native增强(DSL)</code> ：</p><ul><li>此类方案通过采用适合专业场景的的 DSL 解析云端下发的逻辑结构，舍弃一部分动态化灵活性，换取其他方面的优势。</li></ul></li></ul></li></ul><img src="/images/Engineering/plans2.jpg" style="zoom:90%"><h2 id="四、容器化"><a href="#四、容器化" class="headerlink" title="四、容器化"></a>四、容器化</h2><p>伴随着上面的动态化方案诞生，容器化这个词在移动端也频繁的出现。</p><p>容器在不同场景下的含义</p><ul><li><p>字面意思，容器就是指容纳小物品的事物，比如：</p><ul><li>UIStackview</li><li>自定义的Container视图组件</li><li>前端组件化开发中的页面充当的角色(将一个页面分成很多个组件，此处页面就相当于是个纯粹的容器)</li></ul></li><li><p>代码/数据的运行环境，完成代码的解释/数据的解析。比如(从小到大)：</p><ul><li><p>美团，后端返回协商好的结构化的数据，移动端对数据进行解析，还原成界面的layout。进行视图创建、渲染</p><p>动态化是整个外卖业务的发展方向。提单页的动态化建立在容器化的基础之上，在完成容器化之后，就具备了动态化的基础。当前提单页的动态化，所指的主要是模块层级的动态化，提单页的各模块展示顺序、展示与否，都可以完全由根据服务端下发的数据决定，各模块可以自由地进行组合、拼装，实现提单页的动态配置。</p></li><li><p>RN。在一定程度上，React Native和NodeJS有异曲同工之妙。它们都是通过扩展JavaScript Engine, 使它具备强大的本地资源和原生接口调用能力，然后结合JavaScript丰富的库和社区和及其稳定的跨平台能力，把javascript的魔力在浏览器之外的地方充分发挥出来。</p><ul><li><p><code>JavaScriptCore</code>负责JS代码解释执行</p></li><li><p><code>ReactJS</code>负责描述和管理<code>VirtualDom</code>，指挥原生组件进行绘制和更新，同时很多计算逻辑也在js里面进行。ReactJS自身是不直接绘制UI的，UI绘制是非常耗时的操作，原生组件最擅长这事情。</p></li><li><p><code>Bridges</code>用来翻译ReactJS的绘制指令给原生组件进行绘制，同时把原生组件接收到的用户事件反馈给<code>ReactJS</code>。</p><p>要在不同的平台实现不同的效果就可以通过定制<code>Bridges</code>来实现</p></li></ul></li><li><p>上面的Docker容器</p></li><li><p>服务器容器</p></li></ul></li></ul><p>容器化是个很大的概念，在移动端中，常见其应用于：</p><ul><li>跨平台</li><li>动态化</li><li>如WebView容器、Weex容器、RN容器、自定义DSL容器等</li></ul><p><strong>跨平台与动态化是功能实现。容器化是一种软件开发方法，其可以实现，但不仅仅只能实现跨平台与动态化等。</strong></p><h2 id="五、模块化和组件化"><a href="#五、模块化和组件化" class="headerlink" title="五、模块化和组件化"></a>五、模块化和组件化</h2><h3 id="5-1-模块化"><a href="#5-1-模块化" class="headerlink" title="5.1 模块化"></a>5.1 模块化</h3><h4 id="5-1-1-什么是模块"><a href="#5-1-1-什么是模块" class="headerlink" title="5.1.1 什么是模块"></a>5.1.1 什么是模块</h4><blockquote><p>模块化编程是一种软件设计技术，它强调将程序的功能分成独立的、可互换的模块，这样每个模块都包含执行所需功能的一个方面所需的一切。—— <a href="https://en.wikipedia.org/wiki/Modular_programming">Modular programming</a></p></blockquote><p>模块：模块化的目的在于将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。</p><ul><li>将一个大的系统模块化之后，每个模块都可以被高度复用。</li><li>但是值得注意的是模块不等于功能，二者的关系大概为：功能 &gt; 模块。一个功能可能包含多个模块。</li></ul><h4 id="5-1-2-横向拆分业务、功能模块"><a href="#5-1-2-横向拆分业务、功能模块" class="headerlink" title="5.1.2 横向拆分业务、功能模块"></a>5.1.2 横向拆分业务、功能模块</h4><img src="/images/Engineering/modular_and_component_summary_1.jpg" style="zoom:80%"><h4 id="5-1-3-纵向拆分技术、架构模块"><a href="#5-1-3-纵向拆分技术、架构模块" class="headerlink" title="5.1.3 纵向拆分技术、架构模块"></a>5.1.3 纵向拆分技术、架构模块</h4><img src="/images/Engineering/modular_and_component_summary_2.jpg" style="zoom:80%"><h3 id="5-2-组件化"><a href="#5-2-组件化" class="headerlink" title="5.2 组件化"></a>5.2 组件化</h3><h4 id="5-2-1-什么是组件？"><a href="#5-2-1-什么是组件？" class="headerlink" title="5.2.1 什么是组件？"></a>5.2.1 什么是组件？</h4><blockquote><p>基于组件的软件工程(CBSE)，也称为基于组件的开发(CBD)，是软件工程的一个分支，它强调对整个给定软件系统中可用的广泛功能的关注分离。它是一种 <strong>基于重用(reuse-based)</strong> 的方法，用来定义、实现松散耦合的独立组件，并将它们组合成系统。—— <a href="https://en.wikipedia.org/wiki/Component-based_software_engineering">Component-based software engineering</a></p><p>定义与模块化很相似，都是主要为了对一个系统做拆分。</p></blockquote><p>组件：通俗点就是组件化就是基于可重用的目的，将一个大的软件系统按照<strong>分离关注点</strong>的形式，拆分成多个独立的组件。</p><ul><li>组件的出现是为了解决全局工程中有很多重复代码的问题，是为了复用，而且划分力度是相对较小的模块。      </li><li>组件化的另一个目的是为了解耦，把系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</li></ul><p>组件的特性：</p><ul><li><strong>通过接口访问</strong>：组件通过接口相互通信。 当一个组件向系统的其余部分提供服务时，它采用一个提供的接口，指定其他组件可以使用的服务，以及它们如何使用。这个接口可以看作是组件的签名(signature)——客户端不需要知道组件的内部工作（实现）来使用它。 这个原理导致组件被称为封装。</li><li><strong>可替换的</strong>(<em>substitutable</em>)：组件是可替换的，因此如果后续组件满足初始组件的需求(通过接口表示)，则组件可以替换另一个组件(在设计时或运行时)。因此，可以用更新版本或替代版本替换组件，而不会破坏组件运行的系统。</li><li><strong>可重用性</strong>(<em>Reusability</em>)：可重用性是高质量软件组件的一个重要特征。 程序员应该以许多不同的程序可以重用它们的方式来设计和实现软件组件。</li></ul><h4 id="5-2-2-从界面入手，拆分可视化组件"><a href="#5-2-2-从界面入手，拆分可视化组件" class="headerlink" title="5.2.2 从界面入手，拆分可视化组件"></a>5.2.2 从界面入手，拆分可视化组件</h4><img src="/images/Engineering/modular_and_component_summary_3.jpg" style="zoom:80%"><h4 id="5-2-3-从数据入手，拆分数据加工组件"><a href="#5-2-3-从数据入手，拆分数据加工组件" class="headerlink" title="5.2.3 从数据入手，拆分数据加工组件"></a>5.2.3 从数据入手，拆分数据加工组件</h4><img src="/images/Engineering/modular_and_component_summary_4.jpg" style="zoom:80%"><p>大部分时候，拆分模块、组件都是以清晰的流程、逻辑为基础的，就如上图的过程，当流程清晰后，可以拆分复用的组件也就出来了。</p><h3 id="5-3-插件化"><a href="#5-3-插件化" class="headerlink" title="5.3 插件化"></a>5.3 插件化</h3><p>插件：可以理解为是封装了一层对外调用的接口的组件。</p><p>插件的概念比较形象，一般存在一个“插拔”过程，所以要求可插拔的插件有一个相同的接口（这里所说的接口只是概念上的接口，即调用方法及参数等）。而组件是不存在这个相同接口的。</p><p>插件和组件的实质区别就在于：通过统一接口隔绝业务代码对于组件的直接依赖。</p><p>Android中对组件化、插件化有不太一样的定义：</p><ul><li>组件化：开发模式下面module本来就是一个独立app，只是发布模式下变成library。</li><li>插件化：就是不存在发布模式开发模式，每个组件业务就是一个独立apk开发，然后通过主工程app动态加载部署业务组件apk。</li></ul><h3 id="5-4-总结-异同"><a href="#5-4-总结-异同" class="headerlink" title="5.4 总结(异同)"></a>5.4 总结(异同)</h3><h4 id="5-4-1-三者小结"><a href="#5-4-1-三者小结" class="headerlink" title="5.4.1 三者小结"></a>5.4.1 三者小结</h4><p>模块：高内聚，松耦合，功能相对复杂，有多个统一接口。模块化开发的基础是框架。</p><p>组件：代码重用，功能相对单一或者独立，无统一接口。组件化开发的成果是基础库和公共组件。</p><p>插件：近乎组件，有统一接口，可以说是封装了一层对外调用的接口的组件。</p><h4 id="5-4-2-组件和模块的异同"><a href="#5-4-2-组件和模块的异同" class="headerlink" title="5.4.2 组件和模块的异同"></a>5.4.2 组件和模块的异同</h4><p>相同点：</p><ul><li>组件化和模块化的中心思想都是分而治之。目的都是将一个庞大的系统拆分成多个组件或者说是模块。</li></ul><p>区别：</p><ul><li><p>模块化开发是横向分块，组件化开发是纵向分层。(说法都不绝对，一般来讲)</p></li><li><p>模块化强调的是<strong>拆分</strong>，无论是从业务角度还是从架构、技术角度，模块化首先意味着将代码、数据等内容按照其职责不同分离，使其变得更加容易维护、迭代，使开发人员可以分而治之。</p></li><li><p>组件化则着重于<strong>可重用性</strong>，不管是界面上反复使用的用户头像按钮，还是处理数据的流程中的某个部件，只要可以被反复使用，并且进行了高度封装，只能通过接口访问，就可以称其为“组件”。</p></li><li><p>进行模块化拆分时你可以完全不考虑代码重用，只是把同一业务的代码做内聚整合成不同的模块。只不过这样得到的成果相对简单，我们一般不会这样而已。(<strong>并不是说模块就不能被复用！</strong>)</p></li><li><p>一般来讲，模块的体量会大于组件。不过，大的组件也可以称为模块，小的模块也可以称为组件，所以，在我看来组件和模块的划分并没有那么的泾渭分明。随意两者的粒度的大小改变，两者是可以转换的。</p></li></ul><p>这三个概念是经常同时出现在一个项目中的，我们往往对复杂大项目进行模块化划分的时候，也会进行组件化，而且插件化的本质是面向接口编程，对于组件化和模块化都是适用的，可实现随意插拔的灵活和高扩展性，属于项目架构的高端设计。</p><h3 id="5-5-前端与iOS中的组件化"><a href="#5-5-前端与iOS中的组件化" class="headerlink" title="5.5 前端与iOS中的组件化"></a>5.5 前端与iOS中的组件化</h3><p>在前端、iOS、Android中，都会有组件化的说法(Android先不讨论)。不过与上面的组件概念都稍微有所出入。</p><blockquote><p><em>以复用为基础，定义、实现许多松耦合的独立组件（Component），再将组件组合成为系统</em>。</p></blockquote><p>前端中的组件化：</p><ul><li><p>横向划分模块、纵向划分组件</p></li><li><p>前端中的组件 <code>Component </code>可以简单理解为<strong>页面组成部件</strong>：页面组成部件(header、footer、nav、search等)。不是以重用为基础定义组件</p></li><li><p>前端中数据加工一般不称为组件，更倾向于<code>utils</code>。</p></li></ul><p>iOS中的组件化：以蘑菇街的组件化文章图为例：</p><img src="/images/Engineering/mgj-component.jpg" style="zoom:50%"><ul><li><p>大到业务模块，小到视图、数据加工组件，都统称为了组件。可以简单理解为<strong>APP组成部件</strong>。</p></li><li><p>这个叫法在起初接触组件化概念的时候给我造成了很大的困惑。一度怀疑自己的理解狭隘了….，直到看到Bang的文章，找到了同感。</p></li></ul><blockquote><p>首先我觉得”组件”在这里不太合适，因为按我理解组件是指比较小的功能块，这些组件不需要多少组件间通信，没什么依赖，也就不需要做什么其他处理，面向对象就能搞定。而这里提到的是较大粒度的业务功能，我们习惯称为”模块”。为了方便表述，下面模块和组件代表同一个意思，都是指较大粒度的业务模块。 —— <a href="http://blog.cnbang.net/tech/3080/">iOS 组件化方案探索 — Bang’s blog</a></p></blockquote><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ul><li>工程化<ul><li><a href="https://www.mengfansheng.com/2020/01/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a></li></ul></li><li>动态化<ul><li><a href="https://zhuanlan.zhihu.com/p/64968076">「Morph」知乎移动端动态化方案全览</a></li></ul></li><li>模块化、组件化<ul><li><a href="https://cloud.tencent.com/developer/article/1336167">聊聊工程级别的组件化、插件化 以及 模块化</a></li><li><a href="http://tutuge.me/2016/03/29/modular-and-component-summary/">对组件化与模块化的思考与总结</a></li></ul></li><li>IOS组件化方案<ul><li><a href="https://www.oschina.net/action/GoToLink?url=http://casatwy.com/iOS-Modulization.html">《iOS应用架构谈 组件化方案》</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=http://limboy.me/ios/2016/03/10/mgj-components.html?utm_source=tuicool&utm_medium=referral">《蘑菇街 App 的组件化之路》</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=http://limboy.me/ios/2016/03/14/mgj-components-continued.html">《蘑菇街 App 的组件化之路·续》</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=http://blog.cnbang.net/tech/3080/">《iOS 组件化方案探索》</a> from Bang</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、工程化&quot;&gt;&lt;a href=&quot;#一、工程化&quot; class=&quot;headerlink&quot; title=&quot;一、工程化&quot;&gt;&lt;/a&gt;一、工程化&lt;/h2&gt;&lt;h3 id=&quot;2-1-几个概念&quot;&gt;&lt;a href=&quot;#2-1-几个概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="工程化" scheme="https://tenloy.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>[转]谈谈DSL以及DSL的应用（以CocoaPods 为例）</title>
    <link href="https://tenloy.github.io/2021/04/29/06_DSL/"/>
    <id>https://tenloy.github.io/2021/04/29/06_DSL/</id>
    <published>2021-04-29T16:42:44.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://draveness.me/dsl/">谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例）</a></p></blockquote><blockquote><p>因为 DSL 以及 DSL 的界定本身就是一个比较模糊的概念，所以难免有与他人观点意见相左的地方，如果有不同的意见，我们可以具体讨论。</p></blockquote><p>这次文章的题目虽然是谈谈 DSL 以及 DSL 的应用，不过文章中主要侧重点仍然是 DSL，会简单介绍 DSL 在 iOS 开发中（CocoaPods）是如何应用的。</p><h2 id="没有银弹？"><a href="#没有银弹？" class="headerlink" title="没有银弹？"></a>没有银弹？</h2><p>1987 年，IBM 大型电脑之父 Fred Brooks 发表了一篇关于软件工程中的论文 [No Silver Bullet—Essence and Accidents of Software Engineering](No Silver Bullet—Essence and Accidents of Software Engineering) 文中主要围绕这么一个观点：没有任何一种技术或者方法能使软件工程的生产力在十年之内提高十倍。</p><blockquote><p>There is no single development, in either technology or management technique, which by itself promises even one order-of-magnitude improvement within a decade in productivity, in reliability, in simplicity.</p></blockquote><p>时至今日，我们暂且不谈银弹在软件工程中是否存在（<del>这句话在老板或者项目经理要求加快项目进度时，还是十分好用的</del>），作为一个开发者也不是很关心这种抽象的理论，我们更关心的是开发效率能否有实质的提升。</p><img src="/images/DSL/2016-10-03-silver-bullet.jpg" style="zoom:70%"><p>而今天要介绍的 DSL 就可以真正的提升生产力，减少不必要的工作，在一些领域帮助我们更快的实现需求。</p><h2 id="DSL-是什么？"><a href="#DSL-是什么？" class="headerlink" title="DSL 是什么？"></a>DSL 是什么？</h2><blockquote><p>笔者是在两年以前，在大一的一次分享上听到 DSL 这个词的，但是当时并没有对这个名词有多深的理解与认识，听过也就忘记了，但是最近做的一些开源项目让我重新想起了 DSL，也是这次分享题目的由来。</p></blockquote><p>DSL 其实是 Domain Specific Language 的缩写，中文翻译为<em>领域特定语言</em>（下简称 DSL）；而与 DSL 相对的就是 GPL，这里的 GPL 并不是我们知道的开源许可证，而是 General Purpose Language 的简称，即<em>通用编程语言</em>，也就是我们非常熟悉的 Objective-C、Java、Python 以及 C 语言等等。</p><p><a href="https://en.wikipedia.org/wiki/Domain-specific_language">Wikipedia</a> 对于 DSL 的定义还是比较简单的：</p><blockquote><p>A specialized computer language designed for a specific task.</p><p>为了解决某一类任务而专门设计的计算机语言。</p></blockquote><p>与 GPL 相对，DSL 与传统意义上的通用编程语言 C、Python 以及 Haskell 完全不同。通用的计算机编程语言是可以用来编写任意计算机程序的，并且能表达任何的<strong>可被计算</strong>的逻辑，同时也是 <a href="https://en.wikipedia.org/wiki/Turing_completeness">图灵完备</a> 的。</p><blockquote><p>在可计算性理论，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟任何图灵机，那么它是图灵完备的。图灵完全(图灵完备)意味着可以计算任何图灵-可计算函数。</p><p>没有任何物理系统可以拥有无限内存；如果忽略有限内存的限制，大多数编程语言在其他方面都是图灵完备的。</p></blockquote><blockquote><p>这一小节中的 DSL 指外部 DSL，下一节中会介绍 <a href="https://draveness.me/dsl/#embedded-dsl%E5%B5%8C%E5%85%A5%E5%BC%8F-dsl">内部 DSL/嵌入式 DSL</a></p></blockquote><p>但是在里所说的 DSL 并不是图灵完备的，它们的<strong>表达能力有限</strong>，只是在特定领域解决特定任务的。</p><blockquote><p>A computer programming language of limited expressiveness focused on a particular domain.</p></blockquote><p>另一个世界级软件开发大师 Martin Fowler 对于领域特定语言的定义在笔者看来就更加具体了，<strong>DSL 通过在表达能力上做的妥协换取在某一领域内的高效</strong>。</p><p>而有限的表达能力就成为了 GPL 和 DSL 之间的一条界限。</p><h3 id="几个栗子"><a href="#几个栗子" class="headerlink" title="几个栗子"></a>几个栗子</h3><p>最常见的 DSL 包括 Regex 以及 HTML &amp; CSS，在这里会对这几个例子进行简单介绍</p><ul><li><p>Regex</p><ul><li><p>正则表达式仅仅指定了字符串的 pattern，其引擎就会根据 pattern 判断当前字符串跟正则表达式是否匹配。</p><img src="/images/DSL/2016-10-03-regex.jpg" style="zoom:70%"></li></ul></li><li><p>SQL</p><ul><li>SQL 语句在使用时也并没有真正的执行，我们输入的 SQL 语句最终还要交给数据库来进行处理，数据库会从 SQL 语句中<strong>读取</strong>有用的信息，然后从数据库中返回使用者期望的结果。</li></ul></li><li><p>HTML &amp; CSS</p><ul><li>HTML 和 CSS 只是对 Web 界面的结构语义和样式进行描述，虽然它们在构建网站时非常重要，但是它们并非是一种编程语言，正相反，我们可以认为 HTML 和 CSS 是在 Web 中的领域特定语言。</li></ul></li></ul><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><p>上面的几个🌰明显的缩小了通用编程语言的概念，但是它们确实在自己领域表现地非常出色，因为这些 DSL 就是根据某一个特定领域的特点塑造的；而通用编程语言相比领域特定语言，在设计时是为了解决更加抽象的问题，而关注点并不只是在某一个领域。</p><p>上面的几个例子有着一些共同的特点：</p><ul><li>没有计算和执行的概念；</li><li>其本身并不需要直接表示计算；</li><li>使用时只需要声明规则、事实以及某些元素之间的层级和关系；</li></ul><p>虽然了解了 DSL 以及 DSL 的一些特性，但是，到目前为止，我们对于如何构建一个 DSL 仍然不是很清楚。</p><h3 id="构建-DSL"><a href="#构建-DSL" class="headerlink" title="构建 DSL"></a>构建 DSL</h3><p>DSL 的构建与编程语言其实比较类似，想想我们在重新实现编程语言时，需要做那些事情；<font color=red>实现编程语言的过程可以简化为定义语法与语义，然后实现编译器或者解释器的过程</font>，而 DSL 的实现与它也非常类似，我们也需要对 DSL 进行语法与语义上的设计。</p><img src="/images/DSL/2016-10-03-compiler.png" style="zoom:70%"><p>总结下来，实现 DSL 总共有这么两个需要完成的工作：</p><ol><li>设计语法和语义，定义 DSL 中的元素是什么样的，元素代表什么意思</li><li>实现 parser，对 DSL 解析，最终通过解释器来执行</li></ol><p>以 HTML 为例，HTML 中所有的元素都是包含在尖括号 <code>&lt;&gt;</code> 中的，尖括号中不同的元素代表了不同的标签，而这些标签会被浏览器<strong>解析</strong>成 DOM 树，再经过一系列的过程调用 Native 的图形 API 进行绘制。</p><img src="/images/DSL/2016-10-03-dom-tree.png" style="zoom:70%"><p>再比如，我们使用下面这种方式对一个模型进行定义，实现一个 ORM 领域的 DSL：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define <span class="symbol">:article</span> <span class="keyword">do</span></span><br><span class="line">  attr <span class="symbol">:name</span></span><br><span class="line">  attr <span class="symbol">:content</span></span><br><span class="line">  attr <span class="symbol">:upvotes</span>, <span class="symbol">:int</span></span><br><span class="line"></span><br><span class="line">  has_many <span class="symbol">:comments</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在上面的 DSL 中，使用 <code>define</code> 来定义一个新的模型，使用 <code>attr</code> 来为模型添加属性，使用 <code>has_many</code> 建立数据模型中的一对多关系；我们可以使用 DSL 对这段“字符串”进行解析，然后交给代码生成器来生成代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> createdAt: <span class="type">Date</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">init</span>(<span class="params">title</span>: <span class="type">String</span>, <span class="params">content</span>: <span class="type">String</span>, <span class="params">createdAt</span>: <span class="type">Date</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">new</span>(<span class="params">title</span>: <span class="type">String</span>, <span class="params">content</span>: <span class="type">String</span>, <span class="params">createdAt</span>: <span class="type">Date</span>)</span> -&gt; <span class="type">Article</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span>(<span class="params">title</span>: <span class="type">String</span>, <span class="params">content</span>: <span class="type">String</span>, <span class="params">createdAt</span>: <span class="type">Date</span>)</span> -&gt; <span class="type">Article</span>?</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建的 DSL 中的元素数量非常少，只有 <code>define</code> <code>attr</code> 以及 <code>has_many</code> 等几个关键字，但是通过这几个关键字就可以完成在模型层需要表达的绝大部分语义。</p><h3 id="设计原则和妥协"><a href="#设计原则和妥协" class="headerlink" title="设计原则和妥协"></a>设计原则和妥协</h3><p>DSL 最大的设计原则就是<strong>简单</strong>，通过简化语言中的元素，降低使用者的负担；无论是 Regex、SQL 还是 HTML 以及 CSS，其说明文档往往只有几页，非常易于学习和掌握。但是，由此带来的问题就是，DSL 中缺乏抽象的概念，比如：模块化、变量以及方法等。</p><blockquote><p>抽象的概念并不是某个领域所关注的问题，就像 Regex 并不需要有模块、变量以及方法等概念。</p></blockquote><p>由于抽象能力的缺乏，在我们的项目规模变得越来越大时，DSL 往往满足不了开发者的需求；我们仍然需要编程语言中的模块化等概念对 DSL 进行补充，以此解决 DSL 并不是真正编程语言的问题。</p><img src="/images/DSL/2016-10-03-css-sass.jpg" style="zoom:70%"><p>在当今的 Web 前端项目中，我们在开发大规模项目时往往不会直接手写 CSS 文件，而是会使用 Sass 或者 Less 为 CSS 带来更强大的抽象能力，比如嵌套规则，变量，混合以及继承等特性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">li</span> &#123; <span class="attribute">display</span>: inline-block; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在使用 DSL 的项目规模逐渐变大时，开发者会通过增加抽象能力的方式，对已有的 DSL 进行拓展；但是这种扩展往往需要重新实现通用编程语言中的特性，所以一般情况下都是比较复杂的。</p><h2 id="Embedded-DSL（嵌入式-DSL）"><a href="#Embedded-DSL（嵌入式-DSL）" class="headerlink" title="Embedded DSL（嵌入式 DSL）"></a>Embedded DSL（嵌入式 DSL）</h2><p>那么，是否有一种其它的方法为 DSL 快速添加抽象能力呢？而这也就是这一小节的主题，嵌入式 DSL。</p><p>在上一节讲到的 DSL 其实可以被称为外部 DSL；而这里即将谈到的嵌入式 DSL 也有一个别名，内部 DSL。</p><p>这两者最大的区别就是，内部 DSL 的实现往往是嵌入一些编程语言的，比如 iOS 的依赖管理组件 CocoaPods 和 Android 的主流编译工具 Gradle，前者的实现是基于 Ruby 语言的一些特性，而后者基于 Groovy。</p><img src="/images/DSL/2016-10-03-cocoapods.png" style="zoom:70%"><p>CocoaPods 以及其它的嵌入式 DSL 使用了宿主语言（host language）的抽象能力，并且省去了实现复杂语法分析器（Parser）的过程，并不需要重新实现模块、变量等特性。</p><p>嵌入式 DSL 的产生其实模糊了框架和 DSL 的边界，不过这两者看起来也没有什么比较明显的区别；不过，DSL 一般会使用宿主语言的特性进行创造，在设计 DSL 时，也不会考虑宿主语言中有哪些 API 以及方法，而框架一般都是对语言中的 API 进行组合和再包装。</p><blockquote><p>我们没有必要争论哪些是框架，哪些是 DSL，因为这些争论并没有什么意义。</p></blockquote><h3 id="Rails-和-Embedded-DSL"><a href="#Rails-和-Embedded-DSL" class="headerlink" title="Rails 和 Embedded DSL"></a>Rails 和 Embedded DSL</h3><p>最出名也最成功的嵌入式 DSL 应该就是 Ruby on Rails 了，虽然对于 Rails 是否是 DSL 有争议，不过 Rails 为 Web 应用的创建提供大量的内置的支撑，使我们在开发 Web 应用时变得非常容易。</p><img src="/images/DSL/2016-10-03-rails.jpg" style="zoom:70%"><h2 id="Ruby、-DSL-和-iOS"><a href="#Ruby、-DSL-和-iOS" class="headerlink" title="Ruby、 DSL 和 iOS"></a>Ruby、 DSL 和 iOS</h2><p>笔者同时作为 iOS 和 Rails 开发者接触了非常多的 DSL，而在 iOS 开发中最常见的 DSL 就是 CocoaPods 了，而这里我们以 CocoaPods 为例，介绍如何使用 Ruby 创造一个嵌入式 DSL。</p><h3 id="Why-Ruby？"><a href="#Why-Ruby？" class="headerlink" title="Why Ruby？"></a>Why Ruby？</h3><p>看到这里有人可能会问了，为什么使用 Ruby 创造嵌入式 DSL，而不是使用 C、Java、Python 等等语言呢，这里大概有四个原因：</p><ul><li>一切皆对象的特性减少了语言中的元素，不存在基本类型、操作符；</li><li>向 Ruby 方法中传入代码块非常方便；</li><li>作为解释执行的语言，eval 模糊了数据和代码的边界；</li><li>不对代码的格式进行约束，同时一些约定减少了代码中的噪音。</li></ul><h4 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h4><p>在许多语言，比如 Java 中，数字与其他的基本类型都不是对象，而在 Ruby 中所有的元素，包括基本类型都是对象，同时也不存在运算符的概念，所谓的 <code>1 + 1</code>，其实只是 <code>1.+(1)</code> 的语法糖而已。</p><p>得益于一切皆对象的概念，在 Ruby 中，你可以向任意的对象发送 <code>methods</code> 消息，在运行时自省，所以笔者在每次忘记方法时，都会直接用 <code>methods</code> 来“查阅文档”：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2.3.1 :003 &gt;</span> <span class="number">1</span>.methods</span><br><span class="line"> =&gt; [<span class="symbol">:%</span>, <span class="symbol">:&amp;</span>, <span class="symbol">:*</span>, <span class="symbol">:+</span>, <span class="symbol">:-</span>, <span class="symbol">:/</span>, <span class="symbol">:&lt;</span>, <span class="symbol">:&gt;</span>, <span class="symbol">:^</span>, <span class="symbol">:|</span>, <span class="symbol">:~</span>, <span class="symbol">:-@</span>, <span class="symbol">:**</span>, <span class="symbol">:&lt;=&gt;</span>, <span class="symbol">:&lt;&lt;</span>, <span class="symbol">:&gt;&gt;</span>, <span class="symbol">:&lt;=</span>, <span class="symbol">:&gt;=</span>, <span class="symbol">:==</span>, <span class="symbol">:===</span>, <span class="symbol">:[]</span>, <span class="symbol">:inspect</span>, <span class="symbol">:size</span>, <span class="symbol">:succ</span>, <span class="symbol">:to_s</span>, <span class="symbol">:to_f</span>, <span class="symbol">:div</span>, <span class="symbol">:divmod</span>, <span class="symbol">:fdiv</span>, <span class="symbol">:modulo</span>, ...]</span><br></pre></td></tr></table></figure><p>比如在这里向对象 <code>1</code> 调用 <code>methods</code> 就会返回它能响应的所有方法。</p><p>一切皆对象不仅减少了语言中类型的数量，消灭了基本数据类型与对象之间的边界；这一概念同时也简化了组成语言的元素，这样 Ruby 中只有对象和方法，这两个概念，极大降低了这门语言的复杂度：</p><ul><li>使用对象存储状态</li><li>对象之间通过方法通信</li></ul><h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>Ruby 对函数式编程范式的支持是通过 block，这里的 block 和 Objective-C 中的 block 有些不同。</p><p>首先 Ruby 中的 block 也是一种对象，即 <code>Proc</code> 类的实例，也就是所有的 block 都是 first-class 的，可以作为参数传递，返回。</p><p>下面的代码演示了两种向 Ruby 方法中传入代码块的方式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twice</span><span class="params">(&amp;<span class="built_in">proc</span>)</span></span></span><br><span class="line"><span class="number">2</span>.times &#123; <span class="built_in">proc</span>.call() &#125; <span class="keyword">if</span> <span class="built_in">proc</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twice</span></span></span><br><span class="line"><span class="number">2</span>.times &#123; <span class="keyword">yield</span> &#125; <span class="keyword">if</span> block_given?</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>yield</code> 会调用外部传入的 block，<code>block_given?</code> 用于判断当前方法是否传入了 <code>block</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">twice <span class="keyword">do</span></span><br><span class="line">puts <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">twice &#123; puts <span class="string">&quot;hello&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>向 <code>twice</code> 方法传入 block 也非常简单，使用 <code>do</code>、<code>end</code> 或者 <code>&#123;</code>、<code>&#125;</code> 就可以向任何的 Ruby 方法中传入代码块。</p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>早在几十年前的 Lisp 语言就有了 <code>eval</code> 这个方法，这个方法会将字符串当做代码来执行，也就是说 <code>eval</code> 模糊了代码与数据之间的边界。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval <span class="string">&quot;1 + 2 * 3&quot;</span></span><br><span class="line"> =&gt; <span class="number">7</span></span><br></pre></td></tr></table></figure><p>有了 <code>eval</code> 方法，我们就获得了更加强大的动态能力，在运行时，使用字符串来改变控制流程，执行代码并可以直接利用当前语言的解释器；而不需要去手动解析字符串然后执行代码。</p><h4 id="格式和约定"><a href="#格式和约定" class="headerlink" title="格式和约定"></a>格式和约定</h4><p>编写 Ruby 脚本时并不需要像 Python 一样对代码的格式有着严格的规定，没有对空行、Tab 的要求，完全可以想怎么写就怎么写，这样极大的增加了 DSL 设计的可能性。</p><p>同时，在一般情况下，Ruby 在方法调用时并不需要添加括号：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">&quot;Wello World!&quot;</span></span><br><span class="line">puts(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样减少了 DSL 中的噪音，能够帮助我们更加关心语法以及语义上的设计，降低了使用者出错的可能性。</p><p>最后，Ruby 中存在一种特殊的数据格式 <code>Symbol</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="symbol">:symbol</span>.to_s</span><br><span class="line"> =&gt; <span class="string">&quot;symbol&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;symbol&quot;</span>.to_sym</span><br><span class="line"> =&gt; <span class="symbol">:symbol</span></span><br></pre></td></tr></table></figure><p>Symbol 可以通过 Ruby 中内置的方法与字符串之间无缝转换。那么作为一种字符串的替代品，它的使用也能够降低使用者出错的成本并提升使用体验，我们并不需要去写两边加上引号的字符串，只需要以 <code>:</code> 开头就能创建一个 Symbol 对象。</p><h3 id="Podfile-是什么"><a href="#Podfile-是什么" class="headerlink" title="Podfile 是什么"></a>Podfile 是什么</h3><p>对 Ruby 有了一些了解之后，我们就可以再看一下使用 CocoaPods 的工程中的 Podfile 到底是什么了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;Demo&#x27;</span> <span class="keyword">do</span></span><br><span class="line">pod <span class="string">&#x27;Mantle&#x27;</span>, <span class="string">&#x27;~&gt; 1.5.1&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>如果不了解 iOS 开发后者没有使用过 CocoaPods，笔者在这里简单介绍一下这个文件中的一些信息。</p><p><code>source</code> 可以看作是存储依赖元信息（包括依赖的对应的 GitHub 地址）的源地址；</p><p><code>target</code> 表示需要添加依赖的工程的名字；</p><p><code>pod</code> 表示依赖，<code>Mantle</code> 为依赖的框架，后面是版本号。</p></blockquote><p>上面是一个使用 Podfile 定义依赖的一个例子，不过 Podfile 对约束的描述其实是这样的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source(<span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&#x27;Demo&#x27;</span>) <span class="keyword">do</span></span><br><span class="line">pod(<span class="string">&#x27;Mantle&#x27;</span>, <span class="string">&#x27;~&gt; 1.5.1&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Podfile 中对于约束的描述，其实都可以看作是代码的简写，在解析时会当做 Ruby 代码来执行。</p><h3 id="简单搞个-Embedded-DSL"><a href="#简单搞个-Embedded-DSL" class="headerlink" title="简单搞个 Embedded DSL"></a>简单搞个 Embedded DSL</h3><p>使用 Ruby 实现嵌入式 DSL 一般需要三个步骤，这里以 CocoaPods 为例进行简单介绍：</p><ul><li>创建一个 Podfile 中“代码”执行的上下文，也就是一些方法；</li><li>读取 Podfile 中的内容到脚本中；</li><li>使用 <code>eval</code> 在上下文中执行 Podfile 中的“代码”；</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CocoaPods 对于 DSL 的实现基本上就是我们创建一个 DSL 的过程，定义一系列必要的方法，比如 <code>source</code>、<code>pod</code> 等等，创造一个执行的上下文；然后去读存储 DSL 的文件，并且使用 <code>eval</code> 执行。</p><p><strong>信息的传递一般都是通过参数</strong>来进行的，比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br></pre></td></tr></table></figure><p><code>source</code> 方法的参数就是依赖元信息 <code>Specs</code> 的 Git 地址，在 <code>eval</code> 执行时就会被读取到 CocoaPods 中，然后进行分析。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>下面是一个非常常见的 Podfile 内容：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;http://source.git&#x27;</span></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;Demo&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;SDWebImage&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;Masonry&#x27;</span></span><br><span class="line">    pod <span class="string">&quot;Typeset&quot;</span></span><br><span class="line">    pod <span class="string">&#x27;BlocksKit&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;Mantle&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;IQKeyboardManager&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;IQDropDownTextField&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因为这里的 <code>source</code>、<code>platform</code>、<code>target</code> 以及 <code>pod</code> 都是方法，所以在这里我们需要构建一个包含上述方法的上下文：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eval_pod.rb</span></span><br><span class="line"><span class="variable">$hash_value</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">source</span><span class="params">(url)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(target)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">platform</span><span class="params">(platform, version)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pod</span><span class="params">(pod)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用一个全局变量 <code>hash_value</code> 存储 Podfile 中指定的依赖，并且构建了一个 Podfile 解析脚本的骨架；我们先不去完善这些方法的实现细节，先尝试一下读取 Podfile 中的内容并执行 <code>eval</code> 看看会不会有问题。</p><p>在 <code>eval_pod.rb</code> 文件的最下面加入这几行代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content = File.read <span class="string">&#x27;./Podfile&#x27;</span></span><br><span class="line">eval content</span><br><span class="line">p <span class="variable">$hash</span>_value</span><br></pre></td></tr></table></figure><p>这里读取了 Podfile 文件中的内容，并把其中的内容当做字符串执行，最后打印 <code>hash_value</code> 的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby eval_pod.rb</span><br></pre></td></tr></table></figure><p>运行这段 Ruby 代码虽然并没有什么输出，但是并没有报出任何的错误，接下来我们就可以完善这些方法了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">source</span><span class="params">(url)</span></span></span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;source&#x27;</span>] = url</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(target)</span></span></span><br><span class="line">    targets = <span class="variable">$hash_value</span>[<span class="string">&#x27;targets&#x27;</span>]</span><br><span class="line">    targets = [] <span class="keyword">if</span> targets == <span class="literal">nil</span></span><br><span class="line">    targets &lt;&lt; target</span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;targets&#x27;</span>] = targets</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">if</span> block_given?</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">platform</span><span class="params">(platform, version)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pod</span><span class="params">(pod)</span></span></span><br><span class="line">    pods = <span class="variable">$hash_value</span>[<span class="string">&#x27;pods&#x27;</span>]</span><br><span class="line">    pods = [] <span class="keyword">if</span> pods == <span class="literal">nil</span></span><br><span class="line">    pods &lt;&lt; pod</span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;pods&#x27;</span>] = pods</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在添加了这些方法的实现之后，再次运行脚本就会得到 Podfile 中的依赖信息了，不过这里的实现非常简单的，很多情况都没有处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby eval_pod.rb</span><br><span class="line">&#123;<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;http://source.git&quot;</span>, <span class="string">&quot;targets&quot;</span>=&gt;[<span class="string">&quot;Demo&quot;</span>], <span class="string">&quot;pods&quot;</span>=&gt;[<span class="string">&quot;AFNetworking&quot;</span>, <span class="string">&quot;SDWebImage&quot;</span>, <span class="string">&quot;Masonry&quot;</span>, <span class="string">&quot;Typeset&quot;</span>, <span class="string">&quot;BlocksKit&quot;</span>, <span class="string">&quot;Mantle&quot;</span>, <span class="string">&quot;IQKeyboardManager&quot;</span>, <span class="string">&quot;IQDropDownTextField&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><p>不过使用 Ruby 构建一个嵌入式 DSL 的过程大概就是这样，使用语言内建的特性来进行创作，创造出一个在使用时看起来并不像代码的 DSL。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>在最后，笔者想说的是，当我们在某一个领域经常需要解决重复性问题时，可以考虑实现一个 DSL 专门用来解决这些类似的问题。</p><p>而使用嵌入式 DSL 来解决这些问题是一个非常好的办法，我们并不需要重新实现解释器，也可以利用宿主语言的抽象能力。</p><p>同时，在嵌入式 DSL 扩展了 DSL 的范畴之后，不要纠结于某些东西到底是框架还是领域特定语言，这些都不重要，重要的是，在遇到了某些问题时，我们能否跳出来，使用文中介绍的方法减轻我们的工作量。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>[No Silver Bullet—Essence and Accidents of Software Engineering](No Silver Bullet—Essence and Accidents of Software Engineering)</li><li><a href="https://en.wikipedia.org/wiki/Domain-specific_language">Domain-specific language</a></li><li><a href="http://martinfowler.com/bliki/DomainSpecificLanguage.html">DomainSpecificLanguage</a></li><li><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm">How browsers work</a></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><blockquote><p>GitHub Repo：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p></blockquote><blockquote><p>Source: <a href="https://draveness.me/dsl">https://draveness.me/dsl</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://draveness.me/dsl/&quot;&gt;谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 DSL 以及 D</summary>
      
    
    
    
    <category term="DSL" scheme="https://tenloy.github.io/categories/DSL/"/>
    
    
    <category term="DSL" scheme="https://tenloy.github.io/tags/DSL/"/>
    
  </entry>
  
  <entry>
    <title>常见的容器概念：Linux容器、Docker容器、服务器容器</title>
    <link href="https://tenloy.github.io/2021/04/29/05_Containers/"/>
    <id>https://tenloy.github.io/2021/04/29/05_Containers/</id>
    <published>2021-04-29T14:42:44.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、容器"><a href="#一、容器" class="headerlink" title="一、容器"></a>一、容器</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>汉语释义：</p><blockquote><p>容器(Container)是一种基础工具。泛指任何可以用于容纳其它物品的工具。</p></blockquote><p>容器的特性：</p><ul><li><p>可以部分或完全封闭。— 隔离性</p></li><li><p>被用于容纳、储存、运输物品。 — 便携性、换到程序的概念就是可移植性</p></li><li><p>物体可以被放置在容器中，而容器则可以保护内容物。— 安全</p></li></ul><h2 id="二、Linux容器与Docker容器"><a href="#二、Linux容器与Docker容器" class="headerlink" title="二、Linux容器与Docker容器"></a>二、Linux容器与Docker容器</h2><h3 id="2-1-诞生背景—环境配置的难题"><a href="#2-1-诞生背景—环境配置的难题" class="headerlink" title="2.1 诞生背景—环境配置的难题"></a>2.1 诞生背景—环境配置的难题</h3><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p><h3 id="2-2-虚拟机"><a href="#2-2-虚拟机" class="headerlink" title="2.2 虚拟机"></a>2.2 虚拟机</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p><p><strong>（1）资源占用多</strong></p><p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p><p><strong>（2）冗余步骤多</strong></p><p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p><p><strong>（3）启动慢</strong></p><p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><h3 id="2-3-Linux容器"><a href="#2-3-Linux容器" class="headerlink" title="2.3 Linux容器"></a>2.3 Linux容器</h3><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><h4 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h4><ul><li><p>Linux 容器技术能够让您对应用及其整个运行时环境（包括全部所需文件）一起进行打包或隔离。从而让您可以在不同环境（如开发、测试和生产等环境）之间轻松迁移应用，同时还可保留应用的全部功能。 —  <a href="https://www.redhat.com/zh/topics/containers">Red Hat官网</a></p></li><li><p>容器是包含在任何环境中运行所需的所有元素的软件包。是轻量级应用代码包，还包含了依赖项，例如编程语言运行时的特定版本和运行软件服务所需的库。 —  <a href="https://cloud.google.com/learn/what-are-containers?hl=zh-cn#section-1"> Google Cloud官网</a></p></li><li><p>Linux 容器，又称Linux软件容器，是一种操作系统层虚拟化技术，为Linux内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器(Container)，内含应用软件本身的代码，以及所需要的操作系统核心和库。</p><p>Linux 容器透过统一的名字空间和共享API来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得Linux用户可以容易的创建和管理系统或应用容器。— <a href="https://zh.wikipedia.org/wiki/LXC">维基百科</a></p></li></ul><p>总之：容器就是代码/应用程序+运行时环境</p><p>LXC通常被认为介于“加强版”的chroot和完全成熟的虚拟机之间的技术。LXC的目标是创建一个尽可能与标准安装的Linux相同但又不需要分离内核的环境。</p><p>容器虚拟化操作系统，可以在任何地方运行，不管目标环境是私有数据中心、公有云，还是开发者的个人笔记本电脑。</p><p>容器也是保障 IT 安全的一个重要组成部分。将安全性内置于容器管道，可以为基础架构增添防护，从而保障容器的可靠性、可扩展性和信赖度。</p><h4 id="2-3-2-优势"><a href="#2-3-2-优势" class="headerlink" title="2.3.2 优势"></a>2.3.2 优势</h4><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>由于容器是进程级别的，相比虚拟机有很多优势。</p><p><strong>（1）启动快</strong></p><p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p><p><strong>（2）资源占用少</strong></p><p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p><p><strong>（3）体积小</strong></p><p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p><p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h4 id="2-3-3-使用"><a href="#2-3-3-使用" class="headerlink" title="2.3.3 使用"></a>2.3.3 使用</h4><p>LXC的使用：</p><ul><li><p>Proxmox VE: 它直到4.0版才使用LXC技术，在此之前的版本都是使用OpenVZ技术。</p></li><li><p>Docker：它在0.9版之前都是使用LXC技术，但在0.9版之后，已不再是唯一且默认的运行环境。</p><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p></li></ul><h3 id="2-4-Docker容器"><a href="#2-4-Docker容器" class="headerlink" title="2.4 Docker容器"></a>2.4 Docker容器</h3><p><a href="https://yeasy.gitbook.io/docker_practice/">Docker — 从入门到实践</a></p><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><ul><li>最初实现是基于 LXC</li><li>从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer</li><li>从 1.11 版本开始，则进一步演进为使用 runC 和 containerd。</li></ul><p><strong>Docker</strong> 自开源后受到广泛的关注和讨论，至今其 <a href="https://github.com/moby/moby">GitHub 项目</a> 已经超过 6 万 多个星标和一万多个 <code>fork</code>。甚至由于 <code>Docker</code> 项目的火爆，在 <code>2013</code> 年底，dotCloud 公司决定改名为 Docker。<code>Docker</code> 最初是在 <code>Ubuntu 12.04</code> 上开发实现的；<code>Red Hat</code> 则从 <code>RHEL 6.5</code> 开始对 <code>Docker</code> 进行支持；<code>Google</code> 也在其 <code>PaaS</code> 产品中广泛应用 <code>Docker</code>。</p><h4 id="2-4-2-用途"><a href="#2-4-2-用途" class="headerlink" title="2.4.2 用途"></a>2.4.2 用途</h4><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h4 id="2-4-3-镜像Image"><a href="#2-4-3-镜像Image" class="headerlink" title="2.4.3 镜像Image"></a>2.4.3 镜像Image</h4><p>镜像Image于Docker容器（本质上还是程序与进程的区别？）</p><h5 id="1-引自Docker网站"><a href="#1-引自Docker网站" class="headerlink" title="1) 引自Docker网站"></a>1) 引自Docker网站</h5><p>镜像/映像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p><strong>容器映像</strong>：包含创建容器所需的所有依赖项和信息的包。 映像包括所有依赖项（例如框架），以及容器运行时使用的部署和执行配置。 通常情况下，映像派生自多个基础映像，这些基础映像是堆叠在一起形成容器文件系统的层。 创建后，映像不可变。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><h5 id="2-引自阮一峰"><a href="#2-引自阮一峰" class="headerlink" title="2) 引自阮一峰"></a>2) 引自阮一峰</h5><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><h3 id="2-5-容器与虚拟机的区别"><a href="#2-5-容器与虚拟机的区别" class="headerlink" title="2.5 容器与虚拟机的区别"></a>2.5 容器与虚拟机的区别</h3><p>虚拟机：一种运行在主机操作系统之上，可以访问底层硬件的客机操作系统，例如Linux 或 Windows。</p><p>容器常常被拿来和虚拟机 (VM) 比较。与虚拟机相似，容器也可以让您将应用与库和其他依赖项打包，提供独立环境来运行您的软件服务。</p><p>但是两者的相似性仅此而已，因为容器为开发者和 IT 运营团队提供了更加轻型、具有众多优势的运营单元。</p><ul><li>容器比虚拟机更加轻量化</li><li>容器在操作系统级别进行虚拟化，而虚拟机在硬件级别进行虚拟化</li><li>容器共享操作系统内核，其占用的内存与虚拟机相比微乎其微</li></ul><h3 id="2-6-容器化的优势"><a href="#2-6-容器化的优势" class="headerlink" title="2.6 容器化的优势"></a>2.6 容器化的优势</h3><p>容器化是软件开发的一种方法，通过该方法可将应用程序或服务、其依赖项及其配置（抽象化为部署清单文件）一起打包为容器映像。容器化应用程序可以作为一个单元进行测试，并可以作为容器映像实例部署到主机操作系统 (OS)。 <a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/container-docker-introduction/">参考链接</a></p><p>容器在整个应用程序生命周期工作流中提供以下优点：</p><ul><li><p><strong>责任分离</strong>：容器化使开发者和 IT 运营团队的责任泾渭分明，开发者专注于应用逻辑和依赖项，而 IT 运营团队可以专注于部署和管理，不必为应用细节分心，例如具体的软件版本和配置。</p></li><li><p><strong>工作负载可移植性</strong>：</p><ul><li>软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。 按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境。</li><li>容器几乎能在任何地方运行，极大减轻了开发和部署工作量：在 Linux、Windows 和 Mac 操作系统中；在虚拟机或物理服务器上；在开发者的机器或本地数据中心的机器上；当然还有在公有云上。</li><li>就像船只、火车或卡车运输集装箱而不管其内部是什么货物一样。</li></ul></li><li><p><strong>应用隔离/隔离性</strong>：容器会在操作系统级别虚拟化 CPU、内存、存储和网络资源，为开发者提供在逻辑上与其他应用相隔离的操作系统接口，即在共享 OS 上将应用程序彼此隔离开。</p></li><li><p><strong>灵活性</strong>：轻量级。容器化应用程序在容器主机上运行，而容器主机在 OS（Linux 或 Windows）上运行。 因此，容器的占用比虚拟机 (VM) 映像小得多。</p><p>每个容器可以运行整个 Web 应用或服务，如下图所示，在一个容器主机上运行多个容器。 在此示例中，Docker 主机是容器主机，而 App1、App2、Svc 1 和 Svc 2 是容器化应用程序或服务。</p></li></ul><img src = '/images/Docker/multiple-containers-single-host.png' width = '50%'><ul><li><p><strong>可伸缩性</strong>：通过为短期任务创建新容器，可以快速扩大。 从应用程序的角度来看，实例化映像（创建容器）类似于实例化 服务或 Web 应用等进程。 </p><p>但出于可靠性考虑，在多个主机服务器上运行同一映像的多个实例时，通常要使每个容器（映像实例）在不同容错域中的不同主机服务器或 VM 中运行。</p></li></ul><h2 id="三、服务器与容器"><a href="#三、服务器与容器" class="headerlink" title="三、服务器与容器"></a>三、服务器与容器</h2><h3 id="3-1-服务器-server"><a href="#3-1-服务器-server" class="headerlink" title="3.1 服务器(server)"></a>3.1 服务器(server)</h3><p>服务器(server)指：<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a></p><ul><li><p>一个管理资源并为用户提供服务的计算机软件，通常分为文件服务器（能使用户在其它计算机访问文件），数据库服务器和应用程序服务器。</p></li><li><p>运行以上软件的计算机，或称为网络主机（host）。通常是指那些具有较高计算能力，能够提供给多个用户使用的计算机。</p></li></ul><p>有时，这两种定义会引起混淆。如网页服务器：</p><ul><li>它可能是指用于网站的计算机。</li><li>也可能是指像Apache这样的软件，运行在这样的计算机上以管理网页组件和回应网页浏览器的请求。</li></ul><p>根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，Web服务器等。</p><h4 id="3-1-1-作为硬件"><a href="#3-1-1-作为硬件" class="headerlink" title="3.1.1 作为硬件"></a>3.1.1 作为硬件</h4><p>服务器与PC机的不同点很多：</p><ul><li>服务器的最大特点就是其强大的运算能力或是具备大量磁盘存储空间，使其能在短时间内完成大量工作及负载大量的文件资料存储，并为大量用户提供服务。</li><li>服务器通常以网络作为介质，既可以通过内部网对内提供服务，也可以通过互联网对外提供服务。所以PC机在一个时刻通常只为一个用户服务。而服务器能够通过网络同时提供给多个用户使用</li><li>和普通的个人电脑相比， 服务器需要连续的工作在7×24小时环境。这就意味着服务器需要更多的稳定性技术RAS，比如支持使用ECC存储器。</li></ul><h4 id="3-1-2-作为软件"><a href="#3-1-2-作为软件" class="headerlink" title="3.1.2 作为软件"></a>3.1.2 作为软件</h4><p>服务器软件工作在客户端-服务器或浏览器-服务器的方式，有很多形式的服务器，常用的包括：</p><ul><li><p>文件服务器(file server)或网络存储设备(network attached storage)</p></li><li><p>数据库服务器(database server) —— 如Oracle数据库服务器，MySQL，MariaDB，PostgreSQL，Microsoft SQL Server，MongoDB，Redis等；</p></li><li><p>应用程序服务器(application server/AP server)</p><ul><li><strong>运行应用程序，提供应用程序所实现服务</strong>。通常来说，<strong>服务器端的应用程序实现各种业务逻辑，应用服务器通过各种协议把这些业务逻辑曝露给客户端的程序</strong>。它提供了访问业务逻辑的途径，以供客户端应用程序使用。应用服务器使用此业务逻辑就像调用对象的一个方法一样。</li><li>如Bea公司的WebLogic、JBoss、Sun的GlassFish，及Tomcat、Jetty、Websphere、JBoss等都是Java EE WEB应用服务器/<strong>Java EE服务器</strong><ul><li>Java EE服务器是实现Java EE技术规范，并提供标准Java EE服务的应用程序服务器。</li><li>Java EE服务器有时称为应用服务器，因为它们允许您向客户端提供应用数据，就像Web服务器向Web浏览器提供Web页面一样。</li></ul></li></ul></li><li><p>网页服务器(Web server) </p><ul><li>WEB：现广泛译作网络、互联网等技术领域。表现为三种形式，即<strong>超文本（hypertext）、超媒体（hypermedia）、超文本传输协议（HTTP）</strong>等。</li><li>Web server可以向浏览器等WEB客户端提供文档浏览、数据文件下载等WEB服务。</li><li>如Apache、lighttpd、nginx、微软的IIS等；</li></ul></li><li><p>FTP服务器（FTP server）—— Pureftpd、Proftpd、WU-ftpd、Serv-U、vs-ftpd等；</p></li><li><p>邮件服务器(mail server)</p></li><li><p>域名服务器（DNS server）—— 如BIND等</p></li><li><p>代理服务器（proxy server）—— 如Squid cache</p></li><li><p>其他，如Active Directory服务器、Minecraft游戏服务器等</p></li><li><p>补充：WEB应用服务器</p><ul><li><p>上面我们把应用服务器和WEB服务器严格区分：应用服务器通过应用程序接口(通常是网络请求API）把业务逻辑暴露给客户端应用程序。而WEB服务器通过HTTP提供静态内容给浏览器等客户端。</p><p>如果不严格区分，应用服务器包含WEB服务器，因为WEB服务器是WEB服务应用程序实现的。</p></li><li><p>WEB应用服务器：结合应用服务器和WEB服务器，可以说，它是带应用服务器的Web服务器，接收HTTP请求后，既能返回页面等静态内容，又能处理业务逻辑返回数据。</p></li></ul></li></ul><img src = '/images/Docker/servers.jpg' width = '70%' align:left style='margin-left:10%'><h3 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h3><p>如果说Linux、Docker容器是装满物体的容器：应用/服务程序 + 运行时环境</p><p>那么服务器中说的容器就是纯指未装物体的容器：运行时环境 — <strong>可以部署应用程序，使其在上面运行的环境</strong>。</p><img src = '/images/Docker/container_server.jpg' width = '50%' align:left style='margin-left:10%'><p>容器是服务器中位于应用程序/组件和平台之间的<code>接口集合</code>。它处理屏蔽了服务器平台的复杂性(如线程安全、事务、网络、资源等细节)，使得应用程序在它的基础上可以方便快捷的部署。<a href="https://zh.wikipedia.org/zh-hans/Web%E5%AE%B9%E5%99%A8">Web容器</a></p><ul><li><p>容器管理组件的生命周期，向应用程序组件分派请求，并提供与上下文数据（如关于当前请求的信息）的接口。</p></li><li><p>容器一般位于服务器之内，由服务器负责加载和维护。一个容器只能存在于一个服务器之内，一个服务器可以创建和维护多个容器。</p></li><li><p>容器一般遵守可配置的原则，即容器的用户可以通过对容器参数的配置，来达到自己的使用需求，而不需要修改容器的代码。</p></li></ul><p>根据接口实现的规范、用途不同，常见的分类有：</p><img src = '/images/Docker/containers.jpg' width = '70%' align:left style='margin-left:10%'><h4 id="3-2-1-Servlet容器"><a href="#3-2-1-Servlet容器" class="headerlink" title="3.2.1 Servlet容器"></a>3.2.1 Servlet容器</h4><p>Servlet：属于Java EE重要技术规范，构建了”接收请求–调用servlet程序处理–返回响应”基本模型。</p><p>Servlet程序：Java提供了开发Servlet程序的API，该API可以说Servlet容器的一部分，它对接应用程序与Servlet容器；</p><p>Servlet容器：就是<strong>实现了Servlet</strong>技术规范的部署环境，它可以部署运行Servlet程序。</p><h4 id="3-2-2-Java-WEB容器"><a href="#3-2-2-Java-WEB容器" class="headerlink" title="3.2.2 Java WEB容器"></a>3.2.2 Java WEB容器</h4><p>WEB容器：可以部署多个WEB应用程序的环境。</p><p>Java WEB容器：<strong>实现了Java EE</strong>规定的WEB应用技术规范的的部署环境。</p><p>Java EE WEB应用技术规范：Servlet、JSP（JavaServer Pages）、Java WebSocket等。</p><p>所以，完整的<strong>Java WEB</strong>容器包含Servlet容器。</p><h4 id="3-2-3-Java-EE容器"><a href="#3-2-3-Java-EE容器" class="headerlink" title="3.2.3 Java EE容器"></a>3.2.3 Java EE容器</h4><p>Java EE容器：实现了Java EE技术规范的部署环境。</p><p>Java EE技术规范：除了上面说的Servlet、JSP等Java EE WEB应用技术规范，还包括EJB（Enterprise JavaBeans）等许多技术规范。</p><p>所以，<strong>完整的Java EE</strong>容器包含Java WEB容器（Servlet容器）、EJB容器等。</p><h3 id="3-3-举例说明容器与服务器的联系"><a href="#3-3-举例说明容器与服务器的联系" class="headerlink" title="3.3 举例说明容器与服务器的联系"></a>3.3 举例说明容器与服务器的联系</h3><blockquote><p>服务器是指管理资源并为用户提供服务的计算机软件，或运行该软件的硬件设备。</p></blockquote><blockquote><p>容器是对服务器平台上接口的一层上层封装，屏蔽一些复杂性，提供简化版的接口。使得程序可以在其上快捷的开发和部署运行。</p></blockquote><h4 id="3-3-1-Apache、Nginx、IIS"><a href="#3-3-1-Apache、Nginx、IIS" class="headerlink" title="3.3.1 Apache、Nginx、IIS"></a>3.3.1 Apache、Nginx、IIS</h4><p>Apache、Nginx、IIS是目前主流的三个Web服务器。</p><p>但是可以用它们来构建WEB应用服务器，通常它们发现一个请求是动态请求，就通过CGI、ISAPI、特殊管道等协议接口调用后面的应用服务器来协同处理请求。如Nginx通过fastCGI模块来调用ZendEngine执行PHP应用来处理PHP请求。</p><h4 id="3-3-2-Tomcat及常见的JavaEE应用服务器"><a href="#3-3-2-Tomcat及常见的JavaEE应用服务器" class="headerlink" title="3.3.2 Tomcat及常见的JavaEE应用服务器"></a>3.3.2 Tomcat及常见的JavaEE应用服务器</h4><p>Tomcat、Jetty、WebLogic、Websphere、JBoss都是Java（EE） WEB应用服务器。</p><p>Tomcat</p><ul><li>按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）、Java Expression Language 和 Java WebSocket（Java EE）技术的支持。并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。</li><li>因为实现了Servlet规范，所以可以称为是一个Servlet容器，可以运行Servlet程序</li><li>由于Tomcat本身也内含了HTTP服务器，可以通过HTTP提供HTML页面等静态内容的请求访问，因此也可以视作是一个Web服务器。</li><li>因为可以通过Servlet容器，调用Servlet处理动态请求，所以也是一个应用服务器；</li></ul><p>所以，可以说Tomcat是Java（EE） WEB应用服务器。</p><p>注意，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是用C语言实现的HTTPWeb服务器；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</p><p>Tomcat提供了一个Jasper编译器用以将JSP编译成对应的Servlet。</p><p>Tomcat的Servlet引擎通常与Apache或者其他Web服务器一起工作。除了用于开发过程中的调试以及那些对速度和事务处理只有很小要求的用户，很少会将Tomcat单独作为Web服务器。但随着版本的更新，正有越来越多的用户将其单独作为Web服务器用以那些对速度和可靠性有较高要求的环境中。</p><h4 id="3-3-3-Nginx-Tomcat的WEB应用服务器-集群"><a href="#3-3-3-Nginx-Tomcat的WEB应用服务器-集群" class="headerlink" title="3.3.3 Nginx + Tomcat的WEB应用服务器(集群)"></a>3.3.3 Nginx + Tomcat的WEB应用服务器(集群)</h4><img src = '/images/Docker/nginx_tomcat.jpg' width = '50%' align:left style='margin-left:10%'><p>一般在实际应用中：</p><ul><li>先是通过Nginx反向代理服务器(reverse proxy server)接收请求，匹配分离动态/静态请求（动静分离）</li><li>如果是静态请求，则转发到另外的Nginx WEB服务器上，返回静态内容；</li><li>如果是动态请求，则转发到后面的Tomcat应用服务器，处理动态请求的业务逻辑。</li></ul><p><a href="https://blog.csdn.net/tjiyu/article/details/53148174">参考链接 — 各种容器与服务器的区别与联系</a></p><h2 id="五、iOS的容器化"><a href="#五、iOS的容器化" class="headerlink" title="五、iOS的容器化"></a>五、iOS的容器化</h2><h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>容器在不同场景下的含义</p><ol><li><p>字面意思，容器就是指容纳小物品的事物，比如：</p><ol><li>UIStackview</li><li>自定义的Container视图组件</li><li>前端组件化开发中的页面充当的角色(将一个页面分成很多个组件，此处页面就相当于是个纯粹的容器)</li></ol></li><li><p>代码/数据的运行环境，完成代码的解释/数据解析。比如：</p><ol><li><p>美团，后端返回协商好的结构化的数据，移动端对数据进行解析，还原成界面的layout。进行视图创建、渲染</p></li><li><p>上面的Docker容器</p></li><li><p>服务器容器</p></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、容器&quot;&gt;&lt;a href=&quot;#一、容器&quot; class=&quot;headerlink&quot; title=&quot;一、容器&quot;&gt;&lt;/a&gt;一、容器&lt;/h2&gt;&lt;h3 id=&quot;1-1-定义&quot;&gt;&lt;a href=&quot;#1-1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 定</summary>
      
    
    
    
    <category term="容器化" scheme="https://tenloy.github.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>[转]Docker入门教程</title>
    <link href="https://tenloy.github.io/2021/04/28/04_Dock-Reprinted-from-RuanYIFeng/"/>
    <id>https://tenloy.github.io/2021/04/28/04_Dock-Reprinted-from-RuanYIFeng/</id>
    <published>2021-04-28T15:10:28.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">原文链接 — 《Docker 入门教程》</a></p><p>2013年发布至今， <a href="https://www.docker.com/">Docker</a> 一直广受瞩目，被认为可能会改变软件行业。</p><p>但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。</p><img src='/images/Docker/docker_logo.png' width = '60%'><h2 id="一、环境配置的难题"><a href="#一、环境配置的难题" class="headerlink" title="一、环境配置的难题"></a>一、环境配置的难题</h2><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p><h2 id="二、虚拟机"><a href="#二、虚拟机" class="headerlink" title="二、虚拟机"></a>二、虚拟机</h2><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p><p><strong>（1）资源占用多</strong></p><p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p><p><strong>（2）冗余步骤多</strong></p><p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p><p><strong>（3）启动慢</strong></p><p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><h2 id="三、Linux-容器"><a href="#三、Linux-容器" class="headerlink" title="三、Linux 容器"></a>三、Linux 容器</h2><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>由于容器是进程级别的，相比虚拟机有很多优势。</p><p><strong>（1）启动快</strong></p><p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p><p><strong>（2）资源占用少</strong></p><p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p><p><strong>（3）体积小</strong></p><p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p><p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h2 id="四、Docker-是什么？"><a href="#四、Docker-是什么？" class="headerlink" title="四、Docker 是什么？"></a>四、Docker 是什么？</h2><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h2 id="五、Docker-的用途"><a href="#五、Docker-的用途" class="headerlink" title="五、Docker 的用途"></a>五、Docker 的用途</h2><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h2 id="六、Docker-的安装"><a href="#六、Docker-的安装" class="headerlink" title="六、Docker 的安装"></a>六、Docker 的安装</h2><p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p><p>Docker CE 的安装请参考官方文档。</p><blockquote><ul><li><a href="https://docs.docker.com/docker-for-mac/install/">Mac</a></li><li><a href="https://docs.docker.com/docker-for-windows/install/">Windows</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/debian/">Debian</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/centos/">CentOS</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/fedora/">Fedora</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/binaries/">其他 Linux 发行版</a></li></ul></blockquote><p>安装完成后，运行下面的命令，验证是否安装成功。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker info</span><br></pre></td></tr></table></figure></blockquote><p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组（<a href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user">官方文档</a>）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></blockquote><p>Docker 是服务器—-客户端架构。命令行运行<code>docker</code>命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（<a href="https://docs.docker.com/config/daemon/systemd/">官方文档</a>）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service 命令的用法</span></span><br><span class="line">$ sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># systemctl 命令的用法</span></span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></blockquote><h2 id="六、image-文件"><a href="#六、image-文件" class="headerlink" title="六、image 文件"></a>六、image 文件</h2><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure></blockquote><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><h2 id="七、实例：hello-world"><a href="#七、实例：hello-world" class="headerlink" title="七、实例：hello world"></a>七、实例：hello world</h2><p>下面，我们通过最简单的 image 文件”<a href="https://hub.docker.com/r/library/hello-world/">hello world”</a>，感受一下 Docker。</p><p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在<a href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">下一篇文章</a>的第一节。有需要的朋友，可以先看一下。</p><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull library/hello-world</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull hello-world</span><br></pre></td></tr></table></figure></blockquote><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure></blockquote><p>现在，运行这个 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br></pre></td></tr></table></figure></blockquote><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure></blockquote><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -it ubuntu bash</span><br></pre></td></tr></table></figure></blockquote><p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br></pre></td></tr></table></figure></blockquote><h2 id="八、容器文件"><a href="#八、容器文件" class="headerlink" title="八、容器文件"></a>八、容器文件</h2><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container ls --all</span><br></pre></td></tr></table></figure></blockquote><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href="https://docs.docker.com/engine/reference/commandline/container_rm/"><code>docker container rm</code></a>命令删除。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h2 id="九、Dockerfile-文件"><a href="#九、Dockerfile-文件" class="headerlink" title="九、Dockerfile 文件"></a>九、Dockerfile 文件</h2><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p><h2 id="十、实例：制作自己的-Docker-容器"><a href="#十、实例：制作自己的-Docker-容器" class="headerlink" title="十、实例：制作自己的 Docker 容器"></a>十、实例：制作自己的 Docker 容器</h2><p>下面我以 <a href="https://www.ruanyifeng.com/blog/2017/08/koa.html">koa-demos</a> 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p><p>作为准备工作，请先<a href="https://github.com/ruanyf/koa-demos/archive/master.zip">下载源码</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ruanyf/koa-demos.git</span><br><span class="line">$ <span class="built_in">cd</span> koa-demos</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-1-编写-Dockerfile-文件"><a href="#10-1-编写-Dockerfile-文件" class="headerlink" title="10.1 编写 Dockerfile 文件"></a>10.1 编写 Dockerfile 文件</h3><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore">内容</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></blockquote><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile">内容</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure></blockquote><p>上面代码一共五行，含义如下。</p><blockquote><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul></blockquote><h3 id="10-2-创建-image-文件"><a href="#10-2-创建-image-文件" class="headerlink" title="10.2 创建 image 文件"></a>10.2 创建 image 文件</h3><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-3-生成容器"><a href="#10-3-生成容器" class="headerlink" title="10.3 生成容器"></a>10.3 生成容器</h3><p><code>docker container run</code>命令会从 image 文件生成容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p>上面命令的各个参数含义如下：</p><blockquote><ul><li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul></blockquote><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment">#</span></span><br></pre></td></tr></table></figure></blockquote><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment"># node demos/01.js</span></span><br></pre></td></tr></table></figure></blockquote><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 <a href="https://github.com/ruanyf/koa-demos/blob/master/demos/01.js">demo</a> 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本机的另一个终端窗口，查出容器的 ID</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查出容器的 ID</span></span><br><span class="line">$ docker container ls --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-4-CMD-命令"><a href="#10-4-CMD-命令" class="headerlink" title="10.4 CMD 命令"></a>10.4 CMD 命令</h3><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure></blockquote><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-5-发布-image-文件"><a href="#10-5-发布-image-文件" class="headerlink" title="10.5 发布 image 文件"></a>10.5 发布 image 文件</h3><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去 <a href="https://hub.docker.com/">hub.docker.com</a> 或 <a href="https://cloud.docker.com/">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure></blockquote><p>接着，为本地的 image 标注用户名和版本。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure></blockquote><p>也可以不标注用户名，重新构建一下 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure></blockquote><p>最后，发布 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure></blockquote><p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p><h2 id="十一、其他有用的命令"><a href="#十一、其他有用的命令" class="headerlink" title="十一、其他有用的命令"></a>十一、其他有用的命令</h2><p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p><p><strong>（1）docker container start</strong></p><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>（2）docker container stop</strong></p><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash container stop [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><p><strong>（3）docker container logs</strong></p><p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>（4）docker container exec</strong></p><p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p><strong>（5）docker container cp</strong></p><p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot;&gt;原文链接 — 《Docker 入门教程》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2013年发布至今， &lt;a href=&quot;https://www.do</summary>
      
    
    
    
    <category term="容器化" scheme="https://tenloy.github.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
    <category term="Docker" scheme="https://tenloy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>同步和异步解读及编程中的使用场景</title>
    <link href="https://tenloy.github.io/2021/04/20/03-7_Sync-Async/"/>
    <id>https://tenloy.github.io/2021/04/20/03-7_Sync-Async/</id>
    <published>2021-04-20T20:05:13.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、同步"><a href="#一、同步" class="headerlink" title="一、同步"></a>一、同步</h2><blockquote><p>协调，实现步调一致。两个或几个随时间变化的量，在变化过程中(在时域序列上相对位置)保持一定的相对/约束关系(这个关系分很多种：可以是两者 <code>同时</code>做指定的事、也可以是两者 <code>先后</code>做指定的事等)。</p></blockquote><p>比如：</p><ul><li>音画同步、动作同步等。指某人/事 <code>同时</code>产生，同时进行。</li><li>云同步等。在时间上保持一致性与统一化的现象。</li><li>同步。两部分任务之间按照 <code>先后</code>顺序进行。<ul><li>线程同步：一者暂停(在时域中是一个横线)，等另一者执行完成，再继续</li></ul></li></ul><p>注意：</p><blockquote><p>简单来说：同步就是一段时间内，规定<code>同一时间标准的每一刻</code>（注解1），每个模块(设备/部件/线程)分别应该完成什么(变化)，且各模块的<code>变化之间有一定的相对/约束关系</code>(注解2)</p></blockquote><ol><li><code>当两个设备需要有同步关系的时候，需要在两个设备之间规定一个共同的时间参考(时钟)。</code>即由同宽同距(同频同相)的时钟信号控制每个设备(部件/线程)，分别完成相应的操作</li><li>这两(多)个量的变化之间 <code>可能</code>没有联系，突出的是这两(多)个量<code>一段时间段内随时间的变化过程之间的对应关系</code>。比如上述第一个例子中两者的变化没有联系，而第二个例子中是一者的变化引起另一者的变化</li></ol><h2 id="二、异步"><a href="#二、异步" class="headerlink" title="二、异步"></a>二、异步</h2><blockquote><p>与同步概念相反，两(多)者在随时间变化过程中没有相对/约束关系</p></blockquote><p>比如：</p><ul><li>异步：多线程异步、进程异步</li><li>异步传输：一种通讯方式，对设备需求简单，异步双方不需要共同的时钟。</li></ul><h2 id="三、编程中的使用"><a href="#三、编程中的使用" class="headerlink" title="三、编程中的使用"></a>三、编程中的使用</h2><p>在操作系统中：同步执行的代码的执行过程有顺序性。而并发带来的异步性，每个进(线)程的代码都以其相对独立的不可预知的速度向前推进。</p><p>在计算机中，同步异步常见的两处使用场景：</p><ul><li>线程同步、异步</li><li>同步通信、异步通信(指的是计算机内部件之间的通信)</li><li>同步传输、异步传输(指的是计算机网络中的数据传输，原理基本上与上相同，增加了一些内容，详见下文)</li></ul><h3 id="3-1-线程同步、异步"><a href="#3-1-线程同步、异步" class="headerlink" title="3.1 线程同步、异步"></a>3.1 线程同步、异步</h3><h4 id="3-1-1-同步"><a href="#3-1-1-同步" class="headerlink" title="3.1.1 同步"></a>3.1.1 同步</h4><p>线程之间存在一定的约束关系，在执行过程中，存在一定的<code>前后顺序</code>。可能是出于临界资源的占用，也可能是等待另一条线程执行结果的返回等原因，需要执行完前一个，才能再执行下一个，<code>需要等待、协调运行</code></p><h4 id="3-1-1-异步"><a href="#3-1-1-异步" class="headerlink" title="3.1.1 异步"></a>3.1.1 异步</h4><p>紧贴上面的概念，异步可以解释为两(多)者之间在随时间的执行过程中，两者之间没有约束关系，相互独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。</p><p><code>异步和多线程并不是一个同等关系，异步是最终目的，多线程只是我们实现异步的一种手段</code>。异步是当一个调用请求发送给被调用者，而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。</p><h3 id="3-2-同步通信、异步通信"><a href="#3-2-同步通信、异步通信" class="headerlink" title="3.2 同步通信、异步通信"></a>3.2 同步通信、异步通信</h3><p>总线通信控制主要解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调如何配合，通常用4种方式：同步通信、异步通信、半同步通信、分离式通信。</p><ul><li><p>同步通信中通信双方由统一时标控制数据传送。即双方按统一的传输周期进行信息传输，双方按约定好的时序进行联络，在规定的时钟周期内分别完成相应的操作。</p></li><li><p>异步通信中没有公共的时钟标准，不要求所有部件严格的统一操作时间，而是采用应答方式(又称握手方式)，即当主模块发出请求信号时，一直等待从模块反馈回来响应信号后，才开始通信。</p></li><li><p>异步通信的应答方式又可分为不互锁、半互锁和全互锁三种类型。不互锁方式通信双方没有相互制约关系；半互锁方式通信双方有简单的制约关系；全互锁方式通信双方有完全的制约关系。其中全互锁通信可靠性最高；</p></li></ul><p>详见总线通信控制 ——《计组》</p><h3 id="3-3-同步、异步传输"><a href="#3-3-同步、异步传输" class="headerlink" title="3.3 同步、异步传输"></a>3.3 同步、异步传输</h3><p>在网络通信过程中，通信双方要交换数据，需要高度的协同工作。为了正确的解释信号，接收方必须确切地知道信号应当何时接收和处理，因此定时是至关重要的。</p><p>在计算机网络中，定时的因素称为位同步。同步是要接收方按照发送方发送的每个位的起止时刻和速率来接收数据，否则会产生误差。</p><p>通常可以采用同步或异步的传输方式对位进行同步处理。</p><p>首先是两者的不同</p><table><thead><tr><th></th><th>同步传输</th><th>异步传输</th></tr></thead><tbody><tr><td><code>同步</code></td><td><code>外同步</code></td><td><code>自同步</code>（见底部总结）</td></tr><tr><td>传输格式</td><td>面向 <code>比特</code>的传输，每个信息帧中包含若干个字符( <code>单位是帧</code>)</td><td>面向 <code>字符</code>的传输，每个字符帧只包含一个字符( <code>单位是字符</code>)</td></tr><tr><td>时钟</td><td>要求接收时钟和发送时钟同频同相，通过特定的时钟线路协调时序</td><td>不要求接收时钟和发送时钟完全同步，对时序的要求较低</td></tr><tr><td>数据流</td><td>发送端发送<code>连续</code>的比特流</td><td>发送端发送完一个字节后，可经过任意长的时间间隔再发送</td></tr></tbody></table><p>是否拥有同一个时钟序列进行工作，或者是以数据块为单位进行数据传输，是同步传输和异步传输之间的差别；</p><p>同步效率更高，更加适合对速度要求高的传输，当然这种通信对时序的要求也更高，硬件更复杂。</p><h4 id="3-3-1-位同步"><a href="#3-3-1-位同步" class="headerlink" title="3.3.1 位同步"></a>3.3.1 位同步</h4><p>要求接收端根据发送端发送数据的起止时间和时钟频率，来校正自己的时间基准和时钟频率，这个过程叫位同步。可见，位同步的目的是使接收端接收的每一位信息都与发送端保持同步。</p><img src = '/images/OS/bit_sync.png' width = '80%'><h4 id="3-3-2-同步通信"><a href="#3-3-2-同步通信" class="headerlink" title="3.3.2 同步通信"></a>3.3.2 同步通信</h4><p>同步通信是一种比特同步通信技术，要求发收双方具有同频同相的同步时钟信号，只需在传送报文的最前面附加特定的同步字符，当接收端确认接收到同步字符后，发收双方建立同步，此后便在 <code>同步时钟的控制下</code>逐位发送/接收。</p><p>同步通信是一种连续串行传送数据的通信方式，一次通信只传送一帧信息，<code>由同步字符、数据字符和校验字符（CRC）组成。(见上图)</code></p><ul><li>同步字符：位于帧的开头，用于确认数据字符的开始；</li><li>数据字符：在同步字符之后，个数没有限制，由所需传输的数据块长度来决定；</li><li>校验字符：有1到2个，用于接收端对接收到的字符序列进行正确性的校验</li></ul><p>同步这种方式中因为分组相比异步大得多，很长一段数据才会有额外的辅助位负载，所以效率更高，更加适合对速度要求高的传输，当然这种通信对时序的要求也更高。</p><p>随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。</p><p>另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。</p><blockquote><p>“同步通信”的通信双方必须先建立同步，即双方的时钟要调整到同一个频率。收发双方不停地发送和接收连续的同步比特流。但这时还有两种不同的同步方式。一种是使用全网同步，用一个非常精确的主时钟对全网所有结点上的时钟进行同步。另一种是使用准同步，各结点的时钟之间允许有微小的误差，然后采用其他措施实现同步传输。</p></blockquote><h4 id="3-3-3-异步通信"><a href="#3-3-3-异步通信" class="headerlink" title="3.3.3 异步通信"></a>3.3.3 异步通信</h4><blockquote><p>异步通信指两个互不同步的设备通过计时机制或其他技术进行数据传输。异步通信中两个字符之间的时间间隔是不固定的，而在一个字符内各位的时间间隔是固定的。基本上，发送方可以随时传输数据，而接收方必须在信息到达时准备好接收。</p></blockquote><p>这种传输通常是很小的分组，比如一个字符为一组，为这个组配备起始位和结束位。所以这种传输方式的效率是比较低的，毕竟额外加入了很多的辅助位作为负载，常用在低速的传输中。</p><p>异步通信，是以字符或者字节为单位组成字符帧进行传输。<code>字符帧格式中包括空闲位、起始位、资料位、奇偶校验位、停止位。(见上图)</code></p><p>以RS232协议规定为例，异步通信一个字符一个字符地传输，每个字符一位一位地传输，并且传输一个字符时：</p><ul><li>总是以“起始位”开始（低电平，逻辑值0），以“停止位”结束，字符之间没有固定的时间间隔要求。</li><li>字符数据本身由5~8位数据位组成，接着字符后面是一位校验位（也可以没有校验位）</li><li>最后是一位或一位半或二位停止位</li><li>停止位后面是不定长的空闲位(处于逻辑“1”状态，表示当前线路上没有资料传送)。</li><li>停止位和空闲位都规定为高电平（逻辑值１），这样就保证起始位开始处一定有一个下跳沿。</li></ul><p>异步通信是按字符传输的，接收设备在收到起始信号之后只要在一个字符的传输时间内能和发送设备保持同步就能正确接收。下一个字符起始位的到来又使同步重新校准(<code>依靠检测起始位来实现发送与接收方的时钟 自同步的</code>)。这样，只要发送端和接收端协商好字符帧格式和波特率，就可以由各自的时钟来控制数据的发送和接收。</p><p>举个例子，我们的键盘按下一个按键，发出一个字符信号，异步传输机制就会为它加上前后的辅助同步信息，帮助接收方识别到我们按下了哪一个按键。因为我们敲击键盘的节奏不固定，所以异步是一种很适合的方式</p><p>用于异步通信的连接在OSI(开放系统互连)参考模型的物理层中被定义。</p><blockquote><p>“异步通信”是一种很常用的通信方式。</p><p>异步通信在发送字符时，所发送的字符之间的时间间隔可以是任意的。当然，接收端必须时刻做好接收的准备（如果接收端主机的电源都没有加上，那么发送端发送字符就没有意义，因为接收端根本无法接收）。发送端可以在任意时刻开始发送字符，因此必须在每一个字符的开始和结束的地方加上标志，即加上开始位和停止位，以便使接收端能够正确地将每一个字符接收下来。</p></blockquote><p>异步通信的好处是通信设备简单、便宜，但传输效率较低（因为开始位和停止位的开销所占比例较大）。</p><p>异步通信也可以是以帧作为发送的单位。接收端必须随时做好接收帧的准备。这时，帧的首部必须设有一些特殊的比特组合，使得接收端能够找出一帧的开始。这也称为 <code>帧定界</code>。</p><p>帧定界还包含确定帧的结束位置，这有两种方法：</p><ul><li>一种是在帧的尾部设有某种特殊的比特组合来标志帧的结束</li><li>在帧首部中设有帧长度的字段</li></ul><p>需要注意的是，在异步发送帧时，并不是说发送端对帧中的每一个字符都必须加上开始位和停止位后再发送出去，而是说，发送端可以在任意时间发送一个帧，而帧与帧之间的时间间隔也可以是任意的。在一帧中的所有比特是连续发送的。发送端不需要在发送一帧之前和接收端进行协调（不需要先进行比特同步）。</p><h4 id="3-3-4-总结"><a href="#3-3-4-总结" class="headerlink" title="3.3.4 总结"></a>3.3.4 总结</h4><h5 id="1-异步通信方式的特点"><a href="#1-异步通信方式的特点" class="headerlink" title="1.异步通信方式的特点"></a>1.异步通信方式的特点</h5><p>异步通信是按字符传输的。每传输一个字符就用起始位来进行收、发双方的同步。不会因收发双方的时钟频率的小的偏差导致错误。</p><p>这种传输方式利用每一帧的起、止信号来建立发送与接收之间的同步。特点是：<code>每帧内部各位均采用固定的时间间隔，而帧与帧之间的间隔时随即的</code>。接收机完全靠每一帧的起始位和停止位来识别字符时正在进行传输还是传输结束。</p><p>（使用串口USART中的串行异步通信是一个代表）</p><h5 id="2-同步通信方式的特点"><a href="#2-同步通信方式的特点" class="headerlink" title="2.同步通信方式的特点"></a>2.同步通信方式的特点</h5><p>进行数据传输时，发送和接收双方要保持完全的同步，因此，要求接收和发送设备必须使用同一时钟。</p><p>优点是可以实现高速度、大容量的数据传送；缺点是要求发生时钟和接收时钟保持严格同步，同时硬件复杂。</p><p>（SPI总线是一个典型代表）</p><h5 id="3-对比："><a href="#3-对比：" class="headerlink" title="3.对比："></a>3.对比：</h5><p>可以这样说，不管是异步通信还是同步通信都需要进行同步，只是异步通信通过传送字符内的起始位来进行同步，而同步通信采用共用外部时钟来进行同步。所以，可以说前者是 <code>自同步</code>，后者是 <code>外同步</code>。同时，同步要求收发两端对时间的精确度要求很高，异步没有同步要求那么高。</p><p>自同步、外同步：</p><ul><li>同步传输：是发送端的发送、接收端的接收是同步的，在统一的时钟信号下进行，发一位，接一位。同步传输的数据格式是一种外同步方式所采用的数据格式。对这种方式，在发送的一帧数据中不包含同步字符。同步信号SYNC通过专门的控制线加到串行的接口上。当SYNC一到达，表明数据部分开始，接口就连续接收数据和CRC校验码。    </li><li>异步传输：发送端的发送、接收端的接收不用时钟同步。发送端发一个字符，接收端等接收到之后按字符的始、止位来实现自同步，处理一个字符。</li></ul><h5 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h5><p>在大量使用异步与同步传输的大型机/终端环境中</p><ul><li>异步传输用于传输来自用户周期性按键的终端的字符。接收系统知道等待下一次按键，即使这会花费较多的时间。</li><li>相反，同步传输用作定期传输大量信息的大型系统之间的数据链路。协议为在公用电话系统上利用慢速链路而进行了优化，因此无关位将从传输中删除，并且时钟用于隔开字符。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、同步&quot;&gt;&lt;a href=&quot;#一、同步&quot; class=&quot;headerlink&quot; title=&quot;一、同步&quot;&gt;&lt;/a&gt;一、同步&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;协调，实现步调一致。两个或几个随时间变化的量，在变化过程中(在时域序列上相对位置)保持一定的相对/</summary>
      
    
    
    
    <category term="OS" scheme="https://tenloy.github.io/categories/OS/"/>
    
    
    <category term="多线程" scheme="https://tenloy.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ARM64指令简易手册</title>
    <link href="https://tenloy.github.io/2021/04/17/03-5_Arm64-Handbook/"/>
    <id>https://tenloy.github.io/2021/04/17/03-5_Arm64-Handbook/</id>
    <published>2021-04-17T15:00:20.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<p>ARM处理器的指令集可以分为跳转指令、数据处理指令、程序状态寄存器（PSR）处理指令、加载/存储指令、协处理器指令和异常产生指令6大指令。</p><p>本文只列举一些常见的基本指令，可以正常阅读汇编代码即可。有几个注意点：</p><ul><li><strong>寄存器</strong>：为标号，不加前缀（ARM汇编中，标号就是一个符号，代表着汇编程序中指令或数据的内存地址）</li><li><strong>操作数顺序</strong>：目标操作数在左，源操作数在右</li><li><strong>立即数</strong>：前加#作为前缀</li><li><strong>寻址格式</strong>：常见的有三种</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;寻址格式：</span><br><span class="line">[x10, #0x10]      ; signed offset。 意思是从 x10 + 0x10的地址取值</span><br><span class="line">[sp, #-16]!       ; pre-index。  意思是从 sp-16地址取值，取值完后在把 sp-16  writeback 回 sp</span><br><span class="line">                  ; ! 表示寄存器写回，如果没有！，那么只会从 sp-16 地址读写值，而不会修改 sp 的值</span><br><span class="line">[sp], #16         ; post-index。 意思是从 sp 地址取值，取值完后在把 sp+16 writeback 回 sp</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; 举例：</span><br><span class="line">ldr x0,  [x1]              ; 从&#96;x1&#96;指向的地址里面取出一个 64 位大小的数存入 &#96;x0&#96;</span><br><span class="line">ldp x1,  x2, [x10, #0x10]  ; 从 x10 + 0x10 指向的地址里面取出 2个 64位的数，分别存入x1, x2</span><br><span class="line">str x5,  [sp, #24]         ; 把x5的值（64位数值）存到 sp+24 指向的内存地址上</span><br><span class="line">stp x29, x30, [sp, #-16]!  ; 把 x29, x30的值存到 sp-16的地址上，并且把 sp-&#x3D;16. </span><br><span class="line">ldp x29, x30, [sp], #16    ; 从sp地址取出 16 byte数据，分别存入x29, x30. 然后 sp+&#x3D;16;</span><br></pre></td></tr></table></figure><p>本文中检索不到，全面的可以查看<a href="https://links.jianshu.com/go?to=https://developer.arm.com/architectures">ARM官网文档</a>。如果想看中文版的资料可以看<a href="https://links.jianshu.com/go?to=http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204ic/Cegbgefe.html">《汇编器指南》— 第二章、第四章</a>：</p><h2 id="一、跳转指令"><a href="#一、跳转指令" class="headerlink" title="一、跳转指令"></a>一、跳转指令</h2><p>跳转指令用于实现程序流程的跳转，在ARM程序中有以下两种方法可以实现程序流程的跳转：</p><ul><li>使用专门的跳转指令；</li><li>直接向程序计数器PC写入跳转地址值，通过向程序计数器PC写入跳转地址值，可以实现在4GB的地址空间中的任意跳转，在跳转之前结合使用MOV LR，PC等类似指令，可以保存将来的返回地址值，从而实现在4GB连续的线性地址空间的子程序调用。</li></ul><p>ARM指令集中的跳转指令可以完成从当前指令向前或向后的32MB的地址空间的跳转，包括以下4条指令：</p><h3 id="1-B指令"><a href="#1-B指令" class="headerlink" title="1. B指令"></a>1. B指令</h3><p>B指令是最简单的跳转指令。一旦遇到一个B指令，ARM处理器将立即跳转到给定的目标地址，从那里继续执行。</p><p>注意存储在<strong>跳转指令中的实际值是相对当前PC 值的一个偏移量，而不是一个绝对地址</strong>，它的值由汇编器来计算（参考寻址方式中的相对寻址）。它是24位有符号数，左移两位后有符号扩展为32 位，表示的有效偏移为26 位(前后32MB的地址空间)。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B    Label      ; 程序无条件跳转到标号Label处执行</span><br><span class="line">CMP  R1, #0     ; 当CPSR寄存器中的Z条件码置位时，程序跳转到标号Label处执行</span><br><span class="line">BEQ  Label</span><br></pre></td></tr></table></figure><p>补充：BNE与BEQ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TST  R0, #0X8</span><br><span class="line">BNE  SuspendUp  ; BNE指令是“不相等（或不为0）跳转指令”： </span><br><span class="line">LDR  R1, #0x00000000</span><br><span class="line"></span><br><span class="line">; 先进行and运算，如果R0的第四位不为1，则结果为零，则设置zero&#x3D;1（继续下面的LDR指令）；</span><br><span class="line">; 否则，如果R0的第四位为1，zero&#x3D;0（跳到SuspendUp处执行）。</span><br></pre></td></tr></table></figure><p>tst 和 bne 连用：先是用tst进行位与运算，然后将位与的结果与0比较，如果不为0，则跳到bne紧跟着的标记（如bne sleep，则跳到sleep处）。<br>tst 和 beq 连用：先是用tst进行位与运算，然后将位与的结果与0比较，如果为0，则跳到beq紧跟着的标记（如bne AAAA，则跳到AAAA处）。   </p><h3 id="2-BL指令"><a href="#2-BL指令" class="headerlink" title="2. BL指令"></a>2. BL指令</h3><p>BL是另一个跳转指令，但跳转之前，会在寄存器R14中保存PC的当前内容，因此，可以通过将R14的内容重新加载到PC中，来返回到跳转指令之后的那个 指令处执行。该指令是实现子程序调用的一个基本但常用的手段。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BL&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BL   Label      ; 当程序无条件跳转到标号Label处执行时，同时将当前的 PC值保存到R14（LR）中</span><br></pre></td></tr></table></figure><h3 id="3-BLX指令"><a href="#3-BLX指令" class="headerlink" title="3. BLX指令"></a>3. BLX指令</h3><p>BLX指令从ARM指令集跳转到指令中所指定的目标地址，并将处理器的工作状态有ARM状态切换到Thumb状态，该指令同时将PC的当前内容保存到寄存器R14中。因此，当子程序使用Thumb指令集，而调用者使用ARM指令集时，可以通过BLX指令实现子程序的调用和处理器工作状态的切换。同时，子程序的返回可以通过将寄存器R14值复制到PC中来完成。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLX 目标地址</span><br></pre></td></tr></table></figure><h3 id="4-BX指令"><a href="#4-BX指令" class="headerlink" title="4. BX指令"></a>4. BX指令</h3><p>BX指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BX&#123;条件&#125; 目标地址</span><br></pre></td></tr></table></figure><h2 id="二、数据处理指令"><a href="#二、数据处理指令" class="headerlink" title="二、数据处理指令"></a>二、数据处理指令</h2><p>此类指令用于对通用寄存器执行运算。</p><ul><li>它们可对两个寄存器的内容执行加法、减法或按位逻辑等运算，并将结果存放到第三个寄存器中。</li><li>还可以对单个寄存器中的值执行运算，或者对寄存器中的值与指令中提供的常数（立即值）执行运算。</li></ul><p>数据处理指令可分为数据传送指令、比较指令和算术、逻辑运算指令等。</p><ul><li>数据传送指令用于在寄存器和存储器之间进行数据的双向传输；</li><li>算术逻辑运算指令完成常用的算术与逻辑的运算，该类指令不但将运算结果保存在目的寄存器中，同时更新CPSR中的相应条件标志位；</li><li>比较指令不保存运算结果，只更新CPSR中相应的条件标志位。</li></ul><p>数据处理指令如下：</p><h3 id="2-1-数据传送指令"><a href="#2-1-数据传送指令" class="headerlink" title="2.1 数据传送指令"></a>2.1 数据传送指令</h3><h4 id="1-MOV指令-传送"><a href="#1-MOV指令-传送" class="headerlink" title="1. MOV指令(传送)"></a>1. MOV指令(传送)</h4><p>MOV指令可完成从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV&#123;条件&#125;&#123;S&#125; 目的寄存器，源操作数</span><br></pre></td></tr></table></figure><ul><li>S选项决定指令的操作是否影响CPSR中条件标志位的值，当没有S 时指令不更新CPSR中条件标志位的值。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV R1，R0          ; 将寄存器R0的值传送到寄存器R1</span><br><span class="line">MOV PC，R14         ; 将寄存器R14的值传送到 PC，常用于子程序返回</span><br><span class="line">MOV R1，R0，LSL#3   ; 将寄存器R0的值左移3位后传送到R1</span><br></pre></td></tr></table></figure><h4 id="2-MVN指令-取反移动"><a href="#2-MVN指令-取反移动" class="headerlink" title="2. MVN指令(取反移动)"></a>2. MVN指令(取反移动)</h4><p>MVN指令可完成从另一个寄存器、被移位的寄存器、或将一个立即数加载到目的寄存器。与MOV指令不同之处是在传送之前按位被取反了，即把一个被取反的值 传送到目的寄存器中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVN&#123;条件&#125;&#123;S&#125; 目的寄存器，源操作数</span><br></pre></td></tr></table></figure><ul><li>S决定指令的操作是否影响CPSR中条件标志位的值，当没有S时指令不更新CPSR中条件标志位的值。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVN R0，#0   ; 将 立即数0取反传送到寄存器R0中，完成后R0&#x3D;-1</span><br></pre></td></tr></table></figure><h3 id="2-2-比较指令"><a href="#2-2-比较指令" class="headerlink" title="2.2 比较指令"></a>2.2 比较指令</h3><h4 id="1-CMP指令-比较"><a href="#1-CMP指令-比较" class="headerlink" title="1. CMP指令(比较)"></a>1. CMP指令(比较)</h4><p>CMP指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较，同时更新CPSR中条件标志位的值。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMP&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure><p>该指令进行一次减法运算，但不存储结果，只更改条件标志位。 标志位表示的是操作数1与操作数2的关系(大、小、相等)，例如，当操作数1大于操作操作数2，则此后的有GT后缀的指令将可以执行。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMP   R1，R0     ; 将寄存器R1的值与寄存器R0的值相减，并根据 结果设置CPSR的标志位</span><br><span class="line">CMP   R1，#100   ; 将寄存器R1的值与立即数100相减，并根 据结果设置CPSR的标志位</span><br></pre></td></tr></table></figure><h4 id="2-CMN指令-负数比较"><a href="#2-CMN指令-负数比较" class="headerlink" title="2. CMN指令(负数比较)"></a>2. CMN指令(负数比较)</h4><p>CMN指令用于把一个寄存器的内容和另一个寄存器的内容或立即数取反后进行比较，同时更新CPSR中条件标志位的值。该指令实际完成操作数1和操作数2相 加，并根据结果更改条件标志位。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMN&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMN   R1，R0    ; 将寄存器R1的值与寄存器R0的值相加，并根据 结果设置CPSR 的标志位</span><br><span class="line">CMN   R1，#100  ; 将寄存器R1的值与立即数100相加，并根据 结果设置CPSR的标志位</span><br></pre></td></tr></table></figure><h4 id="3-TST指令-位测试"><a href="#3-TST指令-位测试" class="headerlink" title="3. TST指令(位测试)"></a>3. TST指令(位测试)</h4><p>TST指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的与运算，并根据运算结果更新CPSR中条件标志位的值。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TST&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1是要测试的数据，而操作数2是一个位掩码，该指令一般用来检测是否设置了特定的位。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TST   R1，#%1       ; 用于测试在寄存器R1中是否设置了最低位（％表 示二进制数）</span><br><span class="line">TST   R1，#0xffe    ; 将寄存器R1的值与立即数0xffe按位与，并根据 结果设置CPSR的标志位</span><br></pre></td></tr></table></figure><h4 id="4-TEQ指令-相等测试"><a href="#4-TEQ指令-相等测试" class="headerlink" title="4. TEQ指令(相等测试)"></a>4. TEQ指令(相等测试)</h4><p>TEQ指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的异或运算，并根据运算结果更新CPSR中条件标志位的值。该指令通常用于比较操作数1和操作数2是否相等。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEQ&#123;条件&#125; 操作数1，操作数2</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEQ  R1，R2   ; 将寄存器R1的值与寄存器R2的值按位异或，并根据结果 设置CPSR的标志位</span><br></pre></td></tr></table></figure><h3 id="2-3-算术运算指令"><a href="#2-3-算术运算指令" class="headerlink" title="2.3 算术运算指令"></a>2.3 算术运算指令</h3><h4 id="1-ADD指令-相加"><a href="#1-ADD指令-相加" class="headerlink" title="1. ADD指令(相加)"></a>1. ADD指令(相加)</h4><p>ADD指令用于把两个操作数相加，并将结果存放到目的寄存器中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD     R0，R1，R2              ; R0 &#x3D; R1 + R2</span><br><span class="line">ADD     R0，R1，#256            ; R0 &#x3D; R1 + 256</span><br><span class="line">ADD     R0，R2，R3，LSL#1       ; R0 &#x3D; R2 + (R3 &lt;&lt; 1)</span><br></pre></td></tr></table></figure><h4 id="2-ADC指令-带进位相加"><a href="#2-ADC指令-带进位相加" class="headerlink" title="2. ADC指令(带进位相加)"></a>2. ADC指令(带进位相加)</h4><p>ADC指令用于把两个操作数相加，再加上CPSR中的C条件标志位的值，并将结果存放到目的寄存器中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>它使用一个进位标志位，这样就可以做比32位大的数的加法，注意不要忘记设置S后缀来更改进位标志。</li><li>操作数1应是一个寄存器</li><li>操作数2可以是一 个寄存器，被移位的寄存器，或一个立即数</li></ul><p>示例：</p><p>以下指令序列完成两个128位数的加法，第一个数由高到低存放在寄存器R7～R4，第二个数由高到低存放在寄存器R11～R8，运算结果由高到低存放在寄 存器R3～R0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADDS    R0，R4，R8         ;  加低端的字</span><br><span class="line">ADCS    R1，R5，R9         ;  加第二个字，带进位</span><br><span class="line">ADCS    R2，R6，R10        ;  加第三个字，带进位</span><br><span class="line">ADC     R3，R7，R11        ;  加第四个字，带进位</span><br></pre></td></tr></table></figure><h4 id="3-SUB指令-相减"><a href="#3-SUB指令-相减" class="headerlink" title="3. SUB指令(相减)"></a>3. SUB指令(相减)</h4><p>SUB指令用于把操作数1减去操作数2，并将结果存放到目的寄存器中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1应是一个寄存器</li><li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li></ul><p>该指令可用于有符号数或无符号数的减法运算。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUB     R0，R1，R2             ;  R0 &#x3D; R1 - R2</span><br><span class="line">SUB     R0，R1，#256           ;  R0 &#x3D; R1 - 256</span><br><span class="line">SUB     R0，R2，R3，LSL#1      ;  R0 &#x3D; R2 - (R3 &lt;&lt; 1)</span><br></pre></td></tr></table></figure><h4 id="4-SBC指令-带进位减法"><a href="#4-SBC指令-带进位减法" class="headerlink" title="4. SBC指令(带进位减法)"></a>4. SBC指令(带进位减法)</h4><p>SBC指令用于把操作数1减去操作数2，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SBC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1应是一个寄存器</li><li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li></ul><p>该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。该指令可用于有符号数或无符号数的减法运算。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBS    R0，R1，R2    ; R0 &#x3D; R1 - R2 - ！C，并根据结果设置CPSR的进位标志位</span><br></pre></td></tr></table></figure><h4 id="5-RSB指令-逆向-反向减法"><a href="#5-RSB指令-逆向-反向减法" class="headerlink" title="5. RSB指令(逆向/反向减法)"></a>5. RSB指令(逆向/反向减法)</h4><p>RSB指令称为逆向减法指令，用于把操作数2减去操作数1，并将结果存放到目的寄存器中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSB&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1应是一个寄存器</li><li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li></ul><p>该指令可用于有符号数或无符号数的减法运算。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSB     R0，R1，R2                  ;  R0 &#x3D; R2 – R1</span><br><span class="line">RSB     R0，R1，#256                ;  R0 &#x3D; 256 – R1</span><br><span class="line">RSB     R0，R2，R3，LSL#1           ;  R0 &#x3D; (R3 &lt;&lt; 1) - R2</span><br></pre></td></tr></table></figure><h4 id="6-RSC指令-反向带进位减"><a href="#6-RSC指令-反向带进位减" class="headerlink" title="6. RSC指令(反向带进位减)"></a>6. RSC指令(反向带进位减)</h4><p>RSC指令用于把 操作数2减去操作数1，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1应是一个寄存器操作</li><li>数2可以是一个寄存器，被移位 的寄存器，或一个立即数。</li></ul><p>该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。该指令可用于有符号数或 无符号数的减法运算。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSC     R0，R1，R2           ; R0 &#x3D; R2 – R1 - ！C</span><br></pre></td></tr></table></figure><h4 id="—乘法指令与乘加指令—"><a href="#—乘法指令与乘加指令—" class="headerlink" title="—乘法指令与乘加指令—"></a>—乘法指令与乘加指令—</h4><ul><li>ARM 微处理器支持的乘法指令与乘加指令共有6条，可分为运算结果为32位和运算结果为64位两类。</li><li>与前面的数据处理指令不同，指令中的所有操作数、目的寄存器 必须为通用寄存器，不能对操作数使用立即数或被移位的寄存器，同时，目的寄存器和操作数1必须是不同的寄存器。 </li></ul><h4 id="1-MUL指令-相乘"><a href="#1-MUL指令-相乘" class="headerlink" title="1. MUL指令(相乘)"></a>1. MUL指令(相乘)</h4><p>MUL指令完成将操作数1与操作数2的乘法运算，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1和操 作数2均为32位的有符号数或无符号数。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MUL  R0，R1，R2            ; R0 &#x3D; R1 × R2</span><br><span class="line">MULS R0，R1，R2            ; R0 &#x3D; R1 × R2，同时设置CPSR中的相关条件标志位</span><br></pre></td></tr></table></figure><h4 id="2-MLA指令-带累加的相乘"><a href="#2-MLA指令-带累加的相乘" class="headerlink" title="2. MLA指令(带累加的相乘)"></a>2. MLA指令(带累加的相乘)</h4><p>MLA指令完成将操作数1与操作数2的乘法运算，再将乘积加上操作数3，并把结果放置到目的寄存器中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MLA&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2，操作数3</span><br></pre></td></tr></table></figure><ul><li>操作数1和操作数2均为32位的有符号数或无符号数。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MLA   R0，R1，R2，R3            ; R0 &#x3D; R1 × R2 + R3</span><br><span class="line">MLAS  R0，R1，R2，R3            ; R0 &#x3D; R1 × R2 + R3，同时设置CPSR中的相关条件标志位</span><br></pre></td></tr></table></figure><h4 id="3-SMULL指令"><a href="#3-SMULL指令" class="headerlink" title="3. SMULL指令"></a>3. SMULL指令</h4><p>SMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以 根据运算结果设置CPSR中相应的条件标志位。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMULL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1和操作数2均为32位的有符号数。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMULL   R0，R1，R2，R3     ; R0 &#x3D; （R2 × R3）的低32位</span><br><span class="line">                          ; R1 &#x3D; （R2 × R3）的高32位</span><br></pre></td></tr></table></figure><h4 id="4-SMLAL指令"><a href="#4-SMLAL指令" class="headerlink" title="4. SMLAL指令"></a>4. SMLAL指令</h4><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMLAL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure><p>SMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p><ul><li>操作数1和操作数2均为32位的有符号数。</li><li>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位;</li><li>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMLAL   R0，R1，R2，R3       ; R0 &#x3D; （R2 × R3）的低32位 ＋ R0</span><br><span class="line">                            ; R1 &#x3D; （R2 × R3）的高32位 ＋ R1</span><br></pre></td></tr></table></figure><h4 id="5-UMULL指令"><a href="#5-UMULL指令" class="headerlink" title="5. UMULL指令"></a>5. UMULL指令</h4><p>UMULL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中，同时可以 根据运算结果设置CPSR中相应的条件标志位。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UMULL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1和操作数2均为32位的无符号数。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UMULL   R0，R1，R2，R3       ; R0 &#x3D; （R2 × R3）的低32位</span><br><span class="line">                            ; R1 &#x3D; （R2 × R3）的高32位</span><br></pre></td></tr></table></figure><h4 id="6-UMLAL指令"><a href="#6-UMLAL指令" class="headerlink" title="6. UMLAL指令"></a>6. UMLAL指令</h4><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UMLAL&#123;条件&#125;&#123;S&#125;   目的寄存器Low，目的寄存器High，操作数1，操作数2</span><br></pre></td></tr></table></figure><p>UMLAL指令完成将操作数1与操作数2的乘法运算，并把结果的低32位同目的寄存器Low中的值相加后又放置到目的寄存器Low中，结果的高32位同目的寄存器High中的值相加后又放置到目的寄存器High 中，同时可以根据运算结果设置CPSR中相应的条件标志位。</p><ul><li>操作数1和操作数2均为32位的无符号数；</li><li>对于目的寄存器Low，在指令执行前存放64位加数的低32位，指令执行后存放结果的低32位; </li><li>对于目的寄存器High，在指令执行前存放64位加数的高32位，指令执行后存放结果的高32位。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UMLAL   R0，R1，R2，R3            ; R0 &#x3D; （R2 × R3）的低32位 ＋ R0</span><br><span class="line">                                 ; R1 &#x3D; （R2 × R3）的高32位 ＋ R1</span><br></pre></td></tr></table></figure><h3 id="2-4-逻辑运算指令"><a href="#2-4-逻辑运算指令" class="headerlink" title="2.4 逻辑运算指令"></a>2.4 逻辑运算指令</h3><h4 id="1-AND指令-逻辑位-与"><a href="#1-AND指令-逻辑位-与" class="headerlink" title="1. AND指令(逻辑位 与)"></a>1. AND指令(逻辑位 与)</h4><p>AND指令用于在两个操作数上进行逻辑与运算，并把结果放置到目的寄存器中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1应是一个寄存器</li><li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li></ul><p>该指令常用于屏蔽操作数1的某些位。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND     R0, R0, #3          ; 该指令保持R0的0、1位，其余位清零。</span><br></pre></td></tr></table></figure><h4 id="2-ORR指令-逻辑位-或"><a href="#2-ORR指令-逻辑位-或" class="headerlink" title="2. ORR指令(逻辑位 或)"></a>2. ORR指令(逻辑位 或)</h4><p>ORR指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORR&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1应是一个寄存器</li><li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。</li></ul><p>该指令常用于设置操作数1的某些位。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORR R0，R0，#3        ; 该指令设置R0的0、1位，其余位保持不变。</span><br></pre></td></tr></table></figure><h4 id="3-EOR指令-逻辑位-异或"><a href="#3-EOR指令-逻辑位-异或" class="headerlink" title="3. EOR指令(逻辑位 异或)"></a>3. EOR指令(逻辑位 异或)</h4><p>EOR指令用于在两个操作数上进行逻辑异或运算，并把结果放置到目的寄存器中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EOR&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1应是一个寄存器</li><li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数</li></ul><p>该指令常用于反转操作数1的某些位。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EOR R0，R0，#3        ; 该指令反转R0的0、1位，其余位保持不变。</span><br></pre></td></tr></table></figure><h4 id="4-BIC指令-位清零"><a href="#4-BIC指令-位清零" class="headerlink" title="4. BIC指令(位清零)"></a>4. BIC指令(位清零)</h4><p>BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIC&#123;条件&#125;&#123;S&#125; 目的寄存器，操作数1，操作数2</span><br></pre></td></tr></table></figure><ul><li>操作数1应是一个寄存器</li><li>操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。 操作数2为32位的掩码，如果在掩码中设置了某一位，则清除这一位。未设置的掩码位保持不变。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BIC R0, R0, #%1011    ; 该指令清除R0中的位 0、1、和 3，其余的位保持不变。</span><br></pre></td></tr></table></figure><h4 id="5-LSL-ASL-LSL逻辑左移、ASL算术左移"><a href="#5-LSL-ASL-LSL逻辑左移、ASL算术左移" class="headerlink" title="5. LSL ASL(LSL逻辑左移、ASL算术左移)"></a>5. LSL ASL(LSL逻辑左移、ASL算术左移)</h4><p>LSL（或ASL）可完成对通用寄存器中的内容进行逻辑（或算术）的左移操作，按操作数所指定的数量向左移位，低位用零来填充。 </p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，LSL（或ASL） 操作数</span><br></pre></td></tr></table></figure><ul><li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   R0, R1, LSL #2          ; 将R1中的内容左移两位后传送到R0 中。</span><br></pre></td></tr></table></figure><h4 id="6-LSR-逻辑右移"><a href="#6-LSR-逻辑右移" class="headerlink" title="6. LSR(逻辑右移)"></a>6. LSR(逻辑右移)</h4><p>LSR可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用零来填充。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，LSR 操作数</span><br></pre></td></tr></table></figure><ul><li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   R0, R1, LSR #2         ; 将R1中的内容右移两位后传送到R0 中，左端用零来填充。</span><br></pre></td></tr></table></figure><h4 id="7-ASR-算术右移"><a href="#7-ASR-算术右移" class="headerlink" title="7. ASR(算术右移)"></a>7. ASR(算术右移)</h4><p>ASR可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用第31位的值来填充。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，ASR 操作数</span><br></pre></td></tr></table></figure><ul><li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV    R0, R1, ASR #2        ; 将R1中的内容右移两位后传送到R0 中，左端用第31位的值来填充。</span><br></pre></td></tr></table></figure><h4 id="8-ROR-向右循环移"><a href="#8-ROR-向右循环移" class="headerlink" title="8. ROR(向右循环移)"></a>8. ROR(向右循环移)</h4><p>ROR可完成对通用寄存器中的内容进行循环右移的操作，按操作数所指定的数量向右循环移位，左端用右端移出的位来填充。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，ROR 操作数</span><br></pre></td></tr></table></figure><ul><li>其中，操作数可以是通用寄存器，也可以是立即数（0～31）。显然，当进行32位的循环右移操作时，通用寄存器中的值不改变。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV    R0, R1, ROR #2       ; 将R1中的内容循环右移两位后传送到R0 中。</span><br></pre></td></tr></table></figure><h4 id="9-RRX-带扩展向右循环移"><a href="#9-RRX-带扩展向右循环移" class="headerlink" title="9. RRX(带扩展向右循环移)"></a>9. RRX(带扩展向右循环移)</h4><p>RRX可完成对通用寄存器中的内容进行带扩展的循环右移的操作，按操作数所指定的数量向右循环移位，左端用进位标志位C来填充。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器，RRX 操作数</span><br></pre></td></tr></table></figure><ul><li>操作数可以是通用寄存器，也可以是立即数（0～31）。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV   R0, R1, RRX #2         ; 将R1中的内容进行带扩展的循环右移两位 后传送到R0中。</span><br></pre></td></tr></table></figure><h2 id="三、程序状态寄存器访问指令"><a href="#三、程序状态寄存器访问指令" class="headerlink" title="三、程序状态寄存器访问指令"></a>三、程序状态寄存器访问指令</h2><p>此类指令向通用寄存器或者从通用寄存器往外移动状态寄存器的内容。</p><h3 id="1-MRS指令-从PSR移动到寄存器"><a href="#1-MRS指令-从PSR移动到寄存器" class="headerlink" title="1. MRS指令(从PSR移动到寄存器)"></a>1. MRS指令(从PSR移动到寄存器)</h3><p>MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。该指令一般用在以下两种情况：</p><ul><li>当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器。</li><li>当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用该指令读出程序状态寄存器的值，然后保存。</li></ul><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRS&#123;条件&#125;  通用寄存器 程序状态寄存器（CPSR或SPSR）</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRS R0，CPSR      ; 传送CPSR的内容到R0</span><br><span class="line">MRS R0，SPSR      ; 传送 SPSR的内容到R0</span><br></pre></td></tr></table></figure><h3 id="2-MSR指令-从寄存器移动到PSR"><a href="#2-MSR指令-从寄存器移动到PSR" class="headerlink" title="2. MSR指令(从寄存器移动到PSR)"></a>2. MSR指令(从寄存器移动到PSR)</h3><p>MSR指令用于将操作数的内容传送到程序状态寄存器的特定域中。其中，操作数可以为通用寄存器或立即数。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSR&#123;条件&#125;    程序状态寄存器（CPSR或SPSR）_&lt;域&gt;，操作数</span><br></pre></td></tr></table></figure><p>&lt;域&gt;用于设置程序状态寄存器中需要 操作的位，32位的程序状态寄存器可分为4个域：</p><ul><li>位[31：24]为条件位域，用f表示；</li><li>位[23：16]为状态位域，用s表示；</li><li>位[15：8] 为扩展位域，用x表示；</li><li>位[7：0]    为控制位域，用c表示；</li></ul><p>该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MSR CPSR，R0        ; 传送R0的内容到CPSR</span><br><span class="line">MSR SPSR，R0        ; 传送R0的内容到SPSR</span><br><span class="line">MSR CPSR_c，R0      ; 传送R0的内容到SPSR，但仅仅修改CPSR中的控制位域</span><br></pre></td></tr></table></figure><h2 id="四、加载-存储指令"><a href="#四、加载-存储指令" class="headerlink" title="四、加载/存储指令"></a>四、加载/存储指令</h2><p>ARM微处理器支持加载/存储指令用于在寄存器和存储器之间传送数据：</p><ul><li>加载指令用于将存储器中的数据传送到寄存器；</li><li>存储指令则完成相反的操作。</li></ul><p>此类指令用于从内存加载单个寄存器的值，或者在内存中存储单个寄存器的值。 它们可加载或存储 32 位字、16 位半字或 8 位无符号字节。 可以用符号或零扩展字节和半字加载以填充 32 位寄存器。</p><p>此外，还有<strong>多个寄存器加载和存储指令</strong>，此类指令可从内存加载通用寄存器的任何子集，或者在内存中存储这样的子集。</p><p>常用的加载存储指令如下：</p><h3 id="1-LDR指令"><a href="#1-LDR指令" class="headerlink" title="1. LDR指令"></a>1. LDR指令</h3><p>LDR指令用于从存储器中将一个32位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR&#123;条件&#125; 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure><ul><li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li></ul><p>该指令在程序设计中比较常用，且寻址方式灵活多样，请读者认真掌握。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LDR R0，[R1]             ; 将存储器地址为R1的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，R2]         ; 将存储器地址为R1+R2的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，#8]         ; 将存储器地址为R1+8的字数据读入寄存器R0。</span><br><span class="line">LDR R0，[R1，R2] ！       ; 将存储器地址为R1+R2的字数据读入寄存器R0，并将新地址R1＋R2写入R1。</span><br><span class="line">LDR R0，[R1，#8] ！      ; 将存储器地址为R1+8的字数据读入寄存器R0，并将新地址 R1＋8写入R1。</span><br><span class="line">LDR R0，[R1]，R2          ; 将存储器地址为R1的字数据读入寄存器R0，并将新地址 R1＋R2写入R1。</span><br><span class="line">LDR R0，[R1，R2，LSL#2]！ ; 将存储器地址为R1＋R2×4的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。</span><br><span class="line">LDR R0，[R1]，R2，LSL#2   ; 将存储器地址为R1的字数据读入 寄存器R0，并将新地址R1＋R2×4写入R1。</span><br></pre></td></tr></table></figure><h3 id="2-LDRB指令"><a href="#2-LDRB指令" class="headerlink" title="2. LDRB指令"></a>2. LDRB指令</h3><p>LDRB指令用于从存储器中将一个8位的字节数据传送到目的寄存器中，同时将寄存器的高24位清零。 该指令通常用于从存储器中读取8位的字节数据到通用寄存器，然后对数据进行处理。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR&#123;条件&#125;B 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure><ul><li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDRB R0，[R1]           ; 将存储器地址为R1的字节数据读入寄存器R0，并将R0的高24位清零。</span><br><span class="line">LDRB R0，[R1，#8]       ; 将存储器地址为R1＋8的字节数据读入寄存器R0，并将R0的高24位清零。</span><br></pre></td></tr></table></figure><h3 id="3-LDRH指令"><a href="#3-LDRH指令" class="headerlink" title="3. LDRH指令"></a>3. LDRH指令</h3><p>LDRH指令用于从存储器中将一个16位的半字数据传送到目的寄存器中，同时将寄存器的高16位清零。 该指令通常用于从存储器中读取16位的半字数据到通用寄存器，然后对数据进行处理。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR&#123;条件&#125;H 目的寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure><ul><li>当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LDRH   R0，[R1]         ; 将存储器地址为R1的半字数据读入寄存器 R0，并将R0的高16位清零。</span><br><span class="line">LDRH   R0，[R1，#8]     ; 将存储器地址为R1＋8的半字数据读入寄存器R0，并将R0 的高16位清零。</span><br><span class="line">LDRH   R0，[R1，R2]     ; 将存储器地址为R1＋R2的半字数据读入寄存器R0，并将 R0的高16位清零。</span><br></pre></td></tr></table></figure><h3 id="4-STR指令"><a href="#4-STR指令" class="headerlink" title="4. STR指令"></a>4. STR指令</h3><p>STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。 该指令在程序设计中比较常用，且寻址方式灵活多样，使用方式可参考指令LDR。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR&#123;条件&#125; 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STR R0，[R1]，#8           ; 将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。</span><br><span class="line">STR R0，[R1，#8]           ; 将R0中的字数据写入以R1＋8为地址的存储器中。</span><br></pre></td></tr></table></figure><h3 id="5-STRB指令"><a href="#5-STRB指令" class="headerlink" title="5. STRB指令"></a>5. STRB指令</h3><p>STRB指令用于从源寄存器中将一个8位的字节数据传送到存储器中。该字节数据为源寄存器中的低8位。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR&#123;条件&#125;B 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STRB    R0，[R1]             ; 将寄存器R0中的字节数据写入以R1为地 址的存储器中。</span><br><span class="line">STRB    R0，[R1，#8]         ; 将寄存器R0中的字节数据写入以R1＋8为地址的存 储器中。</span><br></pre></td></tr></table></figure><h3 id="6-STRH指令"><a href="#6-STRH指令" class="headerlink" title="6. STRH指令"></a>6. STRH指令</h3><p>STRH指令用于从源寄存器中将一个16位的半字数据传送到存储器中。该半字数据为源寄存器中的低16位。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR&#123;条件&#125;H 源寄存器，&lt;存储器地址&gt;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STRH   R0，[R1]            ; 将寄存器R0中的半字数据写入以R1为地址的 存储器中。</span><br><span class="line">STRH   R0，[R1，#8]        ; 将寄存器R0中的半字数据写入以R1＋8 为地址的存储器中。</span><br></pre></td></tr></table></figure><h3 id="7-ADR指令"><a href="#7-ADR指令" class="headerlink" title="7. ADR指令"></a>7. ADR指令</h3><p>将一个立即值与 pc 值相加，并将结果写入目标寄存器</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADR&#123;cond&#125;&#123;.W&#125;  Rd,label</span><br></pre></td></tr></table></figure><h3 id="8-ADRP指令"><a href="#8-ADRP指令" class="headerlink" title="8. ADRP指令"></a>8. ADRP指令</h3><p>以页为单位的大范围的地址读取指令，这里的P就是page的意思。取得page的基地址存入寄存器</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADRP&#123;cond&#125;  Rd  label</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adrp    x2, .LANCHOR0   ; .LANCHOR0是个&lt;lable&gt;——一个大小为4KB的页的基址，指令的作用就是将该页的基址存到寄存器x2中</span><br><span class="line"></span><br><span class="line">; 示例2：</span><br><span class="line">adrp    x0, l_.str@PAGE         ; 将符号l.str所在的page基址读入x0</span><br><span class="line">add     x0, x0, l_.str@PAGEOFF  ; x0 &#x3D; x0 + l.str所在page中的偏移量</span><br></pre></td></tr></table></figure><h3 id="—批量数据加载-存储指令—"><a href="#—批量数据加载-存储指令—" class="headerlink" title="—批量数据加载/存储指令—"></a>—批量数据加载/存储指令—</h3><p>ARM微处理器所支持批量数据加载/存储指令可以一次在一片连续的存储器单元和多个寄存器之间传送数据，批量加载指令 用于将一片连续的存储器中的数据传送到多个寄存器，批量数据存储指令则完成相反的操作。</p><p>常用的加载存储指令如下：</p><h3 id="1-LDM-STM-指令（加载、存储多个寄存器）"><a href="#1-LDM-STM-指令（加载、存储多个寄存器）" class="headerlink" title="1. LDM(STM)指令（加载、存储多个寄存器）"></a>1. LDM(STM)指令（加载、存储多个寄存器）</h3><p>LDM（或STM）指令用于从由基址寄存器所指示的一片连续存储器到寄存器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDM（或STM）&#123;条件&#125;&#123;类型&#125; 基址寄存器&#123;！&#125;，寄存器列表&#123;∧&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>&#123;类型&#125;</code> 为 以下几种情况：<ul><li>IA    每次传送后地址加1; </li><li>IB    每次传送前地址加1; </li><li>DA   每次传送后地址减1; </li><li>DB   每次传送前地址减1; </li><li>FD   满递减堆栈; </li><li>ED   空递减堆栈; </li><li>FA   满递增堆栈; </li><li>EA   空递增堆栈; </li></ul></li><li><code>&#123;！&#125;</code> 为可选后缀，若选用该后缀，则当数据 传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。<ul><li>基址寄存器不允许为R15，寄存器列表可以为R0～R15的任意组合。</li></ul></li><li><code>&#123;∧&#125;</code> 为可选后缀，当指令为LDM且寄存器列表中包含R15，选用该后缀时表示：除了正常的数据传送之外，还将SPSR复制到CPSR。同时，该后缀还表 示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STMFD R13!，&#123;R0，R4-R12，LR&#125;        ; 将寄存器列表中的寄存器（R0，R4到R12，LR）存入堆栈。</span><br><span class="line">LDMFD R13!， &#123;R0，R4-R12，PC&#125;       ; 将堆栈内容恢复到寄存器（R0，R4到R12，LR）。</span><br></pre></td></tr></table></figure><h3 id="—数据交换指令—"><a href="#—数据交换指令—" class="headerlink" title="—数据交换指令—"></a>—数据交换指令—</h3><p>在寄存器和内存之间交换数据</p><h3 id="1-SWP指令"><a href="#1-SWP指令" class="headerlink" title="1. SWP指令"></a>1. SWP指令</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWP&#123;条件&#125; 目的寄存器，源寄存器1，[源寄存器2]</span><br></pre></td></tr></table></figure><p>SWP指令用于将源寄存器2所指向的存储器中的字数据传送到目的寄存器中，同时将源寄存器1中的字数据传送到源寄存器2所指向的存储器中。显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SWP   R0，R1，[R2]     ; 将R2所指向的存储器中的字数据传送到R0，同时将R1 中的字数据传送到R2所指向的存储单元。</span><br><span class="line">SWP   R0，R0，[R1]     ; 该指令完成将R1所指向的存储器中的字数 据与R0中的数据交换。</span><br></pre></td></tr></table></figure><p>SWP{B}：B是一个可选的后缀。如果存在 B，则交换一个字节。否则，交换一个32位字。</p><h3 id="2-SWPB指令"><a href="#2-SWPB指令" class="headerlink" title="2. SWPB指令"></a>2. SWPB指令</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWP&#123;条件&#125;B 目的寄存器，源寄存器1，[源寄存器2]</span><br></pre></td></tr></table></figure><p>SWPB指令用于将源寄存器2所指向的存储器中的字节数据传送到目的寄存器中，目的寄存器的高24清零，同时将源寄存器1中的字节数据传送到源寄存器2所指向的存储器中。</p><p>显然，当源寄存器1和目的寄存器为同一个寄存器时，指令交换该寄存器和存储器的内容。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SWPB   R0，R1，[R2]       ; 将R2所指向的存储器中的字节数据传送到 R0，R0的高24位清零，同时将R1中的低8位数据传送到R2所指向的存储单元。</span><br><span class="line">SWPB   R0，R0，[R1]       ; 该指令完成将R1所指向的存储器中的 字节数据与R0中的低8位数据交换。</span><br></pre></td></tr></table></figure><h2 id="五、协处理器指令"><a href="#五、协处理器指令" class="headerlink" title="五、协处理器指令"></a>五、协处理器指令</h2><p>此类指令支持一种用于扩展 ARM 体系结构的通用方式。</p><p>ARM 微处理器可支持多达 16 个协处理器，用于各种协处理操作，在程序执行的过程中，每个协处理器只执行针对自身的协处理指令，忽略 ARM 处理器和其他协处理器的指令。</p><p>ARM 的协处理器指令主要用于 ARM 处理器初始化 ARM 协处理器的数据处理操作，以及在ARM 处理器的寄存器和协处理器的寄存器之间传送数据，和在 ARM 协处理器的寄存器和存储器之间传送数据。</p><h3 id="1-CDP指令"><a href="#1-CDP指令" class="headerlink" title="1. CDP指令"></a>1. CDP指令</h3><p>CDP指令用于ARM处理器通知ARM协处理器执行特定的操作，若协处理器不能成功完成特定的操作，则产生未定义指令异常。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CDP&#123;条件&#125; 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure><p>其中协处理器操作码1和协处理 器操作码2为协处理器将要执行的操作，目的寄存器和源寄存器均为协处理器的寄存器，指令不涉及ARM处理器的寄存器和存储器。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CDP   P3，2，C12，C10，C3，4  ; 该指令完成协处理器P3的初始化 </span><br></pre></td></tr></table></figure><h3 id="2-LDC指令"><a href="#2-LDC指令" class="headerlink" title="2. LDC指令"></a>2. LDC指令</h3><p>LDC指令用于将源寄存器所指向的存储器中的字数据传送到目的寄存器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDC&#123;条件&#125;&#123;L&#125; 协处理器编码，目的寄存器，[源寄存器]</span><br></pre></td></tr></table></figure><p>其中，{L}选项表示指 令为长读取操作，如用于双精度数据的传输。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDC   P3，C4，[R0]        ; 将ARM处理器的寄存器R0所指向的存储器中的字数 据传送到协处理器P3的寄存器C4中。 </span><br></pre></td></tr></table></figure><h3 id="3-STC指令"><a href="#3-STC指令" class="headerlink" title="3. STC指令"></a>3. STC指令</h3><p>STC指令用于将源寄存器中的字数据传送到目的寄存器所指向的存储器中，若协处理器不能成功完成传送操作，则产生未定义指令异常。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STC&#123;条件&#125;&#123;L&#125; 协处理器编码，源寄存器，[目的寄存器]</span><br></pre></td></tr></table></figure><p>其中，{L}选项表示指 令为长读取操作，如用于双精度数据的传输。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STC   P3，C4，[R0]     ; 将协处理器P3的寄存器C4中的字数据传送到ARM处理 器的寄存器R0所指向的存储器中。 </span><br></pre></td></tr></table></figure><h3 id="4-MCR指令"><a href="#4-MCR指令" class="headerlink" title="4. MCR指令"></a>4. MCR指令</h3><p>MCR指令用于将ARM处理器寄存器中的数据传送到协处理器寄存器中，若协处理器不能成功完成操作，则产生未定义指令异常。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MCR&#123;条件&#125; 协处理器编码，协处理器操作码1，源寄存器，目的寄存器1，目的寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure><p>其中协处理器操作码1和协处理 器操作码2为协处理器将要执行的操作，源寄存器为ARM处理器的寄存器，目的寄存器1和目的寄存器2均为协处理器的寄 存器。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MCR   P3，3，R0，C4，C5，6     ; 将ARM处理器寄存器R0中的数据传送到协处 理器P3的寄存器C4和C5中。 </span><br></pre></td></tr></table></figure><h3 id="5-MRC指令"><a href="#5-MRC指令" class="headerlink" title="5. MRC指令"></a>5. MRC指令</h3><p>MRC指令用于将协处理器寄存器中的数据传送到ARM处理器寄存器中,若协处理器不能成功完成操作，则产生未定义指令异常。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRC&#123;条件&#125; 协处理器编码，协处理器操作码1，目的寄存器，源寄存器1，源寄存器2，协处理器操作码2。</span><br></pre></td></tr></table></figure><p>其中协处理器操作码1和协处理器操作码2为协处理器将要执行的操作，目的寄存器为ARM处理器的寄存器，源寄存器1和源寄存器2均为协处理器的寄存器。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRC   P3，3，R0，C4，C5，6     ; 该指令将协处理器P3的寄存器中的数据传送到 ARM处理器寄存器中。</span><br></pre></td></tr></table></figure><h2 id="六、异常产生指令"><a href="#六、异常产生指令" class="headerlink" title="六、异常产生指令"></a>六、异常产生指令</h2><p>ARM指令集中提供了两条产生异常的指令，通过这两条指令可以用软件的方法实现异常。</p><h3 id="1-SWI指令"><a href="#1-SWI指令" class="headerlink" title="1. SWI指令"></a>1. SWI指令</h3><p>SWI指令用于产生软件中断，以便用户程序能调用操作系统的系统例程。操作系统在SWI的异常处理程序中提供相应的系统服务。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWI&#123;条件&#125; 24位的立即数</span><br></pre></td></tr></table></figure><p>指令中24位的立即数指定用户程序调用系统例程的类型，相关参数通过通用寄存器传递，当指令中24位的立即数被忽略时，用户程序调用系统例程的类型由通用寄存器R0的内容决定，同时，参数通过其他通用寄存器传递。 </p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWI   0x02     ; 该指令调用操作系统编号位02的系统例程。</span><br></pre></td></tr></table></figure><h3 id="2-BKPT指令"><a href="#2-BKPT指令" class="headerlink" title="2. BKPT指令"></a>2. BKPT指令</h3><p>BKPT指令产生软件断点中断，可用于程序的调试。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BKPT   16位的立即数</span><br></pre></td></tr></table></figure><h2 id="ARM汇编伪指令"><a href="#ARM汇编伪指令" class="headerlink" title="ARM汇编伪指令"></a>ARM汇编伪指令</h2><p>在ARM汇编语言程序里，有一些特殊指令助记符，这些助记符与指令系统的助记符不同，没有相对应的操作码，通常称这些特殊指令助记符为伪指令，他们所完成的操作称为伪操作。</p><p><strong>伪指令在源程序中的作用是为完成汇编程序作各种准备工作的，这些伪指令仅在汇编过程中起作用，一旦汇编结束，伪指令的使命就完成。</strong></p><p>在ARM 的汇编程序中，有如下几种伪指令：符号定义伪指令、数据定义伪指令、汇编控制伪指令(包括宏指令)、以及其他伪指令。</p><h3 id="一、符号定义（Symbol-Definition）伪指令"><a href="#一、符号定义（Symbol-Definition）伪指令" class="headerlink" title="一、符号定义（Symbol Definition）伪指令"></a>一、符号定义（Symbol Definition）伪指令</h3><p>符号定义伪指令用于定义ARM 汇编程序中的变量、对变量赋值以及定义寄存器的别名等操作。<br>常见的符号定义伪指令有如下几种：</p><ul><li>用于定义全局变量的GBLA 、GBLL 和GBLS 。</li><li>用于定义局部变量的LCLA 、LCLL 和LCLS 。</li><li>用于对变量赋值的SETA 、SETL 、SETS 。</li><li>为通用寄存器列表定义名称的RLIST 。</li></ul><h4 id="1-GBLA、GBLL-和GBLS"><a href="#1-GBLA、GBLL-和GBLS" class="headerlink" title="1. GBLA、GBLL 和GBLS"></a>1. GBLA、GBLL 和GBLS</h4><p>GBLA 、GBLL 和GBLS 伪指令用于定义一个ARM 程序中的全局变量，并将其初始化。其中：</p><ul><li>GBLA 伪指令用于定义一个全局的数字变量，并初始化为0 ；</li><li>GBLL 伪指令用于定义一个全局的逻辑变量，并初始化为F（假）；</li><li>GBLS 伪指令用于定义一个全局的字符串变量，并初始化为空；</li></ul><p>由于以上三条伪指令用于定义全局变量，因此在整个程序范围内变量名必须唯一。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GBLA(GBLL或GBLS）全局变量名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GBLA Test1            ; 定义一个全局的数字变量，变量名为 Test1。    </span><br><span class="line">Test1 SETA 0xaa       ; 将该变量赋值为0xaa。</span><br><span class="line"></span><br><span class="line">GBLL Test2            ; 定义一个全局的逻辑变量，变量名为 Test2。    </span><br><span class="line">Test2 SETL &#123;TRUE&#125;     ; 将该变量赋值为真。    </span><br><span class="line"></span><br><span class="line">GBLS Test3            ; 定义一个全局的字符串变量，变量名为 Test3。    </span><br><span class="line">Test3 SETS “Testing”  ; 将该变量赋值为&quot;Testing”。  </span><br></pre></td></tr></table></figure><h4 id="2-LCLA、LCLL-和LCLS"><a href="#2-LCLA、LCLL-和LCLS" class="headerlink" title="2. LCLA、LCLL 和LCLS"></a>2. LCLA、LCLL 和LCLS</h4><p>LCLA 、LCLL 和LCLS 伪指令用于定义一个ARM 程序中的局部变量，并将其初始化。其中：</p><ul><li>LCLA伪指令用于定义一个局部的数字变量，并初始化为0 ;</li><li>LCLL伪指令用于定义一个局部的逻辑变量，并初始化为F（假）;</li><li>LCLS伪指令用于定义一个局部的字符串变量，并初始化为空;</li></ul><p>以上三条伪指令用于声明局部变量，在其作用范围内变量名必须唯一。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LCLA(LCLL或LCLS) 局部变量名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LCLA Test4             ; 声明一个局部的数字变 量，变量名为Test4。  </span><br><span class="line">Test3 SETA 0xaa        ; 将该变量赋值为0xaa。 </span><br><span class="line"></span><br><span class="line">LCLL Test5             ; 声明一个局部的逻辑变 量，变量名为Test5。    </span><br><span class="line">Test4 SETL &#123;TRUE&#125;      ; 将该变量赋值为真。    </span><br><span class="line"></span><br><span class="line">LCLS Test6             ; 定义一个局部的字 符串变量，变量名为Test6。    </span><br><span class="line">Test6 SETS “Testing”   ; 将该变量赋值为 &quot;Testing”。   </span><br></pre></td></tr></table></figure><h4 id="3-SETA、SETL-和SETS"><a href="#3-SETA、SETL-和SETS" class="headerlink" title="3. SETA、SETL 和SETS"></a>3. SETA、SETL 和SETS</h4><p>伪指令 SETA 、SETL 、SETS 用于给一个已经定义的全局变量或局部变量赋值。</p><ul><li>SETA伪指令用于给一个数学变量赋值;</li><li>SETL伪指令用于给一个逻辑变量赋值;</li><li>SETS伪指令用于给一个字符串变量赋值;</li></ul><p>其中，变量名为已经定义过的全局变量或局部变量，表达式为将要赋给变量的值。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 SETA(SETL或SETS) 表达式</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LCLA Test3              ; 声明一个局部的数字变量，变量名为 Test3。</span><br><span class="line">Test3 SETA 0xaa         ; 将该变量赋值为0xaa。</span><br><span class="line">LCLL Test4              ; 声明一个局部的逻辑变量，变量名为 Test4。</span><br><span class="line">Test4 SETL &#123;TRUE&#125;       ; 将该变量赋值为真。</span><br></pre></td></tr></table></figure><h4 id="4-RLIST"><a href="#4-RLIST" class="headerlink" title="4. RLIST"></a>4. RLIST</h4><p>RLIST伪指令可用于对一个通用寄存器列表定义名称，使用该伪指令定义的名称可在ARM 指令 LDM/STM中使用。</p><p>在LDM/STM指令中，列表中的寄存器访问次序为根据寄存器的编号由低到高，而与列表中的寄存器排列次序无关。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名称 RLIST &#123; 寄存器列表 &#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegList RLIST &#123;R0-R5 ，R8 ，R10&#125;  ; 将寄存器列表名称定义为 RegList ，可在ARM指令LDM&#x2F;STM中通过该名称访问寄存器列表。</span><br></pre></td></tr></table></figure><h3 id="二、数据定义（Data-Definition）伪指令"><a href="#二、数据定义（Data-Definition）伪指令" class="headerlink" title="二、数据定义（Data Definition）伪指令"></a>二、数据定义（Data Definition）伪指令</h3><p>数据定义伪指令一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。<br>常见的数据定义伪指令有如下几种：</p><ul><li>DCB：用于分配一片连续的字节存储单元并用指定的数据初始化。</li><li>DCW(DCWU)：用于分配一片连续的半字存储单元并用指定的数据初始化。</li><li>DCD(DCDU)：用于分配一片连续的字存储单元并用指定的数据初始化。</li><li>DCFD(DCFDU)：用于为双精度的浮点数分配一片连续的字存储单元并用指定的数据初始化。</li><li>DCFS(DCFSU)：用于为单精度的浮点数分配一片连续的字存储单元并用指定的数据初始化。</li><li>DCQ(DCQU)：用于分配一片以8字节为单位的连续的存储单元并用指定的数据初始化。</li><li>SPACE：用于分配一片连续的存储单元。</li><li>MAP：用于定义一个结构化的内存表首地址。</li><li>FIELD：用于定义一个结构化的内存表的数据域。</li></ul><h4 id="1-DCB"><a href="#1-DCB" class="headerlink" title="1. DCB"></a>1. DCB</h4><p>DCB伪指令用于分配一片连续的字节存储单元并用伪指令中指定的表达式初始化。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号 DCB 表达式</span><br></pre></td></tr></table></figure><ul><li>表达式可以为0～255的数字或字符串。</li><li>DCB 也可用 “=” 代替。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Str DCB “This is a test” ; 分配一片连续的字节存储单元并初始化。 </span><br></pre></td></tr></table></figure><h4 id="2-DCW-或DCWU"><a href="#2-DCW-或DCWU" class="headerlink" title="2. DCW(或DCWU)"></a>2. DCW(或DCWU)</h4><p>DCW(或DCWU)伪指令用于分配一片连续的半字存储单元并用伪指令中指定的表达式初始化。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号 DCW (或DCWU) 表达式</span><br></pre></td></tr></table></figure><ul><li>表达式可以为程序标号或数字表达式。</li></ul><p>用DCW分配的字存储单元是半字对齐的，而用DCWU分配的字存储单元并不严格半字对齐。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataTest DCW 1 ，2 ，3 ; 分配一片连续的半字存储单元并初始化。</span><br></pre></td></tr></table></figure><h4 id="3-DCD-或DCDU"><a href="#3-DCD-或DCDU" class="headerlink" title="3. DCD(或DCDU)"></a>3. DCD(或DCDU)</h4><p>DCD（或DCDU）伪指令用于分配一片连续的字存储单元并用伪指令中指定的表达式初始化。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号 DCD(或DCDU) 表达式</span><br></pre></td></tr></table></figure><ul><li>表达式可以为程序标号或数字表达式。</li><li>DCD也可 用”&amp;” 代替。</li></ul><p>用DCD分配的字存储单元是字对齐的，而用DCDU分配的字存储单元并不严格字对齐。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataTest DCD 4 , 5 , 6 ; 分配一片连续的字存储单元并初始化。 </span><br></pre></td></tr></table></figure><h4 id="4-DCFD-或DCFDU"><a href="#4-DCFD-或DCFDU" class="headerlink" title="4. DCFD(或DCFDU)"></a>4. DCFD(或DCFDU)</h4><p>DCFD（或DCFDU）伪指令用于为双精度的浮点数分配一片连续的字存储单元并用伪指令中指定的表达式初始化。</p><p>每个双精度的浮点数占据两个字单元。</p><p>用 DCFD分配的字存储单元是字对齐的，而用DCFDU分配的字存储单元并不严格字对齐。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号 DCFD（或DCFDU） 表达式</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FDataTest DCFD 2E115 , -5E7 ; 分配一片连续的字存储单元并初始化 为指定的双精度数。</span><br></pre></td></tr></table></figure><h4 id="5-DCFS-或DCFSU"><a href="#5-DCFS-或DCFSU" class="headerlink" title="5. DCFS(或DCFSU)"></a>5. DCFS(或DCFSU)</h4><p>DCFS（或DCFSU）伪指令用于为单精度的浮点数分配一片连续的字存储单元并用伪指令中指定的表达式初始化。</p><p>每个单精度的浮点数占据一个字单元。</p><p>用 DCFS分配的字存储单元是字对齐的，而用DCFSU分配的字存储单元并不严格字对齐。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号 DCFS（或DCFSU） 表达式</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FDataTest DCFS 2E5 ，-5E －7 ; 分配一片连续的字存储单元并初始化为 指定的单精度数。</span><br></pre></td></tr></table></figure><h4 id="6-DCQ-或DCQU）"><a href="#6-DCQ-或DCQU）" class="headerlink" title="6. DCQ(或DCQU）"></a>6. DCQ(或DCQU）</h4><p>DCQ（或DCQU）伪指令用于分配一片以8个字节(双字)为单位的连续存储区域并用伪指令中指定的表达式初始化。</p><p>用DCQ分配的存储单元是字对齐的，而用DCQU 分配的存储单元并不严格字对齐。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号 DCQ（或DCQU） 表达式</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataTest DCQ 100   ; 分配一片连续的存储单元并初始化为指定的值。 </span><br></pre></td></tr></table></figure><h4 id="7-SPACE"><a href="#7-SPACE" class="headerlink" title="7. SPACE"></a>7. SPACE</h4><p>SPACE伪指令用于分配一片连续的存储区域并初始化为0。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号 SPACE 表达式</span><br></pre></td></tr></table></figure><ul><li>表达式为要分配的字节数</li><li>SPACE也可用 “％” 代替</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSpace SPACE 100 ; 分配连续100字节的存储单元并初始化为0 。</span><br></pre></td></tr></table></figure><h4 id="8-MAP"><a href="#8-MAP" class="headerlink" title="8. MAP"></a>8. MAP</h4><p>MAP伪指令用于定义一个结构化的内存表的首地址。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAP 表达式 &#123; ,基址寄存器 &#125;</span><br></pre></td></tr></table></figure><ul><li>MAP也可用 “＾” 代替。</li><li>表达式可以为程序中的标号或数学表达式</li><li>基址寄存器为可选项，当基址寄存器选项不存在时，表达式的值即为内存表的首地址，当该选项存在时，内存表的首地址为表达式的值与基址寄存器的和。</li></ul><p>MAP伪指令通常与FIELD伪指令配合使用来定义结构化的内存表。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAP 0x100 , R0  ; 定义结构化内存表首地址的值为0x100＋R0 。 </span><br></pre></td></tr></table></figure><h4 id="9-FILED"><a href="#9-FILED" class="headerlink" title="9. FILED"></a>9. FILED</h4><p>FIELD伪指令用于定义一个结构化内存表中的数据域。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号 FIELD 表达式</span><br></pre></td></tr></table></figure><ul><li>FILED 也可用 “#” 代替。</li><li>表达式的值为当前数据域在内存表中所占的字节数。</li></ul><p>FIELD伪指令常与MAP伪指令配合使用来定义结构化的内存表。MAP伪指令定义内存表的首地址，FIELD伪指令定义内存表中的各个数据域，并可以为 每个数据域指定一个标号供其他的指令引用。</p><p>注意MAP和FIELD伪指令仅用于定义数据结构，并不实际分配存储单元。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAP 0x100    ; 定义结构化内存表首地址的值为0x100。</span><br><span class="line">A FIELD 16   ; 定义A的长度为16字节，位置为0x100。</span><br><span class="line">B FIELD 32   ; 定义B的长度为32字节，位置为0x110。</span><br><span class="line">S FIELD 256  ; 定义S的长度为256字节，位置为0x130。   </span><br></pre></td></tr></table></figure><h3 id="三、汇编控制（Assembly-Control）伪指令"><a href="#三、汇编控制（Assembly-Control）伪指令" class="headerlink" title="三、汇编控制（Assembly Control）伪指令"></a>三、汇编控制（Assembly Control）伪指令</h3><p>汇编控制伪指令用于控制汇编程序的执行流程，常用的汇编控制伪指令包括以下几条：</p><h4 id="1-IF、ELSE、ENDIF"><a href="#1-IF、ELSE、ENDIF" class="headerlink" title="1. IF、ELSE、ENDIF"></a>1. IF、ELSE、ENDIF</h4><p>IF 、ELSE 、ENDIF伪指令能根据条件的成立与否决定是否执行某个指令序列。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF 逻辑表达式</span><br><span class="line">指令序列 1</span><br><span class="line">ELSE</span><br><span class="line">指令序列 2</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure><ul><li>当IF后面的逻辑表达式为真，则执行指令序列1 ，否则执行指令序列2 。</li><li>ELSE及指令序列2可以没有，此时，当IF后面的逻辑表达式为真，则执行指令序列1 ，否则继续执行后面的指令。</li></ul><p>IF 、ELSE 、ENDIF伪指令可以嵌套使用。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GBLL Test ; 声明一个全局的逻辑变量，变量名为Test   </span><br><span class="line">IF Test &#x3D; TRUE</span><br><span class="line">指令序列 1</span><br><span class="line">ELSE</span><br><span class="line">指令序列 2</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure><h4 id="2-WHILE、WEND"><a href="#2-WHILE、WEND" class="headerlink" title="2. WHILE、WEND"></a>2. WHILE、WEND</h4><p>WHILE 、WEND伪指令能根据条件的成立与否决定是否循环执行某个指令序列。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE 逻辑表达式</span><br><span class="line">指令序列</span><br><span class="line">WEND</span><br></pre></td></tr></table></figure><p>当WHILE后面的逻辑表达式为真，则执行指令序列，该指令序列执行完毕后，再判断逻辑表达式的值，若为真则继续执行，一直到逻辑表达式的值为假。</p><p>WHILE 、WEND伪指令可以嵌套使用。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GBLA Counter   ; 声明一个全局的数学变量，变量名为Counter</span><br><span class="line">Counter SETA 3 ; 由变量Counter 控制循环次数</span><br><span class="line">……</span><br><span class="line">WHILE Counter &lt; 10</span><br><span class="line">指令序列</span><br><span class="line">WEND</span><br></pre></td></tr></table></figure><h4 id="3-MACRO、MEND"><a href="#3-MACRO、MEND" class="headerlink" title="3. MACRO、MEND"></a>3. MACRO、MEND</h4><p>MACRO 、MEND伪指令可以将一段代码定义为一个整体，称为宏指令，然后就可以在程序中通过宏指令多次调用该段代码。 </p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ 标号 宏名 $ 参数 1 ，$ 参数 2 ，……</span><br><span class="line">指令序列</span><br><span class="line">MEND</span><br></pre></td></tr></table></figure><p>其中，$标号在宏指令被展开时，标号会被替换为用户定义的符号，宏指令可以使用一个或多个参数，当宏指令被展开时，这些参数被相应的值替换。</p><p>宏指令的使用方式和功能与子程序有些相似，子程序可以提供模块化的程序设计、节省存储空间并提高运行速度。但在使用子程序结构时需要保护现场，从而增加了 系统的开销，因此，在代码较短且需要传递的参数较多时，可以使用宏指令代替子程序。</p><p>包含在MACRO和MEND之间的指令序列称为宏定义体，在宏定义体的第一行应声明宏的原型（包含宏名、所需的参数），然后就可以在汇编程序中通过宏名来 调用该指令序列。在源程序被编译时，汇编器将宏调用展开，用宏定义中的指令序列代替程序中的宏调用，并将实际参数的值传递给宏定义中的形式参数。</p><p>MACRO、MEND伪指令可以嵌套使用。  </p><h4 id="4-MEXIT"><a href="#4-MEXIT" class="headerlink" title="4. MEXIT"></a>4. MEXIT</h4><p>MEXIT用于从宏定义中跳转出去。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MEXIT</span><br></pre></td></tr></table></figure><h3 id="四、其他常用的伪指令"><a href="#四、其他常用的伪指令" class="headerlink" title="四、其他常用的伪指令"></a>四、其他常用的伪指令</h3><p>还有一些其他的伪指令，在汇编程序中经常会被使用，包括以下几条：</p><h4 id="1-AREA"><a href="#1-AREA" class="headerlink" title="1. AREA"></a>1. AREA</h4><p>AREA伪指令用于定义一个代码段或数据段。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AREA 段名 属性1 ，属性2 ，……</span><br></pre></td></tr></table></figure><ul><li>段名若以数字开头，则该段名需用“|”括起来，如：|1_test| 。</li><li>属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。常用的属性如下：<ul><li>CODE 属性：用于定义代码段，默认为READONLY 。</li><li>DATA 属性：用于定义数据段，默认为READWRITE 。</li><li>READONLY 属性：指定本段为只读，代码段默认为READONLY 。</li><li>READWRITE 属性：指定本段为可读可写，数据段的默认属性为READWRITE 。</li><li>ALIGN 属性：使用方式为ALIGN表达式。在默认时，ELF（可执行连接文件）的代码段和数据段是按字对齐的，表达式的取值范围为0～31，相应的对齐方式为2 表达式次方。</li><li>COMMON 属性：该属性定义一个通用的段，不包含任何的用户代码和数据。各源文件中同名的COMMON段共享同一段存储单元。 </li></ul></li></ul><p>一个汇编语言程序至少要包含一个段，当程序太长时，也可以将程序分为多个代码段和数据段。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AREA Init ，CODE ，READONLY   ; 该伪指令定义了一个代码段，段 名为Init ，属性为只读。</span><br></pre></td></tr></table></figure><h4 id="2-ALIGN"><a href="#2-ALIGN" class="headerlink" title="2. ALIGN"></a>2. ALIGN</h4><p>ALIGN伪指令可通过添加填充字节的方式，使当前位置满足一定的对齐方式。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALIGN &#123; 表达式 &#123; ,偏移量 &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>表达式的值用于指定对齐方式，可能的取值为2的幂，如1 、2 、4 、8 、16 等。若未指定表达式，则将当前位置对齐到下一个字的位置。</li><li>偏移量也为一个数字表达式，若使用该字段，则当前位置的对齐方式为：2的表达式次幂＋偏移量。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AREA Init ，CODE ，READONLY ，ALIEN＝3  ; 指定后面的指令为8字节对齐。</span><br><span class="line">指令序列</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h4 id="3-CODE16、CODE32"><a href="#3-CODE16、CODE32" class="headerlink" title="3. CODE16、CODE32"></a>3. CODE16、CODE32</h4><p>若在汇编源程序中同时包含ARM指令和Thumb指令时，可用CODE16伪指令通知编译器其后的指令序列为16位的Thumb指令，CODE32伪指令 通知编译器其后的指令序列为32位的ARM指令。</p><p>因此，在使用ARM指令和Thumb指令混合编程的代码里，可用这两条伪指令进行切换，但注意他们只通知 编译器其后指令的类型，并不能对处理器进行状态的切换。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CODE16（或CODE32）</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AREA Init ，CODE ，READONLY   ……</span><br><span class="line">CODE32 ; 通知编译器其后的指令为32位的 ARM指令</span><br><span class="line">LDR R0 ，＝NEXT＋1 ; 将跳转地址放入寄存器R0</span><br><span class="line">BX R0 ;  程序跳转到新的位置执行， 并将处理器切换到Thumb工作状态</span><br><span class="line">……</span><br><span class="line">CODE16 ;  通知编译器其后的指令为16位的 Thumb指令</span><br><span class="line">NEXT LDR R3，＝0x3FF</span><br><span class="line">……   </span><br><span class="line">END ; </span><br></pre></td></tr></table></figure><h4 id="4-ENTRY"><a href="#4-ENTRY" class="headerlink" title="4. ENTRY"></a>4. ENTRY</h4><p>ENTRY伪指令用于指定汇编程序的入口点。在一个完整的汇编程序中至少要有一个ENTRY（也可以有多个，当有多个ENTRY时，程序的真正入口点由链 接器指定），但在一个源文件里最多只能有一个ENTRY（可以没有）。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRY</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AREA Init ，CODE ，READONLY</span><br><span class="line">ENTRY ;  指定应用程序的入口点</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h4 id="5-END"><a href="#5-END" class="headerlink" title="5. END"></a>5. END</h4><p>END伪指令用于通知编译器已经到了源程序的结尾。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">END</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AREA Init ，CODE ，READONLY</span><br><span class="line">……  </span><br><span class="line">END ; 指定应用程序的结尾</span><br></pre></td></tr></table></figure><h4 id="6-EQU"><a href="#6-EQU" class="headerlink" title="6. EQU"></a>6. EQU</h4><p>EQU伪指令用于为程序中的常量、标号等定义一个等效的字符名称，类似于C语言中的＃define 。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名称 EQU 表达式 &#123; ，类型 &#125;</span><br></pre></td></tr></table></figure><ul><li>EQU可用“*”代替。</li><li>名称为EQU伪指令定义的字符名称</li><li>当表达式为32位的常量时，可以指定表达式的数据类型，可以有以下三种类型：CODE16 、CODE32 和DATA</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test EQU 50            ; 定义标号Test 的值为50。</span><br><span class="line">Addr EQU 0x55 ，CODE32  ; 定义Addr的值为0x55 ，且该处为32位的ARM指令。</span><br></pre></td></tr></table></figure><h4 id="7-EXPORT-或GLOBAL"><a href="#7-EXPORT-或GLOBAL" class="headerlink" title="7. EXPORT(或GLOBAL)"></a>7. EXPORT(或GLOBAL)</h4><p>EXPORT伪指令用于在程序中声明一个全局的标号，该标号可在其他的文件中引用。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPORT 标号 &#123;[WEAK]&#125;</span><br></pre></td></tr></table></figure><ul><li>EXPORT 可用GLOBAL代替</li><li>标号在程序中区分大小写</li><li>[WEAK] 选项声明其他的同名标号优先于该标号被引用</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AREA Init ，CODE ，READONLY</span><br><span class="line">EXPORT Stest ; 声明一个可全局引用的标号Stest   </span><br><span class="line">END</span><br></pre></td></tr></table></figure><h4 id="8-IMPORT"><a href="#8-IMPORT" class="headerlink" title="8. IMPORT"></a>8. IMPORT</h4><p>IMPORT伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，而且无论当前源文件是否引用该标号，该标号均会被加入到当前源文件的符号表中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPORT 标号 &#123;[WEAK]&#125;</span><br></pre></td></tr></table></figure><ul><li>标号在程序中区分大小写</li><li>[WEAK] 选项表示当所有的源文件都没有定义这样一个标号时，编译器也不给出错误信息，在多数情况下将该标号置为0 ，若该标号为B或BL指令引用，则将B或BL指令置为NOP操作。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AREA Init ，CODE ，READONLY</span><br><span class="line">IMPORT Main ; 通知编译器当前文件要引用标号Main，但Main在其他源文件中定 义。 </span><br><span class="line">END</span><br></pre></td></tr></table></figure><h4 id="9-EXTERN"><a href="#9-EXTERN" class="headerlink" title="9. EXTERN"></a>9. EXTERN</h4><p>EXTERN伪指令用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用，如果当前源文件实际并未引用该标号，该标号就不会被加入到当前源文件的符号表中。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXTERN 标号 &#123;[WEAK]&#125;</span><br></pre></td></tr></table></figure><ul><li>标号在程序中区分大小写</li><li>[WEAK] 选项表示当所有的源文件都没有定义这样一个标号时，编译器也不给出错误信息，在多数情况下将该标号置为0 ，若该标号为B或BL指令引用，则将B或BL指令置为NOP操作。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AREA Init ，CODE ，READONLY</span><br><span class="line">EXTERN Main   ; 通知编译器当前文件要引用标号Main，但Main在其他源文件中定 义。   </span><br><span class="line">END</span><br></pre></td></tr></table></figure><h4 id="10-GET-或INCLUDE"><a href="#10-GET-或INCLUDE" class="headerlink" title="10. GET(或INCLUDE)"></a>10. GET(或INCLUDE)</h4><p>GET伪指令用于将一个源文件包含到当前的源文件中，并将被包含的源文件在当前位置进行汇编处理。可以使用INCLUDE代替GET。</p><p>汇编程序中常用的方法是在某源文件中定义一些宏指令，用EQU定义常量的符号名称，用MAP和FIELD定义结构化的数据类型，然后用GET伪指令将这个 源文件包含到其他的源文件中。使用方法与C 语言中的”include” 相似。</p><p>GET伪指令只能用于包含源文件，包含目标文件需要使用INCBIN伪指令。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET 文件名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AREA Init ，CODE ，READONLY</span><br><span class="line">GET a1.s      ; 通知编译器当前源文件包含源文件a1.s</span><br><span class="line">GET C：\a2.s  ; 通知编译器当前源文件包含源文件C：\a2.s </span><br><span class="line">END</span><br></pre></td></tr></table></figure><h4 id="11-INCBIN"><a href="#11-INCBIN" class="headerlink" title="11. INCBIN"></a>11. INCBIN</h4><p>INCBIN伪指令用于将一个目标文件或数据文件包含到当前的源文件中，被包含的文件不作任何变动的存放在当前文件中，编译器从其后开始继续处理。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCBIN 文件名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AREA Init ，CODE ，READONLY</span><br><span class="line">INCBIN a1.dat     ; 通知编译器当前源文件包含文件a1.dat</span><br><span class="line">INCBIN C：\a2.txt ; 通知编译器当前源文件包含文件C：\a2.txt  </span><br><span class="line">END</span><br></pre></td></tr></table></figure><h4 id="12-RN"><a href="#12-RN" class="headerlink" title="12. RN"></a>12. RN</h4><p>RN伪指令用于给一个寄存器定义一个别名。采用这种方式可以方便程序员记忆该寄存器的功能。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">名称 RN 表达式</span><br></pre></td></tr></table></figure><ul><li>名称为给寄存器定义的别名</li><li>表达式为寄存器的编码</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Temp RN R0   ; 将R0定义一个别名Temp</span><br></pre></td></tr></table></figure><h4 id="13-ROUT"><a href="#13-ROUT" class="headerlink" title="13. ROUT"></a>13. ROUT</h4><p>ROUT伪指令用于给一个局部变量定义作用范围。在程序中未使用该伪指令时，局部变量的作用范围为所在的AREA，而使用ROUT后，局部变量的作为范围为当前ROUT和下一个ROUT之间。</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;名称&#125; ROUT</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxx</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ARM处理器的指令集可以分为跳转指令、数据处理指令、程序状态寄存器（PSR）处理指令、加载/存储指令、协处理器指令和异常产生指令6大指令。&lt;/p&gt;
&lt;p&gt;本文只列举一些常见的基本指令，可以正常阅读汇编代码即可。有几个注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;寄存器</summary>
      
    
    
    
    <category term="OS" scheme="https://tenloy.github.io/categories/OS/"/>
    
    
    <category term="ARM手册" scheme="https://tenloy.github.io/tags/ARM%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>iOS需要了解的ARM64汇编</title>
    <link href="https://tenloy.github.io/2021/04/16/03-4_Arm64-Introduce/"/>
    <id>https://tenloy.github.io/2021/04/16/03-4_Arm64-Introduce/</id>
    <published>2021-04-16T15:00:20.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-2-汇编语言"><a href="#1-2-汇编语言" class="headerlink" title="1.2 汇编语言"></a>1.2 汇编语言</h3><p>早期的程序员发现机器语言在阅读、书写方面的问题，是如此的难以辨别和记忆，需要记住所有抽象的二进制码，为了解决这个问题，汇编语言就产生了。汇编语言是各种CPU提供的机器指令的助记符的集合，人们可以用汇编语言直接控制硬件系统进行工作。</p><p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式。</p><p>汇编语言与硬件关联很深，所以涉及到的知识点有很多，如：寄存器、端口、寻址方式、内外中断、以及指令的实现原理等，额，如果想了解这些知识点，可以阅读<a href="https://links.jianshu.com/go?to=https://item.jd.com/12259774.html">《汇编语言（第3版）》 王爽著</a>。本篇博客类似阅读手册，主要记录一些常见的寄存器、以及不同汇编语言规范中指令的编写风格(intel及AT&amp;T的篇幅很少，毕竟我是一个iOSer，以移动端主流ARM64汇编为例)。</p><h3 id="1-2-iOS相关的指令集及对应的ARM汇编语言"><a href="#1-2-iOS相关的指令集及对应的ARM汇编语言" class="headerlink" title="1.2 iOS相关的指令集及对应的ARM汇编语言"></a>1.2 iOS相关的指令集及对应的ARM汇编语言</h3><p>作为iOS开发工程师，主要需要了解的汇编语言是：</p><ul><li>iOS模拟器：兼容x86指令集，对应 <code>AT&amp;T 汇编</code>语言规范</li><li>iOS真机设备：兼容ARM指令集，对应 <code>ARM 汇编</code>语言规范</li></ul><img src="/images/OS/arm64/2181780-36cc3b54e593b773.png" style="zoom:80%"><h2 id="二、ARM64-汇编"><a href="#二、ARM64-汇编" class="headerlink" title="二、ARM64 汇编"></a>二、ARM64 汇编</h2><ul><li>汇编里面要学习的三个重要概念：寄存器、内存模型、指令。</li><li>arm64架构又分为2种执行状态：<code>AArch64 Application Level</code> 和 <code>AArch32 Application Level</code> (后者是为了兼容以前的32bit的程序)<ul><li>AArch64执行A64指令，使用64bit的通用寄存器；</li><li>AArch32执行A32/T32指令，使用32bit的通用寄存器；</li></ul></li></ul><h3 id="2-1-先放代码-—-Hello-world"><a href="#2-1-先放代码-—-Hello-world" class="headerlink" title="2.1 先放代码 — Hello world"></a>2.1 先放代码 — Hello world</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成汇编文件：<code>xcrun --sdk iphoneos clang -S -arch arm64 helloworld.c</code>。也可以在XCode中，<code>Product -&gt; Perform Action -&gt; Assemble</code> 来生成汇编文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    .section    __TEXT,__text,regular,pure_instructions</span><br><span class="line">    .build_version ios, 13, 2   sdk_version 13, 2</span><br><span class="line">    .globl  _main               ; -- Begin function main</span><br><span class="line">    .p2align    2</span><br><span class="line">_main:                          ; @main</span><br><span class="line">    .cfi_startproc</span><br><span class="line">; %bb.0:</span><br><span class="line">    sub sp, sp, #32             ；sub 减法； sp &#x3D; sp - 32Byte</span><br><span class="line">    stp x29, x30, [sp, #16]     ；stp 寄存器存储到内存上，依次存两个；保存x29(FP)，和x30(LR) 到sp+16Byte上的16个Byte</span><br><span class="line">    add x29, sp, #16            ；add 加法；把sp+16Byte的结果写入x29(FP)；</span><br><span class="line">    .cfi_def_cfa w29, 16</span><br><span class="line">    .cfi_offset w30, -8</span><br><span class="line">    .cfi_offset w29, -16</span><br><span class="line">    stur    wzr, [x29, #-4]     ；stur 寄存器内容存储到内存；把wzr(零寄存器)中的数据写入 x29(FP)减 4Byte 的内存</span><br><span class="line">    adrp    x0, l_.str@PAGE     ；adrp 读取地址到寄存器；把符号l.str所在的Page读入x0</span><br><span class="line">    add x0, x0, l_.str@PAGEOFF  ；x0 &#x3D; x0 + l.str所在Page的偏移量</span><br><span class="line">    bl  _printf                 ; bl 子程序调用；调用printf函数</span><br><span class="line">    mov w8, #0                  ；mov 传送指令；0写入x8</span><br><span class="line">    str w0, [sp, #8]            ；w0写入sp+8的内存</span><br><span class="line">    mov x0, x8                  ; x8写入x0</span><br><span class="line">    ldp x29, x30, [sp, #16]     ；sp+16Byte处的内存的两个8Byte，分别写入x29, x30</span><br><span class="line">    add sp, sp, #32             ；sp &#x3D; sp + 32Byte</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">                                        ; -- End function</span><br><span class="line">    .section    __TEXT,__cstring,cstring_literals</span><br><span class="line">l_.str:                                 ; @.str</span><br><span class="line">    .asciz  &quot;hellom, world\n&quot;</span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure><p>汇编代码几个规则：</p><ul><li>以<code>.(点)</code>开头的是汇编器指令。汇编器指令是告诉汇编器如何生成机器码的，阅读汇编代码的时候通常可以忽略掉。<ul><li><code>.section __TEXT，__text，regular，pure_instructions</code>：表示接下来的内容在生成二进制代码的时候，应该生成到Mach-O文件 <code>__TEXT(Segment)</code> 中的 <code>__text(Section)</code>；</li><li><code>.cfi_startproc</code>：用在每个函数的开始，用于初始化一些内部数据结构；</li><li><code>.cfi_endproc</code>：在函数结束的时候使用与.cfi_startproc相配套使用；</li><li><code>.cfi_def_cfa &lt;register&gt;, &lt;offset&gt;</code>：从寄存器中获取地址并向其添加偏移量；</li><li><code>.cfi_offset &lt;register&gt;, &lt;offset&gt;</code>：寄存器以前的值保存在CFA的offset偏移处；</li></ul></li><li>以<code>:(冒号)</code>结尾的是标签(Label)。代表一个地址，在需要时可以使用跳转指令<code>跳转到标签</code>处执行。其中，以小写字母l开头的是本地(local)标签，只能用于函数内部。</li></ul><h3 id="2-2-ARM中的寄存器"><a href="#2-2-ARM中的寄存器" class="headerlink" title="2.2 ARM中的寄存器"></a>2.2 ARM中的寄存器</h3><h4 id="2-2-1-寄存器"><a href="#2-2-1-寄存器" class="headerlink" title="2.2.1 寄存器"></a>2.2.1 寄存器</h4><p>CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p><p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p><img src="/images/OS/arm64/2181780-3dffe09c419c6841.png" style="zoom:100%"><p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p><p>这里介绍一下arm64常见的一些寄存器：</p><ul><li>通用寄存器 31个：x0-x30，64位</li><li>浮点寄存器 32个：v0-v31，128位</li><li>特殊寄存器：ZR、SP、PC、SPRs</li></ul><h4 id="2-2-2-通用寄存器x0-–-x30"><a href="#2-2-2-通用寄存器x0-–-x30" class="headerlink" title="2.2.2 通用寄存器x0 – x30"></a>2.2.2 通用寄存器x0 – x30</h4><p><code>x0 - x30</code> 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。 当使用 <code>x0 - x30</code> 访问时，它就是一个64位的数。当使用 <code>w0 - w30</code> 访问时，访问的是这些寄存器的低32位，如图：</p><img src="/images/OS/arm64/2181780-e75c427c84c8457b.png" style="zoom:70%"><p>为了函数调用的目的，通用寄存器分为四组(<a href="https://links.jianshu.com/go?to=https://developer.arm.com/docs/den0024/latest/the-abi-for-arm-64-bit-architecture/register-use-in-the-aarch64-procedure-call-standard/parameters-in-general-purpose-registers">官网文档</a>):</p><img src="/images/OS/arm64/2181780-27421d825a780d70.png" style="zoom:70%"><ul><li>注意，但参数过多、返回值过大时，比如是个成员很多的结构体，通用x0-x7不够用，会通过栈来传递</li></ul><h4 id="2-2-3-一些特殊寄存器"><a href="#2-2-3-一些特殊寄存器" class="headerlink" title="2.2.3 一些特殊寄存器"></a>2.2.3 一些特殊寄存器</h4><h5 id="ZR"><a href="#ZR" class="headerlink" title="ZR"></a>ZR</h5><p>zero register 零寄存器，与通用寄存器一样，x、w分别代表64/32位(<code>XZR/WZR</code>)，作用就是0，写进去代表丢弃结果，拿出来是0.</p><h5 id="SP"><a href="#SP" class="headerlink" title="SP"></a>SP</h5><p>Stack Pointer 保存栈指针。在指令编码中，使用 <code>SP/WSP</code>来进行对SP寄存器的访问。</p><h5 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h5><p>程序计数器，俗称PC指针，总是指向即将要执行的下一条指令。在arm64中，软件是不能改写PC寄存器的。</p><h5 id="V0-–-V31"><a href="#V0-–-V31" class="headerlink" title="V0 – V31"></a>V0 – V31</h5><p>向量寄存器，也可以说是浮点型寄存器。它的特点是每个寄存器的大小是 128 位的。 分别可以用 <code>Bn Hn Sn Dn Qn</code> 的方式来访问不同的位数。可以这样理解记忆，基于一个word是32位，也就是4Byte大小：</p><ul><li>Bn：一个Byte的大小</li><li>Hn：half word. 就是16位</li><li>Sn：single word. 32位</li><li>Dn：double word. 64位</li><li>Qn：quad word. 128位</li></ul><img src="/images/OS/arm64/2181780-a1e8cfe27820c7be.png" style="zoom:70%"><h5 id="程序状态寄存器"><a href="#程序状态寄存器" class="headerlink" title="程序状态寄存器"></a>程序状态寄存器</h5><p>状态寄存器，用于存放程序运行中一些状态标识。不同于编程语言里面的if else。在汇编中就需要根据状态寄存器中的一些状态来控制分支的执行。状态寄存器又分为</p><ul><li>The Current Program Status Register (CPSR)</li><li>The Saved Program Status Registers (SPSRs)</li></ul><p>一般都是使用 <code>CPSR</code> ，当发生异常时，<code>CPSR</code> 会存入 <code>SPSR</code> 。当异常恢复，再拷贝回 <code>CPSR</code>。</p><p>不同于其他寄存器，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而CPSR寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p><ul><li>CPSR寄存器是32位的</li><li>CPSR的低8位（包括I、F、T和M[4:0]）称为<code>控制位</code>，程序无法修改，除非CPU运行于特权模式下，程序才能修改控制位。</li><li>N、Z、C、V均为<code>条件标志位</code>，分别代表运算过程中产生的状态。它们的内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行。</li></ul><img src="/images/OS/arm64/CPSR01.png" style="zoom:75%"><img src="/images/OS/arm64/CPSR02.png" style="zoom:70%"><p>还有一些系统寄存器，如 <code>FPSR</code> <code>FPCR</code>是浮点型运算时的状态寄存器等。基本了解上面这些寄存器就可以了。</p><h3 id="2-3-ARM指令的使用格式"><a href="#2-3-ARM指令的使用格式" class="headerlink" title="2.3 ARM指令的使用格式"></a>2.3 ARM指令的使用格式</h3><p>ARM作为精简指令集(RISC)，所有 ARM 指令(RISC)的长度都是 <code>32 位</code>。行成对比的是复杂指令集(CISC，如x86)，指令长度不同，最长的指令长达15 bytes，等于120位。</p><p>ARM指令使用的基本格式如下：<code>&lt;opcode&gt;&#123;&lt;cond&gt;&#125;&#123;S&#125; &lt;Rd&gt;,&lt;Rn&gt;,&#123;&lt;operand2&gt;&#125;</code></p><ul><li>Opcode：操作码；指令助记符，如LDR、STR等。</li><li>Cond：可选的条件码；执行条件，如EQ、NE等。</li><li>S：可选后缀；若指定S，则根据指令执行结果更新CPSR中的条件码</li><li>Rd：目标寄存器</li><li>Rn：存放在第1操作数的寄存器。</li><li>operand2：第2个操作数。</li><li>“&lt; &gt;”：“&lt; &gt;”内的项是必需的，例如，<opcode>是指令助记符，这是必须书写的。</li><li>“{ }”：“{ }”内的(ˇˍˇ) 项是可选的，例如，{&lt; code&gt;}为指令执行条件，是可选项。若不书写，则使用默认条件AL（无条件执行）。</li></ul><p>有几个注意点：</p><ul><li><strong>寄存器</strong>：为标号，不加前缀（ARM汇编中，标号就是一个符号，代表着汇编程序中指令或数据的内存地址）</li><li><strong>操作数顺序</strong>：目标操作数在左，源操作数在右</li><li><strong>立即数</strong>：前加#作为前缀</li><li><strong>寻址格式</strong>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;寻址格式：</span><br><span class="line">[x10, #0x10]      ; signed offset。意思是从 x10 + 0x10的地址取值</span><br><span class="line">[sp, #-16]!       ; pre-index。意思是从 sp-16地址取值，取值完后在把 sp-16  writeback 回 sp</span><br><span class="line">                  ; ! 表示寄存器写回，如果没有！，那么只会从 sp-16 地址读写值，而不会修改 sp 的值</span><br><span class="line">[sp], #16         ; post-index。意思是从 sp 地址取值，取值完后在把 sp+16 writeback 回 sp</span><br><span class="line"></span><br><span class="line">;举例：</span><br><span class="line">ldr x0, [x1]              ; 从&#96;x1&#96;指向的地址里面取出一个 64 位大小的数存入 &#96;x0&#96;</span><br><span class="line">ldp x1, x2, [x10, #0x10]  ; 从 x10 + 0x10 指向的地址里面取出 2个 64位的数，分别存入x1, x2</span><br><span class="line">str x5, [sp, #24]         ; 把x5的值（64位数值）存到 sp+24 指向的内存地址上</span><br><span class="line">stp x29, x30, [sp, #-16]! ; 把 x29, x30的值存到 sp-16的地址上，并且把 sp-&#x3D;16. </span><br><span class="line">ldp x29, x30, [sp], #16   ; 从sp地址取出 16 byte数据，分别存入x29, x30. 然后 sp+&#x3D;16;</span><br></pre></td></tr></table></figure><p>除此之外，还有两种地址表示方式(相对寻址)：</p><ul><li><code>程序相对地址</code>(程序相对的表达式)：是命名寄存器的值加上或减去一个数字常数</li><li><code>寄存器相对地址</code>(寄存器相对的表达式)：表示为相对当前程序计数器 (PC) 的偏移量。它通常是标签与数字<br>表达式的组合(如<code>ADR</code>指令)</li></ul><h3 id="2-4-ARM常用指令"><a href="#2-4-ARM常用指令" class="headerlink" title="2.4 ARM常用指令"></a>2.4 ARM常用指令</h3><p>ARM处理器的指令集可以分为跳转指令、数据处理指令、程序状态寄存器（PSR）处理指令、加载/存储指令、协处理器指令和异常产生指令6大指令。</p><p>由于篇幅原因，只列举了常用的一些，可以正常阅读汇编代码即可。更多的可以跳转<a href="https://www.jianshu.com/p/b9301d02a125">ARM64指令简易手册</a>查阅。全面的可以查看<a href="https://links.jianshu.com/go?to=https://developer.arm.com/architectures">ARM官网文档</a>。如果想看中文版的资料可以看<a href="https://links.jianshu.com/go?to=http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204ic/Cegbgefe.html">《汇编器指南》— 第二章、第四章</a></p><h4 id="2-4-1-数据处理指令"><a href="#2-4-1-数据处理指令" class="headerlink" title="2.4.1 数据处理指令"></a>2.4.1 数据处理指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  MOV    X1，X0              ; 将寄存器X0的值传送到寄存器X1。MOV：从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器。</span><br><span class="line"></span><br><span class="line">;算术运算：ADD SUB MUL … 等加减乘除运算</span><br><span class="line">  ADD    X0，X1，X2          ; 寄存器X1和X2的值相加后传送到X0</span><br><span class="line">  SUB    X0，X1，X2          ; 寄存器X1和X2的值相减后传送到X0</span><br><span class="line">  MUL</span><br><span class="line">  add  x14, x4, x27, lsl #1  ; 算术运算也可以与逻辑位移运算一起用，意思是把  (x27 &lt;&lt; 1) + x4 &#x3D; x14;</span><br><span class="line"></span><br><span class="line">;扩展位数运算：有 zero extend(高位补0) 和 sign extend(高位填充和符号位一致，一般有符号数用这个)。 一般用来补齐位数。常和算术运算配合一起.</span><br><span class="line">  add  w20, w30, w20, uxth   ; 算术运算也可以与扩展位数运输算一起，意思是取 w20的低16位，无符号补齐到32位后再进行  w30 + w20的运算</span><br><span class="line"></span><br><span class="line">;逻辑运算指令</span><br><span class="line">  LSL                        ; 逻辑左移</span><br><span class="line">  LSR                        ; 逻辑右移</span><br><span class="line">  ASR                        ; 算术右移</span><br><span class="line">  ROR                        ; 循环右移</span><br><span class="line">  AND    X0，X0，#0xF        ; 与。X0的值与0xF相位与后的值传送到X0</span><br><span class="line">  ORR    X0，X0，#9          ; 或。X0的值与9相位或后的值传送到X0</span><br><span class="line">  EOR    X0，X0，#0xF        ; 异或。X0的值与0xF相异或后的值传送到X0</span><br></pre></td></tr></table></figure><p>ARM指令中，不支持将立即数直接写入内存，需要先通过mov写入寄存器，然后通过str将寄存器中的值存储进内存</p><h4 id="2-4-2-寄存器加载-存储指令"><a href="#2-4-2-寄存器加载-存储指令" class="headerlink" title="2.4.2 寄存器加载/存储指令"></a>2.4.2 寄存器加载/存储指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LDR    X5，[X6，#0x08]           ; ld(load)： X6寄存器加0x08的和的地址值内的数据传送到X5</span><br><span class="line">LDP    x29, x30, [sp, #0x10]     ; ldp(load pair)：是ldr 的变种指令，可以同时操作两个寄存器，从指定内存处读取两个数据到寄存器</span><br><span class="line">STR    X0, [SP, #0x8]            ; st:store, str:往内存中写数据（偏移值为正）; X0寄存器的数据传送到SP+0x8地址值指向的存储空间</span><br><span class="line">STUR   w0, [x29, #-0x8]          ; 往内存中写数据（偏移值为负）</span><br><span class="line">STP    x29, x30, [sp, #0x10]     ; stp(store pair)：是str 的变种指令，可以同时操作两个寄存器，将一对寄存器中的值，入栈，存放到指定内存处</span><br><span class="line">ADR      ; 将一个立即值与 pc 值相加，并将结果写入目标寄存器</span><br><span class="line">ADRP     ; 以页为单位的大范围的地址读取指令，这里的P就是page的意思。取得page的基地址存入寄存器</span><br><span class="line">&#x2F;*示例: </span><br><span class="line">  adrp    x0, l_.str@PAGE         ；将符号l.str所在的page基址读入x0</span><br><span class="line">  add     x0, x0, l_.str@PAGEOFF  ；x0 &#x3D; x0 + l.str所在page中的偏移量</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><h4 id="2-4-3-跳转和控制指令"><a href="#2-4-3-跳转和控制指令" class="headerlink" title="2.4.3 跳转和控制指令"></a>2.4.3 跳转和控制指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CBZ      ; 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）</span><br><span class="line">CBNZ     ; 比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）</span><br><span class="line">CMP      ; 比较指令，相当于SUBS，影响程序状态寄存器CPSR，关于CPSR的几个状态值，前面寄存器节已经讲过</span><br><span class="line"></span><br><span class="line">B&#123;条件&#125; 目标地址  ; 跳转指令，可带条件跳转与cmp配合使用。一般是本方法内的跳转，如while循环，if else等。</span><br><span class="line">BL  ; 带返回的跳转指令， 返回地址保存到LR（X30）。存了LR也就意味着可以返回到本方法继续执行。一般用于不同方法之间的调用</span><br><span class="line">RET ; 子程序返回指令，返回地址默认保存在LR（X30）</span><br></pre></td></tr></table></figure><h4 id="2-4-4-异常产生指令"><a href="#2-4-4-异常产生指令" class="headerlink" title="2.4.4 异常产生指令"></a>2.4.4 异常产生指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SWI(Software Interrupt)    ; 软件中断指令。用于产生软中断，从而实现处理器从用户模式变换到管理模式，CPSR保存到管理模式的SPSR中，执行转移到SWI向量，在其他模式下也可以使用SWI指令，处理器同样切换到管理模式。</span><br><span class="line">BKPT(BreakPoint)           ; 断点中断指令。产生一个预取异常（prefetch abort），它常被用来设置软件断点，在调试程序时十分有用。当系统中存在调试硬件时，该指令被忽略。</span><br></pre></td></tr></table></figure><h3 id="2-5-ARM指令的二进制编码"><a href="#2-5-ARM指令的二进制编码" class="headerlink" title="2.5 ARM指令的二进制编码"></a>2.5 ARM指令的二进制编码</h3><h4 id="2-5-1-对应的二进制编码格式"><a href="#2-5-1-对应的二进制编码格式" class="headerlink" title="2.5.1 对应的二进制编码格式"></a>2.5.1 对应的二进制编码格式</h4><p>ARM指令集是以<code>32位</code>二进制编码的方式给出的，大部分的指令编码中定义了第一操作数、第二操作数、目的操作数、条件标志影响位以及每条指令所对应的不同功能实现的二进制位。<strong>每条32位ARM指令都具有不同的二进制编码方式，与不同的指令功能相对应</strong>。</p><p>如图所示表示了ARM指令集编码：</p><img src="/images/OS/arm64/2181780-fe8f75682a49fb75.jpg" style="zoom:65%"><h4 id="2-5-2-条件执行"><a href="#2-5-2-条件执行" class="headerlink" title="2.5.2 条件执行"></a>2.5.2 条件执行</h4><p>ARM指令的一个重要特点就是所有指令都是带有条件的，就是说汇编中可以根据状态寄存器中的一些状态来控制分支的执行。</p><p>在ARM的指令编码表中，统一占用编码的最高4位[31:28]来表示条件码。每种条件码用两个英文缩写字符表示其含义，可添加在指令助记符的后面，表示指令执行时必须要满足的条件。ARM指令根据CPSR中的条件位自动判断是否执行指令。在条件满足时，指令执行；否则，指令被忽略。</p><p>例如，数据传送指令MOV加上条件后缀EQ后成为MOVEQ，表示“相等则执行传送”，“不相等则本条指令不执行”，即只有当CPRS中的Z标志为1时，才会发生数据传送。ARM指令集编码表列举了4位条件码的16种编码中能为用户所使用的15种，而编码1111为系统暂不使用的保留编码。</p><img src="/images/OS/arm64/2181780-00533963d2c07253.jpg" style="zoom:90%"><img src="/images/OS/arm64/2181780-72b831ae09d51685.png" style="zoom:65%"><p>看下面几行汇编指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmp x2, #0         ; x2 - 0 &#x3D; 0。  状态寄存器标识zero: PSTATE.NZCV.Z &#x3D; 1</span><br><span class="line">b.ne  0x1000d48f0  ; ne就是个condition code, 这句的意思是，当判断状态寄存器 NZCV.Z !&#x3D; 1才跳转，因此这句不会跳转</span><br><span class="line"></span><br><span class="line">0x1000d4ab0 bl testFuncA               ; 跳转方法，这个时候 lr 设置为 0x1000d4ab4</span><br><span class="line">0x1000d4ab4 orr x8, xzr, #0x1f00000000 ; testFuncA执行完之后跳回lr就周到了这一行</span><br></pre></td></tr></table></figure><ul><li><a href="https://links.jianshu.com/go?to=http://blog.eetop.cn/blog-204849-53277.html">ARM指令集编码概述</a></li><li><a href="https://links.jianshu.com/go?to=https://wenku.baidu.com/view/79d1582d59fafab069dc5022aaea998fcd224042.html?re=view">ARM汇编指令机器码举例详解</a></li></ul><h2 id="三、函数调用栈"><a href="#三、函数调用栈" class="headerlink" title="三、函数调用栈"></a>三、函数调用栈</h2><p>先简单再说一下内存模型：</p><h3 id="3-1-堆"><a href="#3-1-堆" class="headerlink" title="3.1 堆"></a>3.1 堆</h3><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p><p>程序运行的时候，操作系统会给它<strong>分配一段内存，用来储存程序和运行产生的数据</strong>。这段内存有起始地址和结束地址，比如从 <code>0x1000</code> 到 <code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p><p>程序运行过程中，对于<strong>动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户</strong>，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址 <code>0x1000</code> 开始给他分配，一直分配到地址 <code>0x100A</code> ，如果再要求得到22个字节，那么就分配到 <code>0x1020</code>。</p><blockquote><p><strong>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</strong></p></blockquote><h3 id="3-2-栈"><a href="#3-2-栈" class="headerlink" title="3.2 栈"></a>3.2 栈</h3><blockquote><p>Stack 是由于函数运行而临时占用的内存区域。或者说栈是指令执行时存放临时变量的内存空间。<strong>一个函数对应一帧，<code>fp</code>指向当前frame的栈底，<code>sp</code>指向栈顶</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，系统开始执行main函数时，会为它在内存里面建立一个<code>帧（frame）</code>，所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p><p>如果函数内部调用了其他函数，会发生什么情况？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">add_a_and_b</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，<strong>调用栈有多少层，就有多少帧</strong>。</p><p>等到<code>add_a_and_b</code><strong>运行结束，它的帧就会被回收</strong>，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p>注意：</p><ul><li>Stack 是由内存区域的结束地址开始，<code>从高位（地址）向低位（地址）分配</code>。<ul><li>栈顶置针向低移动，就是分配临时存储空间，栈顶置针向高移动，就是释放临时存储空间。</li><li>比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。</li></ul></li><li>栈中一个数据所分配到的内存中，存储(读取)数据时，是<code>从低位（地址）向高位（地址）读写</code>的。即<code>栈中数据的打印地址(起始地址)与堆中一样，是低地址开始</code>。<ul><li>情况一：见下面代码块中的<code>stp</code>、<code>ldp</code>。</li><li>情况二：复合类型，如创建一个结构体局部变量，打印成员变量，会发现是从低地址向高地址依次打印出来的</li><li>注意：基本数据类型的存储，还涉及到<code>大端、小端字节序</code>的概念，即指高位字节在前(后)。</li></ul></li><li>补充：复合数据类型都是由基本数据类型组成的，基本数据类型的存储不会带来空闲(冗余)空间的：<ul><li>char类型的数据值为单个字符，ASCII码值对应为0-255，正好一个字节存储。</li><li>int类型，比如int = 1，int占4字节，存的时候会存0x00000001，即会转成8位的16进制表示存储，占满4字节</li><li>冗余空间的产生，往往是因为一些比如对齐之类的存储策略造成的</li></ul></li></ul><p>下面的图简单的描述了 main 调用方法 printf 时，栈是如何划分的：</p><img src="/images/OS/arm64/2181780-1905b18d9661ce46.png" style="zoom:35%"><p>下面是方法的调用过程，分别对应方法头、方法尾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">; x29就是fp, x30就是lr</span><br><span class="line"></span><br><span class="line">; 方法头：保存当前函数&#x2F;子程序(main)的栈底FP、LR(main结束后需要执行的下一条指令)</span><br><span class="line">sub  sp， sp， #32             ; sub 减法； sp &#x3D; sp - 32Byte</span><br><span class="line">stp  x29， x30， [sp， #16]    ; stp 寄存器存储到内存上；保存x29(FP)、x30(LR)到sp+16Byte上的16个Byte(通用寄存器，用x访问，表示64位，8Byte)</span><br><span class="line">add  x29， sp， #16            ; add 加法；把sp+16Byte写入x29(FP)，保存即将执行函数的栈底</span><br><span class="line"></span><br><span class="line">bl  _printf ; 子程序调用。 </span><br><span class="line">&#x2F;*</span><br><span class="line"> 跳转到_printf方法处，同时将该行的下一个指令的地址复制到 lr。作用也很好理解：当printf执行完了之后要返回来继续执行，但是计算机要如何知道返回到哪执行呢？ 就是靠lr记录了返回的地址，方法才能得以正常返回。</span><br><span class="line"> 本来LR中存储的是LR(main)，是记录main函数执行完需要返回执行的下一条指令。在发生bl _printf后，LR存储的是printf函数执行完需要执行的下一条执行。这里没显示printf函数的汇编代码，在其中还有一个ret，会返回到这个LR</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">; 方法尾</span><br><span class="line">ldp x29， x30， [sp， #16]     ; 将sp+16Byte后的两个8Byte，分别存入FP、LR，恢复为FP(main)，LR(main)</span><br><span class="line">add sp， sp， #32              ; sp &#x3D; sp + 32Byte</span><br><span class="line">&#x2F;*</span><br><span class="line">这一步执行完之后，fp就执行了图中FP(main)；sp指向了 SP(main)；lr恢复成main执行完后的返回地址。 </span><br><span class="line">这个时候状态已经完全恢复到了 main 的环境</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">ret    ; 返回指令，这一步直接执行lr的指令。</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>方法头、尾的作用就是调用前保存程序状态，调用后恢复程序状态。</li><li>如果一个函数内部没有其他函数调用，也就没有这几行方法头、尾了，比如一个最简单的程序如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  #include &lt;stdio.h&gt;</span><br><span class="line">  void nothing()&#123;</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">  汇编代码中就一行ret指令，如下：</span><br><span class="line"> *&#x2F;</span><br><span class="line"> </span><br><span class="line">_nothing:                               ; @nothing</span><br><span class="line">    .cfi_startproc</span><br><span class="line">; %bb.0:</span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure><p>关于参数及返回值的传递，具有以下规则(赘述一遍，前面讲寄存器时提过)：</p><ul><li>当函数参数个数小于等于8个的时候，x0-x7依次存储前8个参数</li><li>参数个数大于8个的时候，多余的参数会通过栈传递</li><li>方法通常通过x0返回数据，如果返回的数据结构较大，则通过x8将数据的地址进行返回（寄存器最大为8字节，超过8字节的返回值，一个寄存器就传递不了了）</li><li>在Intel 32位汇编中：<ul><li>小于等于4字节，函数将返回值存储在eax中（32位机器，eax本身只有4个字节）</li><li>5～8字节，几乎所有的调用惯例(调用约定)都是采用eax和edx 联合返回的方式进行的，eax存储返回值的低4字节，edx存储返回值的高4字节</li><li>大于8字节，在栈上临时开辟一块内存区域作为中转，eax返回数据的地址。返回时，先将值写入到这一块指定的栈内存，外部程序使用时再读取，多了两次内存读写，造成额外开销。(参考<a href="https://www.jianshu.com/p/23a9110cff96">《程序员的自我修养—第10章内存》</a>)</li></ul></li></ul><h3 id="3-3-Stack-backtrace与符号化"><a href="#3-3-Stack-backtrace与符号化" class="headerlink" title="3.3 Stack backtrace与符号化"></a>3.3 Stack backtrace与符号化</h3><p>栈回溯对代码调试和crash定位有很重大的意义，通过之前几个步骤的图解，栈回溯的原理也相对比较清楚了。</p><ol><li>通过当前的SP，FP可以得到当前函数的stack frame，通过PC可以得到当前执行的地址。</li><li>在当前栈的FP上方，可以得到Caller(调用者)的FP，和LR。通过偏移，我们还可以获取到Caller的SP。由于LR保存了Caller下一条指令的地址，所以实际上我们也获取到了Caller的PC</li><li>有了Caller的FP，SP和PC，我们就可以获取到Caller的stack frame信息，由此递归就可以不获取到所有的Stack Frame信息。</li></ol><p>下面这个网图(<a href="https://juejin.cn/post/6910791727670362125">BSBackTracelogger学习笔记</a>)挺详细的：</p><img src="/images/OS/arm64/k3u1fbpfcp-watermark.png" style="zoom:95%"><p>c函数调用a函数是一个入栈出栈的过程，调用开始的时候入栈，同时需要保存c函数的FP(x29)和LR(x30)在a函数的FP和FP+8的位置，即当前函数a的FP位置保存的就是调用方的FP位置，a函数调用结束时返回到LR的位置继续执行下一条指令，而这条指令属于c函数，因此我们可以 <strong>通过FP来建立整个调用链的关系，通过LR来确认调用方函数的符号。</strong></p><p><strong>尽管如此，有两种情况是获取不到调用堆栈的，一种是尾调用优化，一种是内联函数。</strong></p><p>栈回溯的过程中，我们拿到的是函数的地址，又是如何通过函数地址获取到函数的名称和偏移量的呢？</p><ul><li>对于系统的库，比如<code>CoreFoundation</code>我们可以直接通过系统的符号表拿到</li><li>对于自己代码，则依赖于编译时候生成的dsym文件。</li></ul><p>这个过程我们称之为 <code>symbolicate</code> ，对于iOS设备上的crash log，我们可以直接通过XCode的工具 <code>symbolicatecrash</code> 来符号化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources</span><br><span class="line">./symbolicatecrash ~/Desktop/1.crash ~/Desktop/1.dSYM &gt; ~/Desktop/result.crash</span><br></pre></td></tr></table></figure><p>当然，可以用工具 <code>dwarfdump</code> 去查询一个函数地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --lookup 0x000000010007528c  -arch arm64 1.dSYM</span><br></pre></td></tr></table></figure><h2 id="四、内联汇编"><a href="#四、内联汇编" class="headerlink" title="四、内联汇编"></a>四、内联汇编</h2><p>用汇编编写的程序虽然运行速度快，但开发速度非常慢，效率也很低。如果只是想对关键代码段进行优化，或许更好的办法是将汇编指令嵌入到 C 语言程序中，从而充分利用高级语言和汇编语言各自的特点。但一般来讲，在 C 代码中嵌入汇编语句要比”纯粹”的汇编语言代码复杂得多，因为需要解决如何分配寄存器，以及如何与C代码中的变量相结合等问题。</p><p>GCC 提供了很好的内联汇编支持。最基本的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__asm__(&quot;asm statements&quot;);</span><br><span class="line">; 例如：__asm__(&quot;nop&quot;);</span><br></pre></td></tr></table></figure><p>如果需要同时执行多条汇编语句，则应该用”\n\t”将各个语句分隔开，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__asm__( &quot;pushl %%eax \\n\\t&quot;</span><br><span class="line">         &quot;movl $0, %%eax \\n\\t&quot;</span><br><span class="line">         &quot;popl %eax&quot;);</span><br></pre></td></tr></table></figure><p>通常嵌入到 C 代码中的汇编语句很难做到与其它部分没有任何关系，因此更多时候需要用到完整的内联汇编格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__asm__(&quot;asm statements&quot; </span><br><span class="line">        : outputs </span><br><span class="line">        : inputs </span><br><span class="line">        : registers-modified);                        </span><br></pre></td></tr></table></figure><p>插入到 C 代码中的汇编语句是以”:”分隔的四个部分：</p><ul><li><p>第一部分是汇编代码本身，通常称为指令部，其格式和在汇编语言中使用的格式基本相同。指令部分是必须的，而其它部分则可以根据实际情况而省略。</p><ul><li>在将汇编语句嵌入到C代码中时，操作数如何与C代码中的变量相结合是个很大的问题。GCC采用如下方法来解决这个问题：程序员提供具体的指令，而对寄存器的使用则只需给出”样板”和约束条件就可以了，具体如何将寄存器与变量结合起来完全由GCC和GAS来负责。</li><li>在GCC内联汇编语句的指令部中，加上前缀’%’的数字(如%0，%1)表示的就是需要使用寄存器的”样板”操作数。指令部中使用了几个样板操作数，就表明有几个变量需要与寄存器相结合，这样GCC和GAS在编译和汇编时会根据后面给定的约束条件进行恰当的处理。由于样板操作数也使用’ %’作为前缀，因此在涉及到具体的寄存器时，寄存器名前面应该加上两个’%’，以免产生混淆。</li></ul></li><li><p>紧跟在指令部后面的是输出部，是规定输出变量如何与样板操作数进行结合的条件，每个条件称为一个”约束”，必要时可以包含多个约束，相互之间用逗号分隔开就可以了。每个输出约束都以’=’号开始，然后紧跟一个对操作数类型进行说明的字后，最后是如何与变量相结合的约束。凡是与输出部中说明的操作数相结合的寄存器或操作数本身，在执行完嵌入的汇编代码后均不保留执行之前的内容，这是GCC在调度寄存器时所使用的依据。</p></li><li><p>输出部后面是输入部，输入约束的格式和输出约束相似，但不带’=’号。如果一个输入约束要求使用寄存器，则GCC在预处理时就会为之分配一个寄存器，并插入必要的指令将操作数装入该寄存器。与输入部中说明的操作数结合的寄存器或操作数本身，在执行完嵌入的汇编代码后也不保留执行之前的内容。</p></li><li><p>有时在进行某些操作时，除了要用到进行数据输入和输出的寄存器外，还要使用多个寄存器来保存中间计算结果，这样就难免会破坏原有寄存器的内容。在GCC内联汇编格式中的最后一个部分中，可以对将产生副作用的寄存器进行说明，以便GCC能够采用相应的措施。</p></li></ul><p>下面是一个内联汇编的简单例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* inline.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">0</span>;</span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;movl %1, %%eax;\\n\\r&quot;</span></span><br><span class="line">                         <span class="string">&quot;movl %%eax, %0;&quot;</span></span><br><span class="line">                         :<span class="string">&quot;=r&quot;</span>(b)      <span class="comment">/* 输出 */</span></span><br><span class="line">                         :<span class="string">&quot;r&quot;</span>(a)       <span class="comment">/* 输入 */</span></span><br><span class="line">                         :<span class="string">&quot;%eax&quot;</span>);     <span class="comment">/* 不受影响的寄存器 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d, %d\\n&quot;</span>, a, b);                        </span><br><span class="line">&#125;                        </span><br></pre></td></tr></table></figure><p>上面的程序完成将变量a的值赋予变量b，有几点需要说明：</p><ul><li>变量 b 是输出操作数，通过 %0 来引用，而变量 a 是输入操作数，通过 %1 来引用。</li><li>输入操作数和输出操作数都使用 r 进行约束，表示将变量 a 和变量 b 存储在寄存器中。输入约束和输出约束的不同点在于输出约束多一个约束修饰符 ‘=’。</li><li>在内联汇编语句中使用寄存器 eax 时，寄存器名前应该加两个 ‘%’，即 %%eax。内联汇编中使用 %0、%1 等来标识变量，任何只带一个 ‘%’ 的标识符都看成是操作数，而不是寄存器。</li><li>内联汇编语句的最后一个部分告诉 GCC 它将改变寄存器 eax 中的值，GCC 在处理时不应使用该寄存器来存储任何其它的值。</li><li>由于变量 b 被指定成输出操作数，当内联汇编语句执行完毕后，它所保存的值将被更新。</li></ul><p>在内联汇编中用到的操作数从输出部的第一个约束开始编号，序号从0开始，每个约束记数一次，指令部要引用这些操作数时，只需在序号前加上 ‘%’ 作为前缀就可以了。需要注意的是，内联汇编语句的指令部在引用一个操作数时总是将其作为32位的长字使用，但实际情况可能需要的是字或字节，因此应该在约束中指明正确的限定符：</p><table><thead><tr><th>限定符</th><th>意义</th></tr></thead><tbody><tr><td>“m”、”v”、”o”</td><td>内存单元</td></tr><tr><td>“r”</td><td>任何寄存器</td></tr><tr><td>“q”</td><td>寄存器eax、ebx、ecx、edx之一</td></tr><tr><td>“i”、”h”</td><td>直接操作数</td></tr><tr><td>“E”和”F”</td><td>浮点数</td></tr><tr><td>“g”</td><td>任意</td></tr><tr><td>“a”、”b”、”c”、”d”</td><td>分别表示寄存器eax、ebx、ecx和edx</td></tr><tr><td>“S”和”D”</td><td>寄存器esi、edi</td></tr><tr><td>“I”</td><td>常数（0至31）</td></tr></tbody></table><p>摘自<a href="https://links.jianshu.com/go?to=https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html">Linux 汇编语言开发指南—第七节</a></p><h2 id="五、汇编层次看高级语言"><a href="#五、汇编层次看高级语言" class="headerlink" title="五、汇编层次看高级语言"></a>五、汇编层次看高级语言</h2><p>汇编层面上只有寄存器、内存及数据(地址(无符号整数)、数字(定点、浮点)、字符、逻辑数)</p><ul><li><strong>指针</strong>：本质上就是一个变量的地址。</li><li><strong>结构体</strong>：本质上就是按照一定规则分配的连续内存。<ul><li>结构体作为参数时，将成员通过连续的通用寄存器或者浮点型寄存器传入。当结构体过大(<code>成员过多、复杂</code>)的时候，作为参数和返回值时，通过栈来传递，这一点和函数的<code>参数个数过多</code>的时候类似。</li><li>举例：当使用printf直接打印<code>结构体变量</code>时(一般不这么使用，而是打印<code>结构体.成员变量</code>)，不是直接打印地址，而是打印成员。前面有多少个打印字符，就会打印出多少个成员变量的值。(如果打印字符多于成员数，会打印出一些随机的东西)</li></ul></li><li><strong>数组</strong>：<ul><li>数组作为函数参数的时候，是以指针的方式传入的，比如这个例子中，是把sp+12Byte的地址作为参数放到x0中，传递给logArray函数的。</li><li>初始化数组的变量是存储在代码段的常量区，<code>.section __TEXT，__const</code></li><li>在编译过后，会在变量区域的上下各插入一个<code>___stack_chk_guard</code>，在方法执行完毕后，检查栈上的___stack_chk_guard是否被修改过了，如果被修改过了报错。</li></ul></li></ul><h2 id="六、intel、AT-amp-T汇编的简单对比了解"><a href="#六、intel、AT-amp-T汇编的简单对比了解" class="headerlink" title="六、intel、AT&amp;T汇编的简单对比了解"></a>六、intel、AT&amp;T汇编的简单对比了解</h2><img src="/images/OS/arm64/2181780-7e9657f2cd933fff.png" style="zoom:80%"><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li>关于ARM64汇编<ul><li><a href="https://links.jianshu.com/go?to=https://developer.arm.com/products/architecture">ARMv8-A Architecture – ARM</a></li><li><a href="https://links.jianshu.com/go?to=http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204ic/Cegbgefe.html">《汇编器指南》第二章、第四章— ARM官网文档</a></li><li><a href="https://links.jianshu.com/go?to=http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">汇编语言入门教程(intel汇编) — 阮一峰</a></li><li><a href="https://links.jianshu.com/go?to=https://blog.cnbluebox.com/blog/2017/07/24/arm64-start/">iOS开发同学的arm64汇编入门</a></li><li><a href="https://links.jianshu.com/go?to=https://blog.csdn.net/zqixiao_09/article/details/50726544">ARM汇编指令集手册</a></li><li><a href="https://links.jianshu.com/go?to=https://blog.csdn.net/Hello_Hwc/article/details/80028030">iOS汇编 — 实践篇</a></li></ul></li><li>关于Intel与AT&amp;T汇编<ul><li><a href="https://links.jianshu.com/go?to=https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html"><strong>Linux 汇编语言开发指南(AT&amp;T汇编与intel汇编)</strong></a></li><li><a href="https://www.jianshu.com/p/7e4dcc768ad1">iOS-AT&amp;T汇编</a></li><li><a href="https://links.jianshu.com/go?to=http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">汇编语言入门教程(intel汇编) — 阮一峰</a></li><li><a href="https://links.jianshu.com/go?to=https://blog.csdn.net/albertsh/article/details/106041560">汇编指令入门级整理(intel汇编与AT&amp;T汇编)</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;h3 id=&quot;1-2-汇编语言&quot;&gt;&lt;a href=&quot;#1-2-汇编语言&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="OS" scheme="https://tenloy.github.io/categories/OS/"/>
    
    
    <category term="ARM64" scheme="https://tenloy.github.io/tags/ARM64/"/>
    
  </entry>
  
  <entry>
    <title>指令、系统调用、库、Shell、APP的层次关系</title>
    <link href="https://tenloy.github.io/2021/04/15/03-3_Ins-SysCall-Kernel-Shell/"/>
    <id>https://tenloy.github.io/2021/04/15/03-3_Ins-SysCall-Kernel-Shell/</id>
    <published>2021-04-15T15:00:20.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是梳理机器指令、汇编指令、系统调用(OS Kernel)、语言库、应用程序和OS Shell的层次关系。</p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>首先看一下软硬件间的关系，如图所示：</p><img src="/images/OS/CLI/2181780-3f00874b5ac917a8.png" style="zoom:80%"><h2 id="二、硬件-—-CPU指令集"><a href="#二、硬件-—-CPU指令集" class="headerlink" title="二、硬件 — CPU指令集"></a>二、硬件 — CPU指令集</h2><p><strong>一般指令集专利持有者在设计指令集的时候，往往提供指令集对应的机器语言规范。</strong> 而为了方便，一般也会提供汇编语言规范。</p><p>(注意：CPU微架构设计厂商可能会对指令集进行微调。关于指令集设计者、微架构设计者两者的关系可以参考<a href="https://www.jianshu.com/p/c80850ccfb27">指令集、微架构、手机芯片(Soc)及ARM的介绍(偏硬件科普)</a>)</p><blockquote><p>汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用<code>助记符</code>代替机器指令的操作码，用<code>地址符号或标号</code>代替指令或操作数的地址。汇编语言又被称为第二代计算机语言。</p></blockquote><p><strong>汇编语言产生的原因：</strong></p><p>对于绝大多数人来说，二进制程序是不可读的，当然有能人可以读，比如第一代程序员，但这类人快灭绝了，直接看二进制不容易看出来究竟做了什么事情，比如最简单的加法指令二进制表示为 00000011，如果它混在一大串01字符串中就很难把它找出来，所以汇编语言主要就是为了解决二进制编码的可读性及编写效率问题(CPU指令集机器码形式记不住呀…)。</p><p><strong>即指令集有两种表示形式：机器码形式、汇编语言形式</strong>。比如 00000011 加法指令，对应的汇编指令是 ADD，在调用汇编器时就会把 ADD 翻译成 00000011。</p><p><strong>常见的指令集以及汇编语言规范：</strong></p><ul><li>x86(IA-32)、x86-64指令集(常见于PC端)，对应有2家公司发布的不同汇编语言规范：<ul><li>intel公司发布的汇编语言规范，称<code>intel 汇编</code>：Windows派系(Microsoft)，比较著名的汇编器有微软的masm和开源的nasm。</li><li>AT&amp;T公司发布的汇编语言规范，称<code>AT&amp;T 汇编</code>：Unix派系(或者说GNU)，比如g++编译器等。</li></ul></li><li>ARM指令集(常见于嵌入式、移动端设备，粗略统计覆盖95%左右的手段)：ARM公司发布的汇编语言规范，称<strong>ARM 汇编</strong>(<strong>目前常见的是ARM 64汇编</strong>)，见<a href="https://links.jianshu.com/go?to=https://developer.arm.com/architectures">官网文档</a></li></ul><p><strong>汇编语言规范，是给汇编程序开发者看的，也是给编译器(主要是汇编器)看的，目的只有一个：保证汇编程序能通过汇编器转换成CPU兼容执行、实现逻辑功能的指令(二进制码)序列。如果你能编写自己的汇编器，完全可以定义自己的汇编语言规范</strong></p><p><strong>所以，汇编语言和机器语言是一一对应的吗？</strong></p><p>在同一汇编规范下，它们是一一对应的。如果考虑到不同的汇编语言规范，它们就不是一一对应的了。在多数场合，笼统地说，汇编语言和机器语言是一一对应的（比如 00000011 就是 ADD）。所以汇编语言就和机器语言一样，很受硬件限制，移植性很差。</p><p>高级语言在执行时，需要 <strong>→ 编译器翻译为汇编语言 → 汇编器翻译为机器语言</strong>，此时，才能够被CPU识别并执行。<strong>指令集直接操作硬件。</strong></p><p>**通常是先指定使用的指令集，然后去设计微架构(处理器硬件结构)**。</p><h2 id="三、操作系统"><a href="#三、操作系统" class="headerlink" title="三、操作系统"></a>三、操作系统</h2><p>操作系统分为内核(Kernel)、壳层(Shell)</p><h3 id="3-1-内核-Kernel-与系统调用"><a href="#3-1-内核-Kernel-与系统调用" class="headerlink" title="3.1 内核(Kernel)与系统调用"></a>3.1 内核(Kernel)与系统调用</h3><h4 id="3-1-1-内核概述"><a href="#3-1-1-内核概述" class="headerlink" title="3.1.1 内核概述"></a>3.1.1 内核概述</h4><p>内核(Kernel，又称核心)在计算机科学中是一个用来管理软件发出的数据I/O(输入与输出)要求的电脑程序，是现代操作系统中最基本的部分。</p><p>它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。</p><p><strong>总结：内核对硬件的操作进行封装，向上层(应用、Shell)提供接口，使上层使用硬件更方便，会对上层的硬件资源申请统一管理，当然也就意味上层的使用会受到一些限制。</strong></p><p>严格地说，内核并不是计算机系统中必要的组成部分。有些程序可以直接地被调入计算机中执行；这样的设计，说明了设计者不希望提供任何硬件抽象和操作系统的支持；它常见于早期计算机系统的设计中。</p><p>但随着电脑技术的发展，最终，一些辅助性程序，例如程序加载器和调试器，被设计到机器内核当中，或者写入在只读记忆体里。这些变化发生时，操作系统内核的概念就渐渐明晰起来了。</p><h4 id="3-1-2-系统调用"><a href="#3-1-2-系统调用" class="headerlink" title="3.1.2 系统调用"></a>3.1.2 系统调用</h4><p><strong>内核提供的接口称为系统调用，指运行在用户空间的程序访问操作系统内核所提供服务的接口(内核服务意味着更高的权限）。系统调用是代码方式使用，也就表示了用户（非编程人员）不能直接与内核进行交互。</strong></p><p><strong>系统调用是基于CPU指令集的，进行封装、扩展（比如扩展中断向量，实现一系列的系统调用）。类似于语言库中的API对系统调用的封装。</strong></p><p>调用系统调用的两种方式：以Linux为例(其他系统也是类似)，在 Linux 平台下有两种方式来使用系统调用：</p><ul><li><strong>利用封装后的 C 库（libc）</strong>。Linux、Windows、iOS等许多系统内核大部分都是C语言编写的，其中也有少部分的C++、C#等语言，所以大部分的系统调用通常是C、C++语言格式的</li><li><strong>通过汇编直接调用</strong>。通过汇编语言来直接调用系统调用，是最高效地使用 Linux 内核服务的方法，因为最终生成的程序不需要与任何库进行链接，而是直接和内核通信。</li><li>第一种方式是对第二种方式的封装。如DOS、Linux 的系统调用都是通过中断汇编指令（int 0x80）来实现的。(见下面—系统调用的实现)</li></ul><h4 id="3-1-3-系统调用的实现"><a href="#3-1-3-系统调用的实现" class="headerlink" title="3.1.3 系统调用的实现"></a>3.1.3 系统调用的实现</h4><p>系统调用接口在实现中往往以<strong>软件中断</strong>(Software interrupt)，简称<strong>INT</strong>(软中断)的方式提供，比如：</p><ul><li>Linux 使用 <code>INT 0x80</code>（INT是汇编指令，0x80为参数，表示80号中断）作为系统调用接口。</li><li>Windows使用 0x2E 号中断作为系统调用接口（从Windows XP Sp2开始，Windows开始采用一种新的系统调用方式）。</li></ul><p>以Linux为例，在进行系统调用的时候:</p><ol><li>发起int 0x80中断，并传入<strong>系统调用号</strong>。系统调用号：有一个 <code>sys_call_table</code> 是一个全局函数数组，存储所有系统调用的地址(可以查看 <code>include/linux/sys.h</code> 文件)，系统调用号是系统调用在该数组中的下标。</li><li>调用 <code>set_system_gate</code> 函数处理中断，首先从当前的用户态切换到内核态，然后找到中断向量表，根据中断编号(0x80)，找到对应的中断处理程序</li><li>找到中断处理程序 <code>system_call</code> (在 <code>linux/kernel/system_call.s</code> 中，是汇编程序)，根据系统调用号在 <code>sys_call_table</code> 表中找到相应系统调用对应的函数入口。</li><li>调用 <code>call汇编指令</code> ，输入函数地址。</li></ol><h4 id="3-1-4-关于中断向量的一些补充"><a href="#3-1-4-关于中断向量的一些补充" class="headerlink" title="3.1.4 关于中断向量的一些补充"></a>3.1.4 关于中断向量的一些补充</h4><p>计算机启动时，引导扇区、系统内核会陆续的将一些中断填入中断向量表，并将中断向量指向自己编写的中断服务程序。</p><p>如操作系统启动过程的最后，由<code>head.s</code>进入<code>main.c</code>中，会进行一系列的初始化：内存、设备、时钟、中断等。其中：</p><ul><li><code>trap_init()</code>函数，会初始化一些中断向量</li><li><code>sched_init()</code>函数中会调用<code>set_system_gate(0x80,&amp;system_call)</code>，设置中断向量号0x80的中断描述符</li></ul><p>系统也会为用户保留一些中断向量，用户可以将自己的中断服务程序写入这些中断向量中。不仅如此，用户还可以自己更改和完善系统已有的中断向量。<strong>相当于给INT指令增加参数(中断向量号)选项，且指定对应的调用程序</strong>。</p><blockquote><p><strong>引导扇区(实模式) → bootloader(实模式 → 保护模式，R0层权限) → 操作系统(保护模式，R0层权限) → 操作系统先加载的是内核，内核处于R0，shell已经是在用户态了</strong></p></blockquote><h3 id="3-2-壳层-Shell"><a href="#3-2-壳层-Shell" class="headerlink" title="3.2 壳层(Shell)"></a>3.2 壳层(Shell)</h3><p>操作系统存在的目的是方便用户的使用，而内核提供的代码形式的系统调用，是面向编程开发者的，所以需要一个<strong>壳层：在计算机科学中指“为用户提供用户界面”的软件，或者说是指操作系统中提供访问内核所提供之服务的程序</strong></p><p>Shell又分为了CLI Shell(命令行)、GUI Shell(图形化)两种形式，用户都可以用来使用操作系统。区别：</p><ul><li><strong>样式区别</strong>：前者的页面是一行行的文字命令，后者是图形状的</li><li><strong>程序(APP、命令行工具)的使用</strong>：前者需要用户记住每个程序的路径，然后输入特定的命令来调用对应的功能。后者会将所有的APP以图标的形式显示在桌面上，通过点击就可使用</li><li><strong>本质</strong>：本质上没区别，都是对系统调用的封装，功能一定程度上都是共通的</li></ul><h3 id="3-3-目前的操作系统为例"><a href="#3-3-目前的操作系统为例" class="headerlink" title="3.3 目前的操作系统为例"></a>3.3 目前的操作系统为例</h3><p>对上面的知识点进行总结，以目前的操作系统为例：</p><p>针对不同的角色，操作系统提供了不同的用户界面(不同的操作系统提供的用户界面也不同)</p><ul><li>对普通用户和管理员用户提供<strong>命令控制界面</strong>(也就是<code>Shell</code>)：是一组不同操作命令组成的集合，每个命令实现用户所要求的不同功能，为用户提供相应的服务。<ul><li>包括GUI图形化界面、CLI命令行界面</li><li>用户利用这些操作命令来组织和控制作业的执行。</li></ul></li><li>对编程人员提供<strong>编程界面</strong>：是一组<strong>系统调用</strong>的集合，这些系统调用允许编程人员请求操作系统内核提供的服务，开发能够满足用户服务需求的新的控制命令。</li><li><strong>命令控制界面是基于编程界面，也就是系统调用之上开发完成的。</strong></li></ul><h3 id="3-4-ABI与API"><a href="#3-4-ABI与API" class="headerlink" title="3.4 ABI与API"></a>3.4 ABI与API</h3><p>操作系统相关的有两类接口(意思并不是说只有OS才有ABI、API)：</p><ul><li>API应用程序接口：源代码层次的接口，即操作系统提供了哪些系统调用(一般是C/C++编写)，正确调用OS提供的API，才能被成功编译</li><li>ABI应用二进制接口：机器码层次的接口，按照系统ABI编写(或转换成)的机器码文件(目标文件、可执行文件)，才能成功与OS提供的库(也是目标文件，机器码)链接，然后成功被OS装载运行。</li></ul><h4 id="3-4-1-API"><a href="#3-4-1-API" class="headerlink" title="3.4.1 API"></a>3.4.1 API</h4><p><code>API(Application Programming Interface)</code>应用程序接口：定义了源代码和库之间的接口(函数名、参数、返回值、数据类型定义等)，即规定源代码可以怎么使用库的功能，使得一套 <code>源代码</code>可以在支持这个API的任何系统中 <code>编译</code>。</p><h4 id="3-4-2-ABI"><a href="#3-4-2-ABI" class="headerlink" title="3.4.2 ABI"></a>3.4.2 ABI</h4><p><code>ABI(Application Binary Interface)</code>应用二进制接口：是指两程序模块间的接口，通常其中一个程序模块会是库或操作系统所提供的服务，而另一边的模块则是用户所运行的程序(前面已经知道程序主模块、动态链接库都叫程序模块)。</p><p>规定了机器代码的书写格式(二进制应用程序应该怎么调用CPU指令集中的指令)，使得一套编译好的<strong>二进制代码</strong>(目标文件、可执行文件)可以在兼容ABI的系统中，无需任何修改直接<strong>运行</strong>。</p><ul><li>决定要不要采取既定的ABI（不论是否由官方提供），通常由编译器，操作系统或库的开发者来决定</li></ul><p>ABI涵盖了各种细节，如：</p><ul><li>数据类型的大小、布局和对齐;</li><li>调用约定（控制着函数的参数如何传送以及如何接受返回值），例如：<ul><li>是所有的参数都通过栈传递，还是部分参数通过寄存器传递；</li><li>哪个寄存器用于哪个函数参数；</li><li>通过栈传递的第一个函数参数是最先push到栈上还是最后；</li></ul></li><li>系统调用的编码和一个应用如何向操作系统进行系统调用；</li><li>以及在一个完整的操作系统ABI中，目标文件的二进制格式、程序库等等。</li></ul><h3 id="3-4-3-两者对比"><a href="#3-4-3-两者对比" class="headerlink" title="3.4.3 两者对比"></a>3.4.3 两者对比</h3><ul><li>定义层级<ul><li>API在源代码定义这些，则较为高端，并不直接相依于硬件，通常会是人类可阅读的代码。</li><li>ABI在二进制代码(目标文件、可执行文件)层次定义了机器代码怎么写，此处所定义的界面相当低端并且相依于硬件。</li></ul></li><li>标准化方面<ul><li>POSIX 标准、C99 标准，都是对 API 的规定。</li><li>有一些努力尝试标准化ABI，以减少销售商将程序移植到其他系统时所需的工作。然而，直到现在还没有很成功的例子，虽然Linux标准化工作组正在为Linux做这方面的努力。</li></ul></li></ul><h2 id="四、语言标准库"><a href="#四、语言标准库" class="headerlink" title="四、语言标准库"></a>四、语言标准库</h2><p>编程语言的标准库是该语言的每种实现中都按例提供的库。在某些情况下，编程语言规格说明中会直接提及该库；另一些情况下，标准库的内容由编程社区中的非正式惯例决定。</p><p>根据宿主语言构成要素的不同，标准库可包含如下要素：</p><ul><li>子程序</li><li>宏定义</li><li>全局变量</li><li>类别定义</li><li>模板</li></ul><p>大多数标准库都至少含有如下常用组件的定义：</p><ul><li>算法（例如排序算法）</li><li>数据结构（例如 表、 树、哈希表）</li><li><strong>与宿主平台的交互，包括输入输出和操作系统调用</strong></li></ul><p>比如我们经典的C语言版“hello world”程序，使用C语言标准库的“printf”函数来输出一个字符串，“printf”函数对字符串进行一些必要的处理以后，最后会调用操作系统提供的系统调用。</p><p>各个操作系统，往终端输出字符串的API都不一样，在Linux下，它是一个 <code>“write”</code>的系统调用，而在Windows下则是 <code>“WriteConsole”</code>系统API。此外，还带有很多一些常用的函数。</p><p><strong>Q1：如Java、Object-C语言库可不可以不调用C、C++语言格式的系统调用(API)？</strong></p><p>当然可以，上文讲过，操作系统一般都提供了两种方式来使用系统调用：C语言库、汇编语言。系统调用对Linux、DOS来说只是int 0x80(中断)而已，所以不管语言库是什么语言编写的，(在Linux上运行的软件代码)只要能通过编译器翻译成对应Linux下的int 0x80的汇编语言就行了。</p><p><strong>但是注意</strong>：封装高级语言格式的系统调用、设置0x80中断及对应的中断处理程序实现系统调用，都是操作系统提供的功能。</p><p>而且操作系统的系统调用<strong>实现</strong>是一定的，两种方式(其实是一种，C库本质上也是封装的汇编中断指令)最后找到的系统调用函数的实现(函数入口地址)都是一样的…</p><p>其实，编程人员开发时，用什么语言来调用系统调用是无所谓的，因为运行的时候，都需要编译、汇编成机器代码。从硬件角度来看(即最后的可执行文件)，区别不大的(高级语言调用、汇编语言调用最后生成的机器码还是有些区别的)。</p><p><strong>Q2：既然可以直接写汇编语言，而汇编语言又是直接对应CPU指令，即可以直接操作硬件资源，那为什么不能越过操作系统直接使用硬件？</strong></p><p>不能。主语不要弄错，并不是汇编语言为什么不能操控硬件，是用户程序不能越过操作系统操控硬件。</p><p><strong>核心问题：用户程序和系统调用的权限问题</strong>。</p><p>系统调用是操作系统内核的代码，拥有最高的权限。以x86架构为例，x86指令运行的权限是从Ring0到Ring3的，操作系统内核运行在R0，用户程序运行在R3。</p><p>有一些指令只能在R0执行，比如修改CR寄存器（mov cr0, eax），这种操作在用户态直接会报错。因为CPU会保存当前运行的代码的CPL（当前特权级别）和IOPL（IO权限），如果CPL/IOPL不符，CPU会抛出异常，丢给内核R0的代码去处理。这种错误，是执行到某条特定指令才会遇到的，不是加载的时候遇到的，<strong>是CPU行为，不是操作系统行为。</strong></p><p><strong>操作系统之所以不会被限制，是因为操作系统内核运行在R0上，对CPU有完整的控制权。</strong></p><p>计算机刚启动时，属于实模式，从实模式切换到保护模式的过程中，默认是进入到R0里的，所以操作系统在启动的过程中，是自动获得了R0的权限的。而<strong>用户代码都是被操作系统启动的(装载、链接)<strong>，此时</strong>操作系统能控制用户代码运行在什么级别上</strong>。</p><p>那么为什么操作系统的代码就可以切换特权级而用户的代码却不可以切换特权级？</p><p>实际上可以的。Windows可以加载用户驱动到内核（但受到一些限制），这就是把用户代码放到R0里执行的过程，Linux也有类似的东西存在。</p><h2 id="五、编程开发的应用程序"><a href="#五、编程开发的应用程序" class="headerlink" title="五、编程开发的应用程序"></a>五、编程开发的应用程序</h2><p>内核 → 系统调用 → Shell</p><p>内核 → 系统调用 → 编程语言标准库 → 编程人员开发的应用程序</p><p>以我们日常使用的手机系统为例，应用程序与GUI Shell的关系其实并没有谁基于谁的关系，Shell本质上也是一个应用程序。都是依赖于内核提供的系统调用开发、运行的。只不过功能不同而已：</p><ul><li>应用程序是编程人员为了实现某些功能(比如看书、听音乐等)开发的</li><li>GUI Shell，它的功能是以图形化的方式管理所有的应用入口(并内置了一些应用程序比如文件管理、设置之类的)，并负责将用户的一些交互行为转换为控制命令。<ul><li>比如用户点击APP图标，打开APP，本质上是GUI Shell帮忙调用了系统调用：<code>fork()</code>创建进程 → <code>execve()</code>执行指定的可执行文件等</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要是梳理机器指令、汇编指令、系统调用(OS Kernel)、语言库、应用程序和OS Shell的层次关系。&lt;/p&gt;
&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="OS" scheme="https://tenloy.github.io/categories/OS/"/>
    
    
  </entry>
  
  <entry>
    <title>指令集、微架构、手机芯片(Soc)及ARM的介绍</title>
    <link href="https://tenloy.github.io/2021/04/14/03-2_ISA-Microarch-Soc/"/>
    <id>https://tenloy.github.io/2021/04/14/03-2_ISA-Microarch-Soc/</id>
    <published>2021-04-14T15:00:20.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章偏硬件科普，没有什么实质性的技术知识。</p><h2 id="一、指令集"><a href="#一、指令集" class="headerlink" title="一、指令集"></a>一、指令集</h2><blockquote><p>以下摘自维基百科</p></blockquote><p><strong>指令集架构</strong>(Instruction Set Architecture，缩写为ISA)，又称<strong>指令集</strong>或<strong>指令集体系</strong>，有的地方也称为<strong>CPU架构</strong>。包含了一系列的opcode即操作码（机器语言），以及由特定处理器执行的基本命令。</p><p>一台计算机要有较好的性能，必须设计功能齐全、通用性强、内含丰富的指令系统。常接触的指令集内容：</p><ul><li>寻址方式：立即寻址、直接寻址、基址寻址、变址寻址等等</li><li>数据格式：指令操作数类型比如地址、数字、字符、逻辑数等</li><li>数据在存储器中的存放类型：比如存储字长64位，机器字长32位，是否对齐存放等。及字节序：大端、小端</li><li>指令类型：数据传送、算术逻辑操作、移位操作、转移操作、输入输出等</li></ul><p>指令集体系与<strong>微架构</strong>(<strong>一套用于执行指令集的微处理器设计方法</strong>)不同。使用不同微架构的电脑可以共享一种指令集。例如，Intel的Pentium和AMD的AMD Athlon，两者几乎采用相同版本的x86指令集体系，但是两者在内部设计上有本质的区别。</p><p>从现阶段的主流体系结构讲，指令集可分为：</p><ul><li>复杂指令集<code>CISC(Complex Instruction Set Computer)</code><ul><li>包含许多应用程序中很少使用的特定指令，由此产生的缺陷是指令长度不固定。比如DEC公司的VAX-11/780有16种寻址方式、9种数据格式、303条指令</li></ul></li><li>精简指令集<code>RISC(Reduced Instruction Set Computer)</code><ul><li>通过只执行在程序中经常使用的指令来简化处理器的结构，而特殊操作则以子程序的方式实现，它们的特殊使用通过处理器额外的执行时间来弥补。</li></ul></li></ul><h3 id="1-1-常见的指令集"><a href="#1-1-常见的指令集" class="headerlink" title="1.1 常见的指令集"></a>1.1 常见的指令集</h3><ul><li><p>CISC</p><ul><li><code>IA-32</code>：英特尔32位架构(Intel Architecture, 32-bit，缩写为IA-32)，常被称为i386、或<code>x86</code>。<ul><li>由英特尔公司于1985年推出的指令集架构。它是8086架构的延伸版本，可支持32位运算，首次应用在Intel 80386芯片中。主要用于PC端。</li><li>Intel早期给于AMD授权，使得AMD公司可以开发兼容x86指令集的CPU，但在微架构的实现上区别很大。</li></ul></li><li><code>x86-64</code>：又称x64、x86_64。<ul><li>对x86进行扩展，增加64位支持，向后兼容于16位及32位的x86架构。</li><li>是于1999年由AMD设计，其后也为Intel所采用，称之为<code>Intel 64</code>（所以有媒体讽刺Intel在迎击AMD的民用64位技术上，使用了AMD的技术）。</li><li><strong>x与处理器没有任何关系</strong>，它是一个对所有<code>*86系统</code>的简单的通配符定义，是一个intel通用计算机系列的编号，也标识一套通用的计算机指令集合，例如：i386, 586,奔腾(pentium)。</li></ul></li></ul></li><li><p>CISC</p><ul><li><code>arm系列</code>：原英国公司，后被软银约320亿美元收购，主要用于手机、平台等移动设备</li><li><code>RISC-V</code>：(“RISC” 表示精简指令集，V表示第五代)，最新的开源的，龙头企业SiFive在19年获得D轮6540万美元的融资。本次融资中，高通是其中重要的投资方，另外，三星和英特尔也有相关资金的投入。</li><li><code>MIPS</code>: 是出现最早的商业RISC架构芯片之一，随着移动互联网的兴起，MIPS 指令集逐渐衰落，公司也多次辗转被收购。</li><li><code>PowerPC</code>: IBM公司</li></ul><img src="/images/OS/ISA/2181780-e8d98c5607e0d472.png" style="zoom:50%"></li></ul><h3 id="1-2-指令的组成"><a href="#1-2-指令的组成" class="headerlink" title="1.2 指令的组成"></a>1.2 指令的组成</h3><p>在传统的架构上，一条指令包含<code>op code</code>，表示运算的方式，以及零个或是更多的操作数，有些像是操作数的数字可能指的是寄存器的编号，还有存储器位置，或是文字数据。</p><p>在超长指令字（VLIW）的结构中，包含了许多微指令，借此将复杂的指令分解为简单的指令。</p><h3 id="1-3-指令的长度"><a href="#1-3-指令的长度" class="headerlink" title="1.3 指令的长度"></a>1.3 指令的长度</h3><p>指令长度的范围可以说是相当广泛，从微控制器的4 bit，到VLIW系统的数百bit。在个人电脑，大型机，超级电脑内的处理器，其内部的指令长度介于8到64 bits。在一个指令集架构内，不同的指令可能会有 <code>不同长度</code>。在一些结构，特别是大部分的精简指令集（RISC），指令是 <code>固定的长度</code>，长度对应到结构内一个字的大小。在其他结构，长度则是byte的整数倍或是一个halfword。</p><ul><li><strong>在x86处理器结构(CISC)内，指令长度不同，最长的指令长达15 bytes，等于120 bits</strong></li><li><strong>所有 ARM 指令(RISC)的长度都是 32 位。 这些指令按字对齐方式进行存储，因此在 ARM 状态下，指令地址的两个最低有效位始终为零。</strong></li></ul><h3 id="1-4-CPU指令集的形式：机器码、汇编指令"><a href="#1-4-CPU指令集的形式：机器码、汇编指令" class="headerlink" title="1.4 CPU指令集的形式：机器码、汇编指令"></a>1.4 CPU指令集的形式：机器码、汇编指令</h3><p><strong>一般指令集专利持有者在设计指令集的时候，往往提供指令集对应的机器语言规范。</strong> 而为了方便，一般也会提供汇编语言规范(在机器语言的基础上，增加了一些助记符)。<br>常见的指令集以及汇编语言规范</p><ul><li>x86指令集(PC端)</li><li>x86-64指令集(PC端)<ul><li>根据编译器的不同，有2种汇编语言规范：</li><li>intel汇编语言规范：Windows派系(Microsoft)，比较著名的汇编器有微软的masm和开源的nasm</li><li>AT&amp;T汇编语言规范：Unix派系(或者说GNU)，比如g++编译器等</li></ul></li><li>ARM指令集(嵌入式、移动端设备)<ul><li>ARM汇编，见<a href="https://links.jianshu.com/go?to=https://developer.arm.com/architectures">官网文档</a></li></ul></li></ul><p><strong>汇编语言规范，是给汇编程序开发者看的，也是给编译器(重要的是汇编器)看的，目的只有一个：保证汇编程序能通过汇编器转换成CPU兼容执行、实现逻辑功能的指令(二进制码)序列。如果你能编写自己的汇编器，完全可以定义自己的汇编语言规范</strong></p><p>所以，汇编语言和机器语言是一一对应的吗？</p><p>在同一汇编规范下，它们是一一对应的。如果考虑到不同的汇编语言规范，它们就不是一一对应的了。在多数场合，笼统地说，汇编语言和机器语言是一一对应的。</p><h3 id="1-5-GPU有没有指令集？"><a href="#1-5-GPU有没有指令集？" class="headerlink" title="1.5 GPU有没有指令集？"></a>1.5 GPU有没有指令集？</h3><p>图形处理器（Graphics Processing Unit，GPU)，又称显示核心、视觉处理器、显示芯片或绘图芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上运行绘图运算工作的微处理器。</p><p>图形处理器：</p><ul><li>可单独与专用电路板以及附属组件组成显卡</li><li>或单独一片芯片直接内嵌入到主板上</li><li>或者内置于主板的北桥芯片中</li><li>现在也有内置于CPU上组成SoC的</li></ul><p>发展</p><ul><li>个人电脑领域中<ul><li>在2007年，90%以上的新型台式机和笔记本电脑拥有嵌入式绘图芯片，但是在性能上往往低于不少独立显卡。</li><li>但2009年以后，AMD和英特尔都各自大力发展内置于中央处理器内的高性能集成式图形处理核心</li><li>2012年时，它们的性能已经胜于那些低端独立显卡，这使得不少低端的独立显卡逐渐失去市场需求，两大个人电脑图形处理器研发巨头中，AMD以AMD APU产品线取代旗下大部分的低端独立显示核心产品线。</li></ul></li><li>手持设备领域上<ul><li>随着一些如平板电脑等设备对图形处理能力的需求越来越高，不少厂商像是高通（Qualcomm）、PowerVR、ARM、NVIDIA等，也在这个领域里纷纷“大展拳脚”。</li></ul></li></ul><p>GPU不同于传统的CPU，如Intel i5或i7处理器，其内核数量较少，专为通用计算而设计。相反，GPU是一种特殊类型的处理器，具有数百或数千个内核，经过优化，可并行运行大量计算。虽然GPU在游戏中以3D渲染而闻名，但它们对运行分析、深度学习和机器学习算法尤其有用。GPU允许某些计算比传统CPU上运行相同的计算速度快10倍至100倍。</p><p>指令集是针对微处理器而言，而由<a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8">微处理器的解释</a>可知，根据微处理器的用途划分，常见的有CPU、GPU、APU等，按照概念，GPU应该也有相应的指令集及微架构。从<a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E5%99%A8">GPU的条目</a>中也可以看到指令集的字眼。</p><ul><li><strong>如无特殊说明，说指令集一般是指CPU指令集</strong>。</li><li>至于GPU的指令集，可以参考<a href="https://links.jianshu.com/go?to=https://software.intel.com/content/www/us/en/develop/articles/introduction-to-gen-assembly.html">Intel GPU的ISA</a>。</li></ul><h2 id="二、微-处理器-架构概述"><a href="#二、微-处理器-架构概述" class="headerlink" title="二、微(处理器)架构概述"></a>二、微(处理器)架构概述</h2><p>微架构(Microarchitecture)，又称为微体系结构、微处理器体系结构、计算机组织等，是一套用于执行某种指令集的微处理器设计方法，即<strong>微架构使得指令集架构(ISA)可以在处理器上被运行</strong>。</p><h3 id="2-1-微架构的概念"><a href="#2-1-微架构的概念" class="headerlink" title="2.1 微架构的概念"></a>2.1 微架构的概念</h3><p>从控制单元、运算单元两方面来简单介绍一下：</p><ul><li><strong>控制单元</strong>。现时，<strong>流水线数据路径</strong>是微架构中最常被使用的数据路径（就是指令流水技术）。这种作法也被普遍的用于微处理器，微控制器，以及数字信号处理器。<ul><li>流水线是微架构其中一项主要的工作。流水线的结构允许多个指令在同一时间运行，不同的指令在微架构不同的位置运行。</li><li>流水线分有好几个不同的阶段（stage），这些阶段是微架构的基础。这些阶段包含取指令，译码，运行指令，以及将数据写回。</li><li>一些结构还包含其他阶段，像是对存储器做访问的动作。</li></ul></li><li><strong>运行单元</strong>也是微架构的基本组件。<ul><li>运行单元包含算术逻辑单元（ALU），浮点运算器（FPU），load/store单元，分支预测，以及SIMD。这些单元在处理器内进行计算。</li><li>运行单元的数量，他们的延迟（存储器访问数据的时间）及吞吐量（将数据存到或是读取出存储器的速度）影响微架构的性能。</li></ul></li></ul><h3 id="2-2-指令集与微架构的关系"><a href="#2-2-指令集与微架构的关系" class="headerlink" title="2.2 指令集与微架构的关系"></a>2.2 指令集与微架构的关系</h3><ul><li>一套指令集架构可以在不同的微架构上运行。但注意<strong>厂商开发兼容某种指令集的微架构，需要指令集专利持有者授权</strong>，常见的如：<ul><li>Intel的x86指令集，运行在Intel、AMD公司开发的微结构上</li><li>ARM指令集，运行在ARM公司、苹果、三星公司开发的微架构上</li></ul></li><li>指令集架构相当于是 <strong>微处理器的功能接口，一般公开</strong>。</li><li>微架构是一套用于执行指令集的微处理器设计方法，是指令集的 <strong>硬件实现，一般保密</strong>。</li><li>一般是先确认指令集，然后设计微架构(硬件开发类似软件开发，先确定功能，再设计架构)。</li></ul><p>对于兼容ARM指令集的芯片来说，指令集与微架构这两个概念尤其容易混淆：</p><ul><li>ARM公司将自己研发的指令集叫做ARM指令集，同时它还研发具体的微架构如Cortex系列并对外授权。</li><li>但是，一款CPU使用了ARM指令集不等于它就使用了ARM研发的微架构<ul><li>Intel、高通、苹果、Nvidia等厂商都自行开发了兼容ARM指令集的微架构</li><li>同时还有许多厂商使用ARM开发的微架构来制造CPU</li></ul></li></ul><p>通常，业界认为只有具备独立的微架构研发能力的企业才算具备了CPU研发能力，而是否使用自行研发的指令集无关紧要。微架构的研发也是IT产业技术含量最高的领域之一。</p><h3 id="2-3-发展"><a href="#2-3-发展" class="headerlink" title="2.3 发展"></a>2.3 发展</h3><p>在PC时代，几大主要的CPU研发厂商都只是自己研制微架构自己用。到了智能设备时代，ARM公司的微架构授权模式兴起。ARM自己开发微架构后将它们上架出售，其他厂商可以拿这些核心组装为芯片来使用或销售。由于这种模式对第三方的技术能力要求很低，加上ARM的微架构在低功耗领域表现优异，这种模式获得了广泛成功。如果你发现某款芯片标明使用了Cortex系列核心，则一定是这种模式的产物。</p><p>如前所述，<strong>仅仅从ARM购买微架构来组装芯片的厂商是不能被称作CPU研发企业的，这些芯片也不能被称为“xx厂商研发的CPU”。典型如华为的海思920、三星Exynos 5430，只能说是“使用ARM Cortex-A15核心的芯片”</strong>。</p><p>但是如果一款兼容ARM指令集的芯片使用了厂商自主研发的微架构情况就不同了。高通骁龙800、苹果A7就是这样的例子–它们分别使用了高通、苹果自主研发的CPU。</p><p>那么，现在各家CPU研发厂商选择指令集的标准又是什么呢？一般来说大家倾向于选择<strong>软件生态较好的指令集</strong>，即支持某种指令集的软件应用越多，这种指令集也就越有市场优势。新开发的微架构只需要兼容某种指令集，那么就可以很容易运行大量为其开发的软件。早年因为微软的强势与Wintel联盟的推动，x86指令集成了最受欢迎的角色，帮助Intel用彼时性能相对落后的微架构在PC平台挤跑了一众对手。后PC时代由于苹果谷歌的两大操作系统平台的推动，ARM指令集又取得了绝对的市场优势。</p><p>但对于新的CPU研发单位来说，他们想获得热门指令集的兼容授权是很困难的事情。</p><ul><li>以前x86与ARM的指令集授权是拿钱买不到的，想要得到都需要进行高水平专利交换。拿到x86授权的几家厂商要么是拿的早（AMD、Cyrix、IDT），要么是有高水平技术与Intel交易（Transmeta，以功耗控制技术同Intel交易）。后来Nvidia想要研发自己的CPU，找Intel洽谈多次未果。国内的研发单位当年开始研究时自知不可能拿到x86授权，于是各自去找关系好些的其他授权方解决问题了。<a href="https://links.jianshu.com/go?to=https://www.zhihu.com/question/66330012">关于x86授权的那点事</a></li><li>ARM这边也一直对指令集授权卡的很死，之前只有高通、博通和Intel得到，也是通过技术交换的形式。08年苹果也拿到了ARM的许可，后来ARM对指令集授权也放松了。</li></ul><p>数年前国产龙芯CPU获得MIPS授权的消息曾引起一阵风波，龙芯相关负责人还曾出来解释。龙芯是兼容MIPS指令集，微架构部由中科院自主研发的CPU系列。过去中科院资金不足所以没有MIPS指令集授权，但是指令集的实现方式是公开的，因而中科院可以在研发时选择兼容该指令集。待资金充足买下授权后，龙芯就可以合法在市面销售。</p><p><strong>从这里我们可以知道，厂商研发CPU时并不需要获得指令集授权就可以获得指令集的相关资料与规范，指令集本身的技术含量并不是很高。获得授权主要是为了避免法律问题。然而微架构的设计细节是各家厂商绝对保密的，而且由于其技术复杂，即便获得相应文档也难以山寨</strong>。不同厂商的微架构设计水平也有较大差异，典型如Intel与AMD的对比，前者在最近几年明显技高一筹。</p><h2 id="三、手机芯片-Soc"><a href="#三、手机芯片-Soc" class="headerlink" title="三、手机芯片(Soc)"></a>三、手机芯片(Soc)</h2><h3 id="3-1-芯片的说明"><a href="#3-1-芯片的说明" class="headerlink" title="3.1 芯片的说明"></a>3.1 芯片的说明</h3><blockquote><p>现在常说的芯片非CPU，而是Soc。如麒麟、晓龙芯片</p></blockquote><p>微架构研发完成，或者说核心研发完成，接下来就是将其组装为芯片了。<strong>芯片概念澄清</strong>：</p><ul><li><p>过去的芯片仅仅包括CPU部分</p></li><li><p>如今大量的芯片集成了<strong>CPU</strong>、<strong>GPU</strong>、<strong>NPU</strong>(神经网络处理器)、<strong>ISP</strong>(image sensor processor)、<strong>基带芯片</strong>(Baseband)、<strong>音频芯片</strong>、<strong>WiFi芯片</strong>、<strong>电源管理芯片(PMIC)<strong>、</strong>内存</strong>、<strong>闪存</strong>等多种不同的功能组件，此时这种芯片就不是传统意义上的“CPU”了。那就成为手机的灵魂所在：<strong>单片系统或片上系统</strong> (<strong>System on a Chip, SoC</strong>)。</p><p>所以不用揪着华为使用公版ARM 的CPU和GPU的技术不放，能够把公版CPU/GPU下的SoC设计好也需要很深的技术积累的，全都自研带来的研发成本及最后的研发结果好坏，太难预料。</p></li></ul><p>关于后续的芯片制造，有两种选择</p><ul><li>首先是Intel那样的，从头到尾自己大包大揽，指令集、架构、芯片的设计、芯片的生产一律不依靠任何人。这样做是需要极其雄厚、全方位的实力做保障的，得有钱、有人、有技术，特别是在半导体技术日益复杂的今天，能这么做的屈指可数。好处当然也是很明显的，不但能完全自己把握自己的命脉，利润也是极其可观，Intel几乎任何产品都可以享受非常高的利润，想卖多少钱就可以卖多少钱。</li><li>另外一种是无工厂模式(Fabless)。这类企业只是自己设计芯片，制造则交由专门生产芯片和半导体的晶圆厂生产，比如台积电、联电、GlobalFoundries、三星电子。这时手机处理器芯片的质素，就是靠晶圆厂的工艺，或称制程 (Wafer Fabrication) 所决定。<ul><li>NVIDIA就是这样，AMD实在耗不过Intel就也变成了这样。</li><li>好处很明显，负担很轻，自己只管设计就行了，不用耗费巨资去兴建晶圆厂、开发新工艺。</li><li>坏处同样很突出：你设计出来了，能否造出来、即便造出来又是个什么样子你就无法做主了，得看代工伙伴的能耐。这方面的教训当然很多：<ul><li>台积电40/28nm两代工艺最初都很不成熟，产能也是迟迟上不来，让整个行业为之拖累；</li><li>GlobalFoundries 32nm工艺没有达到AMD的预期水平，第一代FX/APU处理器的频率和电压就跟设计得差很多，28nm工艺吹了那么久直到现在才刚刚上路，迫使AMD一度放弃了整整一代的低功耗APU，不得不重新设计再去找台积电。</li></ul></li></ul></li></ul><img src="/images/OS/ISA/2181780-af598567c5c86805.jpg" style="zoom:90%"><h3 id="3-2-三星、华为、苹果、高通的Soc现状"><a href="#3-2-三星、华为、苹果、高通的Soc现状" class="headerlink" title="3.2 三星、华为、苹果、高通的Soc现状"></a>3.2 三星、华为、苹果、高通的Soc现状</h3><p>以Soc中的CPU、GPU、基带芯片这几个核心器件为例：</p><ul><li>CPU：<ul><li>华为、三星、高通都获得了ARM架构级授权，在公版上改动(三星狂烧千亿后放弃自研)</li><li>苹果使用的是ARM指令集架构，但微架构是自研。</li><li>即：Arm的Cortex系列CPU一家独大，其他的例如MIPS、RISC-V、x86架构都难以与其抗衡。</li><li>补充：桌面级CPU市场，Intel和AMD两家的天下</li></ul></li><li>GPU：<ul><li>华为采用的ARM mali系列GPU</li><li>苹果采用Imagination Technologies的GPU技术，但在2017年苹果宣布将在两年内弃用Imagination的一切技术，包括专利、知产、保密信息等，实现全面自研</li><li>高通自研的Adreno GPU（高通的Adreno GPU源自ATI的imageon，AMD收购ATI后，将移动设备资产出售给了高通）</li><li>三星手机中的GPU也是跟ARM合作的产物，19年6月，三星与AMD达成合作协议，三星将可采用AMD最新的RDNA架构GPU自行设计手机GPU核心</li><li>来自unity的数据显示，截止至2016年7月，移动GPU市场（包括安卓，iOS，WP设备）市场排名为：Arm(35.9%)、高通(32.4%)，苹果(16.0%)，Imagination(11.2%)，Vivante(1.9%)，Broadcom(1.1%)、NVIDIA(0.7%)、Intel(0.4%)。</li><li>补充：桌面级的GPU，特别是独立显卡市场，则是被Nvidia和AMD两家垄断。数据显示，Nvidia占据了66.3%的独立显卡市场，AMD的份额则为33.7%。虽然英特尔正准备推出自研的独立显卡，但是想要与Nvidia和AMD竞争却并不容易。</li></ul></li><li>基带芯片<ul><li>华为、三星、高通自研</li><li>此前苹果由于不愿向高通交纳高额专利费，因此弃用高通芯片，转而同Intel合作。但英特尔无法按时为其提供5G基带服务，只能与高通和解。在苹果和高通达成和解协议的几个小时后，英特尔就宣布退出5G基带业务。随后苹果斥资10亿收购了英特尔基带芯片业务，预计苹果自研的手机基带芯片的研发进程将会进一步加速。</li></ul></li></ul><p>总结：随着以智能手机为代表的移动市场竞争的进一步升级，为了提升自身手机产品的竞争力，三星、苹果、华为等头部的智能手机厂商继打造自己的手机SoC之后，纷纷加码投入自研CPU、GPU、NPU及基带芯片等核心器件当中。</p><p>尤其是华为，自“中兴事件”、美国制裁华为之后，华为便开始进一步加大了对于自研核心芯片的投入。有传闻称，除了自研的手机SoC/基带/NPU，自研CPU/GPU也在进行中</p><h2 id="四、ARM-CPU-GPU-IP授权"><a href="#四、ARM-CPU-GPU-IP授权" class="headerlink" title="四、ARM(CPU/GPU IP授权)"></a>四、ARM(CPU/GPU IP授权)</h2><blockquote><p>与移动端关系密切的ARM指令集。</p></blockquote><p>ARM起初也是卖芯片的，不过业绩平平，在这个情况下，ARM 决定改变他们的产品策略——他们不再生产芯片，转而以授权的方式，将芯片设计方案转让给其他公司，即“Partnership”开放模式。</p><p>ARM 所采取的是 <strong>IP（Intellectual Property，知识产权）授权</strong> 的商业模式，收取一次性技术授权费用和版税提成。对于半导体公司来说，一次性技术授权费用在 100 万 -1000 万美元之间，版税提成比例一般在 1%-2%之间。</p><h3 id="4-1-ARM的几种授权方式"><a href="#4-1-ARM的几种授权方式" class="headerlink" title="4.1 ARM的几种授权方式"></a>4.1 ARM的几种授权方式</h3><p>具体来说，ARM有三种授权方式： 使用层级授权、内核层级授权和架构层级授权。 这三个层级的权限(及价格)是依次上升的。</p><h4 id="4-1-1-使用层级授权"><a href="#4-1-1-使用层级授权" class="headerlink" title="4.1.1 使用层级授权"></a>4.1.1 使用层级授权</h4><p>是最基本也是最低的授权等级。这就意味着你只能拿别人提供的定义好的 IP 来嵌入在你的设计中，不能更改人家的 IP ，也不能借助人家的 IP 创造自己的基于该 IP 的封装产品。</p><p>拥有使用授权的用户只能购买已经封装好的 ARM处理器核心，而如果想要实现更多功能和特性，则只能通过增加封装之外的DSP核心的形式来实现(当然，也可以通过对芯片的再封装方法来实现)。由于担心对知识产权保护不力，ARM对很多中国背景的企业均采取这一级别的授权 。</p><h4 id="4-1-2-内核层级授权"><a href="#4-1-2-内核层级授权" class="headerlink" title="4.1.2 内核层级授权"></a>4.1.2 内核层级授权</h4><p><strong>内核层级授权，也就是常说的IP核授权</strong>。</p><p>指可以以一个内核为基础然后在加上自己的外设，不能改变原有设计，但可以根据自己的需要调整产品的频率、功耗等。比如USART GPIO SPI ADC等等，最后形成了自己的MCU ，比如三星、德州仪器 (TI)、博通、飞思卡尔、富士通以及Calxeda等，这些公司并没有权限去对内核进行改造。</p><p>IP核，全称知识产权核（英语：intellectual property core），是在集成电路的可重用设计方法学中，指某一方提供的、形式为逻辑单元、芯片设计的可重用模组。IP核通常已经通过了设计验证，设计人员以IP核为基础进行设计，可以缩短设计所需的周期。</p><p>IP核可以通过协议由一方提供给另一方，或由一方独自占有。IP核的概念源于产品设计的专利证书和源代码的版权等。设计人员能够以IP核为基础进行专用集成电路或现场可编程逻辑门阵列的逻辑设计，以减少设计周期。</p><p>IP核分为软核、硬核和固核：</p><ul><li><strong>软核</strong>：通常是与工艺无关、具有寄存器传输级 <code>硬件描述语言</code>描述的<code>设计代码</code>，可以进行后续设计；不包含任何物理实现信息（软核特点是对用户来讲可移植性强、设计周期短、成本低。缺点是物理实现性能不定不全面，产权保护不佳）。</li><li><strong>固核</strong>：则通常介于软核、硬核之间，它已经通过功能验证、时序分析等过程，设计人员可以以 <code>逻辑门级网表</code>的形式获取。</li><li><strong>硬核</strong>：是软核通过逻辑综合、布局、布线之后的一系列表征文件，具有特定的工艺形式、物理实现方式；</li></ul><h4 id="4-1-3-架构-指令集层级授权"><a href="#4-1-3-架构-指令集层级授权" class="headerlink" title="4.1.3 架构/指令集层级授权"></a>4.1.3 架构/指令集层级授权</h4><p>是 ARM会授权合作厂商使用自己的架构，且可以对ARM架构进行大幅度改造，甚至可以对ARM指令集进行扩展或缩减，方便其根据自己的需要来设计处理器。例如高通的Krait架构和苹果的Swift架构，就是在取得ARM的授权后根据自己的需求设计完成的。拥有架构级授权的高通和苹果所制造的ARM处理器也总是拥有更低的功耗和更高的性能</p><p><strong>注意，某一版本的架构层级授权，通常是永久性的。</strong></p><p>比如，假如ARM为了遵循美国禁令，中断了与华为的相关业务，短期内华为不受受到影响，因为华为有ARMv8架构的永久授权，而目前主流处理器的CPU核心基本上基于ARMv8指令集。华为可以直接根据ARMv8的指令集进行大幅度的改造，甚至扩展ARM指令集，实现某些特殊的功能。</p><p>华为完全可以自己与ARMv8指令集自行设计处理器而不受授权限制，并且具有完整的知识产权，不受美国禁令的影响。高通骁龙处理器、苹果A系列处理器都是基于ARM指令集授权进行的自主设计。</p><p>做个很形象的比喻：</p><ul><li>假设我写了一篇文章，我只授权了你转发，不能更改，不能添油加醋，便是使用层级授权；</li><li>我授权你可以在文章中引用我的文章，便是内核级授权；</li><li>我授权你可以拿去修改、重组我的文章，形成一篇新的论文，便是架构层级授权。</li></ul><h4 id="4-1-4-间接授权"><a href="#4-1-4-间接授权" class="headerlink" title="4.1.4 间接授权"></a>4.1.4 间接授权</h4><p>需要说明的是，上述三种级别的授权均不允许被授权者再次出售ARM架构授权。而对于半导体工厂而言，ARM通常会对其进行特殊授权。这使得台积电、三星半导体等拥有半导体代工业务的企业不仅能够直接向用户出货拥有ARM内核的芯片，更在一定情况下拥有重置ARM内核的实力和权力。</p><p>这也就让很多根本无法取得ARM授权的企业能够间接的使用或拥有ARM核心；当然，这种方法所带来的成本通常也比要直接从ARM手中买授权的价格高出数倍。简单的说，芯片代工厂在某种程度上扮演了ARM授权代理商的角色，其存在可以满足某些用户小批量生产以及早期论证和试验的需要。</p><h4 id="4-1-5-其他"><a href="#4-1-5-其他" class="headerlink" title="4.1.5 其他"></a>4.1.5 其他</h4><p>如果划分得更细一点，ARM的授权模式还包括了：</p><ul><li><strong>学术授权</strong>，是免费面向高校和科研机构的；</li><li><strong>Design Start</strong>，是为了方便半导体企业低成本、低风险、快速了解ARM IP的一种授权模式；<br>这两种模式下设计出来的芯片不能销售，只能用于内部研究。</li><li><strong>多用途授权和终身多用途授权</strong>，以时间为授权效力划分，相对来说比较适合大型企业。</li><li><strong>单用途授权</strong>：以用途划分授权效力范围，这种授权模式之下，需要交一笔前期授权费，此后按照每颗芯片收取约 2％的版税。这种授权相对来说比较适合创业公司，或者目标明确的特定设计项目。</li></ul><h3 id="4-2-ARM的规模"><a href="#4-2-ARM的规模" class="headerlink" title="4.2 ARM的规模"></a>4.2 ARM的规模</h3><p>正是ARM的这种授权模式，极大地降低了自身的研发成本和研发风险。它以风险共担、利益共享的模式，形成了一个以ARM为核心的生态圈，使得低成本创新成为可能。目前ARM在全球拥有大约1000个授权合作、超过300家合作伙伴，但是敢于购买架构授权的，也只有15家。高通Krait、苹果Swift、Marvell都是典型的用户。正是靠着如此众多授权伙伴的支持，ARM处理器才获得了25亿颗的季度出货量，历史总量已经达到500亿颗，可以绕地球12周。</p><p>2011年，ARM的客户报告79亿ARM处理器(一般来说，只要是使用ARM指令集架构的处理器，我们都会称之为 ARM 处理器)出货量，占有95%的智能手机、90%的硬盘驱动器、40%的数字电视和机上盒、15%的微控制器、和20%的移动电脑。</p><p><strong>简言之：ARM 已经垄断了移动芯片市场。</strong></p><p>有人觉得，ARM的成功得益于自身的开放，但实际上它仅仅是在商业模式上开放，在技术上的保守程度超乎大家的想象。ARM架构授权支持芯片厂商修改芯片，但同时必须遵守ARM设置的许多条件。</p><p>到现在，获得ARM32授权的公司一只手都能数的过来，ARM64授权虽然多一些，但授权费却异常昂贵。一家基于RISC-V架构的法国创业公司Greenwave表示，如果选择ARM架构，要花掉1500万美元的授权费。而且授权到期后，一切都是未知的，是否继续授权和授权费用都要重新谈判。</p><p>为什么像苹果高通这些有能力设计自主架构的公司不能自己设计指令集而非要买ARM的然后再在上面设计架构？<br>可能是做不出比arm性能更好的指令集了呗，或者性价比太低</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/19893066">关于CPU、指令集、架构、芯片的一些科普</a></li><li><a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B">指令集架构 —— 维基百科</a></li><li><a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E5%99%A8">图形处理器GPU —— 维基百科</a></li><li><a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9E%B6%E6%A7%8B">微架构 —— 维基百科</a></li></ul><p>课外读物</p><ul><li><a href="https://links.jianshu.com/go?to=https://www.ifanr.com/category/business">英国 ARM：如何用设计定义移动时代的故事</a></li><li><a href="https://links.jianshu.com/go?to=https://www.ifanr.com/688023">为什么苹果和三星不买 ARM？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇文章偏硬件科普，没有什么实质性的技术知识。&lt;/p&gt;
&lt;h2 id=&quot;一、指令集&quot;&gt;&lt;a href=&quot;#一、指令集&quot; class=&quot;headerlink&quot; title=&quot;一、指令集&quot;&gt;&lt;/a&gt;一、指令集&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;以下摘自维基百科&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="OS" scheme="https://tenloy.github.io/categories/OS/"/>
    
    
    <category term="ISA" scheme="https://tenloy.github.io/tags/ISA/"/>
    
    <category term="Microarch" scheme="https://tenloy.github.io/tags/Microarch/"/>
    
    <category term="Soc" scheme="https://tenloy.github.io/tags/Soc/"/>
    
  </entry>
  
  <entry>
    <title>CLI-Shell-Terminal-脚本概念梳理</title>
    <link href="https://tenloy.github.io/2021/04/13/03-1_Command-Line/"/>
    <id>https://tenloy.github.io/2021/04/13/03-1_Command-Line/</id>
    <published>2021-04-13T15:00:20.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<p><strong>命令行界面</strong>已经使用了很久，平时也有很多常用的<strong>命令行工具</strong>，但是对一些相关的概念(终端、Shell、命令、脚本等)却一直有些似懂非懂，今天记录一下，一是梳理自己的思路，二也是希望能对读到这篇博客的人有所帮助。</p><ul><li>命令行界面(CLI)和命令(行) —— 是一种页面交互风格，对比于GUI</li><li>终端(Terminal) —— 人与机器交互的接口，负责数据的输入与输出<ul><li>现在的一些叫法名词(<strong>本小节可只看这一段</strong>)</li><li>历史：起源、字符终端（哑终端、智能终端）、图形终端</li><li>现代：终端模拟器(Terminal Emulator)</li><li>补充：控制台、TTY、终端服务器</li></ul></li><li>Shell —— Shell是一种程序，对OS内核提供的服务进行包装，给用户使用</li><li>Shell与终端的分工 —— 终端负责数据输入输出，Shell负责数据的处理。</li><li>脚本Script —— 实现一些<strong>操作自动化</strong>，目前脚本语言也有多种</li></ul><h2 id="一、命令行界面-CLI-和命令-行"><a href="#一、命令行界面-CLI-和命令-行" class="headerlink" title="一、命令行界面(CLI)和命令(行)"></a>一、命令行界面(CLI)和命令(行)</h2><h3 id="1-1-CLI、GUI是什么？"><a href="#1-1-CLI、GUI是什么？" class="headerlink" title="1.1 CLI、GUI是什么？"></a>1.1 CLI、GUI是什么？</h3><p>是与用户交互的界面的两种风格</p><ul><li><strong>命令行界面CLI(Command-Line Interface)</strong> 是在GUI得到普及之前使用最为广泛的用户界面，通常不支持鼠标，用户通过键盘输入文本指令，计算机接收到指令后，予以执行。也有人称之为<code>字符用户界面</code></li><li><strong>图形用户界面GUI(Graphical User Interface)</strong> 采用图形方式显示（用户可以通过鼠标点击、键盘作为输入）。与早期计算机使用的命令行界面相比，图形界面对于用户来说在视觉上更易于接受，学习成本大幅下降，也让计算机的大众化得以实现。</li></ul><p>Bash命令行界面图例：</p><img src="/images/OS/CLI/2181780-b141590ef0c0c8aa.png" style="zoom:100%"><p>因为，命令行界面的软件通常需要用户记忆操作的命令，所以<strong>操作起来不那么方便</strong>，但是，由于其本身的特点，命令行界面要较图形用户界面<strong>节约计算机系统的资源(GUI要保证界面渲染得易于接收)<strong>。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的</strong>操作速度要快</strong>。</p><p>所以，现在的操作系统中，虽然很注重图形用户界面，提供了好看好用的GUI Shell，但却都没有因而停止提供文字模式的命令行操作方式(CLI Shell)，相反的，许多系统反而更加强这部分的功能</p><h3 id="1-2-命令"><a href="#1-2-命令" class="headerlink" title="1.2 命令"></a>1.2 命令</h3><p><strong>CLI程序区别于GUI程序的是：后者提供给用户的使用(输入)方式是点击、输入即可，输出的结果也是形象生成的图形，而CLI程序提供给用户的是一条条命令，用户通过键盘输入命令、参数来使用功能，结果是以一系列的字符形式输出</strong></p><ul><li>命令提示符<ul><li>命令提示符是操作系统在CLI界面上向用户提供的一种提示标志。命令提示符有两重含义：一是标志着上一条命令的结束; 二是标志着可以启动运行下一条命令。</li><li>比如DOS中的<code>C&gt;</code>、UNIX中的<code>¥</code>或<code>%</code>、Mac OS中的<code>$</code></li></ul></li><li>命令(行)<ul><li>通常把在命令提示符后打入的程序名和其参数称为命令行(到回车为止)或命令。</li><li>任一命令行(即任一条命令)的本质都是 申请某一程序执行</li><li><strong>交互式命令</strong>：与用户进行交互。比如shell等待你的输入，并且执行你提交的命令</li><li><strong>非交互式命令</strong>：不存在进行交互，而是读取存放在文件中的命令，并且执行它们。当它读到文件的结尾，命令也就终止了。</li></ul></li></ul><p>OS提供了一组不同操作命令组成的集合，每个命令实现用户所要求的不同功能，为用户提供相应的服务。另外自己也可以基于内核提供的一些系统调用开发一些命令行工具。</p><p>命令行的执行过程：</p><img src="/images/OS/CLI/2181780-878e469efcfcc763.png" style="zoom:80%"><h3 id="1-3-常见的CLI程序"><a href="#1-3-常见的CLI程序" class="headerlink" title="1.3 常见的CLI程序"></a>1.3 常见的CLI程序</h3><ul><li>CLI Shell<ul><li>bash/sh/ksh/csh/zsh（Unix-like系统）</li><li>COMMAND.COM（MS-DOS系统）</li><li>cmd.exe/命令提示符（Windows NT和Windows CE系统）</li><li>Windows PowerShell（支持.NET Framework技术的Windows NT系统）</li></ul></li><li>此外，还有一些个人开发的、很好用的CLI工具</li></ul><h2 id="二、Shell"><a href="#二、Shell" class="headerlink" title="二、Shell"></a>二、Shell</h2><p>指<strong>操作系统中为用户提供访问内核所提供之服务的程序</strong>，因此与之相对的是内核(Kernel)，内核管理着整台计算机的硬件（硬盘、显卡、网卡、CPU等），是现代操作系统中最基本的部分。但是，内核处于系统的底层，是不能让普通用户随意操作，所以内核不提供和用户的交互功能。</p><img src="/images/OS/CLI/2181780-3f00874b5ac917a8.png" style="zoom:80%"><h3 id="2-1-Shell-分类"><a href="#2-1-Shell-分类" class="headerlink" title="2.1 Shell 分类"></a>2.1 Shell 分类</h3><ul><li>CLI Shell(命令行式的用户交互界面)，CLI Shell出现的很早，是传统意义上的shell，<strong>如果不特别注明，shell一般都是指 CLI Shell</strong>。</li><li>GUI Shell(图形化的用户交互界面)，GUI通常会建构在视窗系统上。（视窗系统是以使用视窗作为主要特征之一的图形用户接口的构成组件。更为明确地说，它是桌面环境的构成组件）</li></ul><p><strong>不管是GUI shell 还是命令行 Shell，其实都是在解释命令，只不过GUI shell隐藏解释命令细节，用户通过点击鼠标的操作操作内核命令。所以Shell本质上就是个命令解释器。</strong></p><h3 id="2-2-CLI-Shell的发展"><a href="#2-2-CLI-Shell的发展" class="headerlink" title="2.2 CLI Shell的发展"></a>2.2 CLI Shell的发展</h3><p>不同的GUI Shell提供给用户不同的界面风格、操作方式，不同的 CLI Shell也会提供给用户不同风格的命令语法：除非我们需要编写shell脚本，普通用户一般很难发现不同shell脚本语言差异。对文件操作ls、pwd等等这些常用命令所有shell都一样支持。</p><p><a href="https://links.jianshu.com/go?to=http://www.howtoip.com/htg-explains-what-are-the-differences-between-linux-shells/">Bash，Zsh和其他Linux Shell之间有什么区别？</a></p><ul><li><code>Thompson Shell</code>：是第一个shell环境，在贝尔实验室开发并于1971年发布。Shell环境一直在基于这个概念，添加了各种新功能，功能和速度的改进</li><li><code>C shell(csh)</code>：发布于1978年，它添加了许多交互式元素，用户可以控制他们的系统，如别名（长命令的快捷方式），作业管理能力，命令历史等。</li><li><code>Bourne Shell(sh)</code>：被称作现代Shell最突出的祖先，发布于1979年，它成为Unix中的默认命令解释器，因为它支持命令替换，管道，变量，条件测试和循环，以及其他功能。 它没有为用户提供太多的定制，并且不支持像别名，命令完成和shell函数这样的现代化的细节。</li><li><code>tcsh</code>、<code>ksh</code>：随着时间的推移，很多人修复了bug，并向C shell添加了功能，最终导致了csh的改进版本，称为“<code>tcsh</code>”。 但是csh在基于Unix的计算机上仍然是默认的，并且添加了一些非标准的功能。 贝尔实验室的David Korn致力于<code>KornShell</code>或“<code>ksh</code>”，它试图通过向后兼容Bourne shell的语言来改进这种情况，但增加了csh shell的许多功能。 它在1983年发布，但是根据专有许可。 它不是自由软件，直到2000年代，当它发布了各种开源许可证。</li><li><code>Bash</code>：是Bourne shell的后继兼容版本与开放源代码版本，于1989年发布第一个正式版本，原先是计划用在GNU操作系统上，但能运行于大多数[类Unix系统的操作系统之上，包括Linux与Mac OS X v10.4都将它作为默认shell。</li><li><code>ash</code></li><li><code>dash</code>：设计是符合POSIX的和轻量级的，所以它比Bash快，但不会有所有的功能</li><li><code>Z shell(zsh)</code>：目前非常流行，1990年创建的，它是一个Bourne风格的shell。这个较新的shell与bash兼容，但包括更多的功能。 zsh shell提供内置的拼写校正，改进的命令行完成，充当shell插件的可加载模块，允许您在命令行上别名文件名或其他任何东西的全局别名，而不仅仅是命令，以及更多主题支持。 它像bash，但有很多附加功能，附加功能和可配置选项，你可能会喜欢，如果你在命令行上花费大量的时间。<pre><code>如果你熟悉bash，你可以切换到zsh，而不学习不同的语法，你只会获得额外的功能。</code></pre></li><li><code>fish</code>：更新的一个shell，2005年发布，它有一个独特的命令行语法，旨在更容易学习，但不是从Bourne shell或C shell派生。</li></ul><h3 id="2-3-不同操作系统的Shell举例"><a href="#2-3-不同操作系统的Shell举例" class="headerlink" title="2.3 不同操作系统的Shell举例"></a>2.3 不同操作系统的Shell举例</h3><p>Unix：第一个Unix壳层(Unix shell)是以Multics上的shell为范本所写出的Thompson shell</p><p>Windows：同时提供了图形壳层、命令行壳层的功能</p><ul><li>Windows 95/98下的command.com</li><li>Windows NT内核下的cmd.exe以及PowerShell</li><li>图形界面壳层即为explorer.exe</li></ul><p>Mac OS：</p><ul><li>macOS开源了内核，而GUI没有开源（否则，可能我们会看到各种“自主知识产权”的，长得像 OS X 的 Linux，以及其他各种不知所谓的 Mod）</li><li>mac的GUI 层又称 Aqua 层，基于 Cocoa，在系统的架构的最顶端，也是直接面向用户和大部分应用程序开发者的层面。</li><li>mac内置的shell壳层有很多(对命令行的支持力度很大)</li></ul><p>Unix/类Unix(Linux、Mac OS等)：</p><ul><li>GUI Shell：X window manager (BlackBox和FluxBox），以及功能更强大的CDE、GNOME、KDE、 XFCE</li><li>CLI Shell：bash / sh / ksh / csh / zsh</li></ul><h3 id="2-4-Shell与Shell脚本"><a href="#2-4-Shell与Shell脚本" class="headerlink" title="2.4 Shell与Shell脚本"></a>2.4 Shell与Shell脚本</h3><ul><li>CLI Shell — Shell脚本</li><li>GUI Shell — GUI软件</li></ul><p>这两对概念之间的关系是有区别：</p><ul><li>前者中Shell脚本是利用CLI Shell提供的命令编写的脚本程序（只能调用Shell提供的命令），CLI Shell充当的是解释器的角色。</li><li>而GUI软件与GUI Shell、CUI Shell更类似于同级的关系，都是基于系统内核提供的一些API进行开发的。</li></ul><h2 id="三、终端-Terminal"><a href="#三、终端-Terminal" class="headerlink" title="三、终端(Terminal)"></a>三、终端(Terminal)</h2><p>终端(Terminal) — 人与机器交互的接口</p><blockquote><p>终端 (Terminal)，其词汇本身的意义为「终点站；末端；（电路）的端子，线接头」。而在计算机领域，终端则是一种用来让用户输入数据至计算机，以及显示其计算结果的机器。</p></blockquote><p>也就是说，<strong>终端只是一种用于与计算机进行交互的输入输出设备，其本身并不提供运算处理功能。</strong></p><h3 id="3-1-现在的一些叫法名词"><a href="#3-1-现在的一些叫法名词" class="headerlink" title="3.1 现在的一些叫法名词"></a>3.1 现在的一些叫法名词</h3><ul><li>在存在真实的物理终端时，一台主机有一个<strong>控制台</strong>，多个<strong>终端</strong>（控制台是一个权限更高的特殊终端）</li><li>最早的终端设备是电传打字机(tty)，后来将<strong>tty作为终端的统称</strong>，有时也指Linux的tty子系统</li><li><strong>终端和控制台都不是目前个人电脑普遍时代的概念，而是多人共用的小型中型大型计算机上的概念。</strong></li><li>我们经常所使用的终端软件，都是<strong>终端模拟器</strong>（真实的终端是硬件）</li><li>终端模拟器有两种：<ul><li>运行在用户态(GUI下的一个软件)——又称<strong>终端窗口</strong>、<strong>伪终端</strong></li><li>运行在内核态——又叫<strong>虚拟控制台</strong></li></ul></li><li>终端模拟器一般都是模拟的字符终端，在里面可以使用CLI程序</li><li>CLI程序有很多：CLI Shell、Shell脚本。区别于GUI软件提供给用户的使用方式是点击、输入。CLI程序提供给用户的是一条条命令，用户通过输入命令、参数来使用功能</li></ul><h3 id="3-2-历史"><a href="#3-2-历史" class="headerlink" title="3.2 历史"></a>3.2 历史</h3><p>起源、字符终端（哑终端、智能终端）、图形终端</p><h4 id="3-2-1-早期的终端"><a href="#3-2-1-早期的终端" class="headerlink" title="3.2.1 早期的终端"></a>3.2.1 早期的终端</h4><p><strong>早期，一台计算机配置多个终端，人们通过终端共享计算资源。</strong></p><p>个人计算机是上世纪70年代末开始出现的。在那之前，是大型机 (Mainframe) 和小型机 (Minicomputer) 的时代，计算机非常昂贵且巨大(<em>Unix创始人肯•汤普逊和丹尼斯•里奇使用的PDP-7小型机当年的价格为72000美元，GE-45大型机价格高达1000万美元</em>)，不像现在这样人手一台。这些笨重的计算机通常被安置在单独的房间内，而操作计算机的人们坐在另外的房间里，通过某些设备与计算机进行交互。这种设备就叫做<strong>终端 (Terminal)，也叫终端机</strong>。</p><p>肯•汤普逊和丹尼斯•里奇想让Unix成为一个<strong>多用户系统</strong>。多用户系统意味着要给每个用户配置一个终端，每个用户都要有一个显示器、一个键盘。但当时所有的计算机设备(包括显示器)价格都非常昂贵，而且键盘和主机是集成在一起的，根本没有独立的键盘。</p><p>最后他们找到了一样东西，那就是ASR33<strong>电传打字机</strong>(<strong>Teletype</strong>)。ASR是英文Automatic Send-Receive的首字母缩写。虽然电传打字机的用途是在电报线路上收发电报，但是它也可以作为人与计算机的接口，而且价格低廉。ASR33打字机的键盘用来输入信息，打印纸用来输出信息。如图：</p><img src="/images/OS/CLI/2181780-b851c9a27de69622.jpg" style="zoom:60%"><p>以他们把ASR33电传打字机作为终端，很多个ASR33连接到同一个主机，每个用户都可以在终端输入用户名和密码登录主机。这样他们创造了计算机历史上的第一个真正的多用户系统Unix，而ASR33成为第一个Unix终端。</p><h4 id="3-2-2-字符终端（哑终端、智能终端"><a href="#3-2-2-字符终端（哑终端、智能终端" class="headerlink" title="3.2.2 字符终端（哑终端、智能终端)"></a>3.2.2 字符终端（哑终端、智能终端)</h4><p>随着终端的发展，也可以分为不同的种类。</p><p><strong>字符终端</strong>(Character Terminal) 也叫<strong>文本终端</strong>(Text Terminal)，是只能接收和显示文本信息的终端。早期的终端全部是字符终端。</p><p>字符终端也分为<strong>哑终端</strong>(Dumb Terminal) 和所谓的<strong>智能终端</strong>(Intelligent Terminal)，因为后者可以理解转义序列、定位光标和显示位置，比较聪明，而哑终端不行。</p><img src="/images/OS/CLI/2181780-ab038b7a3beed6b0.jpg" style="zoom:60%"><p>DEC 公司在 1978 年制造的 VT100（DEC VT100 终端，上图），由于其设计良好并且是第一批支持 ANSI 转义序列与光标控制的智能终端，获得了空前的成功。<strong>VT100 不仅是史上最流行的字符终端，更是成为了字符终端事实上的标准</strong>。</p><h4 id="3-2-3-图形终端"><a href="#3-2-3-图形终端" class="headerlink" title="3.2.3 图形终端"></a>3.2.3 图形终端</h4><p>随着技术的进步，图形终端 (Graphical Terminal) 也开始出现在公众的视野中。图形终端不但可以接收和显示文本信息，也可以显示图形与图像。著名的图形终端有 Tektronix 4010 系列。</p><p><strong>不过现在专门的图形终端已经极为少见，他们基本上已经被全功能显示器所取代。</strong></p><h3 id="3-3-现代-终端模拟器"><a href="#3-3-现代-终端模拟器" class="headerlink" title="3.3 现代: 终端模拟器"></a>3.3 现代: 终端模拟器</h3><p>随着图形化界面GUI的兴起，时至今日，图形终端已经完全被全功能视频显示器代替。</p><p>随着个人计算机的进化：</p><ul><li>终端也发生了巨大的变化：从电传打字机(tty)、哑终端、智能终端、图形化终端到现代。现代的终端：<ul><li>输入设备包括键盘、鼠标、麦克风等</li><li>输出设备包括显示器、扬声器等</li></ul></li><li>计算机系统的使用方式也变了：<ul><li>GUI之前，操作系统提供命令，用户通过调用命令完成功能</li><li>GUI后，操作系统的中心转到了图形化界面，用户可以通过鼠标点击来完成很多功能</li></ul></li></ul><p>前面提到过，<strong>GUI软件</strong>好用简单，但<strong>CLI工具</strong>也有其独特的优点，所以很有保留的必要。在现在大部分操作系统默认展示GUI Shell的情况下，CLI工具并不能使用，因为CLI工具通常不支持鼠标，而且不能将输出直接展示在图形化界面上。</p><p><strong>为了能使用那些命令行工具，这时候我们就需要一个程序来模拟传统终端的行为，即终端模拟器 (Terminal Emulator)。(模拟智能终端即可)</strong></p><p>一个终端模拟器的标准工作流程是这样的：</p><ol><li>捕获你的键盘输入；</li><li>将输入发送给命令行程序（程序会认为这是从一个真正的终端设备输入的）；</li><li>拿到命令行程序的输出结果（STDOUT 以及 STDERR）；</li><li>调用图形接口（比如 X11），将输出结果渲染至显示器。</li></ol><p>终端模拟器有很多，这里就举几个经典的例子：</p><ul><li>GNU/Linux：gnome-terminal、Konsole；</li><li>macOS：Terminal.app、iTerm2；</li><li>Windows：Win32 控制台、ConEmu 等。</li></ul><p>终端模拟程序可以模拟任何终端，包括真实终端和虚拟(模拟)终端。但实际上只有四种终端被作为模拟的对象：</p><ul><li>最常见的两个模拟对象：<ul><li>DEC公司1978年制造的VT100终端</li><li>xterm终端模拟程序(xterm模拟的是DEC公司制造的VT102终端)</li></ul></li><li>另外两个不太常见的模拟对象是：<ul><li>DEC公司生产的VT220终端</li><li>用于IBM大型机的3270终端</li></ul></li></ul><p><strong>终端模拟器的两种形式：终端窗口、虚拟控制台</strong></p><ul><li>运行在GUI下(用户态)的终端——又叫<strong>伪终端</strong>、<strong>终端窗口(Terminal Window)</strong><ul><li>比如Mac中的Terminal.app、iTerm2等</li></ul></li><li>运行在内核态的终端——又叫<strong>虚拟控制台(Virtual Console)</strong><ul><li>比如在 GNU/Linux 操作系统中，按下 <code>Ctrl+Alt+F1,F2...F6</code> 等组合键可以切换出好六个黑色背景的全屏字符终端界面，而按下 <code>Ctrl+Alt+F7</code> 才是切换回图形界面</li></ul></li></ul><p>下图就是一个正在显示系统启动信息的虚拟控制台：</p><img src="/images/OS/CLI/2181780-845bfa4fdf6a9bc7.png" style="zoom:80%"><p>因为终端窗口是跑在图形界面上的，所有如果图形界面宕掉了那它们也就跟着卡死了。当图形终端崩溃时，我们可以按快捷键切换到这六个 Virtual Console的其中一个，然后输入命令修复问题或重启系统，因为它们由内核直接提供，只要系统本身不出问题一般都可用。</p><h3 id="3-4-补充-控制台、TTY、终端服务器"><a href="#3-4-补充-控制台、TTY、终端服务器" class="headerlink" title="3.4 补充: 控制台、TTY、终端服务器"></a>3.4 补充: 控制台、TTY、终端服务器</h3><h4 id="3-4-1-控制台-Console"><a href="#3-4-1-控制台-Console" class="headerlink" title="3.4.1 控制台(Console)"></a>3.4.1 控制台(Console)</h4><blockquote><p>控制台 —— 一个特殊的能直接显示系统消息的终端</p></blockquote><p>控制台与普通终端的区别：</p><ul><li><strong>结构上</strong>：通常终端都是通过线路连接到主机，而控制台与主机是一体的，不需要连线。两者在外表上没什么区别</li><li><strong>功能上</strong>：一台计算机上可以连接很多个终端，但是一般只有一个控制台。控制台是用于管理主机的，只能给系统管理员使用，有着比普通终端更大的权限。比如计算机输出的信息只会显示在控制台上，例如BIOS的输出，内核的输出。</li></ul><p>下图左侧立式的是Console，桌子上的是Terminal：</p><img src="/images/OS/CLI/2181780-9b4168b70942c326.jpg" style="zoom:65%"><p>随着个人计算机的普及，控制台 (Console) 与终端 (Terminal) 的概念已经逐渐模糊。</p><p>在现代，我们的键盘与显示器既可以认为是控制台，也可以认为是普通的终端。</p><ul><li>当你在管理系统时，它们是Console；</li><li>当你在做一般的工作时(浏览网页、编辑office文档等)，它们是终端。</li><li>自己既是一般用户，也是系统管理员。</li></ul><p><strong>因此，现在 Console 与 Terminal 基本被看作是同义词。</strong></p><h4 id="3-4-2-TTY"><a href="#3-4-2-TTY" class="headerlink" title="3.4.2 TTY"></a>3.4.2 TTY</h4><p>TTY 是 Teletype 或 Teletypewriter 的缩写，原来是指电传打字机，后来这种设备逐渐键盘和显示器取代。不管是电传打字机还是键盘显示器，都是作为计算机的终端设备存在的，所以 TTY 也泛指计算机的终端(terminal)设备。为了支持这些 TTY 设备，Linux 实现了一个叫做 TTY 的子系统。所以 <strong>TTY 既指终端，也指 Linux 的 TTY 子系统</strong>。</p><p>最早的终端(terminal) 是一台独立于计算机的设备(teletype 即, TTY)，通过线缆与计算机连接，并完成计算机的输入输出功能。</p><p><strong>TTY设备</strong></p><p>从历史上看，终端刚开始就是终端机，配有打印机，键盘，带有一个串口，通过串口传送数据到主机端，然后主机处理完交给终端打印出来。电传打字机(teletype)可以被看作是这类设备的统称，因此终端也被简称为 TTY(teletype 的缩写)。</p><img src="/images/OS/CLI/2181780-32c55593fee90d0c.png" style="zoom:90%"><ul><li><p>UART 驱动</p><p>如上图所示，物理终端通过电缆连接到计算机上的 UART(通用异步接收器和发射器)。操作系统中有一个 UART 驱动程序用于管理字节的物理传输。</p></li><li><p>行规范</p><p>上图中内核中的 Line discipline(行规范)用来提供一个编辑缓冲区和一些基本的编辑命令(退格，清除单个单词，清除行，重新打印)，主要用来支持用户在输入时的行为(比如输错了，需要退格)。</p></li><li><p>TTY 驱动</p><p>TTY 驱动用来进行会话管理，并且处理各种终端设备。</p></li></ul><p><strong>UART 驱动、行规范和 TTY 驱动都位于内核中，它们的一端是终端设备，另一端是用户进程。因为在 Linux 下所有的设备都是文件，所以它们三个加在一起被称为 “TTY 设备”，即我们常说的 TTY。</strong></p><h4 id="3-4-3-终端服务器"><a href="#3-4-3-终端服务器" class="headerlink" title="3.4.3 终端服务器"></a>3.4.3 终端服务器</h4><p>当公司或大学的资金只能买一台大型机或小型机时，所有的终端都直接连到这台主机。随着时间的推移，主机价格逐渐下降，这时一个机构内部有多个主机。如何才能让每个终端都能连接到任何一个主机呢？在各个终端和主机之间牵一根线代价太大，而且线路容易搞混。这时候终端服务器就派上用场了。</p><p>各个终端与终端服务器相连，各个主机也与终端服务器相连。当终端启动时，终端服务器询问用户要登录哪个主机，用户指定主机后，再输入用户名和密码登录相应的主机。这种拓扑结构很像今天的家庭网络，终端服务器相当于路由器。</p><h2 id="四、Shell与终端的分工"><a href="#四、Shell与终端的分工" class="headerlink" title="四、Shell与终端的分工"></a>四、Shell与终端的分工</h2><p>现在我们知道，终端干的活儿是从用户这里接收输入（键盘、鼠标等输入设备），扔给 Shell，然后把 Shell 返回的结果展示给用户（比如通过显示器）。而 Shell 干的活儿是从终端那里拿到用户输入的命令，解析后交给操作系统内核去执行，并把执行结果返回给终端。</p><p>以Mac为例，可以在终端中：</p><ul><li><code>cat /etc/shells</code> ：查看所有的shell，打印如下：<ul><li>/bin/bash、/bin/csh、/bin/ksh、/bin/sh、/bin/tcsh、/bin/zsh</li></ul></li><li><code>echo $SHELL</code> ：查看当前窗口使用的shell版本</li><li><code>cat /etc/passwd | grep sh</code>：查看系统用户默认shell</li><li><code>chsh -s /bin/zsh(bash)</code>：切换终端中使用的Shell</li></ul><p><strong>Shell有多种，终端也有多种，两者是搭配工作的关系，并无固定的对应、依赖配置。</strong></p><p><strong>系统默认会为终端设置一种Shell来解释输入的命令，当编写脚本时，应该指定脚本语言对应的解释器(Shell)，脚本第一行决定了需要启动哪个shell来解释，写法比如<code>#!/bin/bash</code>(#!后紧跟解释后面命令的shell的路径）</strong></p><p>不过 Shell 与终端的分工有一些容易混淆的地方，这里以例子进行说明：</p><ul><li>终端将用户的键盘输入转换为控制序列（除了字符以外的按键，比如 <code>左方向键 → ^[[D</code>），Shell 则解析并执行收到的控制序列（比如 <code>^[[D → 将光标向左移动</code>）；<ul><li>不过也有例外，比如终端在接收到 <code>Ctrl + C</code> 组合键时，不会把这个按键转发给当前的程序，而是会发送一个 <code>SIGINT</code> 信号（默认情况下，这会导致进程终止）。</li><li>其他类似的特殊组合键有 <code>Ctrl-Z</code> 与 <code>Ctrl-\</code> 等，可以通过 <code>stty -a</code> 命令查看当前终端的设置。</li></ul></li><li>Shell 发出类似「把前景色改为红色（控制序列为 <code>\033[31m</code>）」「显示 foo」等指令；终端接收这些指令，并且照着 Shell 说的做，于是你就看到了终端上输出了一行红色的 foo。</li><li>除非被重定向，否则 Shell 永远不会知道它所执行命令的输出结果。我们可以在终端窗口中上下翻页查看过去的输出内容，这完全是终端提供的 feature，与 Shell 没有半毛钱关系；</li><li>命令提示符 (Prompt) 是一个完全的 Shell 概念，与终端无关；</li><li>行编辑、输入历史与自动补全等功能是由 Shell 提供的（比如 fish 这个 Shell 就有着很好用的历史命令与命令自动补全功能）。不过终端也能自己实现这些功能，比如说 XShell 这个终端模拟器就可以在本地写完一行命令，然后整条发送给远程服务器中的 Shell（在连接状况不佳时很有用，不然打个字都要卡半天）；</li><li>终端中的复制粘贴功能（<code>Shift + Insert</code> 或者鼠标右键等）基本上都是由终端提供的。举个例子，Windows 默认的终端对于复制粘贴的支持很屎，而换一个终端（例如 ConEmu）后就可以很好地支持复制粘贴。不过 Shell 以及其他命令行程序也可以提供自己的复制粘贴机制（例如 vim）。</li></ul><h2 id="五、脚本Script"><a href="#五、脚本Script" class="headerlink" title="五、脚本Script"></a>五、脚本Script</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>早期，脚本语言经常被称为<a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%E6%89%B9%E5%A4%84%E7%90%86">批处理</a>语言或<strong>工作控制语言</strong>。百度百科中，也称为<strong>扩建的语言</strong>或<strong>动态语言</strong>。编写出的脚本也只是为了实现一些简单任务的自动化，比如使得本来要用键盘进行的相互式操作自动化。</p><p>比如：一个Shell脚本主要由原本需要在<strong>命令行</strong>输入的命令组成。在一个<strong>文本编辑器</strong>中，用户可以使用脚本来把一些常用的操作组合成一组序列。</p><p>用来书写这种脚本的语言叫做脚本语言。</p><h3 id="5-2-脚本、程序、软件"><a href="#5-2-脚本、程序、软件" class="headerlink" title="5.2 脚本、程序、软件"></a>5.2 脚本、程序、软件</h3><p>脚本(Script)语义较抽象，可以借助script的另一个翻译—剧本来理解：</p><ul><li>脚本：是批处理文件的延伸，是一种纯文本保存的<code>程序</code>，是确定的一系列控制计算机进行运算操作动作的组合(命令集合)<ul><li>这些命令通常会写入一个文件，这个文件就叫脚本文件，类似剧本，说明都做什么</li><li>脚本文件明显小于如同类C程序文件</li><li>语法结构、学习使用通常比较简单</li><li>通常是<strong>解释执行</strong>而非编译</li><li>通常是以<strong>文本(TEXT)格式</strong>保存</li></ul></li><li>程序：是为了完成特定的功能，解决特定的问题而用计算机语言编写的命令序列集合。</li><li>软件：软件工程领域对于软件的定义是程序以及文档的集合体</li></ul><p>不用纠结脚本、解释型语言程序的区别，如果是个纯文本文件、解释执行、代码量不大，功能较简练，可以叫脚本，也可以叫程序。 <strong>脚本和传统编程语言程序之间的界限越来越模糊</strong>。</p><h3 id="5-3-脚本语言及分类"><a href="#5-3-脚本语言及分类" class="headerlink" title="5.3 脚本语言及分类"></a>5.3 脚本语言及分类</h3><h4 id="5-3-1-发展"><a href="#5-3-1-发展" class="headerlink" title="5.3.1 发展"></a>5.3.1 发展</h4><p>脚本语言是为了缩短传统的“编写、编译、链接、运行”过程而创建的计算机编程语言。早期，脚本语言经常被称为<a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%E6%89%B9%E5%A4%84%E7%90%86">批处理</a>语言或<strong>工作控制语言</strong>。百度百科中，也称为<strong>扩建的语言</strong>或<strong>动态语言</strong>。</p><p>一个脚本通常是<strong>解释运行</strong>而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作。<a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%E5%AE%8F%E8%AF%AD%E8%A8%80">宏语言</a>则可视为脚本语言的分支，两者也有实质上的相同之处。在许多方面，高级<a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a>和脚本语言之间互相交叉，二者之间没有明确的界限。</p><p>现在，虽然许多脚本语言都超越了计算机简单任务自动化的领域，可以<strong>脱离被扩建的程序</strong>单独存在(有自己的运行库、标准语言库函数等)，成熟到可以自己编写精巧的程序，但仍然还是被称为脚本。</p><h4 id="5-3-2-分类"><a href="#5-3-2-分类" class="headerlink" title="5.3.2 分类"></a>5.3.2 分类</h4><p>脚本的使用有很多，时至今日，脚本语言也各种各样。<strong>有脚本，必然有与之对应的解释器</strong>，进而对应的用途也很广泛，根据解释器/用途，可以将脚本语言分为很多种：</p><ul><li><strong>Shell语言</strong> —— 此类脚本用于<strong>自动化工作控制</strong>，即启动和控制系统程序的行为，解释器为<code>CLI Shell</code>。<ul><li><strong>Shell与Shell Script</strong>：<code>Shell</code> 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务，同时也是<strong>一门语言</strong>，可以编写<strong>shell脚本(script)<strong>，使用Shell来解释执行。</strong>Shell与Shell Script是两个不同的概念，Shell编程是指开发后者，不是指开发Shell本身</strong>。</li><li>常见的比如：C Shell</li></ul></li><li><strong>GUI脚本语言</strong> —— GUI出现带来一种专业的控制计算机的脚本语言。它在用户和图形界面，菜单，按钮等之间互动。它经常用来自动化重复性动作，或设置一个标准状态。理论上它可以用来控制运行于基于GUI的计算机上的所有应用程序，但实际上这些语言是否被支持还要看应用程序和操作系统本身。当通过键盘进行互动时，这些语言也被称为宏语言。</li><li><strong>应用程序定制的脚本语言</strong> —— 许多大型的应用程序都包括根据用户需求而定制的惯用脚本语言。同样地，许多电脑游戏系统使用一种自定义脚本语言来表现NPC和游戏环境的预编程动作。<ul><li>此类语言通常是为一个单独的应用程序所设计，虽然它们貌似一些通用语言（如QuakeC, modeled after C），但它们有自定义的功能。</li></ul></li><li><strong>通用动态语言</strong> —— 一些语言，比如<strong>Perl、PHP、Python、Ruby、Lua、Smalltalk</strong>等，从一门脚本语言发展成了更通用的编程语言。由于“解释执行，内存管理，动态”等特性，它们仍被称为脚本语言。但它们已经用于应用程序编写，用户也不把它们看作脚本语言。</li><li><strong>扩展/可嵌入语言</strong> —— 少数的语言被设计通过嵌入应用程序来取代应用程序定制的脚本语言。开发者（如使用C等其它系统语言）包入使脚本语言可以控制应用程序的hook。<ul><li>这些语言和应用程序定制的脚本语言是同种用途，但优点在于可以在应用程序之间传递一些技能。比如：<strong>JavaScript、Lua、Ch(C/C++ interpreter)、Dao、Tcl</strong></li><li>JavaScript直到现在仍然是网页浏览器内的主要编程语言，它的ECMAScript标准化保证了它成为流行的通用嵌入性语言。</li><li>Tcl作为一种扩展性语言而创建，但更多地被用作通用性语言，就如同Python, Perl, Ruby一样。</li></ul></li></ul><p><strong>脚本语言工作必须依赖对应的解释器，创造一门语言的同时，需要创建(使用已有的)对应的编译器、解释器</strong>。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://links.jianshu.com/go?to=https://www.linuxdashen.com/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%88%E7%AB%AF%E5%90%97%EF%BC%9F">你真的知道什么是终端吗？</a></li><li><a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/sparkdev/p/11460821.html">Linux 终端(TTY)</a></li><li><a href="https://links.jianshu.com/go?to=https://printempw.github.io/the-difference-between-cli-terminal-shell-tty/">命令行界面 (CLI)、终端 (Terminal)、Shell、TTY，傻傻分不清楚？</a></li><li><a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a></li><li><a href="https://links.jianshu.com/go?to=http://www.howtoip.com/htg-explains-what-are-the-differences-between-linux-shells/">Bash，Zsh和其他Linux Shell之间有什么区别？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;命令行界面&lt;/strong&gt;已经使用了很久，平时也有很多常用的&lt;strong&gt;命令行工具&lt;/strong&gt;，但是对一些相关的概念(终端、Shell、命令、脚本等)却一直有些似懂非懂，今天记录一下，一是梳理自己的思路，二也是希望能对读到这篇博客的人有所帮助。&lt;</summary>
      
    
    
    
    <category term="OS" scheme="https://tenloy.github.io/categories/OS/"/>
    
    
    <category term="CLI" scheme="https://tenloy.github.io/tags/CLI/"/>
    
    <category term="Shell" scheme="https://tenloy.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>CI-CD</title>
    <link href="https://tenloy.github.io/2021/04/12/02_CI-CD/"/>
    <id>https://tenloy.github.io/2021/04/12/02_CI-CD/</id>
    <published>2021-04-12T14:59:20.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、常见的Travis-CI与Jenkins"><a href="#一、常见的Travis-CI与Jenkins" class="headerlink" title="一、常见的Travis CI与Jenkins"></a>一、常见的Travis CI与Jenkins</h2><p><a href="https://zhuanlan.zhihu.com/p/67805669">参考链接：谁才是世界上最好的 CI/CD 工具？</a></p><p><strong>On-Premise vs Hosted</strong></p><ul><li>On-Premise 需要用户搭建自己的服务器来运行 CI/CD 工具。</li><li>Hosted CI/CD 工具是一个 SaaS 服务，不需要用户搭建自己的服务器。</li></ul><p>常见的 CI/CD 工具</p><ul><li><p>TeamCity 和 Jenkins 属于 “On-Premise” 阵营</p></li><li><p>Travis CI 属于 “Hosted” 阵营</p></li><li><p>AppVeyor 和 Azure Pipelines 则是既能 “On-Premise” 又能 “Hosted” </p></li></ul><p>如果在 CI/CD 过程中，需要连接到不同的内网服务。那么 On-Premise 的 CI/CD 工具适合这样的使用场景，你可以把 Build Agent 部署在内网的机器上，这样可以轻松地连接内网资源。</p><p>如果你不需要连接内网资源，那么 Hosted CI/CD Service 就是你的最佳选择了，有以下几个优势：</p><ul><li>维护成本：Hosted CI/CD Service 可以说是零维护成本了，整个运行环境都由服务商托管。相比于 On-Premise 的CI/CD 工具，使用者需要自己花大量时间搭建与维护服务器，对于 Hosted CI/CD Service 来说，使用者完全不需要担心背后服务器的维护。</li><li>Clean的运行环境：假设你在为你的 Python 项目寻求一个 CI/CD 工具，而你的 Python 项目需要同时对 Python 2.7, 3.6, 3.7 进行持续集成，那么 Hosted CI/CD Service 完全可以满足你的需要。On-Premise 的机器上，你需要对不同的 Python 版本而烦恼，而 Hosted CI/CD Service 每次都会创建一个新的运行环境，想用哪个 Python 版本就用哪个。</li><li>预装的软件和运行时：每一个项目在做持续集成时，往往会需要依赖不同的运行时和工具链，Hosted CI/CD Service 会帮你预装好许多常用的软件和运行时，大大减少了搭建环境的时间。</li><li>价格：价格成本也是我们在技术选型要重点考虑的一点。<ul><li>On-Premise 的 TeamCity 和 Jenkins：虽然他们都是免费使用的，但是使用者都需要搭建自己的服务器，不论是用自己的物理机还是使用 Azure 或是 AWS 上的虚拟机，这都是一个花费。特别是对于大规模的持续集成的需求下，这会是个很大的价格成本。</li><li>对于开源项目，Hosted CI/CD Service 有着很大的优势，Travis CI、AppVeyor 和 Azure Pipelines 对于开源项目都是完全免费的。</li><li>对于私有项目，Travis CI 和 AppVeyor 是收费的，而 Azure Pipelines 有一个月 1800 分钟的免费额度。可见，对于私有项目，Azure Pipelines 有很大的优势。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、常见的Travis-CI与Jenkins&quot;&gt;&lt;a href=&quot;#一、常见的Travis-CI与Jenkins&quot; class=&quot;headerlink&quot; title=&quot;一、常见的Travis CI与Jenkins&quot;&gt;&lt;/a&gt;一、常见的Travis CI与Jenki</summary>
      
    
    
    
    <category term="软件工程(化)" scheme="https://tenloy.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E5%8C%96/"/>
    
    
    <category term="CI/CD" scheme="https://tenloy.github.io/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo+Github Pages搭建个人博客</title>
    <link href="https://tenloy.github.io/2021/04/10/01_GithubPages-Hexo/"/>
    <id>https://tenloy.github.io/2021/04/10/01_GithubPages-Hexo/</id>
    <published>2021-04-10T10:25:24.000Z</published>
    <updated>2021-07-03T15:03:45.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Hexo配置和基本使用"><a href="#一、Hexo配置和基本使用" class="headerlink" title="一、Hexo配置和基本使用"></a>一、Hexo配置和基本使用</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown(或其他渲染引擎) 解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p><a href="https://hexo.io/zh-cn/docs/github-pages">hexo文档</a></p><h3 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h3><h4 id="1-2-1-init"><a href="#1-2-1-init" class="headerlink" title="1.2.1 init"></a>1.2.1 init</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder] <span class="comment"># 新建一个网站。如果没有设置folder，Hexo默认在目前的文件夹建立网站。</span></span><br></pre></td></tr></table></figure><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h4 id="1-2-2-new"><a href="#1-2-2-new" class="headerlink" title="1.2.2 new"></a>1.2.2 new</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt; <span class="comment"># 新建一篇文章</span></span><br></pre></td></tr></table></figure><ul><li>如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。</li><li>如果标题包含空格的话，请使用引号括起来。</li></ul><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about/me <span class="string">&quot;About me&quot;</span></span><br><span class="line"><span class="comment"># 以上命令会创建一个 `source/about/me.md` 文件，同时 Front Matter 中的 title 为 `&quot;About me&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意！title 是必须指定的！如果你这么做并不能达到你的目的：</span></span><br><span class="line">hexo new page --path about/me</span><br><span class="line"><span class="comment"># 此时 Hexo 会创建 `source/_posts/about/me.md`，同时 `me.md` 的 Front Matter 中的 title 为 `&quot;page&quot;`。这是因为在上述命令中，hexo-cli 将 `page` 视为指定文章的标题、并采用默认的 `layout`。</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-generate"><a href="#1-2-3-generate" class="headerlink" title="1.2.3 generate"></a>1.2.3 generate</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate  <span class="comment"># 生成静态文件。可以简写为hexo g</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站。<code>hexo g -d</code> 与 <code>hexo d -g</code> 两个命令的作用是相同的。</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动。Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h4 id="1-2-4-deploy"><a href="#1-2-4-deploy" class="headerlink" title="1.2.4 deploy"></a>1.2.4 deploy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy <span class="comment"># 部署网站。可以简写为：hexo d</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><h4 id="1-2-5-server"><a href="#1-2-5-server" class="headerlink" title="1.2.5 server"></a>1.2.5 server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server  <span class="comment"># 启动服务器。可以简写为：hexo s</span></span><br></pre></td></tr></table></figure><p>默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h4 id="1-2-6-clean"><a href="#1-2-6-clean" class="headerlink" title="1.2.6 clean"></a>1.2.6 clean</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。</span></span><br></pre></td></tr></table></figure><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h4 id="1-2-7-其他"><a href="#1-2-7-其他" class="headerlink" title="1.2.7 其他"></a>1.2.7 其他</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt; <span class="comment"># 发表草稿</span></span><br><span class="line">hexo render &lt;file1&gt; [file2] ... <span class="comment"># 渲染文件。可通过参数-o,--output来设置输出路径</span></span><br><span class="line">hexo migrate &lt;<span class="built_in">type</span>&gt; <span class="comment"># 从其他博客系统 迁移内容 https://hexo.io/zh-cn/docs/migration</span></span><br><span class="line">hexo list &lt;<span class="built_in">type</span>&gt;  <span class="comment">#列出网站资料</span></span><br><span class="line">hexo version  <span class="comment"># 显示 Hexo 版本</span></span><br></pre></td></tr></table></figure><h2 id="二、主题配置"><a href="#二、主题配置" class="headerlink" title="二、主题配置"></a>二、主题配置</h2><p><a href="https://github.com/Tenloy/hexo-theme-archer">fork的theme</a></p><p>根据喜好随便改：配置简书、RSS</p><p><strong>GIT</strong>子模块：</p><ul><li>现在我们的Blog项目受GitHub管理，是个仓库，其中包含了一个主题仓库。其中对主题仓库的修改，要在外层仓库、theme仓库分别提交一次</li><li>Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。 <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git-子模块</a></li></ul><h2 id="三、Travis-CI配置"><a href="#三、Travis-CI配置" class="headerlink" title="三、Travis CI配置"></a>三、Travis CI配置</h2><p>持续集成（Continuous integration，简称CI）</p><p>可以在其中加入一些自动化命令的执行，如每次commit，自动hexo algolia、hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</p><p><a href="https://mfrank2016.github.io/breeze-blog/2020/05/02/hexo/hexo-start/#toc-heading-12">参考链接</a></p><p>但并没有以下问题：</p><blockquote><p>注意：有两种类型的 <code>github pages</code>，一种是使用 <code>用户名.github.io</code> 作为项目名，一种是使用其它名称。虽然看起来只是名字不一样，但两种方式其实是有差异的，前一种方式里，网页静态文件只能存放在 master 分支，所以如果想要把博客源文件也存到同一个仓库，必须使用其它分支来存放，相应的 travis ci 监听和推送的分支也需要修改，当然也可以使用另一个新的仓库来存放。后一种方式则没这个限制，通常使用名为 <code>gh-pages</code> 作为分支名，<code>Hexo</code> 内默认设置的分支也是叫这个名字。这里我们使用的是后一种方案，即源文件和生成的网页静态文件存放在同一个仓库，源文件在 <code>master</code> 分支，静态文件在 <code>gh-pages</code> 分支。</p></blockquote><h2 id="四、algolia站内搜索配置"><a href="#四、algolia站内搜索配置" class="headerlink" title="四、algolia站内搜索配置"></a>四、algolia站内搜索配置</h2><p>algolia网站本质上就是提供了数据库，提供了接口给使用者，供其将要被检索的内容上传。</p><p>hexo-algolia工具就是完成了文档中内容的摘取，然后上传，上传的各项内容，其key就相当于数据库的表字段。</p><ul><li><p>hexo-algolia 要1.2.2版本之前，之后去掉了content字段，即表中不存储文章内容，所以不能搜索文章内容</p></li><li><p>上传content字段之后，可能会因为某条内容的索引数据太大而报错。那只能对该条内容的<code>content</code>字段进行屏蔽</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AlgoliaSearchError: Record at the position 0 objectID=d8676bd7611266ed2404ee6cee119d4a4a911cb0 is too big size=12920 bytes. Contact us if you need an extended quota</span><br><span class="line">    at success (D:\metang326.github.io\node_modules\hexo-algolia\node_modules\algoliasearch\src\AlgoliaSearchCore.js:375:32)</span><br><span class="line">    at process._tickCallback (node.js:369:9)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules/hexo-algolia/lib/command.js 添加代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> publishedPagesAndPosts.map(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> storedPost = _.pick(data, [</span><br><span class="line">          <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;date&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;slug&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;excerpt&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;permalink&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;layout&#x27;</span></span><br><span class="line">        ]);</span><br><span class="line"><span class="comment">// 添加判断，对指定的文章删除content字段</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> storedPost.permalink === <span class="string">&quot;string&quot;</span> &amp;&amp;</span><br><span class="line">            storedPost.permalink.indexOf(<span class="string">&quot;10_Web-Module&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">          storedPost = _.pick(data, [</span><br><span class="line">            <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;date&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;slug&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;excerpt&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;permalink&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;layout&#x27;</span></span><br><span class="line">          ]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>algolia网站配置步骤<a href="https://blog.csdn.net/qq_35479468/article/details/107335663">参考链接</a></p><h2 id="五、评论系统配置"><a href="#五、评论系统配置" class="headerlink" title="五、评论系统配置"></a>五、评论系统配置</h2><p><a href="https://www.heson10.com/posts/3217.html">https://www.heson10.com/posts/3217.html</a></p><p><a href="https://blog.shuiba.co/comment-systems-recommendation">https://blog.shuiba.co/comment-systems-recommendation</a></p><p>gitalk</p><h2 id="附：GitBook的使用注意点"><a href="#附：GitBook的使用注意点" class="headerlink" title="附：GitBook的使用注意点"></a>附：GitBook的使用注意点</h2><h3 id="6-1-不支持本地导出HTML"><a href="#6-1-不支持本地导出HTML" class="headerlink" title="6.1 不支持本地导出HTML"></a>6.1 不支持本地导出HTML</h3><p>新版本不支持本地导出的HTML跳转，解决方案：</p><ul><li><p>在_book文件夹中找到gitbook-&gt;theme.js文件。</p></li><li><p>在代码中搜索 <code>if(m)for(n.handler&amp;&amp;</code></p></li><li><p>将<code>if(m)</code>改成<code>if(false)</code>，再重新打开index.html即可 </p></li></ul><p>缺点：每次都会重置侧边栏。如果是部署后访问，侧边栏点击跳转后，不会重置状态</p><h3 id="6-2-默认主题运行报错"><a href="#6-2-默认主题运行报错" class="headerlink" title="6.2 默认主题运行报错"></a>6.2 默认主题运行报错</h3><p>在使用该主题的过程中，发现经常会在控制台报下面的错误，没有找到是哪里的原因，官方也一直没有修复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme.js:4UncaughtTypeError:Cannot read property&#39;split&#39; of undefined</span><br></pre></td></tr></table></figure><p>后来在 <a href="https://github.com/maxkoryukov/theme-default/commit/811fcca17fcc84ad9ff3f940a4194dbffa62a31d">这里</a> 看到一个解决方法，需要修改本地的 GitBook Theme 模板。下面是具体步骤：</p><ul><li><p>进入 GitBook 默认主题所在的文件夹 <code>用户主目录</code> -&gt; <code>.gitbook</code> -&gt; <code>versions</code> -&gt; <code>3.2.2</code> -&gt; <code>node_modules</code> -&gt; <code>gitbook-plugin-theme-default</code> -&gt; <code>src</code> -&gt; <code>js</code> -&gt; <code>theme</code>，打开 <code>navigation.js</code>，找到 <code>getChapterHash</code> 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getChapterHash</span>(<span class="params">$chapter</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $link = $chapter.children(<span class="string">&#x27;a&#x27;</span>),      </span><br><span class="line">      hash = $link.attr(<span class="string">&#x27;href&#x27;</span>).split(<span class="string">&#x27;#&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(hash) hash =<span class="string">&#x27;#&#x27;</span>+hash;</span><br><span class="line">  <span class="keyword">return</span>(!!hash)? hash :<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将该函数修改为下面的形式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getChapterHash</span>(<span class="params">$chapter</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $link = $chapter.children(<span class="string">&#x27;a&#x27;</span>),      </span><br><span class="line">      hash,      </span><br><span class="line">      href,      </span><br><span class="line">      parts;</span><br><span class="line">  <span class="keyword">if</span>($link.length)&#123;      </span><br><span class="line">    href = $link.attr(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(href)&#123;          </span><br><span class="line">      parts = href.split(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span>(parts.length&gt;<span class="number">1</span>)&#123;              </span><br><span class="line">        hash = parts[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(hash) hash =<span class="string">&#x27;#&#x27;</span>+hash;</span><br><span class="line">  <span class="keyword">return</span>(!!hash)? hash :<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回到 <code>gitbook-plugin-theme-default</code> 文件夹，运行 <code>npm install</code> 重新编译文件。</p></li></ul><h3 id="6-3-anchor-navigation-ex插件回到顶部"><a href="#6-3-anchor-navigation-ex插件回到顶部" class="headerlink" title="6.3 anchor-navigation-ex插件回到顶部"></a>6.3 <code>anchor-navigation-ex</code>插件回到顶部</h3><ul><li>如果文章有1级标题就必定好使</li><li>如果没有就：第一次好使，之后不好使。锚点设置的有问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Hexo配置和基本使用&quot;&gt;&lt;a href=&quot;#一、Hexo配置和基本使用&quot; class=&quot;headerlink&quot; title=&quot;一、Hexo配置和基本使用&quot;&gt;&lt;/a&gt;一、Hexo配置和基本使用&lt;/h2&gt;&lt;h3 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://tenloy.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
